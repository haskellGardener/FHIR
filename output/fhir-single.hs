{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}
{-# OPTIONS_GHC -fno-warn-duplicate-exports #-}
module Xsd'fhir'single'xsd
  ( module Xsd'fhir'single'xsd
  ) where
 
import Text.XML.HaXml.Schema.Schema (SchemaType(..),SimpleType(..),Extension(..),Restricts(..))
import Text.XML.HaXml.Schema.Schema as Schema
import Text.XML.HaXml.OneOfN
import qualified Text.XML.HaXml.Schema.PrimitiveTypes as Xs
import Xml'xsd as Xml
import Fhir'xhtml'xsd as Xhtml
 
-- Some hs-boot imports are required, for fwd-declaring types.
 
newtype Date'primitive = Date'primitive UnknownSimple deriving (Eq,Show)
instance Restricts Date'primitive UnknownSimple where
    restricts (Date'primitive x) = x
instance SchemaType Date'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Date'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Date'primitive where
    acceptingParser = fmap Date'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1]))?)?)
    simpleTypeText (Date'primitive x) = simpleTypeText x
 
data Date = Date
        { date_id :: Maybe String'primitive
        , date_value :: Maybe Date'primitive
        , date_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Date where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Date a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Date{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ date_id x
                       , maybe [] (toXMLAttribute "value") $ date_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ date_extension x
            ]
instance Extension Date Element where
    supertype (Date a0 a1 e0) =
               Element a0 e0
 
newtype DateTime'primitive = DateTime'primitive UnknownSimple deriving (Eq,Show)
instance Restricts DateTime'primitive UnknownSimple where
    restricts (DateTime'primitive x) = x
instance SchemaType DateTime'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (DateTime'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DateTime'primitive where
    acceptingParser = fmap DateTime'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)?)?)?)
    simpleTypeText (DateTime'primitive x) = simpleTypeText x
 
data DateTime = DateTime
        { dateTime_id :: Maybe String'primitive
        , dateTime_value :: Maybe DateTime'primitive
        , dateTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DateTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DateTime a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DateTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dateTime_id x
                       , maybe [] (toXMLAttribute "value") $ dateTime_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dateTime_extension x
            ]
instance Extension DateTime Element where
    supertype (DateTime a0 a1 e0) =
               Element a0 e0
 
newtype Code'primitive = Code'primitive Xs.Token deriving (Eq,Show)
instance Restricts Code'primitive Xs.Token where
    restricts (Code'primitive x) = x
instance SchemaType Code'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Code'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Code'primitive where
    acceptingParser = fmap Code'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [^\s]+([\s]?[^\s]+)*)
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Code'primitive x) = simpleTypeText x
 
data Code = Code
        { code_id :: Maybe String'primitive
        , code_value :: Maybe Code'primitive
        , code_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Code where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Code a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Code{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ code_id x
                       , maybe [] (toXMLAttribute "value") $ code_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ code_extension x
            ]
instance Extension Code Element where
    supertype (Code a0 a1 e0) =
               Element a0 e0
 
newtype String'primitive = String'primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts String'primitive Xsd.XsdString where
    restricts (String'primitive x) = x
instance SchemaType String'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (String'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType String'primitive where
    acceptingParser = fmap String'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (String'primitive x) = simpleTypeText x
 
data Xsd.XsdString = Xsd.XsdString
        { string_id :: Maybe String'primitive
        , string_value :: Maybe String'primitive
        , string_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Xsd.XsdString where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Xsd.XsdString a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Xsd.XsdString{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ string_id x
                       , maybe [] (toXMLAttribute "value") $ string_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ string_extension x
            ]
instance Extension Xsd.XsdString Element where
    supertype (Xsd.XsdString a0 a1 e0) =
               Element a0 e0
 
newtype Integer'primitive = Integer'primitive Xs.Int deriving (Eq,Show)
instance Restricts Integer'primitive Xs.Int where
    restricts (Integer'primitive x) = x
instance SchemaType Integer'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Integer'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Integer'primitive where
    acceptingParser = fmap Integer'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?([0]|([1-9][0-9]*)))
    simpleTypeText (Integer'primitive x) = simpleTypeText x
 
data Integer = Integer
        { integer_id :: Maybe String'primitive
        , integer_value :: Maybe Integer'primitive
        , integer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Integer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Integer a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Integer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ integer_id x
                       , maybe [] (toXMLAttribute "value") $ integer_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ integer_extension x
            ]
instance Extension Integer Element where
    supertype (Integer a0 a1 e0) =
               Element a0 e0
 
newtype Oid'primitive = Oid'primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Oid'primitive Xs.AnyURI where
    restricts (Oid'primitive x) = x
instance SchemaType Oid'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Oid'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Oid'primitive where
    acceptingParser = fmap Oid'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern urn:oid:(0|[1-9][0-9]*)(\.(0|[1-9][0-9]*))*)
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Oid'primitive x) = simpleTypeText x
 
data Oid = Oid
        { oid_id :: Maybe String'primitive
        , oid_value :: Maybe Oid'primitive
        , oid_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Oid where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Oid a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Oid{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ oid_id x
                       , maybe [] (toXMLAttribute "value") $ oid_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ oid_extension x
            ]
instance Extension Oid Element where
    supertype (Oid a0 a1 e0) =
               Element a0 e0
 
newtype Uri'primitive = Uri'primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Uri'primitive Xs.AnyURI where
    restricts (Uri'primitive x) = x
instance SchemaType Uri'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Uri'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Uri'primitive where
    acceptingParser = fmap Uri'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Uri'primitive x) = simpleTypeText x
 
data Uri = Uri
        { uri_id :: Maybe String'primitive
        , uri_value :: Maybe Uri'primitive
        , uri_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Uri where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Uri a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Uri{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uri_id x
                       , maybe [] (toXMLAttribute "value") $ uri_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uri_extension x
            ]
instance Extension Uri Element where
    supertype (Uri a0 a1 e0) =
               Element a0 e0
 
newtype Uuid'primitive = Uuid'primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Uuid'primitive Xs.AnyURI where
    restricts (Uuid'primitive x) = x
instance SchemaType Uuid'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Uuid'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Uuid'primitive where
    acceptingParser = fmap Uuid'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Uuid'primitive x) = simpleTypeText x
 
data Uuid = Uuid
        { uuid_id :: Maybe String'primitive
        , uuid_value :: Maybe Uuid'primitive
        , uuid_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Uuid where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Uuid a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Uuid{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uuid_id x
                       , maybe [] (toXMLAttribute "value") $ uuid_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uuid_extension x
            ]
instance Extension Uuid Element where
    supertype (Uuid a0 a1 e0) =
               Element a0 e0
 
newtype Instant'primitive = Instant'primitive Xs.DateTime deriving (Eq,Show)
instance Restricts Instant'primitive Xs.DateTime where
    restricts (Instant'primitive x) = x
instance SchemaType Instant'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Instant'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Instant'primitive where
    acceptingParser = fmap Instant'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Instant'primitive x) = simpleTypeText x
 
data Instant = Instant
        { instant_id :: Maybe String'primitive
        , instant_value :: Maybe Instant'primitive
        , instant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Instant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Instant a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Instant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ instant_id x
                       , maybe [] (toXMLAttribute "value") $ instant_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ instant_extension x
            ]
instance Extension Instant Element where
    supertype (Instant a0 a1 e0) =
               Element a0 e0
 
newtype Boolean'primitive = Boolean'primitive Xsd.Boolean deriving (Eq,Show)
instance Restricts Boolean'primitive Xsd.Boolean where
    restricts (Boolean'primitive x) = x
instance SchemaType Boolean'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Boolean'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Boolean'primitive where
    acceptingParser = fmap Boolean'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Boolean'primitive x) = simpleTypeText x
 
data Boolean = Boolean
        { boolean_id :: Maybe String'primitive
        , boolean_value :: Maybe Boolean'primitive
        , boolean_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Boolean where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Boolean a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Boolean{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ boolean_id x
                       , maybe [] (toXMLAttribute "value") $ boolean_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ boolean_extension x
            ]
instance Extension Boolean Element where
    supertype (Boolean a0 a1 e0) =
               Element a0 e0
 
newtype Base64Binary'primitive = Base64Binary'primitive Xs.Base64Binary deriving (Eq,Show)
instance Restricts Base64Binary'primitive Xs.Base64Binary where
    restricts (Base64Binary'primitive x) = x
instance SchemaType Base64Binary'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Base64Binary'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Base64Binary'primitive where
    acceptingParser = fmap Base64Binary'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Base64Binary'primitive x) = simpleTypeText x
 
data Base64Binary = Base64Binary
        { base64Binary_id :: Maybe String'primitive
        , base64Binary_value :: Maybe Base64Binary'primitive
        , base64Binary_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Base64Binary where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Base64Binary a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Base64Binary{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ base64Binary_id x
                       , maybe [] (toXMLAttribute "value") $ base64Binary_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ base64Binary_extension x
            ]
instance Extension Base64Binary Element where
    supertype (Base64Binary a0 a1 e0) =
               Element a0 e0
 
newtype UnsignedInt'primitive = UnsignedInt'primitive Xs.NonNegativeInteger deriving (Eq,Show)
instance Restricts UnsignedInt'primitive Xs.NonNegativeInteger where
    restricts (UnsignedInt'primitive x) = x
instance SchemaType UnsignedInt'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (UnsignedInt'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnsignedInt'primitive where
    acceptingParser = fmap UnsignedInt'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [0]|([1-9][0-9]*))
    simpleTypeText (UnsignedInt'primitive x) = simpleTypeText x
 
data UnsignedInt = UnsignedInt
        { unsignedInt_id :: Maybe String'primitive
        , unsignedInt_value :: Maybe UnsignedInt'primitive
        , unsignedInt_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnsignedInt where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnsignedInt a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnsignedInt{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unsignedInt_id x
                       , maybe [] (toXMLAttribute "value") $ unsignedInt_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unsignedInt_extension x
            ]
instance Extension UnsignedInt Element where
    supertype (UnsignedInt a0 a1 e0) =
               Element a0 e0
 
newtype Markdown'primitive = Markdown'primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts Markdown'primitive Xsd.XsdString where
    restricts (Markdown'primitive x) = x
instance SchemaType Markdown'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Markdown'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Markdown'primitive where
    acceptingParser = fmap Markdown'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Markdown'primitive x) = simpleTypeText x
 
data Markdown = Markdown
        { markdown_id :: Maybe String'primitive
        , markdown_value :: Maybe Markdown'primitive
        , markdown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Markdown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Markdown a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Markdown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ markdown_id x
                       , maybe [] (toXMLAttribute "value") $ markdown_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ markdown_extension x
            ]
instance Extension Markdown Element where
    supertype (Markdown a0 a1 e0) =
               Element a0 e0
 
newtype Time'primitive = Time'primitive Xs.Time deriving (Eq,Show)
instance Restricts Time'primitive Xs.Time where
    restricts (Time'primitive x) = x
instance SchemaType Time'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Time'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Time'primitive where
    acceptingParser = fmap Time'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern ([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?)
    simpleTypeText (Time'primitive x) = simpleTypeText x
 
data Time = Time
        { time_id :: Maybe String'primitive
        , time_value :: Maybe Time'primitive
        , time_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Time where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Time a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Time{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ time_id x
                       , maybe [] (toXMLAttribute "value") $ time_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ time_extension x
            ]
instance Extension Time Element where
    supertype (Time a0 a1 e0) =
               Element a0 e0
 
newtype Id'primitive = Id'primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts Id'primitive Xsd.XsdString where
    restricts (Id'primitive x) = x
instance SchemaType Id'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Id'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Id'primitive where
    acceptingParser = fmap Id'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [A-Za-z0-9\-\.]{1,64})
    --      (StrLength (Occurs (Just 1) (Just 64)))
    simpleTypeText (Id'primitive x) = simpleTypeText x
 
data Id = Id
        { id_id :: Maybe String'primitive
        , id_value :: Maybe Id'primitive
        , id_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Id where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Id a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Id{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ id_id x
                       , maybe [] (toXMLAttribute "value") $ id_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ id_extension x
            ]
instance Extension Id Element where
    supertype (Id a0 a1 e0) =
               Element a0 e0
 
newtype PositiveInt'primitive = PositiveInt'primitive Xs.PositiveInteger deriving (Eq,Show)
instance Restricts PositiveInt'primitive Xs.PositiveInteger where
    restricts (PositiveInt'primitive x) = x
instance SchemaType PositiveInt'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (PositiveInt'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PositiveInt'primitive where
    acceptingParser = fmap PositiveInt'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [1-9][0-9]*)
    simpleTypeText (PositiveInt'primitive x) = simpleTypeText x
 
data PositiveInt = PositiveInt
        { positiveInt_id :: Maybe String'primitive
        , positiveInt_value :: Maybe PositiveInt'primitive
        , positiveInt_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PositiveInt where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PositiveInt a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PositiveInt{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ positiveInt_id x
                       , maybe [] (toXMLAttribute "value") $ positiveInt_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ positiveInt_extension x
            ]
instance Extension PositiveInt Element where
    supertype (PositiveInt a0 a1 e0) =
               Element a0 e0
 
newtype Decimal'primitive = Decimal'primitive Xsd.Decimal deriving (Eq,Show)
instance Restricts Decimal'primitive Xsd.Decimal where
    restricts (Decimal'primitive x) = x
instance SchemaType Decimal'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Decimal'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Decimal'primitive where
    acceptingParser = fmap Decimal'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?([0]|([1-9][0-9]*))(\.[0-9]+)?)
    simpleTypeText (Decimal'primitive x) = simpleTypeText x
 
data Decimal = Decimal
        { decimal_id :: Maybe String'primitive
        , decimal_value :: Maybe Decimal'primitive
        , decimal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Decimal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Decimal a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Decimal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ decimal_id x
                       , maybe [] (toXMLAttribute "value") $ decimal_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ decimal_extension x
            ]
instance Extension Decimal Element where
    supertype (Decimal a0 a1 e0) =
               Element a0 e0
 
data ResourceContainer = ResourceContainer
        { resourceContainer_choice0 :: OneOf117 Account ActivityDefinition AdverseEvent AllergyIntolerance Appointment AppointmentResponse AuditEvent Basic Binary BodySite Bundle CapabilityStatement CarePlan CareTeam ChargeItem Claim ClaimResponse ClinicalImpression CodeSystem Communication CommunicationRequest CompartmentDefinition Composition ConceptMap Condition Consent Contract Coverage DataElement DetectedIssue Device DeviceComponent DeviceMetric DeviceRequest DeviceUseStatement DiagnosticReport DocumentManifest DocumentReference EligibilityRequest EligibilityResponse Encounter Endpoint EnrollmentRequest EnrollmentResponse EpisodeOfCare ExpansionProfile ExplanationOfBenefit FamilyMemberHistory Flag Goal GraphDefinition Group GuidanceResponse HealthcareService ImagingManifest ImagingStudy Immunization ImmunizationRecommendation ImplementationGuide Library Linkage List Location Measure MeasureReport Media Medication MedicationAdministration MedicationDispense MedicationRequest MedicationStatement MessageDefinition MessageHeader NamingSystem NutritionOrder Observation OperationDefinition OperationOutcome Organization Patient PaymentNotice PaymentReconciliation Person PlanDefinition Practitioner PractitionerRole Procedure ProcedureRequest ProcessRequest ProcessResponse Provenance Questionnaire QuestionnaireResponse ReferralRequest RelatedPerson RequestGroup ResearchStudy ResearchSubject RiskAssessment Schedule SearchParameter Sequence ServiceDefinition Slot Specimen StructureDefinition StructureMap Subscription Substance SupplyDelivery SupplyRequest Task TestReport TestScript ValueSet VisionPrescription Parameters
          -- ^ Choice between:
          --   
          --   (1) A financial tool for tracking value accrued for a 
          --   particular purpose. In the healthcare field, used to 
          --   track charges for a patient, cost centers, etc.
          --   
          --   (2) This resource allows for the definition of some 
          --   activity to be performed, independent of a particular 
          --   patient, practitioner, or other performance context.
          --   
          --   (3) Actual or potential/avoided event causing unintended 
          --   physical injury resulting from or contributed to by 
          --   medical care, a research study or other healthcare 
          --   setting factors that requires additional monitoring, 
          --   treatment, or hospitalization, or that results in 
          --   death.
          --   
          --   (4) Risk of harmful or undesirable, physiological response 
          --   which is unique to an individual and associated with 
          --   exposure to a substance.
          --   
          --   (5) A booking of a healthcare event among patient(s), 
          --   practitioner(s), related person(s) and/or device(s) for 
          --   a specific date/time. This may result in one or more 
          --   Encounter(s).
          --   
          --   (6) A reply to an appointment request for a patient and/or 
          --   practitioner(s), such as a confirmation or rejection.
          --   
          --   (7) A record of an event made for purposes of maintaining a 
          --   security log. Typical uses include detection of 
          --   intrusion attempts and monitoring for inappropriate 
          --   usage.
          --   
          --   (8) Basic is used for handling concepts not yet defined in 
          --   FHIR, narrative-only resources that don't map to an 
          --   existing resource, and custom resources not appropriate 
          --   for inclusion in the FHIR specification.
          --   
          --   (9) A binary resource can contain any content, whether 
          --   text, image, pdf, zip archive, etc.
          --   
          --   (10) Record details about the anatomical location of a 
          --   specimen or body part. This resource may be used when a 
          --   coded concept does not provide the necessary detail 
          --   needed for the use case.
          --   
          --   (11) A container for a collection of resources.
          --   
          --   (12) A Capability Statement documents a set of capabilities 
          --   (behaviors) of a FHIR Server that may be used as a 
          --   statement of actual server functionality or a statement 
          --   of required or desired server implementation.
          --   
          --   (13) Describes the intention of how one or more 
          --   practitioners intend to deliver care for a particular 
          --   patient, group or community for a period of time, 
          --   possibly limited to care for a specific condition or 
          --   set of conditions.
          --   
          --   (14) The Care Team includes all the people and organizations 
          --   who plan to participate in the coordination and 
          --   delivery of care for a patient.
          --   
          --   (15) The resource ChargeItem describes the provision of 
          --   healthcare provider products for a certain patient, 
          --   therefore referring not only to the product, but 
          --   containing in addition details of the provision, like 
          --   date, time, amounts and participating organizations and 
          --   persons. Main Usage of the ChargeItem is to enable the 
          --   billing process and internal cost allocation.
          --   
          --   (16) A provider issued list of services and products 
          --   provided, or to be provided, to a patient which is 
          --   provided to an insurer for payment recovery.
          --   
          --   (17) This resource provides the adjudication details from 
          --   the processing of a Claim resource.
          --   
          --   (18) A record of a clinical assessment performed to 
          --   determine what problem(s) may affect the patient and 
          --   before planning the treatments or management strategies 
          --   that are best to manage a patient's condition. 
          --   Assessments are often 1:1 with a clinical consultation 
          --   / encounter, but this varies greatly depending on the 
          --   clinical workflow. This resource is called 
          --   &quot;ClinicalImpression&quot; rather than 
          --   &quot;ClinicalAssessment&quot; to avoid confusion with 
          --   the recording of assessment tools such as Apgar score.
          --   
          --   (19) A code system resource specifies a set of codes drawn 
          --   from one or more code systems.
          --   
          --   (20) An occurrence of information being transmitted; e.g. an 
          --   alert that was sent to a responsible provider, a public 
          --   health agency was notified about a reportable 
          --   condition.
          --   
          --   (21) A request to convey information; e.g. the CDS system 
          --   proposes that an alert be sent to a responsible 
          --   provider, the CDS system proposes that the public 
          --   health agency be notified about a reportable condition.
          --   
          --   (22) A compartment definition that defines how resources are 
          --   accessed on a server.
          --   
          --   (23) A set of healthcare-related information that is 
          --   assembled together into a single logical document that 
          --   provides a single coherent statement of meaning, 
          --   establishes its own context and that has clinical 
          --   attestation with regard to who is making the statement. 
          --   While a Composition defines the structure, it does not 
          --   actually contain the content: rather the full content 
          --   of a document is contained in a Bundle, of which the 
          --   Composition is the first resource contained.
          --   
          --   (24) A statement of relationships from one set of concepts 
          --   to one or more other concepts - either code systems or 
          --   data elements, or classes in class models.
          --   
          --   (25) A clinical condition, problem, diagnosis, or other 
          --   event, situation, issue, or clinical concept that has 
          --   risen to a level of concern.
          --   
          --   (26) A record of a healthcare consumerâ€™s policy choices, 
          --   which permits or denies identified recipient(s) or 
          --   recipient role(s) to perform one or more actions within 
          --   a given policy context, for specific purposes and 
          --   periods of time.
          --   
          --   (27) A formal agreement between parties regarding the 
          --   conduct of business, exchange of information or other 
          --   matters.
          --   
          --   (28) Financial instrument which may be used to reimburse or 
          --   pay for health care products and services.
          --   
          --   (29) The formal description of a single piece of information 
          --   that can be gathered and reported.
          --   
          --   (30) Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions 
          --   for a patient; e.g. Drug-drug interaction, Ineffective 
          --   treatment frequency, Procedure-condition conflict, etc.
          --   
          --   (31) This resource identifies an instance or a type of a 
          --   manufactured item that is used in the provision of 
          --   healthcare without being substantially changed through 
          --   that activity. The device may be a medical or 
          --   non-medical device. Medical devices include durable 
          --   (reusable) medical equipment, implantable devices, as 
          --   well as disposable equipment used for diagnostic, 
          --   treatment, and research for healthcare and public 
          --   health. Non-medical devices may include items such as a 
          --   machine, cellphone, computer, application, etc.
          --   
          --   (32) The characteristics, operational status and 
          --   capabilities of a medical-related component of a 
          --   medical device.
          --   
          --   (33) Describes a measurement, calculation or setting 
          --   capability of a medical device.
          --   
          --   (34) Represents a request for a patient to employ a medical 
          --   device. The device may be an implantable device, or an 
          --   external assistive device, such as a walker.
          --   
          --   (35) A record of a device being used by a patient where the 
          --   record is the result of a report from the patient or 
          --   another clinician.
          --   
          --   (36) The findings and interpretation of diagnostic tests 
          --   performed on patients, groups of patients, devices, and 
          --   locations, and/or specimens derived from these. The 
          --   report includes clinical context such as requesting and 
          --   provider information, and some mix of atomic results, 
          --   images, textual and coded interpretations, and 
          --   formatted representation of diagnostic reports.
          --   
          --   (37) A collection of documents compiled for a purpose 
          --   together with metadata that applies to the collection.
          --   
          --   (38) A reference to a document.
          --   
          --   (39) The EligibilityRequest provides patient and insurance 
          --   coverage information to an insurer for them to respond, 
          --   in the form of an EligibilityResponse, with information 
          --   regarding whether the stated coverage is valid and 
          --   in-force and optionally to provide the insurance 
          --   details of the policy.
          --   
          --   (40) This resource provides eligibility and plan details 
          --   from the processing of an Eligibility resource.
          --   
          --   (41) An interaction between a patient and healthcare 
          --   provider(s) for the purpose of providing healthcare 
          --   service(s) or assessing the health status of a patient.
          --   
          --   (42) The technical details of an endpoint that can be used 
          --   for electronic services, such as for web services 
          --   providing XDS.b or a REST endpoint for another FHIR 
          --   server. This may include any security context 
          --   information.
          --   
          --   (43) This resource provides the insurance enrollment details 
          --   to the insurer regarding a specified coverage.
          --   
          --   (44) This resource provides enrollment and plan details from 
          --   the processing of an Enrollment resource.
          --   
          --   (45) An association between a patient and an organization / 
          --   healthcare provider(s) during which time encounters may 
          --   occur. The managing organization assumes a level of 
          --   responsibility for the patient during this time.
          --   
          --   (46) Resource to define constraints on the Expansion of a 
          --   FHIR ValueSet.
          --   
          --   (47) This resource provides: the claim details; adjudication 
          --   details from the processing of a Claim; and optionally 
          --   account balance information, for informing the 
          --   subscriber of the benefits provided.
          --   
          --   (48) Significant health events and conditions for a person 
          --   related to the patient relevant in the context of care 
          --   for the patient.
          --   
          --   (49) Prospective warnings of potential issues when providing 
          --   care to the patient.
          --   
          --   (50) Describes the intended objective(s) for a patient, 
          --   group or organization care, for example, weight loss, 
          --   restoring an activity of daily living, obtaining herd 
          --   immunity via immunization, meeting a process 
          --   improvement objective, etc.
          --   
          --   (51) A formal computable definition of a graph of resources 
          --   - that is, a coherent set of resources that form a 
          --   graph by following references. The Graph Definition 
          --   resource defines a set and makes rules about the set.
          --   
          --   (52) Represents a defined collection of entities that may be 
          --   discussed or acted upon collectively but which are not 
          --   expected to act collectively and are not formally or 
          --   legally recognized; i.e. a collection of entities that 
          --   isn't an Organization.
          --   
          --   (53) A guidance response is the formal response to a 
          --   guidance request, including any output parameters 
          --   returned by the evaluation, as well as the description 
          --   of any proposed actions to be taken.
          --   
          --   (54) The details of a healthcare service available at a 
          --   location.
          --   
          --   (55) A text description of the DICOM SOP instances selected 
          --   in the ImagingManifest; or the reason for, or 
          --   significance of, the selection.
          --   
          --   (56) Representation of the content produced in a DICOM 
          --   imaging study. A study comprises a set of series, each 
          --   of which includes a set of Service-Object Pair 
          --   Instances (SOP Instances - images or other data) 
          --   acquired or produced in a common context. A series is 
          --   of only one modality (e.g. X-ray, CT, MR, ultrasound), 
          --   but a study may have multiple series of different 
          --   modalities.
          --   
          --   (57) Describes the event of a patient being administered a 
          --   vaccination or a record of a vaccination as reported by 
          --   a patient, a clinician or another party and may include 
          --   vaccine reaction information and what vaccination 
          --   protocol was followed.
          --   
          --   (58) A patient's point-in-time immunization and 
          --   recommendation (i.e. forecasting a patient's 
          --   immunization eligibility according to a published 
          --   schedule) with optional supporting justification.
          --   
          --   (59) A set of rules of how FHIR is used to solve a 
          --   particular problem. This resource is used to gather all 
          --   the parts of an implementation guide into a logical 
          --   whole and to publish a computable definition of all the 
          --   parts.
          --   
          --   (60) The Library resource is a general-purpose container for 
          --   knowledge asset definitions. It can be used to describe 
          --   and expose existing knowledge assets such as logic 
          --   libraries and information model descriptions, as well 
          --   as to describe a collection of knowledge assets.
          --   
          --   (61) Identifies two or more records (resource instances) 
          --   that are referring to the same real-world 
          --   &quot;occurrence&quot;.
          --   
          --   (62) A set of information summarized from a list of other 
          --   resources.
          --   
          --   (63) Details and position information for a physical place 
          --   where services are provided and resources and 
          --   participants may be stored, found, contained or 
          --   accommodated.
          --   
          --   (64) The Measure resource provides the definition of a 
          --   quality measure.
          --   
          --   (65) The MeasureReport resource contains the results of 
          --   evaluating a measure.
          --   
          --   (66) A photo, video, or audio recording acquired or used in 
          --   healthcare. The actual content may be inline or 
          --   provided by direct reference.
          --   
          --   (67) This resource is primarily used for the identification 
          --   and definition of a medication. It covers the 
          --   ingredients and the packaging for a medication.
          --   
          --   (68) Describes the event of a patient consuming or otherwise 
          --   being administered a medication. This may be as simple 
          --   as swallowing a tablet or it may be a long running 
          --   infusion. Related resources tie this event to the 
          --   authorizing prescription, and the specific encounter 
          --   between patient and health care practitioner.
          --   
          --   (69) Indicates that a medication product is to be or has 
          --   been dispensed for a named person/patient. This 
          --   includes a description of the medication product 
          --   (supply) provided and the instructions for 
          --   administering the medication. The medication dispense 
          --   is the result of a pharmacy system responding to a 
          --   medication order.
          --   
          --   (70) An order or request for both supply of the medication 
          --   and the instructions for administration of the 
          --   medication to a patient. The resource is called 
          --   &quot;MedicationRequest&quot; rather than 
          --   &quot;MedicationPrescription&quot; or 
          --   &quot;MedicationOrder&quot; to generalize the use 
          --   across inpatient and outpatient settings, including 
          --   care plans, etc., and to harmonize with workflow 
          --   patterns.
          --   
          --   (71) A record of a medication that is being consumed by a 
          --   patient. A MedicationStatement may indicate that the 
          --   patient may be taking the medication now, or has taken 
          --   the medication in the past or will be taking the 
          --   medication in the future. The source of this 
          --   information can be the patient, significant other (such 
          --   as a family member or spouse), or a clinician. A common 
          --   scenario where this information is captured is during 
          --   the history taking process during a patient visit or 
          --   stay. The medication information may come from sources 
          --   such as the patient's memory, from a prescription 
          --   bottle, or from a list of medications the patient, 
          --   clinician or other party maintains The primary 
          --   difference between a medication statement and a 
          --   medication administration is that the medication 
          --   administration has complete administration information 
          --   and is based on actual administration information from 
          --   the person who administered the medication. A 
          --   medication statement is often, if not always, less 
          --   specific. There is no required date/time when the 
          --   medication was administered, in fact we only know that 
          --   a source has reported the patient is taking this 
          --   medication, where details such as time, quantity, or 
          --   rate or even medication product may be incomplete or 
          --   missing or less precise. As stated earlier, the 
          --   medication statement information may come from the 
          --   patient's memory, from a prescription bottle or from a 
          --   list of medications the patient, clinician or other 
          --   party maintains. Medication administration is more 
          --   formal and is not missing detailed information.
          --   
          --   (72) Defines the characteristics of a message that can be 
          --   shared between systems, including the type of event 
          --   that initiates the message, the content to be 
          --   transmitted and what response(s), if any, are 
          --   permitted.
          --   
          --   (73) The header for a message exchange that is either 
          --   requesting or responding to an action. The reference(s) 
          --   that are the subject of the action as well as other 
          --   information related to the action are typically 
          --   transmitted in a bundle in which the MessageHeader 
          --   resource instance is the first resource in the bundle.
          --   
          --   (74) A curated namespace that issues unique symbols within 
          --   that namespace for the identification of concepts, 
          --   people, devices, etc. Represents a &quot;System&quot; 
          --   used within the Identifier and Coding data types.
          --   
          --   (75) A request to supply a diet, formula feeding (enteral) 
          --   or oral nutritional supplement to a patient/resident.
          --   
          --   (76) Measurements and simple assertions made about a 
          --   patient, device or other subject.
          --   
          --   (77) A formal computable definition of an operation (on the 
          --   RESTful interface) or a named query (using the search 
          --   interaction).
          --   
          --   (78) A collection of error, warning or information messages 
          --   that result from a system action.
          --   
          --   (79) A formally or informally recognized grouping of people 
          --   or organizations formed for the purpose of achieving 
          --   some form of collective action. Includes companies, 
          --   institutions, corporations, departments, community 
          --   groups, healthcare practice groups, etc.
          --   
          --   (80) Demographics and other administrative information about 
          --   an individual or animal receiving care or other 
          --   health-related services.
          --   
          --   (81) This resource provides the status of the payment for 
          --   goods and services rendered, and the request and 
          --   response resource references.
          --   
          --   (82) This resource provides payment details and claim 
          --   references supporting a bulk payment.
          --   
          --   (83) Demographics and administrative information about a 
          --   person independent of a specific health-related 
          --   context.
          --   
          --   (84) This resource allows for the definition of various 
          --   types of plans as a sharable, consumable, and 
          --   executable artifact. The resource is general enough to 
          --   support the description of a broad range of clinical 
          --   artifacts such as clinical decision support rules, 
          --   order sets and protocols.
          --   
          --   (85) A person who is directly or indirectly involved in the 
          --   provisioning of healthcare.
          --   
          --   (86) A specific set of Roles/Locations/specialties/services 
          --   that a practitioner may perform at an organization for 
          --   a period of time.
          --   
          --   (87) An action that is or was performed on a patient. This 
          --   can be a physical intervention like an operation, or 
          --   less invasive like counseling or hypnotherapy.
          --   
          --   (88) A record of a request for diagnostic investigations, 
          --   treatments, or operations to be performed.
          --   
          --   (89) This resource provides the target, request and 
          --   response, and action details for an action to be 
          --   performed by the target on or about existing resources.
          --   
          --   (90) This resource provides processing status, errors and 
          --   notes from the processing of a resource.
          --   
          --   (91) Provenance of a resource is a record that describes 
          --   entities and processes involved in producing and 
          --   delivering or otherwise influencing that resource. 
          --   Provenance provides a critical foundation for assessing 
          --   authenticity, enabling trust, and allowing 
          --   reproducibility. Provenance assertions are a form of 
          --   contextual metadata and can themselves become important 
          --   records with their own provenance. Provenance statement 
          --   indicates clinical significance in terms of confidence 
          --   in authenticity, reliability, and trustworthiness, 
          --   integrity, and stage in lifecycle (e.g. Document 
          --   Completion - has the artifact been legally 
          --   authenticated), all of which may impact security, 
          --   privacy, and trust policies.
          --   
          --   (92) A structured set of questions intended to guide the 
          --   collection of answers from end-users. Questionnaires 
          --   provide detailed control over order, presentation, 
          --   phraseology and grouping to allow coherent, consistent 
          --   data collection.
          --   
          --   (93) A structured set of questions and their answers. The 
          --   questions are ordered and grouped into coherent 
          --   subsets, corresponding to the structure of the grouping 
          --   of the questionnaire being responded to.
          --   
          --   (94) Used to record and send details about a request for 
          --   referral service or transfer of a patient to the care 
          --   of another provider or provider organization.
          --   
          --   (95) Information about a person that is involved in the care 
          --   for a patient, but who is not the target of healthcare, 
          --   nor has a formal responsibility in the care process.
          --   
          --   (96) A group of related requests that can be used to capture 
          --   intended activities that have inter-dependencies such 
          --   as &quot;give this medication after that one&quot;.
          --   
          --   (97) A process where a researcher or organization plans and 
          --   then executes a series of steps intended to increase 
          --   the field of healthcare-related knowledge. This 
          --   includes studies of safety, efficacy, comparative 
          --   effectiveness and other information about medications, 
          --   devices, therapies and other interventional and 
          --   investigative techniques. A ResearchStudy involves the 
          --   gathering of information about human or animal 
          --   subjects.
          --   
          --   (98) A process where a researcher or organization plans and 
          --   then executes a series of steps intended to increase 
          --   the field of healthcare-related knowledge. This 
          --   includes studies of safety, efficacy, comparative 
          --   effectiveness and other information about medications, 
          --   devices, therapies and other interventional and 
          --   investigative techniques. A ResearchStudy involves the 
          --   gathering of information about human or animal 
          --   subjects.
          --   
          --   (99) An assessment of the likely outcome(s) for a patient or 
          --   other subject as well as the likelihood of each 
          --   outcome.
          --   
          --   (100) A container for slots of time that may be available for 
          --   booking appointments.
          --   
          --   (101) A search parameter that defines a named search item 
          --   that can be used to search/filter on a resource.
          --   
          --   (102) Raw data describing a biological sequence.
          --   
          --   (103) The ServiceDefinition describes a unit of decision 
          --   support functionality that is made available as a 
          --   service, such as immunization modules or drug-drug 
          --   interaction checking.
          --   
          --   (104) A slot of time on a schedule that may be available for 
          --   booking appointments.
          --   
          --   (105) A sample to be used for analysis.
          --   
          --   (106) A definition of a FHIR structure. This resource is used 
          --   to describe the underlying resources, data types 
          --   defined in FHIR, and also for describing extensions and 
          --   constraints on resources and data types.
          --   
          --   (107) A Map of relationships between 2 structures that can be 
          --   used to transform data.
          --   
          --   (108) The subscription resource is used to define a push 
          --   based subscription from a server to another system. 
          --   Once a subscription is registered with the server, the 
          --   server checks every resource that is created or 
          --   updated, and if the resource matches the given 
          --   criteria, it sends a message on the defined 
          --   &quot;channel&quot; so that another system is able to 
          --   take an appropriate action.
          --   
          --   (109) A homogeneous material with a definite composition.
          --   
          --   (110) Record of delivery of what is supplied.
          --   
          --   (111) A record of a request for a medication, substance or 
          --   device used in the healthcare setting.
          --   
          --   (112) A task to be performed.
          --   
          --   (113) A summary of information based on the results of 
          --   executing a TestScript.
          --   
          --   (114) A structured set of tests against a FHIR server 
          --   implementation to determine compliance against the FHIR 
          --   specification.
          --   
          --   (115) A value set specifies a set of codes drawn from one or 
          --   more code systems.
          --   
          --   (116) An authorization for the supply of glasses and/or 
          --   contact lenses to a patient.
          --   
          --   (117) This special resource type is used to represent an 
          --   operation request and response (operations.html). It 
          --   has no other use, and there is no RESTful endpoint 
          --   associated with it.
        }
        deriving (Eq,Show)
instance SchemaType ResourceContainer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResourceContainer
            `apply` oneOf' [ ("Account", fmap OneOf117 (elementAccount))
                           , ("ActivityDefinition", fmap TwoOf117 (elementActivityDefinition))
                           , ("AdverseEvent", fmap ThreeOf117 (elementAdverseEvent))
                           , ("AllergyIntolerance", fmap FourOf117 (elementAllergyIntolerance))
                           , ("Appointment", fmap FiveOf117 (elementAppointment))
                           , ("AppointmentResponse", fmap SixOf117 (elementAppointmentResponse))
                           , ("AuditEvent", fmap SevenOf117 (elementAuditEvent))
                           , ("Basic", fmap EightOf117 (elementBasic))
                           , ("Binary", fmap NineOf117 (elementBinary))
                           , ("BodySite", fmap TenOf117 (elementBodySite))
                           , ("Bundle", fmap ElevenOf117 (elementBundle))
                           , ("CapabilityStatement", fmap TwelveOf117 (elementCapabilityStatement))
                           , ("CarePlan", fmap ThirteenOf117 (elementCarePlan))
                           , ("CareTeam", fmap FourteenOf117 (elementCareTeam))
                           , ("ChargeItem", fmap FifteenOf117 (elementChargeItem))
                           , ("Claim", fmap SixteenOf117 (elementClaim))
                           , ("ClaimResponse", fmap SeventeenOf117 (elementClaimResponse))
                           , ("ClinicalImpression", fmap EighteenOf117 (elementClinicalImpression))
                           , ("CodeSystem", fmap NineteenOf117 (elementCodeSystem))
                           , ("Communication", fmap TwentyOf117 (elementCommunication))
                           , ("CommunicationRequest", fmap Choice21Of117 (elementCommunicationRequest))
                           , ("CompartmentDefinition", fmap Choice22Of117 (elementCompartmentDefinition))
                           , ("Composition", fmap Choice23Of117 (elementComposition))
                           , ("ConceptMap", fmap Choice24Of117 (elementConceptMap))
                           , ("Condition", fmap Choice25Of117 (elementCondition))
                           , ("Consent", fmap Choice26Of117 (elementConsent))
                           , ("Contract", fmap Choice27Of117 (elementContract))
                           , ("Coverage", fmap Choice28Of117 (elementCoverage))
                           , ("DataElement", fmap Choice29Of117 (elementDataElement))
                           , ("DetectedIssue", fmap Choice30Of117 (elementDetectedIssue))
                           , ("Device", fmap Choice31Of117 (elementDevice))
                           , ("DeviceComponent", fmap Choice32Of117 (elementDeviceComponent))
                           , ("DeviceMetric", fmap Choice33Of117 (elementDeviceMetric))
                           , ("DeviceRequest", fmap Choice34Of117 (elementDeviceRequest))
                           , ("DeviceUseStatement", fmap Choice35Of117 (elementDeviceUseStatement))
                           , ("DiagnosticReport", fmap Choice36Of117 (elementDiagnosticReport))
                           , ("DocumentManifest", fmap Choice37Of117 (elementDocumentManifest))
                           , ("DocumentReference", fmap Choice38Of117 (elementDocumentReference))
                           , ("EligibilityRequest", fmap Choice39Of117 (elementEligibilityRequest))
                           , ("EligibilityResponse", fmap Choice40Of117 (elementEligibilityResponse))
                           , ("Encounter", fmap Choice41Of117 (elementEncounter))
                           , ("Endpoint", fmap Choice42Of117 (elementEndpoint))
                           , ("EnrollmentRequest", fmap Choice43Of117 (elementEnrollmentRequest))
                           , ("EnrollmentResponse", fmap Choice44Of117 (elementEnrollmentResponse))
                           , ("EpisodeOfCare", fmap Choice45Of117 (elementEpisodeOfCare))
                           , ("ExpansionProfile", fmap Choice46Of117 (elementExpansionProfile))
                           , ("ExplanationOfBenefit", fmap Choice47Of117 (elementExplanationOfBenefit))
                           , ("FamilyMemberHistory", fmap Choice48Of117 (elementFamilyMemberHistory))
                           , ("Flag", fmap Choice49Of117 (elementFlag))
                           , ("Goal", fmap Choice50Of117 (elementGoal))
                           , ("GraphDefinition", fmap Choice51Of117 (elementGraphDefinition))
                           , ("Group", fmap Choice52Of117 (elementGroup))
                           , ("GuidanceResponse", fmap Choice53Of117 (elementGuidanceResponse))
                           , ("HealthcareService", fmap Choice54Of117 (elementHealthcareService))
                           , ("ImagingManifest", fmap Choice55Of117 (elementImagingManifest))
                           , ("ImagingStudy", fmap Choice56Of117 (elementImagingStudy))
                           , ("Immunization", fmap Choice57Of117 (elementImmunization))
                           , ("ImmunizationRecommendation", fmap Choice58Of117 (elementImmunizationRecommendation))
                           , ("ImplementationGuide", fmap Choice59Of117 (elementImplementationGuide))
                           , ("Library", fmap Choice60Of117 (elementLibrary))
                           , ("Linkage", fmap Choice61Of117 (elementLinkage))
                           , ("List", fmap Choice62Of117 (elementList))
                           , ("Location", fmap Choice63Of117 (elementLocation))
                           , ("Measure", fmap Choice64Of117 (elementMeasure))
                           , ("MeasureReport", fmap Choice65Of117 (elementMeasureReport))
                           , ("Media", fmap Choice66Of117 (elementMedia))
                           , ("Medication", fmap Choice67Of117 (elementMedication))
                           , ("MedicationAdministration", fmap Choice68Of117 (elementMedicationAdministration))
                           , ("MedicationDispense", fmap Choice69Of117 (elementMedicationDispense))
                           , ("MedicationRequest", fmap Choice70Of117 (elementMedicationRequest))
                           , ("MedicationStatement", fmap Choice71Of117 (elementMedicationStatement))
                           , ("MessageDefinition", fmap Choice72Of117 (elementMessageDefinition))
                           , ("MessageHeader", fmap Choice73Of117 (elementMessageHeader))
                           , ("NamingSystem", fmap Choice74Of117 (elementNamingSystem))
                           , ("NutritionOrder", fmap Choice75Of117 (elementNutritionOrder))
                           , ("Observation", fmap Choice76Of117 (elementObservation))
                           , ("OperationDefinition", fmap Choice77Of117 (elementOperationDefinition))
                           , ("OperationOutcome", fmap Choice78Of117 (elementOperationOutcome))
                           , ("Organization", fmap Choice79Of117 (elementOrganization))
                           , ("Patient", fmap Choice80Of117 (elementPatient))
                           , ("PaymentNotice", fmap Choice81Of117 (elementPaymentNotice))
                           , ("PaymentReconciliation", fmap Choice82Of117 (elementPaymentReconciliation))
                           , ("Person", fmap Choice83Of117 (elementPerson))
                           , ("PlanDefinition", fmap Choice84Of117 (elementPlanDefinition))
                           , ("Practitioner", fmap Choice85Of117 (elementPractitioner))
                           , ("PractitionerRole", fmap Choice86Of117 (elementPractitionerRole))
                           , ("Procedure", fmap Choice87Of117 (elementProcedure))
                           , ("ProcedureRequest", fmap Choice88Of117 (elementProcedureRequest))
                           , ("ProcessRequest", fmap Choice89Of117 (elementProcessRequest))
                           , ("ProcessResponse", fmap Choice90Of117 (elementProcessResponse))
                           , ("Provenance", fmap Choice91Of117 (elementProvenance))
                           , ("Questionnaire", fmap Choice92Of117 (elementQuestionnaire))
                           , ("QuestionnaireResponse", fmap Choice93Of117 (elementQuestionnaireResponse))
                           , ("ReferralRequest", fmap Choice94Of117 (elementReferralRequest))
                           , ("RelatedPerson", fmap Choice95Of117 (elementRelatedPerson))
                           , ("RequestGroup", fmap Choice96Of117 (elementRequestGroup))
                           , ("ResearchStudy", fmap Choice97Of117 (elementResearchStudy))
                           , ("ResearchSubject", fmap Choice98Of117 (elementResearchSubject))
                           , ("RiskAssessment", fmap Choice99Of117 (elementRiskAssessment))
                           , ("Schedule", fmap Choice100Of117 (elementSchedule))
                           , ("SearchParameter", fmap Choice101Of117 (elementSearchParameter))
                           , ("Sequence", fmap Choice102Of117 (elementSequence))
                           , ("ServiceDefinition", fmap Choice103Of117 (elementServiceDefinition))
                           , ("Slot", fmap Choice104Of117 (elementSlot))
                           , ("Specimen", fmap Choice105Of117 (elementSpecimen))
                           , ("StructureDefinition", fmap Choice106Of117 (elementStructureDefinition))
                           , ("StructureMap", fmap Choice107Of117 (elementStructureMap))
                           , ("Subscription", fmap Choice108Of117 (elementSubscription))
                           , ("Substance", fmap Choice109Of117 (elementSubstance))
                           , ("SupplyDelivery", fmap Choice110Of117 (elementSupplyDelivery))
                           , ("SupplyRequest", fmap Choice111Of117 (elementSupplyRequest))
                           , ("Task", fmap Choice112Of117 (elementTask))
                           , ("TestReport", fmap Choice113Of117 (elementTestReport))
                           , ("TestScript", fmap Choice114Of117 (elementTestScript))
                           , ("ValueSet", fmap Choice115Of117 (elementValueSet))
                           , ("VisionPrescription", fmap Choice116Of117 (elementVisionPrescription))
                           , ("Parameters", fmap Choice117Of117 (elementParameters))
                           ]
    schemaTypeToXML s x@ResourceContainer{} =
        toXMLElement s []
            [ foldOneOf117  (elementToXMLAccount)
                            (elementToXMLActivityDefinition)
                            (elementToXMLAdverseEvent)
                            (elementToXMLAllergyIntolerance)
                            (elementToXMLAppointment)
                            (elementToXMLAppointmentResponse)
                            (elementToXMLAuditEvent)
                            (elementToXMLBasic)
                            (elementToXMLBinary)
                            (elementToXMLBodySite)
                            (elementToXMLBundle)
                            (elementToXMLCapabilityStatement)
                            (elementToXMLCarePlan)
                            (elementToXMLCareTeam)
                            (elementToXMLChargeItem)
                            (elementToXMLClaim)
                            (elementToXMLClaimResponse)
                            (elementToXMLClinicalImpression)
                            (elementToXMLCodeSystem)
                            (elementToXMLCommunication)
                            (elementToXMLCommunicationRequest)
                            (elementToXMLCompartmentDefinition)
                            (elementToXMLComposition)
                            (elementToXMLConceptMap)
                            (elementToXMLCondition)
                            (elementToXMLConsent)
                            (elementToXMLContract)
                            (elementToXMLCoverage)
                            (elementToXMLDataElement)
                            (elementToXMLDetectedIssue)
                            (elementToXMLDevice)
                            (elementToXMLDeviceComponent)
                            (elementToXMLDeviceMetric)
                            (elementToXMLDeviceRequest)
                            (elementToXMLDeviceUseStatement)
                            (elementToXMLDiagnosticReport)
                            (elementToXMLDocumentManifest)
                            (elementToXMLDocumentReference)
                            (elementToXMLEligibilityRequest)
                            (elementToXMLEligibilityResponse)
                            (elementToXMLEncounter)
                            (elementToXMLEndpoint)
                            (elementToXMLEnrollmentRequest)
                            (elementToXMLEnrollmentResponse)
                            (elementToXMLEpisodeOfCare)
                            (elementToXMLExpansionProfile)
                            (elementToXMLExplanationOfBenefit)
                            (elementToXMLFamilyMemberHistory)
                            (elementToXMLFlag)
                            (elementToXMLGoal)
                            (elementToXMLGraphDefinition)
                            (elementToXMLGroup)
                            (elementToXMLGuidanceResponse)
                            (elementToXMLHealthcareService)
                            (elementToXMLImagingManifest)
                            (elementToXMLImagingStudy)
                            (elementToXMLImmunization)
                            (elementToXMLImmunizationRecommendation)
                            (elementToXMLImplementationGuide)
                            (elementToXMLLibrary)
                            (elementToXMLLinkage)
                            (elementToXMLList)
                            (elementToXMLLocation)
                            (elementToXMLMeasure)
                            (elementToXMLMeasureReport)
                            (elementToXMLMedia)
                            (elementToXMLMedication)
                            (elementToXMLMedicationAdministration)
                            (elementToXMLMedicationDispense)
                            (elementToXMLMedicationRequest)
                            (elementToXMLMedicationStatement)
                            (elementToXMLMessageDefinition)
                            (elementToXMLMessageHeader)
                            (elementToXMLNamingSystem)
                            (elementToXMLNutritionOrder)
                            (elementToXMLObservation)
                            (elementToXMLOperationDefinition)
                            (elementToXMLOperationOutcome)
                            (elementToXMLOrganization)
                            (elementToXMLPatient)
                            (elementToXMLPaymentNotice)
                            (elementToXMLPaymentReconciliation)
                            (elementToXMLPerson)
                            (elementToXMLPlanDefinition)
                            (elementToXMLPractitioner)
                            (elementToXMLPractitionerRole)
                            (elementToXMLProcedure)
                            (elementToXMLProcedureRequest)
                            (elementToXMLProcessRequest)
                            (elementToXMLProcessResponse)
                            (elementToXMLProvenance)
                            (elementToXMLQuestionnaire)
                            (elementToXMLQuestionnaireResponse)
                            (elementToXMLReferralRequest)
                            (elementToXMLRelatedPerson)
                            (elementToXMLRequestGroup)
                            (elementToXMLResearchStudy)
                            (elementToXMLResearchSubject)
                            (elementToXMLRiskAssessment)
                            (elementToXMLSchedule)
                            (elementToXMLSearchParameter)
                            (elementToXMLSequence)
                            (elementToXMLServiceDefinition)
                            (elementToXMLSlot)
                            (elementToXMLSpecimen)
                            (elementToXMLStructureDefinition)
                            (elementToXMLStructureMap)
                            (elementToXMLSubscription)
                            (elementToXMLSubstance)
                            (elementToXMLSupplyDelivery)
                            (elementToXMLSupplyRequest)
                            (elementToXMLTask)
                            (elementToXMLTestReport)
                            (elementToXMLTestScript)
                            (elementToXMLValueSet)
                            (elementToXMLVisionPrescription)
                            (elementToXMLParameters)
                            $ resourceContainer_choice0 x
            ]
 
data Extension = Extension
        { extension_id :: Maybe String'primitive
        , extension_url :: Uri'primitive
        , extension_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , extension_choice1 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Value of extension - may be a resource or one of a 
          --   constrained set of the data types (see Extensibility in the 
          --   spec for list).
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType Extension where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- getAttribute "url" e pos
        commit $ interior e $ return (Extension a0 a1)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                                     ])
    schemaTypeToXML s x@Extension{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ extension_id x
                       , toXMLAttribute "url" $ extension_url x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ extension_extension x
            , maybe [] (foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueCode")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueId")
                                     (schemaTypeToXML "valueInstant")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueMarkdown")
                                     (schemaTypeToXML "valueOid")
                                     (schemaTypeToXML "valuePositiveInt")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueUnsignedInt")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAddress")
                                     (schemaTypeToXML "valueAge")
                                     (schemaTypeToXML "valueAnnotation")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueContactPoint")
                                     (schemaTypeToXML "valueCount")
                                     (schemaTypeToXML "valueDistance")
                                     (schemaTypeToXML "valueDuration")
                                     (schemaTypeToXML "valueHumanName")
                                     (schemaTypeToXML "valueIdentifier")
                                     (schemaTypeToXML "valueMoney")
                                     (schemaTypeToXML "valuePeriod")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueReference")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueSignature")
                                     (schemaTypeToXML "valueTiming")
                                     (schemaTypeToXML "valueMeta")
                                    ) $ extension_choice1 x
            ]
instance Extension Extension Element where
    supertype (Extension a0 a1 e0 e1) =
               Element a0 e0
 
data BackboneElement = BackboneElement
        { backboneElement_id :: Maybe String'primitive
        , backboneElement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , backboneElement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        }
        deriving (Eq,Show)
instance SchemaType BackboneElement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BackboneElement a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
    schemaTypeToXML s x@BackboneElement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ backboneElement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ backboneElement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ backboneElement_modifierExtension x
            ]
instance Extension BackboneElement Element where
    supertype (BackboneElement a0 e0 e1) =
               Element a0 e0
 
data Narrative = Narrative
        { narrative_id :: Maybe String'primitive
        , narrative_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , narrative_status :: NarrativeStatus
          -- ^ The status of the narrative - whether it's entirely 
          --   generated (from just the defined data or the extensions 
          --   too), or whether a human authored it and it may contain 
          --   additional data.
        , narrative_Xhtml.div :: Xhtml.Div
        }
        deriving (Eq,Show)
instance SchemaType Narrative where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Narrative a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "status"
            `apply` elementDiv
    schemaTypeToXML s x@Narrative{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ narrative_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ narrative_extension x
            , schemaTypeToXML "status" $ narrative_status x
            , elementToXMLDiv $ narrative_Xhtml.div x
            ]
instance Extension Narrative Element where
    supertype (Narrative a0 e0 e1 e2) =
               Element a0 e0
 
data NarrativeStatus'list
    = NarrativeStatus'list_Generated
      -- ^ Generated
    | NarrativeStatus'list_Extensions
      -- ^ Extensions
    | NarrativeStatus'list_Additional
      -- ^ Additional
    | NarrativeStatus'list_Empty
      -- ^ Empty
    deriving (Eq,Show,Enum)
instance SchemaType NarrativeStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NarrativeStatus'list where
    acceptingParser =  do literal "generated"; return NarrativeStatus'list_Generated
                      `onFail` do literal "extensions"; return NarrativeStatus'list_Extensions
                      `onFail` do literal "additional"; return NarrativeStatus'list_Additional
                      `onFail` do literal "empty"; return NarrativeStatus'list_Empty
                      
    simpleTypeText NarrativeStatus'list_Generated = "generated"
    simpleTypeText NarrativeStatus'list_Extensions = "extensions"
    simpleTypeText NarrativeStatus'list_Additional = "additional"
    simpleTypeText NarrativeStatus'list_Empty = "empty"
 
data NarrativeStatus = NarrativeStatus
        { narrativeStatus_id :: Maybe String'primitive
        , narrativeStatus_value :: Maybe NarrativeStatus'list
        , narrativeStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NarrativeStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NarrativeStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NarrativeStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ narrativeStatus_id x
                       , maybe [] (toXMLAttribute "value") $ narrativeStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ narrativeStatus_extension x
            ]
instance Extension NarrativeStatus Element where
    supertype (NarrativeStatus a0 a1 e0) =
               Element a0 e0
 
data Element = Element
        { element_id :: Maybe String'primitive
        , element_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Element where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Element a0)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Element{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ element_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ element_extension x
            ]
 
data Reference = Reference
        { reference_id :: Maybe String'primitive
        , reference_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , reference_reference :: Maybe Xsd.XsdString
          -- ^ A reference to a location at which the other resource is 
          --   found. The reference may be a relative reference, in which 
          --   case it is relative to the service base URL, or an absolute 
          --   URL that resolves to the location where the resource is 
          --   found. The reference may be version specific or not. If the 
          --   reference is not to a FHIR RESTful server, then it should 
          --   be assumed to be version specific. Internal fragment 
          --   references (start with '#') refer to contained resources.
        , reference_identifier :: Maybe Identifier
          -- ^ An identifier for the other resource. This is used when 
          --   there is no way to reference the other resource directly, 
          --   either because the entity is not available through a FHIR 
          --   server, or because there is no way for the author of the 
          --   resource to convert a known identifier to an actual 
          --   location. There is no requirement that a 
          --   Reference.identifier point to something that is actually 
          --   exposed as a FHIR instance, but it SHALL point to a 
          --   business concept that would be expected to be exposed as a 
          --   FHIR instance, and that instance would need to be of a FHIR 
          --   resource type allowed by the reference.
        , reference_display :: Maybe Xsd.XsdString
          -- ^ Plain text narrative that identifies the resource in 
          --   addition to the resource reference.
        }
        deriving (Eq,Show)
instance SchemaType Reference where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Reference a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@Reference{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ reference_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ reference_extension x
            , maybe [] (schemaTypeToXML "reference") $ reference_reference x
            , maybe [] (schemaTypeToXML "identifier") $ reference_identifier x
            , maybe [] (schemaTypeToXML "display") $ reference_display x
            ]
instance Extension Reference Element where
    supertype (Reference a0 e0 e1 e2 e3) =
               Element a0 e0
 
data Quantity = Quantity
        { quantity_id :: Maybe String'primitive
        , quantity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , quantity_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , quantity_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , quantity_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , quantity_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , quantity_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Quantity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Quantity a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Quantity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ quantity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ quantity_extension x
            , maybe [] (schemaTypeToXML "value") $ quantity_value x
            , maybe [] (schemaTypeToXML "comparator") $ quantity_comparator x
            , maybe [] (schemaTypeToXML "unit") $ quantity_unit x
            , maybe [] (schemaTypeToXML "system") $ quantity_system x
            , maybe [] (schemaTypeToXML "code") $ quantity_code x
            ]
instance Extension Quantity Element where
    supertype (Quantity a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data QuantityComparator'list
    = QuantityComparator'list_V'lt'
      -- ^ Less than
    | QuantityComparator'list_V'lt''
      -- ^ Less or Equal to
    | QuantityComparator'list_V'gt''
      -- ^ Greater or Equal to
    | QuantityComparator'list_V'gt'
      -- ^ Greater than
    deriving (Eq,Show,Enum)
instance SchemaType QuantityComparator'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuantityComparator'list where
    acceptingParser =  do literal "&lt;"; return QuantityComparator'list_V'lt'
                      `onFail` do literal "&lt;="; return QuantityComparator'list_V'lt''
                      `onFail` do literal "&gt;="; return QuantityComparator'list_V'gt''
                      `onFail` do literal "&gt;"; return QuantityComparator'list_V'gt'
                      
    simpleTypeText QuantityComparator'list_V'lt' = "&lt;"
    simpleTypeText QuantityComparator'list_V'lt'' = "&lt;="
    simpleTypeText QuantityComparator'list_V'gt'' = "&gt;="
    simpleTypeText QuantityComparator'list_V'gt' = "&gt;"
 
data QuantityComparator = QuantityComparator
        { quantityComparator_id :: Maybe String'primitive
        , quantityComparator_value :: Maybe QuantityComparator'list
        , quantityComparator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuantityComparator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuantityComparator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuantityComparator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ quantityComparator_id x
                       , maybe [] (toXMLAttribute "value") $ quantityComparator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ quantityComparator_extension x
            ]
instance Extension QuantityComparator Element where
    supertype (QuantityComparator a0 a1 e0) =
               Element a0 e0
 
data Period = Period
        { period_id :: Maybe String'primitive
        , period_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , period_start :: Maybe DateTime
          -- ^ The start of the period. The boundary is inclusive.
        , period_end :: Maybe DateTime
          -- ^ The end of the period. If the end of the period is missing, 
          --   it means that the period is ongoing. The start may be in 
          --   the past, and the end date in the future, which means that 
          --   period is expected/planned to end at that time.
        }
        deriving (Eq,Show)
instance SchemaType Period where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Period a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
    schemaTypeToXML s x@Period{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ period_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ period_extension x
            , maybe [] (schemaTypeToXML "start") $ period_start x
            , maybe [] (schemaTypeToXML "end") $ period_end x
            ]
instance Extension Period Element where
    supertype (Period a0 e0 e1 e2) =
               Element a0 e0
 
data Attachment = Attachment
        { attachment_id :: Maybe String'primitive
        , attachment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , attachment_contentType :: Maybe Code
          -- ^ Identifies the type of the data in the attachment and 
          --   allows a method to be chosen to interpret or render the 
          --   data. Includes mime type parameters such as charset where 
          --   appropriate.
        , attachment_language :: Maybe Code
          -- ^ The human language of the content. The value can be any 
          --   valid value according to BCP 47.
        , attachment_data :: Maybe Base64Binary
          -- ^ The actual data of the attachment - a sequence of bytes. In 
          --   XML, represented using base64.
        , attachment_url :: Maybe Uri
          -- ^ An alternative location where the data can be accessed.
        , attachment_size :: Maybe UnsignedInt
          -- ^ The number of bytes of data that make up this attachment 
          --   (before base64 encoding, if that is done).
        , attachment_hash :: Maybe Base64Binary
          -- ^ The calculated hash of the data using SHA-1. Represented 
          --   using base64.
        , attachment_title :: Maybe Xsd.XsdString
          -- ^ A label or set of text to display in place of the data.
        , attachment_creation :: Maybe DateTime
          -- ^ The date that the attachment was first created.
        }
        deriving (Eq,Show)
instance SchemaType Attachment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Attachment a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "data")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "size")
            `apply` optional (parseSchemaType "hash")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "creation")
    schemaTypeToXML s x@Attachment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ attachment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ attachment_extension x
            , maybe [] (schemaTypeToXML "contentType") $ attachment_contentType x
            , maybe [] (schemaTypeToXML "language") $ attachment_language x
            , maybe [] (schemaTypeToXML "data") $ attachment_data x
            , maybe [] (schemaTypeToXML "url") $ attachment_url x
            , maybe [] (schemaTypeToXML "size") $ attachment_size x
            , maybe [] (schemaTypeToXML "hash") $ attachment_hash x
            , maybe [] (schemaTypeToXML "title") $ attachment_title x
            , maybe [] (schemaTypeToXML "creation") $ attachment_creation x
            ]
instance Extension Attachment Element where
    supertype (Attachment a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               Element a0 e0
 
data Duration = Duration
        { duration_id :: Maybe String'primitive
        , duration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , duration_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , duration_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , duration_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , duration_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , duration_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Duration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Duration a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Duration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ duration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ duration_extension x
            , maybe [] (schemaTypeToXML "value") $ duration_value x
            , maybe [] (schemaTypeToXML "comparator") $ duration_comparator x
            , maybe [] (schemaTypeToXML "unit") $ duration_unit x
            , maybe [] (schemaTypeToXML "system") $ duration_system x
            , maybe [] (schemaTypeToXML "code") $ duration_code x
            ]
instance Extension Duration Quantity where
    supertype (Duration a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Duration Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Duration -> Quantity)
              
 
data Count = Count
        { count_id :: Maybe String'primitive
        , count_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , count_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , count_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , count_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , count_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , count_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Count where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Count a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Count{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ count_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ count_extension x
            , maybe [] (schemaTypeToXML "value") $ count_value x
            , maybe [] (schemaTypeToXML "comparator") $ count_comparator x
            , maybe [] (schemaTypeToXML "unit") $ count_unit x
            , maybe [] (schemaTypeToXML "system") $ count_system x
            , maybe [] (schemaTypeToXML "code") $ count_code x
            ]
instance Extension Count Quantity where
    supertype (Count a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Count Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Count -> Quantity)
              
 
data Range = Range
        { range_id :: Maybe String'primitive
        , range_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , range_low :: Maybe Quantity
          -- ^ The low limit. The boundary is inclusive.
        , range_high :: Maybe Quantity
          -- ^ The high limit. The boundary is inclusive.
        }
        deriving (Eq,Show)
instance SchemaType Range where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Range a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "low")
            `apply` optional (parseSchemaType "high")
    schemaTypeToXML s x@Range{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ range_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ range_extension x
            , maybe [] (schemaTypeToXML "low") $ range_low x
            , maybe [] (schemaTypeToXML "high") $ range_high x
            ]
instance Extension Range Element where
    supertype (Range a0 e0 e1 e2) =
               Element a0 e0
 
data Annotation = Annotation
        { annotation_id :: Maybe String'primitive
        , annotation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , annotation_choice1 :: (Maybe (OneOf2 [Reference] [Xsd.XsdString]))
          -- ^ The individual responsible for making the annotation.
          --   
          --   Choice between:
          --   
          --   (1) authorReference
          --   
          --   (2) authorString
        , annotation_time :: Maybe DateTime
          -- ^ Indicates when this particular annotation was made.
        , annotation_text :: Xsd.XsdString
          -- ^ The text of the annotation.
        }
        deriving (Eq,Show)
instance SchemaType Annotation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Annotation a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("[Reference]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "authorReference")))
                                     , ("[Xsd.XsdString]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "authorString")))
                                     ])
            `apply` optional (parseSchemaType "time")
            `apply` parseSchemaType "text"
    schemaTypeToXML s x@Annotation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ annotation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ annotation_extension x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "authorReference"))
                                    (concatMap (schemaTypeToXML "authorString"))
                                   ) $ annotation_choice1 x
            , maybe [] (schemaTypeToXML "time") $ annotation_time x
            , schemaTypeToXML "text" $ annotation_text x
            ]
instance Extension Annotation Element where
    supertype (Annotation a0 e0 e1 e2 e3) =
               Element a0 e0
 
data Money = Money
        { money_id :: Maybe String'primitive
        , money_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , money_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , money_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , money_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , money_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , money_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Money where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Money a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Money{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ money_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ money_extension x
            , maybe [] (schemaTypeToXML "value") $ money_value x
            , maybe [] (schemaTypeToXML "comparator") $ money_comparator x
            , maybe [] (schemaTypeToXML "unit") $ money_unit x
            , maybe [] (schemaTypeToXML "system") $ money_system x
            , maybe [] (schemaTypeToXML "code") $ money_code x
            ]
instance Extension Money Quantity where
    supertype (Money a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Money Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Money -> Quantity)
              
 
data Identifier = Identifier
        { identifier_id :: Maybe String'primitive
        , identifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , identifier_use :: Maybe IdentifierUse
          -- ^ The purpose of this identifier.
        , identifier_type :: Maybe CodeableConcept
          -- ^ A coded type for the identifier that can be used to 
          --   determine which identifier to use for a specific purpose.
        , identifier_system :: Maybe Uri
          -- ^ Establishes the namespace for the value - that is, a URL 
          --   that describes a set values that are unique.
        , identifier_value :: Maybe Xsd.XsdString
          -- ^ The portion of the identifier typically relevant to the 
          --   user and which is unique within the context of the system.
        , identifier_period :: Maybe Period
          -- ^ Time period during which identifier is/was valid for use.
        , identifier_assigner :: Maybe Reference
          -- ^ Organization that issued/manages the identifier.
        }
        deriving (Eq,Show)
instance SchemaType Identifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Identifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "assigner")
    schemaTypeToXML s x@Identifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identifier_extension x
            , maybe [] (schemaTypeToXML "use") $ identifier_use x
            , maybe [] (schemaTypeToXML "type") $ identifier_type x
            , maybe [] (schemaTypeToXML "system") $ identifier_system x
            , maybe [] (schemaTypeToXML "value") $ identifier_value x
            , maybe [] (schemaTypeToXML "period") $ identifier_period x
            , maybe [] (schemaTypeToXML "assigner") $ identifier_assigner x
            ]
instance Extension Identifier Element where
    supertype (Identifier a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data IdentifierUse'list
    = IdentifierUse'list_Usual
      -- ^ Usual
    | IdentifierUse'list_Official
      -- ^ Official
    | IdentifierUse'list_Temp
      -- ^ Temp
    | IdentifierUse'list_Secondary
      -- ^ Secondary
    deriving (Eq,Show,Enum)
instance SchemaType IdentifierUse'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IdentifierUse'list where
    acceptingParser =  do literal "usual"; return IdentifierUse'list_Usual
                      `onFail` do literal "official"; return IdentifierUse'list_Official
                      `onFail` do literal "temp"; return IdentifierUse'list_Temp
                      `onFail` do literal "secondary"; return IdentifierUse'list_Secondary
                      
    simpleTypeText IdentifierUse'list_Usual = "usual"
    simpleTypeText IdentifierUse'list_Official = "official"
    simpleTypeText IdentifierUse'list_Temp = "temp"
    simpleTypeText IdentifierUse'list_Secondary = "secondary"
 
data IdentifierUse = IdentifierUse
        { identifierUse_id :: Maybe String'primitive
        , identifierUse_value :: Maybe IdentifierUse'list
        , identifierUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IdentifierUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IdentifierUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IdentifierUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identifierUse_id x
                       , maybe [] (toXMLAttribute "value") $ identifierUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identifierUse_extension x
            ]
instance Extension IdentifierUse Element where
    supertype (IdentifierUse a0 a1 e0) =
               Element a0 e0
 
data Coding = Coding
        { coding_id :: Maybe String'primitive
        , coding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coding_system :: Maybe Uri
          -- ^ The identification of the code system that defines the 
          --   meaning of the symbol in the code.
        , coding_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system which was used when choosing 
          --   this code. Note that a well-maintained code system does not 
          --   need the version reported, because the meaning of codes is 
          --   consistent across versions. However this cannot 
          --   consistently be assured. and when the meaning is not 
          --   guaranteed to be consistent, the version SHOULD be 
          --   exchanged.
        , coding_code :: Maybe Code
          -- ^ A symbol in syntax defined by the system. The symbol may be 
          --   a predefined code or an expression in a syntax defined by 
          --   the coding system (e.g. post-coordination).
        , coding_display :: Maybe Xsd.XsdString
          -- ^ A representation of the meaning of the code in the system, 
          --   following the rules of the system.
        , coding_userSelected :: Maybe Boolean
          -- ^ Indicates that this coding was chosen by a user directly - 
          --   i.e. off a pick list of available items (codes or 
          --   displays).
        }
        deriving (Eq,Show)
instance SchemaType Coding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Coding a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "userSelected")
    schemaTypeToXML s x@Coding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ coding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ coding_extension x
            , maybe [] (schemaTypeToXML "system") $ coding_system x
            , maybe [] (schemaTypeToXML "version") $ coding_version x
            , maybe [] (schemaTypeToXML "code") $ coding_code x
            , maybe [] (schemaTypeToXML "display") $ coding_display x
            , maybe [] (schemaTypeToXML "userSelected") $ coding_userSelected x
            ]
instance Extension Coding Element where
    supertype (Coding a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data Signature = Signature
        { signature_id :: Maybe String'primitive
        , signature_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , signature_type :: [Coding]
          -- ^ An indication of the reason that the entity signed this 
          --   document. This may be explicitly included as part of the 
          --   signature information and can be used when determining 
          --   accountability for various actions concerning the document.
        , signature_when :: Instant
          -- ^ When the digital signature was signed.
        , signature_choice3 :: OneOf2 [Uri] [Reference]
          -- ^ A reference to an application-usable description of the 
          --   identity that signed (e.g. the signature used their private 
          --   key).
          --   
          --   Choice between:
          --   
          --   (1) whoUri
          --   
          --   (2) whoReference
        , signature_choice4 :: (Maybe (OneOf2 [Uri] [Reference]))
          -- ^ A reference to an application-usable description of the 
          --   identity that is represented by the signature.
          --   
          --   Choice between:
          --   
          --   (1) onBehalfOfUri
          --   
          --   (2) onBehalfOfReference
        , signature_contentType :: Maybe Code
          -- ^ A mime type that indicates the technical format of the 
          --   signature. Important mime types are 
          --   application/signature+xml for X ML DigSig, application/jwt 
          --   for JWT, and image/* for a graphical image of a signature, 
          --   etc.
        , signature_blob :: Maybe Base64Binary
          -- ^ The base64 encoding of the Signature content. When 
          --   signature is not recorded electronically this element would 
          --   be empty.
        }
        deriving (Eq,Show)
instance SchemaType Signature where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Signature a0)
            `apply` many (parseSchemaType "extension")
            `apply` many1 (parseSchemaType "type")
            `apply` parseSchemaType "when"
            `apply` oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                            (parseSchemaType "whoUri")))
                           , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                  (parseSchemaType "whoReference")))
                           ]
            `apply` optional (oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                      (parseSchemaType "onBehalfOfUri")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "onBehalfOfReference")))
                                     ])
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "blob")
    schemaTypeToXML s x@Signature{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ signature_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ signature_extension x
            , concatMap (schemaTypeToXML "type") $ signature_type x
            , schemaTypeToXML "when" $ signature_when x
            , foldOneOf2  (concatMap (schemaTypeToXML "whoUri"))
                          (concatMap (schemaTypeToXML "whoReference"))
                          $ signature_choice3 x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "onBehalfOfUri"))
                                    (concatMap (schemaTypeToXML "onBehalfOfReference"))
                                   ) $ signature_choice4 x
            , maybe [] (schemaTypeToXML "contentType") $ signature_contentType x
            , maybe [] (schemaTypeToXML "blob") $ signature_blob x
            ]
instance Extension Signature Element where
    supertype (Signature a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data SampledData = SampledData
        { sampledData_id :: Maybe String'primitive
        , sampledData_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sampledData_origin :: Quantity
          -- ^ The base quantity that a measured value of zero represents. 
          --   In addition, this provides the units of the entire 
          --   measurement series.
        , sampledData_period :: Decimal
          -- ^ The length of time between sampling times, measured in 
          --   milliseconds.
        , sampledData_factor :: Maybe Decimal
          -- ^ A correction factor that is applied to the sampled data 
          --   points before they are added to the origin.
        , sampledData_lowerLimit :: Maybe Decimal
          -- ^ The lower limit of detection of the measured points. This 
          --   is needed if any of the data points have the value 
          --   &quot;L&quot; (lower than detection limit).
        , sampledData_upperLimit :: Maybe Decimal
          -- ^ The upper limit of detection of the measured points. This 
          --   is needed if any of the data points have the value 
          --   &quot;U&quot; (higher than detection limit).
        , sampledData_dimensions :: PositiveInt
          -- ^ The number of sample points at each time point. If this 
          --   value is greater than one, then the dimensions will be 
          --   interlaced - all the sample points for a point in time will 
          --   be recorded at once.
        , sampledData_data :: SampledDataDataType
          -- ^ A series of data points which are decimal values separated 
          --   by a single space (character u20). The special values 
          --   &quot;E&quot; (error), &quot;L&quot; (below detection 
          --   limit) and &quot;U&quot; (above detection limit) can also 
          --   be used in place of a decimal value.
        }
        deriving (Eq,Show)
instance SchemaType SampledData where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SampledData a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "origin"
            `apply` parseSchemaType "period"
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "lowerLimit")
            `apply` optional (parseSchemaType "upperLimit")
            `apply` parseSchemaType "dimensions"
            `apply` parseSchemaType "data"
    schemaTypeToXML s x@SampledData{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sampledData_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sampledData_extension x
            , schemaTypeToXML "origin" $ sampledData_origin x
            , schemaTypeToXML "period" $ sampledData_period x
            , maybe [] (schemaTypeToXML "factor") $ sampledData_factor x
            , maybe [] (schemaTypeToXML "lowerLimit") $ sampledData_lowerLimit x
            , maybe [] (schemaTypeToXML "upperLimit") $ sampledData_upperLimit x
            , schemaTypeToXML "dimensions" $ sampledData_dimensions x
            , schemaTypeToXML "data" $ sampledData_data x
            ]
instance Extension SampledData Element where
    supertype (SampledData a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
newtype SampledDataDataType'primitive = SampledDataDataType'primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts SampledDataDataType'primitive Xsd.XsdString where
    restricts (SampledDataDataType'primitive x) = x
instance SchemaType SampledDataDataType'primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (SampledDataDataType'primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SampledDataDataType'primitive where
    acceptingParser = fmap SampledDataDataType'primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern ((-{0,1}\d*\.{0,1}\d+)|[EUL])( ((-{0,1}\d*\.{0,1}\d+)|[EUL]))*)
    simpleTypeText (SampledDataDataType'primitive x) = simpleTypeText x
 
data SampledDataDataType = SampledDataDataType
        { sampledDataDataType_id :: Maybe String'primitive
        , sampledDataDataType_value :: Maybe SampledDataDataType'primitive
        , sampledDataDataType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SampledDataDataType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SampledDataDataType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SampledDataDataType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sampledDataDataType_id x
                       , maybe [] (toXMLAttribute "value") $ sampledDataDataType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sampledDataDataType_extension x
            ]
instance Extension SampledDataDataType Element where
    supertype (SampledDataDataType a0 a1 e0) =
               Element a0 e0
 
data Ratio = Ratio
        { ratio_id :: Maybe String'primitive
        , ratio_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , ratio_numerator :: Maybe Quantity
          -- ^ The value of the numerator.
        , ratio_denominator :: Maybe Quantity
          -- ^ The value of the denominator.
        }
        deriving (Eq,Show)
instance SchemaType Ratio where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Ratio a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "numerator")
            `apply` optional (parseSchemaType "denominator")
    schemaTypeToXML s x@Ratio{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ ratio_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ ratio_extension x
            , maybe [] (schemaTypeToXML "numerator") $ ratio_numerator x
            , maybe [] (schemaTypeToXML "denominator") $ ratio_denominator x
            ]
instance Extension Ratio Element where
    supertype (Ratio a0 e0 e1 e2) =
               Element a0 e0
 
data Distance = Distance
        { distance_id :: Maybe String'primitive
        , distance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , distance_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , distance_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , distance_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , distance_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , distance_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Distance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Distance a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Distance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ distance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ distance_extension x
            , maybe [] (schemaTypeToXML "value") $ distance_value x
            , maybe [] (schemaTypeToXML "comparator") $ distance_comparator x
            , maybe [] (schemaTypeToXML "unit") $ distance_unit x
            , maybe [] (schemaTypeToXML "system") $ distance_system x
            , maybe [] (schemaTypeToXML "code") $ distance_code x
            ]
instance Extension Distance Quantity where
    supertype (Distance a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Distance Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Distance -> Quantity)
              
 
data Age = Age
        { age_id :: Maybe String'primitive
        , age_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , age_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , age_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , age_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , age_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , age_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Age where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Age a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Age{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ age_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ age_extension x
            , maybe [] (schemaTypeToXML "value") $ age_value x
            , maybe [] (schemaTypeToXML "comparator") $ age_comparator x
            , maybe [] (schemaTypeToXML "unit") $ age_unit x
            , maybe [] (schemaTypeToXML "system") $ age_system x
            , maybe [] (schemaTypeToXML "code") $ age_code x
            ]
instance Extension Age Quantity where
    supertype (Age a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Age Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Age -> Quantity)
              
 
data CodeableConcept = CodeableConcept
        { codeableConcept_id :: Maybe String'primitive
        , codeableConcept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeableConcept_coding :: [Coding]
          -- ^ A reference to a code defined by a terminology system.
        , codeableConcept_text :: Maybe Xsd.XsdString
          -- ^ A human language representation of the concept as 
          --   seen/selected/uttered by the user who entered the data 
          --   and/or which represents the intended meaning of the user.
        }
        deriving (Eq,Show)
instance SchemaType CodeableConcept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeableConcept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "coding")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@CodeableConcept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeableConcept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeableConcept_extension x
            , concatMap (schemaTypeToXML "coding") $ codeableConcept_coding x
            , maybe [] (schemaTypeToXML "text") $ codeableConcept_text x
            ]
instance Extension CodeableConcept Element where
    supertype (CodeableConcept a0 e0 e1 e2) =
               Element a0 e0
 
data Meta = Meta
        { meta_id :: Maybe String'primitive
        , meta_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , meta_versionId :: Maybe Id
          -- ^ The version specific identifier, as it appears in the 
          --   version portion of the URL. This values changes when the 
          --   resource is created, updated, or deleted.
        , meta_lastUpdated :: Maybe Instant
          -- ^ When the resource last changed - e.g. when the version 
          --   changed.
        , meta_profile :: [Uri]
          -- ^ A list of profiles (references to [[[StructureDefinition]]] 
          --   resources) that this resource claims to conform to. The URL 
          --   is a reference to [[[StructureDefinition.url]]].
        , meta_security :: [Coding]
          -- ^ Security labels applied to this resource. These tags 
          --   connect specific resources to the overall security policy 
          --   and infrastructure.
        , meta_tag :: [Coding]
          -- ^ Tags applied to this resource. Tags are intended to be used 
          --   to identify and relate resources to process and workflow, 
          --   and applications are not required to consider the tags when 
          --   interpreting the meaning of a resource.
        }
        deriving (Eq,Show)
instance SchemaType Meta where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Meta a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "versionId")
            `apply` optional (parseSchemaType "lastUpdated")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "security")
            `apply` many (parseSchemaType "tag")
    schemaTypeToXML s x@Meta{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ meta_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ meta_extension x
            , maybe [] (schemaTypeToXML "versionId") $ meta_versionId x
            , maybe [] (schemaTypeToXML "lastUpdated") $ meta_lastUpdated x
            , concatMap (schemaTypeToXML "profile") $ meta_profile x
            , concatMap (schemaTypeToXML "security") $ meta_security x
            , concatMap (schemaTypeToXML "tag") $ meta_tag x
            ]
instance Extension Meta Element where
    supertype (Meta a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data Address = Address
        { address_id :: Maybe String'primitive
        , address_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , address_use :: Maybe AddressUse
          -- ^ The purpose of this address.
        , address_type :: Maybe AddressType
          -- ^ Distinguishes between physical addresses (those you can 
          --   visit) and mailing addresses (e.g. PO Boxes and care-of 
          --   addresses). Most addresses are both.
        , address_text :: Maybe Xsd.XsdString
          -- ^ A full text representation of the address.
        , address_line :: [Xsd.XsdString]
          -- ^ This component contains the house number, apartment number, 
          --   street name, street direction, P.O. Box number, delivery 
          --   hints, and similar address information.
        , address_city :: Maybe Xsd.XsdString
          -- ^ The name of the city, town, village or other community or 
          --   delivery center.
        , address_district :: Maybe Xsd.XsdString
          -- ^ The name of the administrative area (county).
        , address_state :: Maybe Xsd.XsdString
          -- ^ Sub-unit of a country with limited sovereignty in a 
          --   federally organized country. A code may be used if codes 
          --   are in common use (i.e. US 2 letter state codes).
        , address_postalCode :: Maybe Xsd.XsdString
          -- ^ A postal code designating a region defined by the postal 
          --   service.
        , address_country :: Maybe Xsd.XsdString
          -- ^ Country - a nation as commonly understood or generally 
          --   accepted.
        , address_period :: Maybe Period
          -- ^ Time period when address was/is in use.
        }
        deriving (Eq,Show)
instance SchemaType Address where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Address a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "line")
            `apply` optional (parseSchemaType "city")
            `apply` optional (parseSchemaType "district")
            `apply` optional (parseSchemaType "state")
            `apply` optional (parseSchemaType "postalCode")
            `apply` optional (parseSchemaType "country")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Address{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ address_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ address_extension x
            , maybe [] (schemaTypeToXML "use") $ address_use x
            , maybe [] (schemaTypeToXML "type") $ address_type x
            , maybe [] (schemaTypeToXML "text") $ address_text x
            , concatMap (schemaTypeToXML "line") $ address_line x
            , maybe [] (schemaTypeToXML "city") $ address_city x
            , maybe [] (schemaTypeToXML "district") $ address_district x
            , maybe [] (schemaTypeToXML "state") $ address_state x
            , maybe [] (schemaTypeToXML "postalCode") $ address_postalCode x
            , maybe [] (schemaTypeToXML "country") $ address_country x
            , maybe [] (schemaTypeToXML "period") $ address_period x
            ]
instance Extension Address Element where
    supertype (Address a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               Element a0 e0
 
data AddressUse'list
    = AddressUse'list_Home
      -- ^ Home
    | AddressUse'list_Work
      -- ^ Work
    | AddressUse'list_Temp
      -- ^ Temporary
    | AddressUse'list_Old
      -- ^ Old / Incorrect
    deriving (Eq,Show,Enum)
instance SchemaType AddressUse'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AddressUse'list where
    acceptingParser =  do literal "home"; return AddressUse'list_Home
                      `onFail` do literal "work"; return AddressUse'list_Work
                      `onFail` do literal "temp"; return AddressUse'list_Temp
                      `onFail` do literal "old"; return AddressUse'list_Old
                      
    simpleTypeText AddressUse'list_Home = "home"
    simpleTypeText AddressUse'list_Work = "work"
    simpleTypeText AddressUse'list_Temp = "temp"
    simpleTypeText AddressUse'list_Old = "old"
 
data AddressUse = AddressUse
        { addressUse_id :: Maybe String'primitive
        , addressUse_value :: Maybe AddressUse'list
        , addressUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AddressUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AddressUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AddressUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ addressUse_id x
                       , maybe [] (toXMLAttribute "value") $ addressUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ addressUse_extension x
            ]
instance Extension AddressUse Element where
    supertype (AddressUse a0 a1 e0) =
               Element a0 e0
 
data AddressType'list
    = AddressType'list_Postal
      -- ^ Postal
    | AddressType'list_Physical
      -- ^ Physical
    | AddressType'list_Both
      -- ^ Postal &amp; Physical
    deriving (Eq,Show,Enum)
instance SchemaType AddressType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AddressType'list where
    acceptingParser =  do literal "postal"; return AddressType'list_Postal
                      `onFail` do literal "physical"; return AddressType'list_Physical
                      `onFail` do literal "both"; return AddressType'list_Both
                      
    simpleTypeText AddressType'list_Postal = "postal"
    simpleTypeText AddressType'list_Physical = "physical"
    simpleTypeText AddressType'list_Both = "both"
 
data AddressType = AddressType
        { addressType_id :: Maybe String'primitive
        , addressType_value :: Maybe AddressType'list
        , addressType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AddressType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AddressType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AddressType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ addressType_id x
                       , maybe [] (toXMLAttribute "value") $ addressType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ addressType_extension x
            ]
instance Extension AddressType Element where
    supertype (AddressType a0 a1 e0) =
               Element a0 e0
 
data TriggerDefinition = TriggerDefinition
        { triggerDefinition_id :: Maybe String'primitive
        , triggerDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , triggerDefinition_type :: TriggerType
          -- ^ The type of triggering event.
        , triggerDefinition_eventName :: Maybe Xsd.XsdString
          -- ^ The name of the event (if this is a named-event trigger).
        , triggerDefinition_choice3 :: (Maybe (OneOf4 [Timing] [Reference] [Date] [DateTime]))
          -- ^ The timing of the event (if this is a period trigger).
          --   
          --   Choice between:
          --   
          --   (1) eventTimingTiming
          --   
          --   (2) eventTimingReference
          --   
          --   (3) eventTimingDate
          --   
          --   (4) eventTimingDateTime
        , triggerDefinition_eventData :: Maybe DataRequirement
          -- ^ The triggering data of the event (if this is a data 
          --   trigger).
        }
        deriving (Eq,Show)
instance SchemaType TriggerDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TriggerDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "eventName")
            `apply` optional (oneOf' [ ("[Timing]", fmap OneOf4 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "eventTimingTiming")))
                                     , ("[Reference]", fmap TwoOf4 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "eventTimingReference")))
                                     , ("[Date]", fmap ThreeOf4 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "eventTimingDate")))
                                     , ("[DateTime]", fmap FourOf4 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "eventTimingDateTime")))
                                     ])
            `apply` optional (parseSchemaType "eventData")
    schemaTypeToXML s x@TriggerDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ triggerDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ triggerDefinition_extension x
            , schemaTypeToXML "type" $ triggerDefinition_type x
            , maybe [] (schemaTypeToXML "eventName") $ triggerDefinition_eventName x
            , maybe [] (foldOneOf4  (concatMap (schemaTypeToXML "eventTimingTiming"))
                                    (concatMap (schemaTypeToXML "eventTimingReference"))
                                    (concatMap (schemaTypeToXML "eventTimingDate"))
                                    (concatMap (schemaTypeToXML "eventTimingDateTime"))
                                   ) $ triggerDefinition_choice3 x
            , maybe [] (schemaTypeToXML "eventData") $ triggerDefinition_eventData x
            ]
instance Extension TriggerDefinition Element where
    supertype (TriggerDefinition a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data TriggerType'list
    = TriggerType'list_Named'event
      -- ^ Named Event
    | TriggerType'list_Periodic
      -- ^ Periodic
    | TriggerType'list_Data'added
      -- ^ Data Added
    | TriggerType'list_Data'modified
      -- ^ Data Modified
    | TriggerType'list_Data'removed
      -- ^ Data Removed
    | TriggerType'list_Data'accessed
      -- ^ Data Accessed
    | TriggerType'list_Data'access'ended
      -- ^ Data Access Ended
    deriving (Eq,Show,Enum)
instance SchemaType TriggerType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TriggerType'list where
    acceptingParser =  do literal "named-event"; return TriggerType'list_Named'event
                      `onFail` do literal "periodic"; return TriggerType'list_Periodic
                      `onFail` do literal "data-added"; return TriggerType'list_Data'added
                      `onFail` do literal "data-modified"; return TriggerType'list_Data'modified
                      `onFail` do literal "data-removed"; return TriggerType'list_Data'removed
                      `onFail` do literal "data-accessed"; return TriggerType'list_Data'accessed
                      `onFail` do literal "data-access-ended"; return TriggerType'list_Data'access'ended
                      
    simpleTypeText TriggerType'list_Named'event = "named-event"
    simpleTypeText TriggerType'list_Periodic = "periodic"
    simpleTypeText TriggerType'list_Data'added = "data-added"
    simpleTypeText TriggerType'list_Data'modified = "data-modified"
    simpleTypeText TriggerType'list_Data'removed = "data-removed"
    simpleTypeText TriggerType'list_Data'accessed = "data-accessed"
    simpleTypeText TriggerType'list_Data'access'ended = "data-access-ended"
 
data TriggerType = TriggerType
        { triggerType_id :: Maybe String'primitive
        , triggerType_value :: Maybe TriggerType'list
        , triggerType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TriggerType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TriggerType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TriggerType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ triggerType_id x
                       , maybe [] (toXMLAttribute "value") $ triggerType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ triggerType_extension x
            ]
instance Extension TriggerType Element where
    supertype (TriggerType a0 a1 e0) =
               Element a0 e0
 
data Contributor = Contributor
        { contributor_id :: Maybe String'primitive
        , contributor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contributor_type :: ContributorType
          -- ^ The type of contributor.
        , contributor_name :: Xsd.XsdString
          -- ^ The name of the individual or organization responsible for 
          --   the contribution.
        , contributor_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the contributor.
        }
        deriving (Eq,Show)
instance SchemaType Contributor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contributor a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "name"
            `apply` many (parseSchemaType "contact")
    schemaTypeToXML s x@Contributor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contributor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contributor_extension x
            , schemaTypeToXML "type" $ contributor_type x
            , schemaTypeToXML "name" $ contributor_name x
            , concatMap (schemaTypeToXML "contact") $ contributor_contact x
            ]
instance Extension Contributor Element where
    supertype (Contributor a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ContributorType'list
    = ContributorType'list_Author
      -- ^ Author
    | ContributorType'list_Editor
      -- ^ Editor
    | ContributorType'list_Reviewer
      -- ^ Reviewer
    | ContributorType'list_Endorser
      -- ^ Endorser
    deriving (Eq,Show,Enum)
instance SchemaType ContributorType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContributorType'list where
    acceptingParser =  do literal "author"; return ContributorType'list_Author
                      `onFail` do literal "editor"; return ContributorType'list_Editor
                      `onFail` do literal "reviewer"; return ContributorType'list_Reviewer
                      `onFail` do literal "endorser"; return ContributorType'list_Endorser
                      
    simpleTypeText ContributorType'list_Author = "author"
    simpleTypeText ContributorType'list_Editor = "editor"
    simpleTypeText ContributorType'list_Reviewer = "reviewer"
    simpleTypeText ContributorType'list_Endorser = "endorser"
 
data ContributorType = ContributorType
        { contributorType_id :: Maybe String'primitive
        , contributorType_value :: Maybe ContributorType'list
        , contributorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContributorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContributorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContributorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contributorType_id x
                       , maybe [] (toXMLAttribute "value") $ contributorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contributorType_extension x
            ]
instance Extension ContributorType Element where
    supertype (ContributorType a0 a1 e0) =
               Element a0 e0
 
data DataRequirement = DataRequirement
        { dataRequirement_id :: Maybe String'primitive
        , dataRequirement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirement_type :: Code
          -- ^ The type of the required data, specified as the type name 
          --   of a resource. For profiles, this value is set to the type 
          --   of the base resource of the profile.
        , dataRequirement_profile :: [Uri]
          -- ^ The profile of the required data, specified as the uri of 
          --   the profile definition.
        , dataRequirement_mustSupport :: [Xsd.XsdString]
          -- ^ Indicates that specific elements of the type are referenced 
          --   by the knowledge module and must be supported by the 
          --   consumer in order to obtain an effective evaluation. This 
          --   does not mean that a value is required for this element, 
          --   only that the consuming system must understand the element 
          --   and be able to provide values for it if they are available. 
          --   Note that the value for this element can be a path to allow 
          --   references to nested elements. In that case, all the 
          --   elements along the path must be supported.
        , dataRequirement_codeFilter :: [DataRequirement'CodeFilter]
          -- ^ Code filters specify additional constraints on the data, 
          --   specifying the value set of interest for a particular 
          --   element of the data.
        , dataRequirement_dateFilter :: [DataRequirement'DateFilter]
          -- ^ Date filters specify additional constraints on the data in 
          --   terms of the applicable date range for specific elements.
        }
        deriving (Eq,Show)
instance SchemaType DataRequirement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirement a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "mustSupport")
            `apply` many (parseSchemaType "codeFilter")
            `apply` many (parseSchemaType "dateFilter")
    schemaTypeToXML s x@DataRequirement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirement_extension x
            , schemaTypeToXML "type" $ dataRequirement_type x
            , concatMap (schemaTypeToXML "profile") $ dataRequirement_profile x
            , concatMap (schemaTypeToXML "mustSupport") $ dataRequirement_mustSupport x
            , concatMap (schemaTypeToXML "codeFilter") $ dataRequirement_codeFilter x
            , concatMap (schemaTypeToXML "dateFilter") $ dataRequirement_dateFilter x
            ]
instance Extension DataRequirement Element where
    supertype (DataRequirement a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data DataRequirement'CodeFilter = DataRequirement'CodeFilter
        { dataRequirement'CodeFilter_id :: Maybe String'primitive
        , dataRequirement'CodeFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirement'CodeFilter_path :: Xsd.XsdString
          -- ^ The code-valued attribute of the filter. The specified path 
          --   must be resolvable from the type of the required data. The 
          --   path is allowed to contain qualifiers (.) to traverse 
          --   sub-elements, as well as indexers ([x]) to traverse 
          --   multiple-cardinality sub-elements. Note that the index must 
          --   be an integer constant. The path must resolve to an element 
          --   of type code, Coding, or CodeableConcept.
        , dataRequirement'CodeFilter_choice2 :: (Maybe (OneOf2 [Xsd.XsdString] [Reference]))
          -- ^ The valueset for the code filter. The valueSet and value 
          --   elements are exclusive. If valueSet is specified, the 
          --   filter will return only those data items for which the 
          --   value of the code-valued element specified in the path is a 
          --   member of the specified valueset.
          --   
          --   Choice between:
          --   
          --   (1) valueSetString
          --   
          --   (2) valueSetReference
        , dataRequirement'CodeFilter_valueCode :: [Code]
          -- ^ The codes for the code filter. Only one of valueSet, 
          --   valueCode, valueCoding, or valueCodeableConcept may be 
          --   specified. If values are given, the filter will return only 
          --   those data items for which the code-valued attribute 
          --   specified by the path has a value that is one of the 
          --   specified codes.
        , dataRequirement'CodeFilter_valueCoding :: [Coding]
          -- ^ The Codings for the code filter. Only one of valueSet, 
          --   valueCode, valueConding, or valueCodeableConcept may be 
          --   specified. If values are given, the filter will return only 
          --   those data items for which the code-valued attribute 
          --   specified by the path has a value that is one of the 
          --   specified Codings.
        , dataRequirement'CodeFilter_valueCodeableConcept :: [CodeableConcept]
          -- ^ The CodeableConcepts for the code filter. Only one of 
          --   valueSet, valueCode, valueConding, or valueCodeableConcept 
          --   may be specified. If values are given, the filter will 
          --   return only those data items for which the code-valued 
          --   attribute specified by the path has a value that is one of 
          --   the specified CodeableConcepts.
        }
        deriving (Eq,Show)
instance SchemaType DataRequirement'CodeFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirement'CodeFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` optional (oneOf' [ ("[Xsd.XsdString]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "valueSetString")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "valueSetReference")))
                                     ])
            `apply` many (parseSchemaType "valueCode")
            `apply` many (parseSchemaType "valueCoding")
            `apply` many (parseSchemaType "valueCodeableConcept")
    schemaTypeToXML s x@DataRequirement'CodeFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirement'CodeFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirement'CodeFilter_extension x
            , schemaTypeToXML "path" $ dataRequirement'CodeFilter_path x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "valueSetString"))
                                    (concatMap (schemaTypeToXML "valueSetReference"))
                                   ) $ dataRequirement'CodeFilter_choice2 x
            , concatMap (schemaTypeToXML "valueCode") $ dataRequirement'CodeFilter_valueCode x
            , concatMap (schemaTypeToXML "valueCoding") $ dataRequirement'CodeFilter_valueCoding x
            , concatMap (schemaTypeToXML "valueCodeableConcept") $ dataRequirement'CodeFilter_valueCodeableConcept x
            ]
instance Extension DataRequirement'CodeFilter Element where
    supertype (DataRequirement'CodeFilter a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data DataRequirement'DateFilter = DataRequirement'DateFilter
        { dataRequirement'DateFilter_id :: Maybe String'primitive
        , dataRequirement'DateFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirement'DateFilter_path :: Xsd.XsdString
          -- ^ The date-valued attribute of the filter. The specified path 
          --   must be resolvable from the type of the required data. The 
          --   path is allowed to contain qualifiers (.) to traverse 
          --   sub-elements, as well as indexers ([x]) to traverse 
          --   multiple-cardinality sub-elements. Note that the index must 
          --   be an integer constant. The path must resolve to an element 
          --   of type dateTime, Period, Schedule, or Timing.
        , dataRequirement'DateFilter_choice2 :: (Maybe (OneOf3 [DateTime] [Period] [Duration]))
          -- ^ The value of the filter. If period is specified, the filter 
          --   will return only those data items that fall within the 
          --   bounds determined by the Period, inclusive of the period 
          --   boundaries. If dateTime is specified, the filter will 
          --   return only those data items that are equal to the 
          --   specified dateTime. If a Duration is specified, the filter 
          --   will return only those data items that fall within Duration 
          --   from now.
          --   
          --   Choice between:
          --   
          --   (1) valueDateTime
          --   
          --   (2) valuePeriod
          --   
          --   (3) valueDuration
        }
        deriving (Eq,Show)
instance SchemaType DataRequirement'DateFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirement'DateFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` optional (oneOf' [ ("[DateTime]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "valueDateTime")))
                                     , ("[Period]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "valuePeriod")))
                                     , ("[Duration]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                             (parseSchemaType "valueDuration")))
                                     ])
    schemaTypeToXML s x@DataRequirement'DateFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirement'DateFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirement'DateFilter_extension x
            , schemaTypeToXML "path" $ dataRequirement'DateFilter_path x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "valueDateTime"))
                                    (concatMap (schemaTypeToXML "valuePeriod"))
                                    (concatMap (schemaTypeToXML "valueDuration"))
                                   ) $ dataRequirement'DateFilter_choice2 x
            ]
instance Extension DataRequirement'DateFilter Element where
    supertype (DataRequirement'DateFilter a0 e0 e1 e2) =
               Element a0 e0
 
data Dosage = Dosage
        { dosage_id :: Maybe String'primitive
        , dosage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dosage_sequence :: Maybe Integer
          -- ^ Indicates the order in which the dosage instructions should 
          --   be applied or interpreted.
        , dosage_text :: Maybe Xsd.XsdString
          -- ^ Free text dosage instructions e.g. SIG.
        , dosage_additionalInstruction :: [CodeableConcept]
          -- ^ Supplemental instruction - e.g. &quot;with meals&quot;.
        , dosage_patientInstruction :: Maybe Xsd.XsdString
          -- ^ Instructions in terms that are understood by the patient or 
          --   consumer.
        , dosage_timing :: Maybe Timing
          -- ^ When medication should be administered.
        , dosage_choice6 :: (Maybe (OneOf2 [Boolean] [CodeableConcept]))
          -- ^ Indicates whether the Medication is only taken when needed 
          --   within a specific dosing schedule (Boolean option), or it 
          --   indicates the precondition for taking the Medication 
          --   (CodeableConcept).
          --   
          --   Choice between:
          --   
          --   (1) asNeededBoolean
          --   
          --   (2) asNeededCodeableConcept
        , dosage_site :: Maybe CodeableConcept
          -- ^ Body site to administer to.
        , dosage_route :: Maybe CodeableConcept
          -- ^ How drug should enter body.
        , dosage_method :: Maybe CodeableConcept
          -- ^ Technique for administering medication.
        , dosage_choice10 :: (Maybe (OneOf2 [Range] [Quantity]))
          -- ^ Amount of medication per dose.
          --   
          --   Choice between:
          --   
          --   (1) doseRange
          --   
          --   (2) doseQuantity
        , dosage_maxDosePerPeriod :: Maybe Ratio
          -- ^ Upper limit on medication per unit of time.
        , dosage_maxDosePerAdministration :: Maybe Quantity
          -- ^ Upper limit on medication per administration.
        , dosage_maxDosePerLifetime :: Maybe Quantity
          -- ^ Upper limit on medication per lifetime of the patient.
        , dosage_choice14 :: (Maybe (OneOf3 [Ratio] [Range] [Quantity]))
          -- ^ Amount of medication per unit of time.
          --   
          --   Choice between:
          --   
          --   (1) rateRatio
          --   
          --   (2) rateRange
          --   
          --   (3) rateQuantity
        }
        deriving (Eq,Show)
instance SchemaType Dosage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Dosage a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "sequence")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "additionalInstruction")
            `apply` optional (parseSchemaType "patientInstruction")
            `apply` optional (parseSchemaType "timing")
            `apply` optional (oneOf' [ ("[Boolean]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "asNeededBoolean")))
                                     , ("[CodeableConcept]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                                  (parseSchemaType "asNeededCodeableConcept")))
                                     ])
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "method")
            `apply` optional (oneOf' [ ("[Range]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "doseRange")))
                                     , ("[Quantity]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "doseQuantity")))
                                     ])
            `apply` optional (parseSchemaType "maxDosePerPeriod")
            `apply` optional (parseSchemaType "maxDosePerAdministration")
            `apply` optional (parseSchemaType "maxDosePerLifetime")
            `apply` optional (oneOf' [ ("[Ratio]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "rateRatio")))
                                     , ("[Range]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "rateRange")))
                                     , ("[Quantity]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                             (parseSchemaType "rateQuantity")))
                                     ])
    schemaTypeToXML s x@Dosage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dosage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dosage_extension x
            , maybe [] (schemaTypeToXML "sequence") $ dosage_sequence x
            , maybe [] (schemaTypeToXML "text") $ dosage_text x
            , concatMap (schemaTypeToXML "additionalInstruction") $ dosage_additionalInstruction x
            , maybe [] (schemaTypeToXML "patientInstruction") $ dosage_patientInstruction x
            , maybe [] (schemaTypeToXML "timing") $ dosage_timing x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "asNeededBoolean"))
                                    (concatMap (schemaTypeToXML "asNeededCodeableConcept"))
                                   ) $ dosage_choice6 x
            , maybe [] (schemaTypeToXML "site") $ dosage_site x
            , maybe [] (schemaTypeToXML "route") $ dosage_route x
            , maybe [] (schemaTypeToXML "method") $ dosage_method x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "doseRange"))
                                    (concatMap (schemaTypeToXML "doseQuantity"))
                                   ) $ dosage_choice10 x
            , maybe [] (schemaTypeToXML "maxDosePerPeriod") $ dosage_maxDosePerPeriod x
            , maybe [] (schemaTypeToXML "maxDosePerAdministration") $ dosage_maxDosePerAdministration x
            , maybe [] (schemaTypeToXML "maxDosePerLifetime") $ dosage_maxDosePerLifetime x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "rateRatio"))
                                    (concatMap (schemaTypeToXML "rateRange"))
                                    (concatMap (schemaTypeToXML "rateQuantity"))
                                   ) $ dosage_choice14 x
            ]
instance Extension Dosage Element where
    supertype (Dosage a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               Element a0 e0
 
data RelatedArtifact = RelatedArtifact
        { relatedArtifact_id :: Maybe String'primitive
        , relatedArtifact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , relatedArtifact_type :: RelatedArtifactType
          -- ^ The type of relationship to the related artifact.
        , relatedArtifact_display :: Maybe Xsd.XsdString
          -- ^ A brief description of the document or knowledge resource 
          --   being referenced, suitable for display to a consumer.
        , relatedArtifact_citation :: Maybe Xsd.XsdString
          -- ^ A bibliographic citation for the related artifact. This 
          --   text SHOULD be formatted according to an accepted citation 
          --   format.
        , relatedArtifact_url :: Maybe Uri
          -- ^ A url for the artifact that can be followed to access the 
          --   actual content.
        , relatedArtifact_document :: Maybe Attachment
          -- ^ The document being referenced, represented as an 
          --   attachment. This is exclusive with the resource element.
        , relatedArtifact_resource :: Maybe Reference
          -- ^ The related resource, such as a library, value set, 
          --   profile, or other knowledge resource.
        }
        deriving (Eq,Show)
instance SchemaType RelatedArtifact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RelatedArtifact a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "citation")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "document")
            `apply` optional (parseSchemaType "resource")
    schemaTypeToXML s x@RelatedArtifact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ relatedArtifact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ relatedArtifact_extension x
            , schemaTypeToXML "type" $ relatedArtifact_type x
            , maybe [] (schemaTypeToXML "display") $ relatedArtifact_display x
            , maybe [] (schemaTypeToXML "citation") $ relatedArtifact_citation x
            , maybe [] (schemaTypeToXML "url") $ relatedArtifact_url x
            , maybe [] (schemaTypeToXML "document") $ relatedArtifact_document x
            , maybe [] (schemaTypeToXML "resource") $ relatedArtifact_resource x
            ]
instance Extension RelatedArtifact Element where
    supertype (RelatedArtifact a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data RelatedArtifactType'list
    = RelatedArtifactType'list_Documentation
      -- ^ Documentation
    | RelatedArtifactType'list_Justification
      -- ^ Justification
    | RelatedArtifactType'list_Citation
      -- ^ Citation
    | RelatedArtifactType'list_Predecessor
      -- ^ Predecessor
    | RelatedArtifactType'list_Successor
      -- ^ Successor
    | RelatedArtifactType'list_Derived'from
      -- ^ Derived From
    | RelatedArtifactType'list_Depends'on
      -- ^ Depends On
    | RelatedArtifactType'list_Composed'of
      -- ^ Composed Of
    deriving (Eq,Show,Enum)
instance SchemaType RelatedArtifactType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RelatedArtifactType'list where
    acceptingParser =  do literal "documentation"; return RelatedArtifactType'list_Documentation
                      `onFail` do literal "justification"; return RelatedArtifactType'list_Justification
                      `onFail` do literal "citation"; return RelatedArtifactType'list_Citation
                      `onFail` do literal "predecessor"; return RelatedArtifactType'list_Predecessor
                      `onFail` do literal "successor"; return RelatedArtifactType'list_Successor
                      `onFail` do literal "derived-from"; return RelatedArtifactType'list_Derived'from
                      `onFail` do literal "depends-on"; return RelatedArtifactType'list_Depends'on
                      `onFail` do literal "composed-of"; return RelatedArtifactType'list_Composed'of
                      
    simpleTypeText RelatedArtifactType'list_Documentation = "documentation"
    simpleTypeText RelatedArtifactType'list_Justification = "justification"
    simpleTypeText RelatedArtifactType'list_Citation = "citation"
    simpleTypeText RelatedArtifactType'list_Predecessor = "predecessor"
    simpleTypeText RelatedArtifactType'list_Successor = "successor"
    simpleTypeText RelatedArtifactType'list_Derived'from = "derived-from"
    simpleTypeText RelatedArtifactType'list_Depends'on = "depends-on"
    simpleTypeText RelatedArtifactType'list_Composed'of = "composed-of"
 
data RelatedArtifactType = RelatedArtifactType
        { relatedArtifactType_id :: Maybe String'primitive
        , relatedArtifactType_value :: Maybe RelatedArtifactType'list
        , relatedArtifactType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RelatedArtifactType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RelatedArtifactType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RelatedArtifactType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ relatedArtifactType_id x
                       , maybe [] (toXMLAttribute "value") $ relatedArtifactType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ relatedArtifactType_extension x
            ]
instance Extension RelatedArtifactType Element where
    supertype (RelatedArtifactType a0 a1 e0) =
               Element a0 e0
 
data ContactDetail = ContactDetail
        { contactDetail_id :: Maybe String'primitive
        , contactDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contactDetail_name :: Maybe Xsd.XsdString
          -- ^ The name of an individual to contact.
        , contactDetail_telecom :: [ContactPoint]
          -- ^ The contact details for the individual (if a name was 
          --   provided) or the organization.
        }
        deriving (Eq,Show)
instance SchemaType ContactDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContactDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
    schemaTypeToXML s x@ContactDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactDetail_extension x
            , maybe [] (schemaTypeToXML "name") $ contactDetail_name x
            , concatMap (schemaTypeToXML "telecom") $ contactDetail_telecom x
            ]
instance Extension ContactDetail Element where
    supertype (ContactDetail a0 e0 e1 e2) =
               Element a0 e0
 
data HumanName = HumanName
        { humanName_id :: Maybe String'primitive
        , humanName_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , humanName_use :: Maybe NameUse
          -- ^ Identifies the purpose for this name.
        , humanName_text :: Maybe Xsd.XsdString
          -- ^ A full text representation of the name.
        , humanName_family :: Maybe Xsd.XsdString
          -- ^ The part of a name that links to the genealogy. In some 
          --   cultures (e.g. Eritrea) the family name of a son is the 
          --   first name of his father.
        , humanName_given :: [Xsd.XsdString]
          -- ^ Given name.
        , humanName_prefix :: [Xsd.XsdString]
          -- ^ Part of the name that is acquired as a title due to 
          --   academic, legal, employment or nobility status, etc. and 
          --   that appears at the start of the name.
        , humanName_suffix :: [Xsd.XsdString]
          -- ^ Part of the name that is acquired as a title due to 
          --   academic, legal, employment or nobility status, etc. and 
          --   that appears at the end of the name.
        , humanName_period :: Maybe Period
          -- ^ Indicates the period of time when this name was valid for 
          --   the named person.
        }
        deriving (Eq,Show)
instance SchemaType HumanName where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HumanName a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "family")
            `apply` many (parseSchemaType "given")
            `apply` many (parseSchemaType "prefix")
            `apply` many (parseSchemaType "suffix")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@HumanName{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ humanName_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ humanName_extension x
            , maybe [] (schemaTypeToXML "use") $ humanName_use x
            , maybe [] (schemaTypeToXML "text") $ humanName_text x
            , maybe [] (schemaTypeToXML "family") $ humanName_family x
            , concatMap (schemaTypeToXML "given") $ humanName_given x
            , concatMap (schemaTypeToXML "prefix") $ humanName_prefix x
            , concatMap (schemaTypeToXML "suffix") $ humanName_suffix x
            , maybe [] (schemaTypeToXML "period") $ humanName_period x
            ]
instance Extension HumanName Element where
    supertype (HumanName a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
data NameUse'list
    = NameUse'list_Usual
      -- ^ Usual
    | NameUse'list_Official
      -- ^ Official
    | NameUse'list_Temp
      -- ^ Temp
    | NameUse'list_Nickname
      -- ^ Nickname
    | NameUse'list_Anonymous
      -- ^ Anonymous
    | NameUse'list_Old
      -- ^ Old
    | NameUse'list_Maiden
      -- ^ Name changed for Marriage
    deriving (Eq,Show,Enum)
instance SchemaType NameUse'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NameUse'list where
    acceptingParser =  do literal "usual"; return NameUse'list_Usual
                      `onFail` do literal "official"; return NameUse'list_Official
                      `onFail` do literal "temp"; return NameUse'list_Temp
                      `onFail` do literal "nickname"; return NameUse'list_Nickname
                      `onFail` do literal "anonymous"; return NameUse'list_Anonymous
                      `onFail` do literal "old"; return NameUse'list_Old
                      `onFail` do literal "maiden"; return NameUse'list_Maiden
                      
    simpleTypeText NameUse'list_Usual = "usual"
    simpleTypeText NameUse'list_Official = "official"
    simpleTypeText NameUse'list_Temp = "temp"
    simpleTypeText NameUse'list_Nickname = "nickname"
    simpleTypeText NameUse'list_Anonymous = "anonymous"
    simpleTypeText NameUse'list_Old = "old"
    simpleTypeText NameUse'list_Maiden = "maiden"
 
data NameUse = NameUse
        { nameUse_id :: Maybe String'primitive
        , nameUse_value :: Maybe NameUse'list
        , nameUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NameUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NameUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NameUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nameUse_id x
                       , maybe [] (toXMLAttribute "value") $ nameUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nameUse_extension x
            ]
instance Extension NameUse Element where
    supertype (NameUse a0 a1 e0) =
               Element a0 e0
 
data ContactPoint = ContactPoint
        { contactPoint_id :: Maybe String'primitive
        , contactPoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contactPoint_system :: Maybe ContactPointSystem
          -- ^ Telecommunications form for contact point - what 
          --   communications system is required to make use of the 
          --   contact.
        , contactPoint_value :: Maybe Xsd.XsdString
          -- ^ The actual contact point details, in a form that is 
          --   meaningful to the designated communication system (i.e. 
          --   phone number or email address).
        , contactPoint_use :: Maybe ContactPointUse
          -- ^ Identifies the purpose for the contact point.
        , contactPoint_rank :: Maybe PositiveInt
          -- ^ Specifies a preferred order in which to use a set of 
          --   contacts. Contacts are ranked with lower values coming 
          --   before higher values.
        , contactPoint_period :: Maybe Period
          -- ^ Time period when the contact point was/is in use.
        }
        deriving (Eq,Show)
instance SchemaType ContactPoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContactPoint a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "rank")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@ContactPoint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPoint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPoint_extension x
            , maybe [] (schemaTypeToXML "system") $ contactPoint_system x
            , maybe [] (schemaTypeToXML "value") $ contactPoint_value x
            , maybe [] (schemaTypeToXML "use") $ contactPoint_use x
            , maybe [] (schemaTypeToXML "rank") $ contactPoint_rank x
            , maybe [] (schemaTypeToXML "period") $ contactPoint_period x
            ]
instance Extension ContactPoint Element where
    supertype (ContactPoint a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data ContactPointSystem'list
    = ContactPointSystem'list_Phone
      -- ^ Phone
    | ContactPointSystem'list_Fax
      -- ^ Fax
    | ContactPointSystem'list_Email
      -- ^ Email
    | ContactPointSystem'list_Pager
      -- ^ Pager
    | ContactPointSystem'list_Url
      -- ^ URL
    | ContactPointSystem'list_Sms
      -- ^ SMS
    | ContactPointSystem'list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType ContactPointSystem'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContactPointSystem'list where
    acceptingParser =  do literal "phone"; return ContactPointSystem'list_Phone
                      `onFail` do literal "fax"; return ContactPointSystem'list_Fax
                      `onFail` do literal "email"; return ContactPointSystem'list_Email
                      `onFail` do literal "pager"; return ContactPointSystem'list_Pager
                      `onFail` do literal "url"; return ContactPointSystem'list_Url
                      `onFail` do literal "sms"; return ContactPointSystem'list_Sms
                      `onFail` do literal "other"; return ContactPointSystem'list_Other
                      
    simpleTypeText ContactPointSystem'list_Phone = "phone"
    simpleTypeText ContactPointSystem'list_Fax = "fax"
    simpleTypeText ContactPointSystem'list_Email = "email"
    simpleTypeText ContactPointSystem'list_Pager = "pager"
    simpleTypeText ContactPointSystem'list_Url = "url"
    simpleTypeText ContactPointSystem'list_Sms = "sms"
    simpleTypeText ContactPointSystem'list_Other = "other"
 
data ContactPointSystem = ContactPointSystem
        { contactPointSystem_id :: Maybe String'primitive
        , contactPointSystem_value :: Maybe ContactPointSystem'list
        , contactPointSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContactPointSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContactPointSystem a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContactPointSystem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPointSystem_id x
                       , maybe [] (toXMLAttribute "value") $ contactPointSystem_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPointSystem_extension x
            ]
instance Extension ContactPointSystem Element where
    supertype (ContactPointSystem a0 a1 e0) =
               Element a0 e0
 
data ContactPointUse'list
    = ContactPointUse'list_Home
      -- ^ Home
    | ContactPointUse'list_Work
      -- ^ Work
    | ContactPointUse'list_Temp
      -- ^ Temp
    | ContactPointUse'list_Old
      -- ^ Old
    | ContactPointUse'list_Mobile
      -- ^ Mobile
    deriving (Eq,Show,Enum)
instance SchemaType ContactPointUse'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContactPointUse'list where
    acceptingParser =  do literal "home"; return ContactPointUse'list_Home
                      `onFail` do literal "work"; return ContactPointUse'list_Work
                      `onFail` do literal "temp"; return ContactPointUse'list_Temp
                      `onFail` do literal "old"; return ContactPointUse'list_Old
                      `onFail` do literal "mobile"; return ContactPointUse'list_Mobile
                      
    simpleTypeText ContactPointUse'list_Home = "home"
    simpleTypeText ContactPointUse'list_Work = "work"
    simpleTypeText ContactPointUse'list_Temp = "temp"
    simpleTypeText ContactPointUse'list_Old = "old"
    simpleTypeText ContactPointUse'list_Mobile = "mobile"
 
data ContactPointUse = ContactPointUse
        { contactPointUse_id :: Maybe String'primitive
        , contactPointUse_value :: Maybe ContactPointUse'list
        , contactPointUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContactPointUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContactPointUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContactPointUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPointUse_id x
                       , maybe [] (toXMLAttribute "value") $ contactPointUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPointUse_extension x
            ]
instance Extension ContactPointUse Element where
    supertype (ContactPointUse a0 a1 e0) =
               Element a0 e0
 
data UsageContext = UsageContext
        { usageContext_id :: Maybe String'primitive
        , usageContext_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , usageContext_code :: Coding
          -- ^ A code that identifies the type of context being specified 
          --   by this usage context.
        , usageContext_choice2 :: OneOf3 [CodeableConcept] [Quantity] [Range]
          -- ^ A value that defines the context specified in this context 
          --   of use. The interpretation of the value is defined by the 
          --   code.
          --   
          --   Choice between:
          --   
          --   (1) valueCodeableConcept
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueRange
        }
        deriving (Eq,Show)
instance SchemaType UsageContext where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (UsageContext a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("[CodeableConcept]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "valueCodeableConcept")))
                           , ("[Quantity]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                 (parseSchemaType "valueQuantity")))
                           , ("[Range]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                (parseSchemaType "valueRange")))
                           ]
    schemaTypeToXML s x@UsageContext{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ usageContext_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ usageContext_extension x
            , schemaTypeToXML "code" $ usageContext_code x
            , foldOneOf3  (concatMap (schemaTypeToXML "valueCodeableConcept"))
                          (concatMap (schemaTypeToXML "valueQuantity"))
                          (concatMap (schemaTypeToXML "valueRange"))
                          $ usageContext_choice2 x
            ]
instance Extension UsageContext Element where
    supertype (UsageContext a0 e0 e1 e2) =
               Element a0 e0
 
data Timing = Timing
        { timing_id :: Maybe String'primitive
        , timing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , timing_event :: [DateTime]
          -- ^ Identifies specific times when the event occurs.
        , timing_repeat :: Maybe Timing'Repeat
          -- ^ A set of rules that describe when the event is scheduled.
        , timing_code :: Maybe CodeableConcept
          -- ^ A code for the timing schedule. Some codes such as BID are 
          --   ubiquitous, but many institutions define their own 
          --   additional codes. If a code is provided, the code is 
          --   understood to be a complete statement of whatever is 
          --   specified in the structured timing data, and either the 
          --   code or the data may be used to interpret the Timing, with 
          --   the exception that .repeat.bounds still applies over the 
          --   code (and is not contained in the code).
        }
        deriving (Eq,Show)
instance SchemaType Timing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Timing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "event")
            `apply` optional (parseSchemaType "repeat")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Timing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ timing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ timing_extension x
            , concatMap (schemaTypeToXML "event") $ timing_event x
            , maybe [] (schemaTypeToXML "repeat") $ timing_repeat x
            , maybe [] (schemaTypeToXML "code") $ timing_code x
            ]
instance Extension Timing Element where
    supertype (Timing a0 e0 e1 e2 e3) =
               Element a0 e0
 
data Timing'Repeat = Timing'Repeat
        { timing'Repeat_id :: Maybe String'primitive
        , timing'Repeat_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , timing'Repeat_choice1 :: (Maybe (OneOf3 [Duration] [Range] [Period]))
          -- ^ Either a duration for the length of the timing schedule, a 
          --   range of possible length, or outer bounds for start and/or 
          --   end limits of the timing schedule.
          --   
          --   Choice between:
          --   
          --   (1) boundsDuration
          --   
          --   (2) boundsRange
          --   
          --   (3) boundsPeriod
        , timing'Repeat_count :: Maybe Integer
          -- ^ A total count of the desired number of repetitions.
        , timing'Repeat_countMax :: Maybe Integer
          -- ^ A maximum value for the count of the desired repetitions 
          --   (e.g. do something 6-8 times).
        , timing'Repeat_duration :: Maybe Decimal
          -- ^ How long this thing happens for when it happens.
        , timing'Repeat_durationMax :: Maybe Decimal
          -- ^ The upper limit of how long this thing happens for when it 
          --   happens.
        , timing'Repeat_durationUnit :: Maybe UnitsOfTime
          -- ^ The units of time for the duration, in UCUM units.
        , timing'Repeat_frequency :: Maybe Integer
          -- ^ The number of times to repeat the action within the 
          --   specified period / period range (i.e. both period and 
          --   periodMax provided).
        , timing'Repeat_frequencyMax :: Maybe Integer
          -- ^ If present, indicates that the frequency is a range - so to 
          --   repeat between [frequency] and [frequencyMax] times within 
          --   the period or period range.
        , timing'Repeat_period :: Maybe Decimal
          -- ^ Indicates the duration of time over which repetitions are 
          --   to occur; e.g. to express &quot;3 times per day&quot;, 3 
          --   would be the frequency and &quot;1 day&quot; would be the 
          --   period.
        , timing'Repeat_periodMax :: Maybe Decimal
          -- ^ If present, indicates that the period is a range from 
          --   [period] to [periodMax], allowing expressing concepts such 
          --   as &quot;do this once every 3-5 days.
        , timing'Repeat_periodUnit :: Maybe UnitsOfTime
          -- ^ The units of time for the period in UCUM units.
        , timing'Repeat_dayOfWeek :: [Code]
          -- ^ If one or more days of week is provided, then the action 
          --   happens only on the specified day(s).
        , timing'Repeat_timeOfDay :: [Time]
          -- ^ Specified time of day for action to take place.
        , timing'Repeat_when :: [EventTiming]
          -- ^ Real world events that the occurrence of the event should 
          --   be tied to.
        , timing'Repeat_offset :: Maybe UnsignedInt
          -- ^ The number of minutes from the event. If the event code 
          --   does not indicate whether the minutes is before or after 
          --   the event, then the offset is assumed to be after the 
          --   event.
        }
        deriving (Eq,Show)
instance SchemaType Timing'Repeat where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Timing'Repeat a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("[Duration]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "boundsDuration")))
                                     , ("[Range]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "boundsRange")))
                                     , ("[Period]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "boundsPeriod")))
                                     ])
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "countMax")
            `apply` optional (parseSchemaType "duration")
            `apply` optional (parseSchemaType "durationMax")
            `apply` optional (parseSchemaType "durationUnit")
            `apply` optional (parseSchemaType "frequency")
            `apply` optional (parseSchemaType "frequencyMax")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "periodMax")
            `apply` optional (parseSchemaType "periodUnit")
            `apply` many (parseSchemaType "dayOfWeek")
            `apply` many (parseSchemaType "timeOfDay")
            `apply` many (parseSchemaType "when")
            `apply` optional (parseSchemaType "offset")
    schemaTypeToXML s x@Timing'Repeat{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ timing'Repeat_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ timing'Repeat_extension x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "boundsDuration"))
                                    (concatMap (schemaTypeToXML "boundsRange"))
                                    (concatMap (schemaTypeToXML "boundsPeriod"))
                                   ) $ timing'Repeat_choice1 x
            , maybe [] (schemaTypeToXML "count") $ timing'Repeat_count x
            , maybe [] (schemaTypeToXML "countMax") $ timing'Repeat_countMax x
            , maybe [] (schemaTypeToXML "duration") $ timing'Repeat_duration x
            , maybe [] (schemaTypeToXML "durationMax") $ timing'Repeat_durationMax x
            , maybe [] (schemaTypeToXML "durationUnit") $ timing'Repeat_durationUnit x
            , maybe [] (schemaTypeToXML "frequency") $ timing'Repeat_frequency x
            , maybe [] (schemaTypeToXML "frequencyMax") $ timing'Repeat_frequencyMax x
            , maybe [] (schemaTypeToXML "period") $ timing'Repeat_period x
            , maybe [] (schemaTypeToXML "periodMax") $ timing'Repeat_periodMax x
            , maybe [] (schemaTypeToXML "periodUnit") $ timing'Repeat_periodUnit x
            , concatMap (schemaTypeToXML "dayOfWeek") $ timing'Repeat_dayOfWeek x
            , concatMap (schemaTypeToXML "timeOfDay") $ timing'Repeat_timeOfDay x
            , concatMap (schemaTypeToXML "when") $ timing'Repeat_when x
            , maybe [] (schemaTypeToXML "offset") $ timing'Repeat_offset x
            ]
instance Extension Timing'Repeat Element where
    supertype (Timing'Repeat a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               Element a0 e0
 
data UnitsOfTime'list
    = UnitsOfTime'list_S
      -- ^ ç§’
    | UnitsOfTime'list_Min
      -- ^ åˆ†é’Ÿ
    | UnitsOfTime'list_H
      -- ^ å°æ—¶
    | UnitsOfTime'list_D
      -- ^ å¤©
    | UnitsOfTime'list_Wk
      -- ^ æ˜ŸæœŸ
    | UnitsOfTime'list_Mo
      -- ^ æœˆ
    | UnitsOfTime'list_A
      -- ^ å¹´
    deriving (Eq,Show,Enum)
instance SchemaType UnitsOfTime'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnitsOfTime'list where
    acceptingParser =  do literal "s"; return UnitsOfTime'list_S
                      `onFail` do literal "min"; return UnitsOfTime'list_Min
                      `onFail` do literal "h"; return UnitsOfTime'list_H
                      `onFail` do literal "d"; return UnitsOfTime'list_D
                      `onFail` do literal "wk"; return UnitsOfTime'list_Wk
                      `onFail` do literal "mo"; return UnitsOfTime'list_Mo
                      `onFail` do literal "a"; return UnitsOfTime'list_A
                      
    simpleTypeText UnitsOfTime'list_S = "s"
    simpleTypeText UnitsOfTime'list_Min = "min"
    simpleTypeText UnitsOfTime'list_H = "h"
    simpleTypeText UnitsOfTime'list_D = "d"
    simpleTypeText UnitsOfTime'list_Wk = "wk"
    simpleTypeText UnitsOfTime'list_Mo = "mo"
    simpleTypeText UnitsOfTime'list_A = "a"
 
data UnitsOfTime = UnitsOfTime
        { unitsOfTime_id :: Maybe String'primitive
        , unitsOfTime_value :: Maybe UnitsOfTime'list
        , unitsOfTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnitsOfTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnitsOfTime a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnitsOfTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unitsOfTime_id x
                       , maybe [] (toXMLAttribute "value") $ unitsOfTime_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unitsOfTime_extension x
            ]
instance Extension UnitsOfTime Element where
    supertype (UnitsOfTime a0 a1 e0) =
               Element a0 e0
 
data EventTiming'list
    = EventTiming'list_MORN
      -- ^ Morning
    | EventTiming'list_AFT
      -- ^ Afternoon
    | EventTiming'list_EVE
      -- ^ Evening
    | EventTiming'list_NIGHT
      -- ^ Night
    | EventTiming'list_PHS
      -- ^ After Sleep
    | EventTiming'list_HS
      -- ^ HS
    | EventTiming'list_WAKE
      -- ^ WAKE
    | EventTiming'list_C
      -- ^ C
    | EventTiming'list_CM
      -- ^ CM
    | EventTiming'list_CD
      -- ^ CD
    | EventTiming'list_CV
      -- ^ CV
    | EventTiming'list_AC
      -- ^ AC
    | EventTiming'list_ACM
      -- ^ ACM
    | EventTiming'list_ACD
      -- ^ ACD
    | EventTiming'list_ACV
      -- ^ ACV
    | EventTiming'list_PC
      -- ^ PC
    | EventTiming'list_PCM
      -- ^ PCM
    | EventTiming'list_PCD
      -- ^ PCD
    | EventTiming'list_PCV
      -- ^ PCV
    deriving (Eq,Show,Enum)
instance SchemaType EventTiming'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventTiming'list where
    acceptingParser =  do literal "MORN"; return EventTiming'list_MORN
                      `onFail` do literal "AFT"; return EventTiming'list_AFT
                      `onFail` do literal "EVE"; return EventTiming'list_EVE
                      `onFail` do literal "NIGHT"; return EventTiming'list_NIGHT
                      `onFail` do literal "PHS"; return EventTiming'list_PHS
                      `onFail` do literal "HS"; return EventTiming'list_HS
                      `onFail` do literal "WAKE"; return EventTiming'list_WAKE
                      `onFail` do literal "C"; return EventTiming'list_C
                      `onFail` do literal "CM"; return EventTiming'list_CM
                      `onFail` do literal "CD"; return EventTiming'list_CD
                      `onFail` do literal "CV"; return EventTiming'list_CV
                      `onFail` do literal "AC"; return EventTiming'list_AC
                      `onFail` do literal "ACM"; return EventTiming'list_ACM
                      `onFail` do literal "ACD"; return EventTiming'list_ACD
                      `onFail` do literal "ACV"; return EventTiming'list_ACV
                      `onFail` do literal "PC"; return EventTiming'list_PC
                      `onFail` do literal "PCM"; return EventTiming'list_PCM
                      `onFail` do literal "PCD"; return EventTiming'list_PCD
                      `onFail` do literal "PCV"; return EventTiming'list_PCV
                      
    simpleTypeText EventTiming'list_MORN = "MORN"
    simpleTypeText EventTiming'list_AFT = "AFT"
    simpleTypeText EventTiming'list_EVE = "EVE"
    simpleTypeText EventTiming'list_NIGHT = "NIGHT"
    simpleTypeText EventTiming'list_PHS = "PHS"
    simpleTypeText EventTiming'list_HS = "HS"
    simpleTypeText EventTiming'list_WAKE = "WAKE"
    simpleTypeText EventTiming'list_C = "C"
    simpleTypeText EventTiming'list_CM = "CM"
    simpleTypeText EventTiming'list_CD = "CD"
    simpleTypeText EventTiming'list_CV = "CV"
    simpleTypeText EventTiming'list_AC = "AC"
    simpleTypeText EventTiming'list_ACM = "ACM"
    simpleTypeText EventTiming'list_ACD = "ACD"
    simpleTypeText EventTiming'list_ACV = "ACV"
    simpleTypeText EventTiming'list_PC = "PC"
    simpleTypeText EventTiming'list_PCM = "PCM"
    simpleTypeText EventTiming'list_PCD = "PCD"
    simpleTypeText EventTiming'list_PCV = "PCV"
 
data EventTiming = EventTiming
        { eventTiming_id :: Maybe String'primitive
        , eventTiming_value :: Maybe EventTiming'list
        , eventTiming_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventTiming where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventTiming a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventTiming{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventTiming_id x
                       , maybe [] (toXMLAttribute "value") $ eventTiming_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventTiming_extension x
            ]
instance Extension EventTiming Element where
    supertype (EventTiming a0 a1 e0) =
               Element a0 e0
 
data ElementDefinition = ElementDefinition
        { elementDefinition_id :: Maybe String'primitive
        , elementDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition_path :: Xsd.XsdString
          -- ^ The path identifies the element and is expressed as a 
          --   &quot;.&quot;-separated list of ancestor elements, 
          --   beginning with the name of the resource or extension.
        , elementDefinition_representation :: [PropertyRepresentation]
          -- ^ Codes that define how this element is represented in 
          --   instances, when the deviation varies from the normal case.
        , elementDefinition_sliceName :: Maybe Xsd.XsdString
          -- ^ The name of this element definition slice, when slicing is 
          --   working. The name must be a token with no dots or spaces. 
          --   This is a unique name referring to a specific set of 
          --   constraints applied to this element, used to provide a name 
          --   to different slices of the same element.
        , elementDefinition_label :: Maybe Xsd.XsdString
          -- ^ A single preferred label which is the text to display 
          --   beside the element indicating its meaning or to use to 
          --   prompt for the element in a user display or form.
        , elementDefinition_code :: [Coding]
          -- ^ A code that has the same meaning as the element in a 
          --   particular terminology.
        , elementDefinition_slicing :: Maybe ElementDefinition'Slicing
          -- ^ Indicates that the element is sliced into a set of 
          --   alternative definitions (i.e. in a structure definition, 
          --   there are multiple different constraints on a single 
          --   element in the base resource). Slicing can be used in any 
          --   resource that has cardinality ..* on the base resource, or 
          --   any resource with a choice of types. The set of slices is 
          --   any elements that come after this in the element sequence 
          --   that have the same path, until a shorter path occurs (the 
          --   shorter path terminates the set).
        , elementDefinition_short :: Maybe Xsd.XsdString
          -- ^ A concise description of what this element means (e.g. for 
          --   use in autogenerated summaries).
        , elementDefinition_definition :: Maybe Markdown
          -- ^ Provides a complete explanation of the meaning of the data 
          --   element for human readability. For the case of elements 
          --   derived from existing elements (e.g. constraints), the 
          --   definition SHALL be consistent with the base definition, 
          --   but convey the meaning of the element in the particular 
          --   context of use of the resource.
        , elementDefinition_comment :: Maybe Markdown
          -- ^ Explanatory notes and implementation guidance about the 
          --   data element, including notes about how to use the data 
          --   properly, exceptions to proper use, etc.
        , elementDefinition_requirements :: Maybe Markdown
          -- ^ This element is for traceability of why the element was 
          --   created and why the constraints exist as they do. This may 
          --   be used to point to source materials or specifications that 
          --   drove the structure of this element.
        , elementDefinition_alias :: [Xsd.XsdString]
          -- ^ Identifies additional names by which this element might 
          --   also be known.
        , elementDefinition_min :: Maybe UnsignedInt
          -- ^ The minimum number of times this element SHALL appear in 
          --   the instance.
        , elementDefinition_max :: Maybe Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the instance.
        , elementDefinition_base :: Maybe ElementDefinition'Base
          -- ^ Information about the base definition of the element, 
          --   provided to make it unnecessary for tools to trace the 
          --   deviation of the element through the derived and related 
          --   profiles. This information is provided when the element 
          --   definition is not the original definition of an element - 
          --   i.g. either in a constraint on another type, or for 
          --   elements from a super type in a snap shot.
        , elementDefinition_contentReference :: Maybe Uri
          -- ^ Identifies the identity of an element defined elsewhere in 
          --   the profile whose content rules should be applied to the 
          --   current element.
        , elementDefinition_type :: [ElementDefinition'Type]
          -- ^ The data type or resource that the value of this element is 
          --   permitted to be.
        , elementDefinition_choice17 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ The value that should be used if there is no value stated 
          --   in the instance (e.g. 'if not otherwise specified, the 
          --   abstract is false').
          --   
          --   Choice between:
          --   
          --   (1) defaultValueBase64Binary
          --   
          --   (2) defaultValueBoolean
          --   
          --   (3) defaultValueCode
          --   
          --   (4) defaultValueDate
          --   
          --   (5) defaultValueDateTime
          --   
          --   (6) defaultValueDecimal
          --   
          --   (7) defaultValueId
          --   
          --   (8) defaultValueInstant
          --   
          --   (9) defaultValueInteger
          --   
          --   (10) defaultValueMarkdown
          --   
          --   (11) defaultValueOid
          --   
          --   (12) defaultValuePositiveInt
          --   
          --   (13) defaultValueString
          --   
          --   (14) defaultValueTime
          --   
          --   (15) defaultValueUnsignedInt
          --   
          --   (16) defaultValueUri
          --   
          --   (17) defaultValueAddress
          --   
          --   (18) defaultValueAge
          --   
          --   (19) defaultValueAnnotation
          --   
          --   (20) defaultValueAttachment
          --   
          --   (21) defaultValueCodeableConcept
          --   
          --   (22) defaultValueCoding
          --   
          --   (23) defaultValueContactPoint
          --   
          --   (24) defaultValueCount
          --   
          --   (25) defaultValueDistance
          --   
          --   (26) defaultValueDuration
          --   
          --   (27) defaultValueHumanName
          --   
          --   (28) defaultValueIdentifier
          --   
          --   (29) defaultValueMoney
          --   
          --   (30) defaultValuePeriod
          --   
          --   (31) defaultValueQuantity
          --   
          --   (32) defaultValueRange
          --   
          --   (33) defaultValueRatio
          --   
          --   (34) defaultValueReference
          --   
          --   (35) defaultValueSampledData
          --   
          --   (36) defaultValueSignature
          --   
          --   (37) defaultValueTiming
          --   
          --   (38) defaultValueMeta
        , elementDefinition_meaningWhenMissing :: Maybe Markdown
          -- ^ The Implicit meaning that is to be understood when this 
          --   element is missing (e.g. 'when this element is missing, the 
          --   period is ongoing'.
        , elementDefinition_orderMeaning :: Maybe Xsd.XsdString
          -- ^ If present, indicates that the order of the repeating 
          --   element has meaning and describes what that meaning is. If 
          --   absent, it means that the order of the element has no 
          --   meaning.
        , elementDefinition_choice20 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Specifies a value that SHALL be exactly the value for this 
          --   element in the instance. For purposes of comparison, 
          --   non-significant whitespace is ignored, and all values must 
          --   be an exact match (case and accent sensitive). Missing 
          --   elements/attributes must also be missing.
          --   
          --   Choice between:
          --   
          --   (1) fixedBase64Binary
          --   
          --   (2) fixedBoolean
          --   
          --   (3) fixedCode
          --   
          --   (4) fixedDate
          --   
          --   (5) fixedDateTime
          --   
          --   (6) fixedDecimal
          --   
          --   (7) fixedId
          --   
          --   (8) fixedInstant
          --   
          --   (9) fixedInteger
          --   
          --   (10) fixedMarkdown
          --   
          --   (11) fixedOid
          --   
          --   (12) fixedPositiveInt
          --   
          --   (13) fixedString
          --   
          --   (14) fixedTime
          --   
          --   (15) fixedUnsignedInt
          --   
          --   (16) fixedUri
          --   
          --   (17) fixedAddress
          --   
          --   (18) fixedAge
          --   
          --   (19) fixedAnnotation
          --   
          --   (20) fixedAttachment
          --   
          --   (21) fixedCodeableConcept
          --   
          --   (22) fixedCoding
          --   
          --   (23) fixedContactPoint
          --   
          --   (24) fixedCount
          --   
          --   (25) fixedDistance
          --   
          --   (26) fixedDuration
          --   
          --   (27) fixedHumanName
          --   
          --   (28) fixedIdentifier
          --   
          --   (29) fixedMoney
          --   
          --   (30) fixedPeriod
          --   
          --   (31) fixedQuantity
          --   
          --   (32) fixedRange
          --   
          --   (33) fixedRatio
          --   
          --   (34) fixedReference
          --   
          --   (35) fixedSampledData
          --   
          --   (36) fixedSignature
          --   
          --   (37) fixedTiming
          --   
          --   (38) fixedMeta
        , elementDefinition_choice21 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Specifies a value that the value in the instance SHALL 
          --   follow - that is, any value in the pattern must be found in 
          --   the instance. Other additional values may be found too. 
          --   This is effectively constraint by example. The values of 
          --   elements present in the pattern must match exactly 
          --   (case-sensitive, accent-sensitive, etc.).
          --   
          --   Choice between:
          --   
          --   (1) patternBase64Binary
          --   
          --   (2) patternBoolean
          --   
          --   (3) patternCode
          --   
          --   (4) patternDate
          --   
          --   (5) patternDateTime
          --   
          --   (6) patternDecimal
          --   
          --   (7) patternId
          --   
          --   (8) patternInstant
          --   
          --   (9) patternInteger
          --   
          --   (10) patternMarkdown
          --   
          --   (11) patternOid
          --   
          --   (12) patternPositiveInt
          --   
          --   (13) patternString
          --   
          --   (14) patternTime
          --   
          --   (15) patternUnsignedInt
          --   
          --   (16) patternUri
          --   
          --   (17) patternAddress
          --   
          --   (18) patternAge
          --   
          --   (19) patternAnnotation
          --   
          --   (20) patternAttachment
          --   
          --   (21) patternCodeableConcept
          --   
          --   (22) patternCoding
          --   
          --   (23) patternContactPoint
          --   
          --   (24) patternCount
          --   
          --   (25) patternDistance
          --   
          --   (26) patternDuration
          --   
          --   (27) patternHumanName
          --   
          --   (28) patternIdentifier
          --   
          --   (29) patternMoney
          --   
          --   (30) patternPeriod
          --   
          --   (31) patternQuantity
          --   
          --   (32) patternRange
          --   
          --   (33) patternRatio
          --   
          --   (34) patternReference
          --   
          --   (35) patternSampledData
          --   
          --   (36) patternSignature
          --   
          --   (37) patternTiming
          --   
          --   (38) patternMeta
        , elementDefinition_example :: [ElementDefinition'Example]
          -- ^ A sample value for this element demonstrating the type of 
          --   information that would typically be found in the element.
        , elementDefinition_choice23 :: (Maybe (OneOf9 [Date] [DateTime] [Instant] [Time] [Decimal] [Integer] [PositiveInt] [UnsignedInt] [Quantity]))
          -- ^ The minimum allowed value for the element. The value is 
          --   inclusive. This is allowed for the types date, dateTime, 
          --   instant, time, decimal, integer, and Quantity.
          --   
          --   Choice between:
          --   
          --   (1) minValueDate
          --   
          --   (2) minValueDateTime
          --   
          --   (3) minValueInstant
          --   
          --   (4) minValueTime
          --   
          --   (5) minValueDecimal
          --   
          --   (6) minValueInteger
          --   
          --   (7) minValuePositiveInt
          --   
          --   (8) minValueUnsignedInt
          --   
          --   (9) minValueQuantity
        , elementDefinition_choice24 :: (Maybe (OneOf9 [Date] [DateTime] [Instant] [Time] [Decimal] [Integer] [PositiveInt] [UnsignedInt] [Quantity]))
          -- ^ The maximum allowed value for the element. The value is 
          --   inclusive. This is allowed for the types date, dateTime, 
          --   instant, time, decimal, integer, and Quantity.
          --   
          --   Choice between:
          --   
          --   (1) maxValueDate
          --   
          --   (2) maxValueDateTime
          --   
          --   (3) maxValueInstant
          --   
          --   (4) maxValueTime
          --   
          --   (5) maxValueDecimal
          --   
          --   (6) maxValueInteger
          --   
          --   (7) maxValuePositiveInt
          --   
          --   (8) maxValueUnsignedInt
          --   
          --   (9) maxValueQuantity
        , elementDefinition_maxLength :: Maybe Integer
          -- ^ Indicates the maximum length in characters that is 
          --   permitted to be present in conformant instances and which 
          --   is expected to be supported by conformant consumers that 
          --   support the element.
        , elementDefinition_condition :: [Id]
          -- ^ A reference to an invariant that may make additional 
          --   statements about the cardinality or value in the instance.
        , elementDefinition_constraint :: [ElementDefinition'Constraint]
          -- ^ Formal constraints such as co-occurrence and other 
          --   constraints that can be computationally evaluated within 
          --   the context of the instance.
        , elementDefinition_mustSupport :: Maybe Boolean
          -- ^ If true, implementations that produce or consume resources 
          --   SHALL provide &quot;support&quot; for the element in some 
          --   meaningful way. If false, the element may be ignored and 
          --   not supported.
        , elementDefinition_isModifier :: Maybe Boolean
          -- ^ If true, the value of this element affects the 
          --   interpretation of the element or resource that contains it, 
          --   and the value of the element cannot be ignored. Typically, 
          --   this is used for status, negation and qualification codes. 
          --   The effect of this is that the element cannot be ignored by 
          --   systems: they SHALL either recognize the element and 
          --   process it, and/or a pre-determination has been made that 
          --   it is not relevant to their particular system.
        , elementDefinition_isSummary :: Maybe Boolean
          -- ^ Whether the element should be included if a client requests 
          --   a search with the parameter _summary=true.
        , elementDefinition_binding :: Maybe ElementDefinition'Binding
          -- ^ Binds to a value set if this element is coded (code, 
          --   Coding, CodeableConcept, Quantity), or the data types 
          --   (string, uri).
        , elementDefinition_mapping :: [ElementDefinition'Mapping]
          -- ^ Identifies a concept from an external specification that 
          --   roughly corresponds to this element.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` many (parseSchemaType "representation")
            `apply` optional (parseSchemaType "sliceName")
            `apply` optional (parseSchemaType "label")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "slicing")
            `apply` optional (parseSchemaType "short")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "requirements")
            `apply` many (parseSchemaType "alias")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "base")
            `apply` optional (parseSchemaType "contentReference")
            `apply` many (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "defaultValueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "defaultValueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "defaultValueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "defaultValueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "defaultValueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "defaultValueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "defaultValueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "defaultValueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "defaultValueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "defaultValueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "defaultValueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "defaultValuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "defaultValueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "defaultValueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "defaultValueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "defaultValueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "defaultValueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "defaultValueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "defaultValueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "defaultValueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "defaultValueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "defaultValueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "defaultValueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "defaultValueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "defaultValueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "defaultValueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "defaultValueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "defaultValueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "defaultValueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "defaultValuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "defaultValueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "defaultValueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "defaultValueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "defaultValueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "defaultValueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "defaultValueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "defaultValueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "defaultValueMeta"))
                                     ])
            `apply` optional (parseSchemaType "meaningWhenMissing")
            `apply` optional (parseSchemaType "orderMeaning")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "fixedBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "fixedBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "fixedCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "fixedDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "fixedDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "fixedDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "fixedId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "fixedInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "fixedInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "fixedMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "fixedOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "fixedPositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "fixedString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "fixedTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "fixedUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "fixedUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "fixedAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "fixedAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "fixedAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "fixedAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "fixedCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "fixedCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "fixedContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "fixedCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "fixedDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "fixedDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "fixedHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "fixedIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "fixedMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "fixedPeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "fixedQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "fixedRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "fixedRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "fixedReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "fixedSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "fixedSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "fixedTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "fixedMeta"))
                                     ])
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "patternBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "patternBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "patternCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "patternDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "patternDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "patternDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "patternId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "patternInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "patternInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "patternMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "patternOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "patternPositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "patternString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "patternTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "patternUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "patternUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "patternAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "patternAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "patternAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "patternAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "patternCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "patternCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "patternContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "patternCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "patternDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "patternDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "patternHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "patternIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "patternMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "patternPeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "patternQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "patternRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "patternRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "patternReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "patternSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "patternSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "patternTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "patternMeta"))
                                     ])
            `apply` many (parseSchemaType "example")
            `apply` optional (oneOf' [ ("[Date]", fmap OneOf9 (between (Occurs Nothing (Just 1))
                                                                       (parseSchemaType "minValueDate")))
                                     , ("[DateTime]", fmap TwoOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "minValueDateTime")))
                                     , ("[Instant]", fmap ThreeOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "minValueInstant")))
                                     , ("[Time]", fmap FourOf9 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "minValueTime")))
                                     , ("[Decimal]", fmap FiveOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "minValueDecimal")))
                                     , ("[Integer]", fmap SixOf9 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "minValueInteger")))
                                     , ("[PositiveInt]", fmap SevenOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "minValuePositiveInt")))
                                     , ("[UnsignedInt]", fmap EightOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "minValueUnsignedInt")))
                                     , ("[Quantity]", fmap NineOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "minValueQuantity")))
                                     ])
            `apply` optional (oneOf' [ ("[Date]", fmap OneOf9 (between (Occurs Nothing (Just 1))
                                                                       (parseSchemaType "maxValueDate")))
                                     , ("[DateTime]", fmap TwoOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "maxValueDateTime")))
                                     , ("[Instant]", fmap ThreeOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "maxValueInstant")))
                                     , ("[Time]", fmap FourOf9 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "maxValueTime")))
                                     , ("[Decimal]", fmap FiveOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "maxValueDecimal")))
                                     , ("[Integer]", fmap SixOf9 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "maxValueInteger")))
                                     , ("[PositiveInt]", fmap SevenOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "maxValuePositiveInt")))
                                     , ("[UnsignedInt]", fmap EightOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "maxValueUnsignedInt")))
                                     , ("[Quantity]", fmap NineOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "maxValueQuantity")))
                                     ])
            `apply` optional (parseSchemaType "maxLength")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "constraint")
            `apply` optional (parseSchemaType "mustSupport")
            `apply` optional (parseSchemaType "isModifier")
            `apply` optional (parseSchemaType "isSummary")
            `apply` optional (parseSchemaType "binding")
            `apply` many (parseSchemaType "mapping")
    schemaTypeToXML s x@ElementDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition_extension x
            , schemaTypeToXML "path" $ elementDefinition_path x
            , concatMap (schemaTypeToXML "representation") $ elementDefinition_representation x
            , maybe [] (schemaTypeToXML "sliceName") $ elementDefinition_sliceName x
            , maybe [] (schemaTypeToXML "label") $ elementDefinition_label x
            , concatMap (schemaTypeToXML "code") $ elementDefinition_code x
            , maybe [] (schemaTypeToXML "slicing") $ elementDefinition_slicing x
            , maybe [] (schemaTypeToXML "short") $ elementDefinition_short x
            , maybe [] (schemaTypeToXML "definition") $ elementDefinition_definition x
            , maybe [] (schemaTypeToXML "comment") $ elementDefinition_comment x
            , maybe [] (schemaTypeToXML "requirements") $ elementDefinition_requirements x
            , concatMap (schemaTypeToXML "alias") $ elementDefinition_alias x
            , maybe [] (schemaTypeToXML "min") $ elementDefinition_min x
            , maybe [] (schemaTypeToXML "max") $ elementDefinition_max x
            , maybe [] (schemaTypeToXML "base") $ elementDefinition_base x
            , maybe [] (schemaTypeToXML "contentReference") $ elementDefinition_contentReference x
            , concatMap (schemaTypeToXML "type") $ elementDefinition_type x
            , maybe [] (foldOneOf38  (schemaTypeToXML "defaultValueBase64Binary")
                                     (schemaTypeToXML "defaultValueBoolean")
                                     (schemaTypeToXML "defaultValueCode")
                                     (schemaTypeToXML "defaultValueDate")
                                     (schemaTypeToXML "defaultValueDateTime")
                                     (schemaTypeToXML "defaultValueDecimal")
                                     (schemaTypeToXML "defaultValueId")
                                     (schemaTypeToXML "defaultValueInstant")
                                     (schemaTypeToXML "defaultValueInteger")
                                     (schemaTypeToXML "defaultValueMarkdown")
                                     (schemaTypeToXML "defaultValueOid")
                                     (schemaTypeToXML "defaultValuePositiveInt")
                                     (schemaTypeToXML "defaultValueString")
                                     (schemaTypeToXML "defaultValueTime")
                                     (schemaTypeToXML "defaultValueUnsignedInt")
                                     (schemaTypeToXML "defaultValueUri")
                                     (schemaTypeToXML "defaultValueAddress")
                                     (schemaTypeToXML "defaultValueAge")
                                     (schemaTypeToXML "defaultValueAnnotation")
                                     (schemaTypeToXML "defaultValueAttachment")
                                     (schemaTypeToXML "defaultValueCodeableConcept")
                                     (schemaTypeToXML "defaultValueCoding")
                                     (schemaTypeToXML "defaultValueContactPoint")
                                     (schemaTypeToXML "defaultValueCount")
                                     (schemaTypeToXML "defaultValueDistance")
                                     (schemaTypeToXML "defaultValueDuration")
                                     (schemaTypeToXML "defaultValueHumanName")
                                     (schemaTypeToXML "defaultValueIdentifier")
                                     (schemaTypeToXML "defaultValueMoney")
                                     (schemaTypeToXML "defaultValuePeriod")
                                     (schemaTypeToXML "defaultValueQuantity")
                                     (schemaTypeToXML "defaultValueRange")
                                     (schemaTypeToXML "defaultValueRatio")
                                     (schemaTypeToXML "defaultValueReference")
                                     (schemaTypeToXML "defaultValueSampledData")
                                     (schemaTypeToXML "defaultValueSignature")
                                     (schemaTypeToXML "defaultValueTiming")
                                     (schemaTypeToXML "defaultValueMeta")
                                    ) $ elementDefinition_choice17 x
            , maybe [] (schemaTypeToXML "meaningWhenMissing") $ elementDefinition_meaningWhenMissing x
            , maybe [] (schemaTypeToXML "orderMeaning") $ elementDefinition_orderMeaning x
            , maybe [] (foldOneOf38  (schemaTypeToXML "fixedBase64Binary")
                                     (schemaTypeToXML "fixedBoolean")
                                     (schemaTypeToXML "fixedCode")
                                     (schemaTypeToXML "fixedDate")
                                     (schemaTypeToXML "fixedDateTime")
                                     (schemaTypeToXML "fixedDecimal")
                                     (schemaTypeToXML "fixedId")
                                     (schemaTypeToXML "fixedInstant")
                                     (schemaTypeToXML "fixedInteger")
                                     (schemaTypeToXML "fixedMarkdown")
                                     (schemaTypeToXML "fixedOid")
                                     (schemaTypeToXML "fixedPositiveInt")
                                     (schemaTypeToXML "fixedString")
                                     (schemaTypeToXML "fixedTime")
                                     (schemaTypeToXML "fixedUnsignedInt")
                                     (schemaTypeToXML "fixedUri")
                                     (schemaTypeToXML "fixedAddress")
                                     (schemaTypeToXML "fixedAge")
                                     (schemaTypeToXML "fixedAnnotation")
                                     (schemaTypeToXML "fixedAttachment")
                                     (schemaTypeToXML "fixedCodeableConcept")
                                     (schemaTypeToXML "fixedCoding")
                                     (schemaTypeToXML "fixedContactPoint")
                                     (schemaTypeToXML "fixedCount")
                                     (schemaTypeToXML "fixedDistance")
                                     (schemaTypeToXML "fixedDuration")
                                     (schemaTypeToXML "fixedHumanName")
                                     (schemaTypeToXML "fixedIdentifier")
                                     (schemaTypeToXML "fixedMoney")
                                     (schemaTypeToXML "fixedPeriod")
                                     (schemaTypeToXML "fixedQuantity")
                                     (schemaTypeToXML "fixedRange")
                                     (schemaTypeToXML "fixedRatio")
                                     (schemaTypeToXML "fixedReference")
                                     (schemaTypeToXML "fixedSampledData")
                                     (schemaTypeToXML "fixedSignature")
                                     (schemaTypeToXML "fixedTiming")
                                     (schemaTypeToXML "fixedMeta")
                                    ) $ elementDefinition_choice20 x
            , maybe [] (foldOneOf38  (schemaTypeToXML "patternBase64Binary")
                                     (schemaTypeToXML "patternBoolean")
                                     (schemaTypeToXML "patternCode")
                                     (schemaTypeToXML "patternDate")
                                     (schemaTypeToXML "patternDateTime")
                                     (schemaTypeToXML "patternDecimal")
                                     (schemaTypeToXML "patternId")
                                     (schemaTypeToXML "patternInstant")
                                     (schemaTypeToXML "patternInteger")
                                     (schemaTypeToXML "patternMarkdown")
                                     (schemaTypeToXML "patternOid")
                                     (schemaTypeToXML "patternPositiveInt")
                                     (schemaTypeToXML "patternString")
                                     (schemaTypeToXML "patternTime")
                                     (schemaTypeToXML "patternUnsignedInt")
                                     (schemaTypeToXML "patternUri")
                                     (schemaTypeToXML "patternAddress")
                                     (schemaTypeToXML "patternAge")
                                     (schemaTypeToXML "patternAnnotation")
                                     (schemaTypeToXML "patternAttachment")
                                     (schemaTypeToXML "patternCodeableConcept")
                                     (schemaTypeToXML "patternCoding")
                                     (schemaTypeToXML "patternContactPoint")
                                     (schemaTypeToXML "patternCount")
                                     (schemaTypeToXML "patternDistance")
                                     (schemaTypeToXML "patternDuration")
                                     (schemaTypeToXML "patternHumanName")
                                     (schemaTypeToXML "patternIdentifier")
                                     (schemaTypeToXML "patternMoney")
                                     (schemaTypeToXML "patternPeriod")
                                     (schemaTypeToXML "patternQuantity")
                                     (schemaTypeToXML "patternRange")
                                     (schemaTypeToXML "patternRatio")
                                     (schemaTypeToXML "patternReference")
                                     (schemaTypeToXML "patternSampledData")
                                     (schemaTypeToXML "patternSignature")
                                     (schemaTypeToXML "patternTiming")
                                     (schemaTypeToXML "patternMeta")
                                    ) $ elementDefinition_choice21 x
            , concatMap (schemaTypeToXML "example") $ elementDefinition_example x
            , maybe [] (foldOneOf9  (concatMap (schemaTypeToXML "minValueDate"))
                                    (concatMap (schemaTypeToXML "minValueDateTime"))
                                    (concatMap (schemaTypeToXML "minValueInstant"))
                                    (concatMap (schemaTypeToXML "minValueTime"))
                                    (concatMap (schemaTypeToXML "minValueDecimal"))
                                    (concatMap (schemaTypeToXML "minValueInteger"))
                                    (concatMap (schemaTypeToXML "minValuePositiveInt"))
                                    (concatMap (schemaTypeToXML "minValueUnsignedInt"))
                                    (concatMap (schemaTypeToXML "minValueQuantity"))
                                   ) $ elementDefinition_choice23 x
            , maybe [] (foldOneOf9  (concatMap (schemaTypeToXML "maxValueDate"))
                                    (concatMap (schemaTypeToXML "maxValueDateTime"))
                                    (concatMap (schemaTypeToXML "maxValueInstant"))
                                    (concatMap (schemaTypeToXML "maxValueTime"))
                                    (concatMap (schemaTypeToXML "maxValueDecimal"))
                                    (concatMap (schemaTypeToXML "maxValueInteger"))
                                    (concatMap (schemaTypeToXML "maxValuePositiveInt"))
                                    (concatMap (schemaTypeToXML "maxValueUnsignedInt"))
                                    (concatMap (schemaTypeToXML "maxValueQuantity"))
                                   ) $ elementDefinition_choice24 x
            , maybe [] (schemaTypeToXML "maxLength") $ elementDefinition_maxLength x
            , concatMap (schemaTypeToXML "condition") $ elementDefinition_condition x
            , concatMap (schemaTypeToXML "constraint") $ elementDefinition_constraint x
            , maybe [] (schemaTypeToXML "mustSupport") $ elementDefinition_mustSupport x
            , maybe [] (schemaTypeToXML "isModifier") $ elementDefinition_isModifier x
            , maybe [] (schemaTypeToXML "isSummary") $ elementDefinition_isSummary x
            , maybe [] (schemaTypeToXML "binding") $ elementDefinition_binding x
            , concatMap (schemaTypeToXML "mapping") $ elementDefinition_mapping x
            ]
instance Extension ElementDefinition Element where
    supertype (ElementDefinition a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               Element a0 e0
 
data ElementDefinition'Constraint = ElementDefinition'Constraint
        { elementDefinition'Constraint_id :: Maybe String'primitive
        , elementDefinition'Constraint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Constraint_key :: Id
          -- ^ Allows identification of which elements have their 
          --   cardinalities impacted by the constraint. Will not be 
          --   referenced for constraints that do not affect cardinality.
        , elementDefinition'Constraint_requirements :: Maybe Xsd.XsdString
          -- ^ Description of why this constraint is necessary or 
          --   appropriate.
        , elementDefinition'Constraint_severity :: ConstraintSeverity
          -- ^ Identifies the impact constraint violation has on the 
          --   conformance of the instance.
        , elementDefinition'Constraint_human :: Xsd.XsdString
          -- ^ Text that can be used to describe the constraint in 
          --   messages identifying that the constraint has been violated.
        , elementDefinition'Constraint_expression :: Xsd.XsdString
          -- ^ A [FHIRPath](http://hl7.org/fluentpath) expression of 
          --   constraint that can be executed to see if this constraint 
          --   is met.
        , elementDefinition'Constraint_xpath :: Maybe Xsd.XsdString
          -- ^ An XPath expression of constraint that can be executed to 
          --   see if this constraint is met.
        , elementDefinition'Constraint_source :: Maybe Uri
          -- ^ A reference to the original source of the constraint, for 
          --   traceability purposes.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Constraint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Constraint a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "key"
            `apply` optional (parseSchemaType "requirements")
            `apply` parseSchemaType "severity"
            `apply` parseSchemaType "human"
            `apply` parseSchemaType "expression"
            `apply` optional (parseSchemaType "xpath")
            `apply` optional (parseSchemaType "source")
    schemaTypeToXML s x@ElementDefinition'Constraint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Constraint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Constraint_extension x
            , schemaTypeToXML "key" $ elementDefinition'Constraint_key x
            , maybe [] (schemaTypeToXML "requirements") $ elementDefinition'Constraint_requirements x
            , schemaTypeToXML "severity" $ elementDefinition'Constraint_severity x
            , schemaTypeToXML "human" $ elementDefinition'Constraint_human x
            , schemaTypeToXML "expression" $ elementDefinition'Constraint_expression x
            , maybe [] (schemaTypeToXML "xpath") $ elementDefinition'Constraint_xpath x
            , maybe [] (schemaTypeToXML "source") $ elementDefinition'Constraint_source x
            ]
instance Extension ElementDefinition'Constraint Element where
    supertype (ElementDefinition'Constraint a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
data ElementDefinition'Mapping = ElementDefinition'Mapping
        { elementDefinition'Mapping_id :: Maybe String'primitive
        , elementDefinition'Mapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Mapping_identity :: Id
          -- ^ An internal reference to the definition of a mapping.
        , elementDefinition'Mapping_language :: Maybe Code
          -- ^ Identifies the computable language in which mapping.map is 
          --   expressed.
        , elementDefinition'Mapping_map :: Xsd.XsdString
          -- ^ Expresses what part of the target specification corresponds 
          --   to this element.
        , elementDefinition'Mapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments that provide information about the mapping or its 
          --   use.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Mapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Mapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "language")
            `apply` parseSchemaType "map"
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@ElementDefinition'Mapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Mapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Mapping_extension x
            , schemaTypeToXML "identity" $ elementDefinition'Mapping_identity x
            , maybe [] (schemaTypeToXML "language") $ elementDefinition'Mapping_language x
            , schemaTypeToXML "map" $ elementDefinition'Mapping_map x
            , maybe [] (schemaTypeToXML "comment") $ elementDefinition'Mapping_comment x
            ]
instance Extension ElementDefinition'Mapping Element where
    supertype (ElementDefinition'Mapping a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data ElementDefinition'Base = ElementDefinition'Base
        { elementDefinition'Base_id :: Maybe String'primitive
        , elementDefinition'Base_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Base_path :: Xsd.XsdString
          -- ^ The Path that identifies the base element - this matches 
          --   the ElementDefinition.path for that element. Across FHIR, 
          --   there is only one base definition of any element - that is, 
          --   an element definition on a [[[StructureDefinition]]] 
          --   without a StructureDefinition.base.
        , elementDefinition'Base_min :: UnsignedInt
          -- ^ Minimum cardinality of the base element identified by the 
          --   path.
        , elementDefinition'Base_max :: Xsd.XsdString
          -- ^ Maximum cardinality of the base element identified by the 
          --   path.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Base where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Base a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` parseSchemaType "min"
            `apply` parseSchemaType "max"
    schemaTypeToXML s x@ElementDefinition'Base{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Base_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Base_extension x
            , schemaTypeToXML "path" $ elementDefinition'Base_path x
            , schemaTypeToXML "min" $ elementDefinition'Base_min x
            , schemaTypeToXML "max" $ elementDefinition'Base_max x
            ]
instance Extension ElementDefinition'Base Element where
    supertype (ElementDefinition'Base a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ElementDefinition'Type = ElementDefinition'Type
        { elementDefinition'Type_id :: Maybe String'primitive
        , elementDefinition'Type_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Type_code :: Uri
          -- ^ URL of Data type or Resource that is a(or the) type used 
          --   for this element. References are URLs that are relative to 
          --   http://hl7.org/fhir/StructureDefinition e.g. 
          --   &quot;string&quot; is a reference to 
          --   http://hl7.org/fhir/StructureDefinition/string. Absolute 
          --   URLs are only allowed in logical models.
        , elementDefinition'Type_profile :: Maybe Uri
          -- ^ Identifies a profile structure or implementation Guide that 
          --   SHALL hold for the datatype this element refers to. Can be 
          --   a local reference - to a contained StructureDefinition, or 
          --   a reference to another StructureDefinition or 
          --   Implementation Guide by a canonical URL. When an 
          --   implementation guide is specified, the resource SHALL 
          --   conform to at least one profile defined in the 
          --   implementation guide.
        , elementDefinition'Type_targetProfile :: Maybe Uri
          -- ^ Identifies a profile structure or implementation Guide that 
          --   SHALL hold for the target of the reference this element 
          --   refers to. Can be a local reference - to a contained 
          --   StructureDefinition, or a reference to another 
          --   StructureDefinition or Implementation Guide by a canonical 
          --   URL. When an implementation guide is specified, the 
          --   resource SHALL conform to at least one profile defined in 
          --   the implementation guide.
        , elementDefinition'Type_aggregation :: [AggregationMode]
          -- ^ If the type is a reference to another resource, how the 
          --   resource is or can be aggregated - is it a contained 
          --   resource, or a reference, and if the context is a bundle, 
          --   is it included in the bundle.
        , elementDefinition'Type_versioning :: Maybe ReferenceVersionRules
          -- ^ Whether this reference needs to be version specific or 
          --   version independent, or whether either can be used.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Type where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Type a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "targetProfile")
            `apply` many (parseSchemaType "aggregation")
            `apply` optional (parseSchemaType "versioning")
    schemaTypeToXML s x@ElementDefinition'Type{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Type_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Type_extension x
            , schemaTypeToXML "code" $ elementDefinition'Type_code x
            , maybe [] (schemaTypeToXML "profile") $ elementDefinition'Type_profile x
            , maybe [] (schemaTypeToXML "targetProfile") $ elementDefinition'Type_targetProfile x
            , concatMap (schemaTypeToXML "aggregation") $ elementDefinition'Type_aggregation x
            , maybe [] (schemaTypeToXML "versioning") $ elementDefinition'Type_versioning x
            ]
instance Extension ElementDefinition'Type Element where
    supertype (ElementDefinition'Type a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data ElementDefinition'Example = ElementDefinition'Example
        { elementDefinition'Example_id :: Maybe String'primitive
        , elementDefinition'Example_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Example_label :: Xsd.XsdString
          -- ^ Describes the purpose of this example amoung the set of 
          --   examples.
        , elementDefinition'Example_choice2 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The actual value for the element, which must be one of the 
          --   types allowed for this element.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Example where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Example a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "label"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@ElementDefinition'Example{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Example_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Example_extension x
            , schemaTypeToXML "label" $ elementDefinition'Example_label x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ elementDefinition'Example_choice2 x
            ]
instance Extension ElementDefinition'Example Element where
    supertype (ElementDefinition'Example a0 e0 e1 e2) =
               Element a0 e0
 
data ElementDefinition'Slicing = ElementDefinition'Slicing
        { elementDefinition'Slicing_id :: Maybe String'primitive
        , elementDefinition'Slicing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Slicing_discriminator :: [ElementDefinition'Discriminator]
          -- ^ Designates which child elements are used to discriminate 
          --   between the slices when processing an instance. If one or 
          --   more discriminators are provided, the value of the child 
          --   elements in the instance data SHALL completely distinguish 
          --   which slice the element in the resource matches based on 
          --   the allowed values for those elements in each of the 
          --   slices.
        , elementDefinition'Slicing_description :: Maybe Xsd.XsdString
          -- ^ A human-readable text description of how the slicing works. 
          --   If there is no discriminator, this is required to be 
          --   present to provide whatever information is possible about 
          --   how the slices can be differentiated.
        , elementDefinition'Slicing_ordered :: Maybe Boolean
          -- ^ If the matching elements have to occur in the same order as 
          --   defined in the profile.
        , elementDefinition'Slicing_rules :: SlicingRules
          -- ^ Whether additional slices are allowed or not. When the 
          --   slices are ordered, profile authors can also say that 
          --   additional slices are only allowed at the end.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Slicing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Slicing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "discriminator")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "ordered")
            `apply` parseSchemaType "rules"
    schemaTypeToXML s x@ElementDefinition'Slicing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Slicing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Slicing_extension x
            , concatMap (schemaTypeToXML "discriminator") $ elementDefinition'Slicing_discriminator x
            , maybe [] (schemaTypeToXML "description") $ elementDefinition'Slicing_description x
            , maybe [] (schemaTypeToXML "ordered") $ elementDefinition'Slicing_ordered x
            , schemaTypeToXML "rules" $ elementDefinition'Slicing_rules x
            ]
instance Extension ElementDefinition'Slicing Element where
    supertype (ElementDefinition'Slicing a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data ElementDefinition'Binding = ElementDefinition'Binding
        { elementDefinition'Binding_id :: Maybe String'primitive
        , elementDefinition'Binding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Binding_strength :: BindingStrength
          -- ^ Indicates the degree of conformance expectations associated 
          --   with this binding - that is, the degree to which the 
          --   provided value set must be adhered to in the instances.
        , elementDefinition'Binding_description :: Maybe Xsd.XsdString
          -- ^ Describes the intended use of this particular set of codes.
        , elementDefinition'Binding_choice3 :: (Maybe (OneOf2 [Uri] [Reference]))
          -- ^ Points to the value set or external definition (e.g. 
          --   implicit value set) that identifies the set of codes to be 
          --   used. If the binding refers to an explicit value set - the 
          --   normal case - then use a Reference(ValueSet) preferably 
          --   containing the canonical URL for the value set. If the 
          --   reference is to an implicit value set - usually, an IETF 
          --   RFC that defines a grammar, such as mime types - then use a 
          --   uri.
          --   
          --   Choice between:
          --   
          --   (1) valueSetUri
          --   
          --   (2) valueSetReference
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Binding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Binding a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "strength"
            `apply` optional (parseSchemaType "description")
            `apply` optional (oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                      (parseSchemaType "valueSetUri")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "valueSetReference")))
                                     ])
    schemaTypeToXML s x@ElementDefinition'Binding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Binding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Binding_extension x
            , schemaTypeToXML "strength" $ elementDefinition'Binding_strength x
            , maybe [] (schemaTypeToXML "description") $ elementDefinition'Binding_description x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "valueSetUri"))
                                    (concatMap (schemaTypeToXML "valueSetReference"))
                                   ) $ elementDefinition'Binding_choice3 x
            ]
instance Extension ElementDefinition'Binding Element where
    supertype (ElementDefinition'Binding a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ElementDefinition'Discriminator = ElementDefinition'Discriminator
        { elementDefinition'Discriminator_id :: Maybe String'primitive
        , elementDefinition'Discriminator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition'Discriminator_type :: DiscriminatorType
          -- ^ How the element value is interpreted when discrimination is 
          --   evaluated.
        , elementDefinition'Discriminator_path :: Xsd.XsdString
          -- ^ A FHIRPath expression, using a restricted subset of 
          --   FHIRPath, that is used to identify the element on which 
          --   discrimination is based.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition'Discriminator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition'Discriminator a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "path"
    schemaTypeToXML s x@ElementDefinition'Discriminator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition'Discriminator_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition'Discriminator_extension x
            , schemaTypeToXML "type" $ elementDefinition'Discriminator_type x
            , schemaTypeToXML "path" $ elementDefinition'Discriminator_path x
            ]
instance Extension ElementDefinition'Discriminator Element where
    supertype (ElementDefinition'Discriminator a0 e0 e1 e2) =
               Element a0 e0
 
data PropertyRepresentation'list
    = PropertyRepresentation'list_XmlAttr
      -- ^ XML Attribute
    | PropertyRepresentation'list_XmlText
      -- ^ XML Text
    | PropertyRepresentation'list_TypeAttr
      -- ^ Type Attribute
    | PropertyRepresentation'list_CdaText
      -- ^ CDA Text Format
    | PropertyRepresentation'list_Xhtml
      -- ^ XHTML
    deriving (Eq,Show,Enum)
instance SchemaType PropertyRepresentation'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PropertyRepresentation'list where
    acceptingParser =  do literal "xmlAttr"; return PropertyRepresentation'list_XmlAttr
                      `onFail` do literal "xmlText"; return PropertyRepresentation'list_XmlText
                      `onFail` do literal "typeAttr"; return PropertyRepresentation'list_TypeAttr
                      `onFail` do literal "cdaText"; return PropertyRepresentation'list_CdaText
                      `onFail` do literal "xhtml"; return PropertyRepresentation'list_Xhtml
                      
    simpleTypeText PropertyRepresentation'list_XmlAttr = "xmlAttr"
    simpleTypeText PropertyRepresentation'list_XmlText = "xmlText"
    simpleTypeText PropertyRepresentation'list_TypeAttr = "typeAttr"
    simpleTypeText PropertyRepresentation'list_CdaText = "cdaText"
    simpleTypeText PropertyRepresentation'list_Xhtml = "xhtml"
 
data PropertyRepresentation = PropertyRepresentation
        { propertyRepresentation_id :: Maybe String'primitive
        , propertyRepresentation_value :: Maybe PropertyRepresentation'list
        , propertyRepresentation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PropertyRepresentation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PropertyRepresentation a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PropertyRepresentation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ propertyRepresentation_id x
                       , maybe [] (toXMLAttribute "value") $ propertyRepresentation_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ propertyRepresentation_extension x
            ]
instance Extension PropertyRepresentation Element where
    supertype (PropertyRepresentation a0 a1 e0) =
               Element a0 e0
 
data ConstraintSeverity'list
    = ConstraintSeverity'list_Error
      -- ^ Error
    | ConstraintSeverity'list_Warning
      -- ^ Warning
    deriving (Eq,Show,Enum)
instance SchemaType ConstraintSeverity'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConstraintSeverity'list where
    acceptingParser =  do literal "error"; return ConstraintSeverity'list_Error
                      `onFail` do literal "warning"; return ConstraintSeverity'list_Warning
                      
    simpleTypeText ConstraintSeverity'list_Error = "error"
    simpleTypeText ConstraintSeverity'list_Warning = "warning"
 
data ConstraintSeverity = ConstraintSeverity
        { constraintSeverity_id :: Maybe String'primitive
        , constraintSeverity_value :: Maybe ConstraintSeverity'list
        , constraintSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConstraintSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConstraintSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConstraintSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ constraintSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ constraintSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ constraintSeverity_extension x
            ]
instance Extension ConstraintSeverity Element where
    supertype (ConstraintSeverity a0 a1 e0) =
               Element a0 e0
 
data AggregationMode'list
    = AggregationMode'list_Contained
      -- ^ Contained
    | AggregationMode'list_Referenced
      -- ^ Referenced
    | AggregationMode'list_Bundled
      -- ^ Bundled
    deriving (Eq,Show,Enum)
instance SchemaType AggregationMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AggregationMode'list where
    acceptingParser =  do literal "contained"; return AggregationMode'list_Contained
                      `onFail` do literal "referenced"; return AggregationMode'list_Referenced
                      `onFail` do literal "bundled"; return AggregationMode'list_Bundled
                      
    simpleTypeText AggregationMode'list_Contained = "contained"
    simpleTypeText AggregationMode'list_Referenced = "referenced"
    simpleTypeText AggregationMode'list_Bundled = "bundled"
 
data AggregationMode = AggregationMode
        { aggregationMode_id :: Maybe String'primitive
        , aggregationMode_value :: Maybe AggregationMode'list
        , aggregationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AggregationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AggregationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AggregationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ aggregationMode_id x
                       , maybe [] (toXMLAttribute "value") $ aggregationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ aggregationMode_extension x
            ]
instance Extension AggregationMode Element where
    supertype (AggregationMode a0 a1 e0) =
               Element a0 e0
 
data ReferenceVersionRules'list
    = ReferenceVersionRules'list_Either
      -- ^ Either Specific or independent
    | ReferenceVersionRules'list_Independent
      -- ^ Version independent
    | ReferenceVersionRules'list_Specific
      -- ^ Version Specific
    deriving (Eq,Show,Enum)
instance SchemaType ReferenceVersionRules'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ReferenceVersionRules'list where
    acceptingParser =  do literal "either"; return ReferenceVersionRules'list_Either
                      `onFail` do literal "independent"; return ReferenceVersionRules'list_Independent
                      `onFail` do literal "specific"; return ReferenceVersionRules'list_Specific
                      
    simpleTypeText ReferenceVersionRules'list_Either = "either"
    simpleTypeText ReferenceVersionRules'list_Independent = "independent"
    simpleTypeText ReferenceVersionRules'list_Specific = "specific"
 
data ReferenceVersionRules = ReferenceVersionRules
        { referenceVersionRules_id :: Maybe String'primitive
        , referenceVersionRules_value :: Maybe ReferenceVersionRules'list
        , referenceVersionRules_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ReferenceVersionRules where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ReferenceVersionRules a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ReferenceVersionRules{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referenceVersionRules_id x
                       , maybe [] (toXMLAttribute "value") $ referenceVersionRules_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referenceVersionRules_extension x
            ]
instance Extension ReferenceVersionRules Element where
    supertype (ReferenceVersionRules a0 a1 e0) =
               Element a0 e0
 
data SlicingRules'list
    = SlicingRules'list_Closed
      -- ^ Closed
    | SlicingRules'list_Open
      -- ^ Open
    | SlicingRules'list_OpenAtEnd
      -- ^ Open at End
    deriving (Eq,Show,Enum)
instance SchemaType SlicingRules'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SlicingRules'list where
    acceptingParser =  do literal "closed"; return SlicingRules'list_Closed
                      `onFail` do literal "open"; return SlicingRules'list_Open
                      `onFail` do literal "openAtEnd"; return SlicingRules'list_OpenAtEnd
                      
    simpleTypeText SlicingRules'list_Closed = "closed"
    simpleTypeText SlicingRules'list_Open = "open"
    simpleTypeText SlicingRules'list_OpenAtEnd = "openAtEnd"
 
data SlicingRules = SlicingRules
        { slicingRules_id :: Maybe String'primitive
        , slicingRules_value :: Maybe SlicingRules'list
        , slicingRules_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SlicingRules where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SlicingRules a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SlicingRules{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ slicingRules_id x
                       , maybe [] (toXMLAttribute "value") $ slicingRules_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ slicingRules_extension x
            ]
instance Extension SlicingRules Element where
    supertype (SlicingRules a0 a1 e0) =
               Element a0 e0
 
data BindingStrength'list
    = BindingStrength'list_Required
      -- ^ Required
    | BindingStrength'list_Extensible
      -- ^ Extensible
    | BindingStrength'list_Preferred
      -- ^ Preferred
    | BindingStrength'list_Example
      -- ^ Example
    deriving (Eq,Show,Enum)
instance SchemaType BindingStrength'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType BindingStrength'list where
    acceptingParser =  do literal "required"; return BindingStrength'list_Required
                      `onFail` do literal "extensible"; return BindingStrength'list_Extensible
                      `onFail` do literal "preferred"; return BindingStrength'list_Preferred
                      `onFail` do literal "example"; return BindingStrength'list_Example
                      
    simpleTypeText BindingStrength'list_Required = "required"
    simpleTypeText BindingStrength'list_Extensible = "extensible"
    simpleTypeText BindingStrength'list_Preferred = "preferred"
    simpleTypeText BindingStrength'list_Example = "example"
 
data BindingStrength = BindingStrength
        { bindingStrength_id :: Maybe String'primitive
        , bindingStrength_value :: Maybe BindingStrength'list
        , bindingStrength_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType BindingStrength where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (BindingStrength a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@BindingStrength{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bindingStrength_id x
                       , maybe [] (toXMLAttribute "value") $ bindingStrength_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bindingStrength_extension x
            ]
instance Extension BindingStrength Element where
    supertype (BindingStrength a0 a1 e0) =
               Element a0 e0
 
data DiscriminatorType'list
    = DiscriminatorType'list_Value
      -- ^ Value
    | DiscriminatorType'list_Exists
      -- ^ Exists
    | DiscriminatorType'list_Pattern
      -- ^ Pattern
    | DiscriminatorType'list_Type
      -- ^ Type
    | DiscriminatorType'list_Profile
      -- ^ Profile
    deriving (Eq,Show,Enum)
instance SchemaType DiscriminatorType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DiscriminatorType'list where
    acceptingParser =  do literal "value"; return DiscriminatorType'list_Value
                      `onFail` do literal "exists"; return DiscriminatorType'list_Exists
                      `onFail` do literal "pattern"; return DiscriminatorType'list_Pattern
                      `onFail` do literal "type"; return DiscriminatorType'list_Type
                      `onFail` do literal "profile"; return DiscriminatorType'list_Profile
                      
    simpleTypeText DiscriminatorType'list_Value = "value"
    simpleTypeText DiscriminatorType'list_Exists = "exists"
    simpleTypeText DiscriminatorType'list_Pattern = "pattern"
    simpleTypeText DiscriminatorType'list_Type = "type"
    simpleTypeText DiscriminatorType'list_Profile = "profile"
 
data DiscriminatorType = DiscriminatorType
        { discriminatorType_id :: Maybe String'primitive
        , discriminatorType_value :: Maybe DiscriminatorType'list
        , discriminatorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DiscriminatorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DiscriminatorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DiscriminatorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ discriminatorType_id x
                       , maybe [] (toXMLAttribute "value") $ discriminatorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ discriminatorType_extension x
            ]
instance Extension DiscriminatorType Element where
    supertype (DiscriminatorType a0 a1 e0) =
               Element a0 e0
 
data ParameterDefinition = ParameterDefinition
        { parameterDefinition_id :: Maybe String'primitive
        , parameterDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , parameterDefinition_name :: Maybe Code
          -- ^ The name of the parameter used to allow access to the value 
          --   of the parameter in evaluation contexts.
        , parameterDefinition_use :: Code
          -- ^ Whether the parameter is input or output for the module.
        , parameterDefinition_min :: Maybe Integer
          -- ^ The minimum number of times this parameter SHALL appear in 
          --   the request or response.
        , parameterDefinition_max :: Maybe Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the request or response.
        , parameterDefinition_documentation :: Maybe Xsd.XsdString
          -- ^ A brief discussion of what the parameter is for and how it 
          --   is used by the module.
        , parameterDefinition_type :: Code
          -- ^ The type of the parameter.
        , parameterDefinition_profile :: Maybe Reference
          -- ^ If specified, this indicates a profile that the input data 
          --   must conform to, or that the output data will conform to.
        }
        deriving (Eq,Show)
instance SchemaType ParameterDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ParameterDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "use"
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "documentation")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
    schemaTypeToXML s x@ParameterDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ parameterDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ parameterDefinition_extension x
            , maybe [] (schemaTypeToXML "name") $ parameterDefinition_name x
            , schemaTypeToXML "use" $ parameterDefinition_use x
            , maybe [] (schemaTypeToXML "min") $ parameterDefinition_min x
            , maybe [] (schemaTypeToXML "max") $ parameterDefinition_max x
            , maybe [] (schemaTypeToXML "documentation") $ parameterDefinition_documentation x
            , schemaTypeToXML "type" $ parameterDefinition_type x
            , maybe [] (schemaTypeToXML "profile") $ parameterDefinition_profile x
            ]
instance Extension ParameterDefinition Element where
    supertype (ParameterDefinition a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
-- | A resource that includes narrative, extensions, and 
--   contained resources.
data DomainResource = DomainResource
        { domainResource_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , domainResource_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , domainResource_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , domainResource_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , domainResource_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , domainResource_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , domainResource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , domainResource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        }
        deriving (Eq,Show)
instance SchemaType DomainResource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DomainResource
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
    schemaTypeToXML s x@DomainResource{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ domainResource_id x
            , maybe [] (schemaTypeToXML "meta") $ domainResource_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ domainResource_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ domainResource_language x
            , maybe [] (schemaTypeToXML "text") $ domainResource_text x
            , concatMap (schemaTypeToXML "contained") $ domainResource_contained x
            , concatMap (schemaTypeToXML "extension") $ domainResource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ domainResource_modifierExtension x
            ]
instance Extension DomainResource Resource where
    supertype (DomainResource e0 e1 e2 e3 e4 e5 e6 e7) =
               Resource e0 e1 e2 e3
 
-- | This is the base resource type for everything.
data Resource = Resource
        { resource_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , resource_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , resource_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , resource_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        }
        deriving (Eq,Show)
instance SchemaType Resource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Resource
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@Resource{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ resource_id x
            , maybe [] (schemaTypeToXML "meta") $ resource_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ resource_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ resource_language x
            ]
 
data PublicationStatus'list
    = PublicationStatus'list_Draft
    | PublicationStatus'list_Active
    | PublicationStatus'list_Retired
    | PublicationStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType PublicationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PublicationStatus'list where
    acceptingParser =  do literal "draft"; return PublicationStatus'list_Draft
                      `onFail` do literal "active"; return PublicationStatus'list_Active
                      `onFail` do literal "retired"; return PublicationStatus'list_Retired
                      `onFail` do literal "unknown"; return PublicationStatus'list_Unknown
                      
    simpleTypeText PublicationStatus'list_Draft = "draft"
    simpleTypeText PublicationStatus'list_Active = "active"
    simpleTypeText PublicationStatus'list_Retired = "retired"
    simpleTypeText PublicationStatus'list_Unknown = "unknown"
 
data PublicationStatus = PublicationStatus
        { publicationStatus_id :: Maybe String'primitive
        , publicationStatus_value :: Maybe PublicationStatus'list
        , publicationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PublicationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PublicationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PublicationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ publicationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ publicationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ publicationStatus_extension x
            ]
instance Extension PublicationStatus Element where
    supertype (PublicationStatus a0 a1 e0) =
               Element a0 e0
 
data SearchParamType'list
    = SearchParamType'list_Number
      -- ^ Number
    | SearchParamType'list_Date
      -- ^ Date/DateTime
    | SearchParamType'list_Xsd.XsdString
      -- ^ String
    | SearchParamType'list_Token
      -- ^ Token
    | SearchParamType'list_Reference
      -- ^ Reference
    | SearchParamType'list_Composite
      -- ^ Composite
    | SearchParamType'list_Quantity
      -- ^ Quantity
    | SearchParamType'list_Uri
      -- ^ URI
    deriving (Eq,Show,Enum)
instance SchemaType SearchParamType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchParamType'list where
    acceptingParser =  do literal "number"; return SearchParamType'list_Number
                      `onFail` do literal "date"; return SearchParamType'list_Date
                      `onFail` do literal "string"; return SearchParamType'list_Xsd.XsdString
                      `onFail` do literal "token"; return SearchParamType'list_Token
                      `onFail` do literal "reference"; return SearchParamType'list_Reference
                      `onFail` do literal "composite"; return SearchParamType'list_Composite
                      `onFail` do literal "quantity"; return SearchParamType'list_Quantity
                      `onFail` do literal "uri"; return SearchParamType'list_Uri
                      
    simpleTypeText SearchParamType'list_Number = "number"
    simpleTypeText SearchParamType'list_Date = "date"
    simpleTypeText SearchParamType'list_Xsd.XsdString = "string"
    simpleTypeText SearchParamType'list_Token = "token"
    simpleTypeText SearchParamType'list_Reference = "reference"
    simpleTypeText SearchParamType'list_Composite = "composite"
    simpleTypeText SearchParamType'list_Quantity = "quantity"
    simpleTypeText SearchParamType'list_Uri = "uri"
 
data SearchParamType = SearchParamType
        { searchParamType_id :: Maybe String'primitive
        , searchParamType_value :: Maybe SearchParamType'list
        , searchParamType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchParamType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchParamType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchParamType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchParamType_id x
                       , maybe [] (toXMLAttribute "value") $ searchParamType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchParamType_extension x
            ]
instance Extension SearchParamType Element where
    supertype (SearchParamType a0 a1 e0) =
               Element a0 e0
 
data AdministrativeGender'list
    = AdministrativeGender'list_Male
      -- ^ Male
    | AdministrativeGender'list_Female
      -- ^ Female
    | AdministrativeGender'list_Other
      -- ^ Other
    | AdministrativeGender'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType AdministrativeGender'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdministrativeGender'list where
    acceptingParser =  do literal "male"; return AdministrativeGender'list_Male
                      `onFail` do literal "female"; return AdministrativeGender'list_Female
                      `onFail` do literal "other"; return AdministrativeGender'list_Other
                      `onFail` do literal "unknown"; return AdministrativeGender'list_Unknown
                      
    simpleTypeText AdministrativeGender'list_Male = "male"
    simpleTypeText AdministrativeGender'list_Female = "female"
    simpleTypeText AdministrativeGender'list_Other = "other"
    simpleTypeText AdministrativeGender'list_Unknown = "unknown"
 
data AdministrativeGender = AdministrativeGender
        { administrativeGender_id :: Maybe String'primitive
        , administrativeGender_value :: Maybe AdministrativeGender'list
        , administrativeGender_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdministrativeGender where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdministrativeGender a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdministrativeGender{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ administrativeGender_id x
                       , maybe [] (toXMLAttribute "value") $ administrativeGender_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ administrativeGender_extension x
            ]
instance Extension AdministrativeGender Element where
    supertype (AdministrativeGender a0 a1 e0) =
               Element a0 e0
 
data RemittanceOutcome'list
    = RemittanceOutcome'list_Complete
      -- ^ Processing Complete
    | RemittanceOutcome'list_Error
      -- ^ Error
    | RemittanceOutcome'list_Partial
      -- ^ Partial Processing
    deriving (Eq,Show,Enum)
instance SchemaType RemittanceOutcome'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RemittanceOutcome'list where
    acceptingParser =  do literal "complete"; return RemittanceOutcome'list_Complete
                      `onFail` do literal "error"; return RemittanceOutcome'list_Error
                      `onFail` do literal "partial"; return RemittanceOutcome'list_Partial
                      
    simpleTypeText RemittanceOutcome'list_Complete = "complete"
    simpleTypeText RemittanceOutcome'list_Error = "error"
    simpleTypeText RemittanceOutcome'list_Partial = "partial"
 
data RemittanceOutcome = RemittanceOutcome
        { remittanceOutcome_id :: Maybe String'primitive
        , remittanceOutcome_value :: Maybe RemittanceOutcome'list
        , remittanceOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RemittanceOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RemittanceOutcome a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RemittanceOutcome{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ remittanceOutcome_id x
                       , maybe [] (toXMLAttribute "value") $ remittanceOutcome_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ remittanceOutcome_extension x
            ]
instance Extension RemittanceOutcome Element where
    supertype (RemittanceOutcome a0 a1 e0) =
               Element a0 e0
 
data NoteType'list
    = NoteType'list_Display
      -- ^ Display
    | NoteType'list_Print
      -- ^ Print (Form)
    | NoteType'list_Printoper
      -- ^ Print (Operator)
    deriving (Eq,Show,Enum)
instance SchemaType NoteType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NoteType'list where
    acceptingParser =  do literal "display"; return NoteType'list_Display
                      `onFail` do literal "print"; return NoteType'list_Print
                      `onFail` do literal "printoper"; return NoteType'list_Printoper
                      
    simpleTypeText NoteType'list_Display = "display"
    simpleTypeText NoteType'list_Print = "print"
    simpleTypeText NoteType'list_Printoper = "printoper"
 
data NoteType = NoteType
        { noteType_id :: Maybe String'primitive
        , noteType_value :: Maybe NoteType'list
        , noteType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NoteType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NoteType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NoteType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ noteType_id x
                       , maybe [] (toXMLAttribute "value") $ noteType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ noteType_extension x
            ]
instance Extension NoteType Element where
    supertype (NoteType a0 a1 e0) =
               Element a0 e0
 
data ConceptMapEquivalence'list
    = ConceptMapEquivalence'list_Relatedto
      -- ^ Related To
    | ConceptMapEquivalence'list_Equivalent
      -- ^ Equivalent
    | ConceptMapEquivalence'list_Equal
      -- ^ Equal
    | ConceptMapEquivalence'list_Wider
      -- ^ Wider
    | ConceptMapEquivalence'list_Subsumes
      -- ^ Subsumes
    | ConceptMapEquivalence'list_Narrower
      -- ^ Narrower
    | ConceptMapEquivalence'list_Specializes
      -- ^ Specializes
    | ConceptMapEquivalence'list_Inexact
      -- ^ Inexact
    | ConceptMapEquivalence'list_Unmatched
      -- ^ Unmatched
    | ConceptMapEquivalence'list_Disjoint
      -- ^ Disjoint
    deriving (Eq,Show,Enum)
instance SchemaType ConceptMapEquivalence'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConceptMapEquivalence'list where
    acceptingParser =  do literal "relatedto"; return ConceptMapEquivalence'list_Relatedto
                      `onFail` do literal "equivalent"; return ConceptMapEquivalence'list_Equivalent
                      `onFail` do literal "equal"; return ConceptMapEquivalence'list_Equal
                      `onFail` do literal "wider"; return ConceptMapEquivalence'list_Wider
                      `onFail` do literal "subsumes"; return ConceptMapEquivalence'list_Subsumes
                      `onFail` do literal "narrower"; return ConceptMapEquivalence'list_Narrower
                      `onFail` do literal "specializes"; return ConceptMapEquivalence'list_Specializes
                      `onFail` do literal "inexact"; return ConceptMapEquivalence'list_Inexact
                      `onFail` do literal "unmatched"; return ConceptMapEquivalence'list_Unmatched
                      `onFail` do literal "disjoint"; return ConceptMapEquivalence'list_Disjoint
                      
    simpleTypeText ConceptMapEquivalence'list_Relatedto = "relatedto"
    simpleTypeText ConceptMapEquivalence'list_Equivalent = "equivalent"
    simpleTypeText ConceptMapEquivalence'list_Equal = "equal"
    simpleTypeText ConceptMapEquivalence'list_Wider = "wider"
    simpleTypeText ConceptMapEquivalence'list_Subsumes = "subsumes"
    simpleTypeText ConceptMapEquivalence'list_Narrower = "narrower"
    simpleTypeText ConceptMapEquivalence'list_Specializes = "specializes"
    simpleTypeText ConceptMapEquivalence'list_Inexact = "inexact"
    simpleTypeText ConceptMapEquivalence'list_Unmatched = "unmatched"
    simpleTypeText ConceptMapEquivalence'list_Disjoint = "disjoint"
 
data ConceptMapEquivalence = ConceptMapEquivalence
        { conceptMapEquivalence_id :: Maybe String'primitive
        , conceptMapEquivalence_value :: Maybe ConceptMapEquivalence'list
        , conceptMapEquivalence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapEquivalence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConceptMapEquivalence a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConceptMapEquivalence{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapEquivalence_id x
                       , maybe [] (toXMLAttribute "value") $ conceptMapEquivalence_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapEquivalence_extension x
            ]
instance Extension ConceptMapEquivalence Element where
    supertype (ConceptMapEquivalence a0 a1 e0) =
               Element a0 e0
 
data DocumentReferenceStatus'list
    = DocumentReferenceStatus'list_Current
      -- ^ Current
    | DocumentReferenceStatus'list_Superseded
      -- ^ Superseded
    | DocumentReferenceStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType DocumentReferenceStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentReferenceStatus'list where
    acceptingParser =  do literal "current"; return DocumentReferenceStatus'list_Current
                      `onFail` do literal "superseded"; return DocumentReferenceStatus'list_Superseded
                      `onFail` do literal "entered-in-error"; return DocumentReferenceStatus'list_Entered'in'error
                      
    simpleTypeText DocumentReferenceStatus'list_Current = "current"
    simpleTypeText DocumentReferenceStatus'list_Superseded = "superseded"
    simpleTypeText DocumentReferenceStatus'list_Entered'in'error = "entered-in-error"
 
data DocumentReferenceStatus = DocumentReferenceStatus
        { documentReferenceStatus_id :: Maybe String'primitive
        , documentReferenceStatus_value :: Maybe DocumentReferenceStatus'list
        , documentReferenceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentReferenceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentReferenceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ documentReferenceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceStatus_extension x
            ]
instance Extension DocumentReferenceStatus Element where
    supertype (DocumentReferenceStatus a0 a1 e0) =
               Element a0 e0
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
elementAccount :: XMLParser Account
elementAccount = parseSchemaType "Account"
elementToXMLAccount :: Account -> [Content ()]
elementToXMLAccount = schemaTypeToXML "Account"
 
data Account = Account
        { account_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , account_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , account_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , account_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , account_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , account_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , account_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , account_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , account_identifier :: [Identifier]
          -- ^ Unique identifier used to reference the account. May or may 
          --   not be intended for human use (e.g. credit card number).
        , account_status :: Maybe AccountStatus
          -- ^ Indicates whether the account is presently used/usable or 
          --   not.
        , account_type :: Maybe CodeableConcept
          -- ^ Categorizes the account for reporting and searching 
          --   purposes.
        , account_name :: Maybe Xsd.XsdString
          -- ^ Name used for the account when displaying it to humans in 
          --   reports, etc.
        , account_subject :: Maybe Reference
          -- ^ Identifies the patient, device, practitioner, location or 
          --   other object the account is associated with.
        , account_period :: Maybe Period
          -- ^ Identifies the period of time the account applies to; e.g. 
          --   accounts created per fiscal year, quarter, etc.
        , account_active :: Maybe Period
          -- ^ Indicates the period of time over which the account is 
          --   allowed to have transactions posted to it. This period may 
          --   be different to the coveragePeriod which is the duration of 
          --   time that services may occur.
        , account_balance :: Maybe Money
          -- ^ Represents the sum of all credits less all debits 
          --   associated with the account. Might be positive, zero or 
          --   negative.
        , account_coverage :: [Account'Coverage]
          -- ^ The party(s) that are responsible for covering the payment 
          --   of this account, and what order should they be applied to 
          --   the account.
        , account_owner :: Maybe Reference
          -- ^ Indicates the organization, department, etc. with 
          --   responsibility for the account.
        , account_description :: Maybe Xsd.XsdString
          -- ^ Provides additional information about what the account 
          --   tracks and how it is used.
        , account_guarantor :: [Account'Guarantor]
          -- ^ Parties financially responsible for the account.
        }
        deriving (Eq,Show)
instance SchemaType Account where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Account
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "balance")
            `apply` many (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "owner")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "guarantor")
    schemaTypeToXML s x@Account{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ account_id x
            , maybe [] (schemaTypeToXML "meta") $ account_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ account_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ account_language x
            , maybe [] (schemaTypeToXML "text") $ account_text x
            , concatMap (schemaTypeToXML "contained") $ account_contained x
            , concatMap (schemaTypeToXML "extension") $ account_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ account_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ account_identifier x
            , maybe [] (schemaTypeToXML "status") $ account_status x
            , maybe [] (schemaTypeToXML "type") $ account_type x
            , maybe [] (schemaTypeToXML "name") $ account_name x
            , maybe [] (schemaTypeToXML "subject") $ account_subject x
            , maybe [] (schemaTypeToXML "period") $ account_period x
            , maybe [] (schemaTypeToXML "active") $ account_active x
            , maybe [] (schemaTypeToXML "balance") $ account_balance x
            , concatMap (schemaTypeToXML "coverage") $ account_coverage x
            , maybe [] (schemaTypeToXML "owner") $ account_owner x
            , maybe [] (schemaTypeToXML "description") $ account_description x
            , concatMap (schemaTypeToXML "guarantor") $ account_guarantor x
            ]
instance Extension Account DomainResource where
    supertype (Account e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Account Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Account -> DomainResource)
              
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
data Account'Coverage = Account'Coverage
        { account'Coverage_id :: Maybe String'primitive
        , account'Coverage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , account'Coverage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , account'Coverage_coverage :: Reference
          -- ^ The party(s) that are responsible for payment (or part of) 
          --   of charges applied to this account (including self-pay). A 
          --   coverage may only be resposible for specific types of 
          --   charges, and the sequence of the coverages in the account 
          --   could be important when processing billing.
        , account'Coverage_priority :: Maybe PositiveInt
          -- ^ The priority of the coverage in the context of this 
          --   account.
        }
        deriving (Eq,Show)
instance SchemaType Account'Coverage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Account'Coverage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "priority")
    schemaTypeToXML s x@Account'Coverage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ account'Coverage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ account'Coverage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ account'Coverage_modifierExtension x
            , schemaTypeToXML "coverage" $ account'Coverage_coverage x
            , maybe [] (schemaTypeToXML "priority") $ account'Coverage_priority x
            ]
instance Extension Account'Coverage BackboneElement where
    supertype (Account'Coverage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Account'Coverage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Account'Coverage -> BackboneElement)
              
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
data Account'Guarantor = Account'Guarantor
        { account'Guarantor_id :: Maybe String'primitive
        , account'Guarantor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , account'Guarantor_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , account'Guarantor_party :: Reference
          -- ^ The entity who is responsible.
        , account'Guarantor_onHold :: Maybe Boolean
          -- ^ A guarantor may be placed on credit hold or otherwise have 
          --   their role temporarily suspended.
        , account'Guarantor_period :: Maybe Period
          -- ^ The timeframe during which the guarantor accepts 
          --   responsibility for the account.
        }
        deriving (Eq,Show)
instance SchemaType Account'Guarantor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Account'Guarantor a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "party"
            `apply` optional (parseSchemaType "onHold")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Account'Guarantor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ account'Guarantor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ account'Guarantor_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ account'Guarantor_modifierExtension x
            , schemaTypeToXML "party" $ account'Guarantor_party x
            , maybe [] (schemaTypeToXML "onHold") $ account'Guarantor_onHold x
            , maybe [] (schemaTypeToXML "period") $ account'Guarantor_period x
            ]
instance Extension Account'Guarantor BackboneElement where
    supertype (Account'Guarantor a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Account'Guarantor Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Account'Guarantor -> BackboneElement)
              
 
data AccountStatus'list
    = AccountStatus'list_Active
      -- ^ Active
    | AccountStatus'list_Inactive
      -- ^ Inactive
    | AccountStatus'list_Entered'in'error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType AccountStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AccountStatus'list where
    acceptingParser =  do literal "active"; return AccountStatus'list_Active
                      `onFail` do literal "inactive"; return AccountStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return AccountStatus'list_Entered'in'error
                      
    simpleTypeText AccountStatus'list_Active = "active"
    simpleTypeText AccountStatus'list_Inactive = "inactive"
    simpleTypeText AccountStatus'list_Entered'in'error = "entered-in-error"
 
data AccountStatus = AccountStatus
        { accountStatus_id :: Maybe String'primitive
        , accountStatus_value :: Maybe AccountStatus'list
        , accountStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AccountStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AccountStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AccountStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ accountStatus_id x
                       , maybe [] (toXMLAttribute "value") $ accountStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ accountStatus_extension x
            ]
instance Extension AccountStatus Element where
    supertype (AccountStatus a0 a1 e0) =
               Element a0 e0
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
elementActivityDefinition :: XMLParser ActivityDefinition
elementActivityDefinition = parseSchemaType "ActivityDefinition"
elementToXMLActivityDefinition :: ActivityDefinition -> [Content ()]
elementToXMLActivityDefinition = schemaTypeToXML "ActivityDefinition"
 
data ActivityDefinition = ActivityDefinition
        { activityDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , activityDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , activityDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , activityDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , activityDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , activityDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , activityDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this activity 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   activity definition is (or will be) published. The URL 
          --   SHOULD include the major version of the activity 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , activityDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this activity 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , activityDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   activity definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the activity definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence. To 
          --   provide a version consistent with the Decision Support 
          --   Service specification, use the format Major.Minor.Revision 
          --   (e.g. 1.0.0). For more information on versioning knowledge 
          --   assets, refer to the Decision Support Service 
          --   specification. Note that a version is required for 
          --   non-experimental active assets.
        , activityDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the activity 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , activityDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the activity 
          --   definition.
        , activityDefinition_status :: PublicationStatus
          -- ^ The status of this activity definition. Enables tracking 
          --   the life-cycle of the content.
        , activityDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this activity definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , activityDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the activity definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the activity definition changes.
        , activityDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the activity definition.
        , activityDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the activity 
          --   definition from a consumer's perspective.
        , activityDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this activity definition is needed and 
          --   why it has been designed as it has.
        , activityDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the asset is used from a 
          --   clinical perspective.
        , activityDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , activityDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , activityDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the activity definition content was 
          --   or is planned to be in active use.
        , activityDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   activity definition instances.
        , activityDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the activity 
          --   definition is intended to be used.
        , activityDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the activity. 
          --   Topics provide a high-level categorization of the activity 
          --   that can be useful for filtering and searching.
        , activityDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the asset, including 
          --   authors, editors, reviewers, and endorsers.
        , activityDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , activityDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the activity definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   activity definition.
        , activityDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , activityDefinition_library :: [Reference]
          -- ^ A reference to a Library resource containing any formal 
          --   logic used by the asset.
        , activityDefinition_kind :: Maybe ResourceType
          -- ^ A description of the kind of resource the activity 
          --   definition is representing. For example, a 
          --   MedicationRequest, a ProcedureRequest, or a 
          --   CommunicationRequest. Typically, but not always, this is a 
          --   Request resource.
        , activityDefinition_code :: Maybe CodeableConcept
          -- ^ Detailed description of the type of activity; e.g. What lab 
          --   test, what procedure, what kind of encounter.
        , activityDefinition_choice33 :: (Maybe (OneOf4 Timing DateTime Period Range))
          -- ^ The period, timing or frequency upon which the described 
          --   activity is to occur.
          --   
          --   Choice between:
          --   
          --   (1) timingTiming
          --   
          --   (2) timingDateTime
          --   
          --   (3) timingPeriod
          --   
          --   (4) timingRange
        , activityDefinition_location :: Maybe Reference
          -- ^ Identifies the facility where the activity will occur; e.g. 
          --   home, hospital, specific clinic, etc.
        , activityDefinition_participant :: [ActivityDefinition'Participant]
          -- ^ Indicates who should participate in performing the action 
          --   described.
        , activityDefinition_choice36 :: (Maybe (OneOf2 Reference CodeableConcept))
          -- ^ Identifies the food, drug or other product being consumed 
          --   or supplied in the activity.
          --   
          --   Choice between:
          --   
          --   (1) productReference
          --   
          --   (2) productCodeableConcept
        , activityDefinition_quantity :: Maybe Quantity
          -- ^ Identifies the quantity expected to be consumed at once 
          --   (per dose, per meal, etc.).
        , activityDefinition_dosage :: [Dosage]
          -- ^ Provides detailed dosage instructions in the same way that 
          --   they are described for MedicationRequest resources.
        , activityDefinition_bodySite :: [CodeableConcept]
          -- ^ Indicates the sites on the subject's body where the 
          --   procedure should be performed (I.e. the target sites).
        , activityDefinition_transform :: Maybe Reference
          -- ^ A reference to a StructureMap resource that defines a 
          --   transform that can be executed to produce the intent 
          --   resource using the ActivityDefinition instance as the 
          --   input.
        , activityDefinition_dynamicValue :: [ActivityDefinition'DynamicValue]
          -- ^ Dynamic values that will be evaluated to produce values for 
          --   elements of the resulting resource. For example, if the 
          --   dosage of a medication must be computed based on the 
          --   patient's weight, a dynamic value would be used to specify 
          --   an expression that calculated the weight, and the path on 
          --   the intent resource that would contain the result.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ActivityDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` optional (parseSchemaType "kind")
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf4 (parseSchemaType "timingTiming"))
                                     , ("DateTime", fmap TwoOf4 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap ThreeOf4 (parseSchemaType "timingPeriod"))
                                     , ("Range", fmap FourOf4 (parseSchemaType "timingRange"))
                                     ])
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "participant")
            `apply` optional (oneOf' [ ("Reference", fmap OneOf2 (parseSchemaType "productReference"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "productCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "dosage")
            `apply` many (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "dynamicValue")
    schemaTypeToXML s x@ActivityDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ activityDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ activityDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ activityDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ activityDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ activityDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ activityDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ activityDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ activityDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ activityDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ activityDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ activityDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ activityDefinition_title x
            , schemaTypeToXML "status" $ activityDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ activityDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ activityDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ activityDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ activityDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ activityDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ activityDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ activityDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ activityDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ activityDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ activityDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ activityDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ activityDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ activityDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ activityDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ activityDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ activityDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ activityDefinition_library x
            , maybe [] (schemaTypeToXML "kind") $ activityDefinition_kind x
            , maybe [] (schemaTypeToXML "code") $ activityDefinition_code x
            , maybe [] (foldOneOf4  (schemaTypeToXML "timingTiming")
                                    (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingRange")
                                   ) $ activityDefinition_choice33 x
            , maybe [] (schemaTypeToXML "location") $ activityDefinition_location x
            , concatMap (schemaTypeToXML "participant") $ activityDefinition_participant x
            , maybe [] (foldOneOf2  (schemaTypeToXML "productReference")
                                    (schemaTypeToXML "productCodeableConcept")
                                   ) $ activityDefinition_choice36 x
            , maybe [] (schemaTypeToXML "quantity") $ activityDefinition_quantity x
            , concatMap (schemaTypeToXML "dosage") $ activityDefinition_dosage x
            , concatMap (schemaTypeToXML "bodySite") $ activityDefinition_bodySite x
            , maybe [] (schemaTypeToXML "transform") $ activityDefinition_transform x
            , concatMap (schemaTypeToXML "dynamicValue") $ activityDefinition_dynamicValue x
            ]
instance Extension ActivityDefinition DomainResource where
    supertype (ActivityDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ActivityDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ActivityDefinition -> DomainResource)
              
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
data ActivityDefinition'Participant = ActivityDefinition'Participant
        { activityDefinition'Participant_id :: Maybe String'primitive
        , activityDefinition'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinition'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinition'Participant_type :: ActionParticipantType
          -- ^ The type of participant in the action.
        , activityDefinition'Participant_role :: Maybe CodeableConcept
          -- ^ The role the participant should play in performing the 
          --   described action.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinition'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ActivityDefinition'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "role")
    schemaTypeToXML s x@ActivityDefinition'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ activityDefinition'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ activityDefinition'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinition'Participant_modifierExtension x
            , schemaTypeToXML "type" $ activityDefinition'Participant_type x
            , maybe [] (schemaTypeToXML "role") $ activityDefinition'Participant_role x
            ]
instance Extension ActivityDefinition'Participant BackboneElement where
    supertype (ActivityDefinition'Participant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ActivityDefinition'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ActivityDefinition'Participant -> BackboneElement)
              
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
data ActivityDefinition'DynamicValue = ActivityDefinition'DynamicValue
        { activityDefinition'DynamicValue_id :: Maybe String'primitive
        , activityDefinition'DynamicValue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinition'DynamicValue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinition'DynamicValue_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the intended 
          --   semantics of the dynamic value.
        , activityDefinition'DynamicValue_path :: Maybe Xsd.XsdString
          -- ^ The path to the element to be customized. This is the path 
          --   on the resource that will hold the result of the 
          --   calculation defined by the expression.
        , activityDefinition'DynamicValue_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , activityDefinition'DynamicValue_expression :: Maybe Xsd.XsdString
          -- ^ An expression specifying the value of the customized 
          --   element.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinition'DynamicValue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ActivityDefinition'DynamicValue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@ActivityDefinition'DynamicValue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ activityDefinition'DynamicValue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ activityDefinition'DynamicValue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinition'DynamicValue_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ activityDefinition'DynamicValue_description x
            , maybe [] (schemaTypeToXML "path") $ activityDefinition'DynamicValue_path x
            , maybe [] (schemaTypeToXML "language") $ activityDefinition'DynamicValue_language x
            , maybe [] (schemaTypeToXML "expression") $ activityDefinition'DynamicValue_expression x
            ]
instance Extension ActivityDefinition'DynamicValue BackboneElement where
    supertype (ActivityDefinition'DynamicValue a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ActivityDefinition'DynamicValue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ActivityDefinition'DynamicValue -> BackboneElement)
              
 
data ActionParticipantType'list
    = ActionParticipantType'list_Patient
      -- ^ Patient
    | ActionParticipantType'list_Practitioner
      -- ^ Practitioner
    | ActionParticipantType'list_Related'person
      -- ^ Related Person
    deriving (Eq,Show,Enum)
instance SchemaType ActionParticipantType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionParticipantType'list where
    acceptingParser =  do literal "patient"; return ActionParticipantType'list_Patient
                      `onFail` do literal "practitioner"; return ActionParticipantType'list_Practitioner
                      `onFail` do literal "related-person"; return ActionParticipantType'list_Related'person
                      
    simpleTypeText ActionParticipantType'list_Patient = "patient"
    simpleTypeText ActionParticipantType'list_Practitioner = "practitioner"
    simpleTypeText ActionParticipantType'list_Related'person = "related-person"
 
data ActionParticipantType = ActionParticipantType
        { actionParticipantType_id :: Maybe String'primitive
        , actionParticipantType_value :: Maybe ActionParticipantType'list
        , actionParticipantType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionParticipantType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionParticipantType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionParticipantType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionParticipantType_id x
                       , maybe [] (toXMLAttribute "value") $ actionParticipantType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionParticipantType_extension x
            ]
instance Extension ActionParticipantType Element where
    supertype (ActionParticipantType a0 a1 e0) =
               Element a0 e0
 
data ResourceType'list
    = ResourceType'list_Account
      -- ^ Account
    | ResourceType'list_ActivityDefinition
      -- ^ ActivityDefinition
    | ResourceType'list_AdverseEvent
      -- ^ AdverseEvent
    | ResourceType'list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | ResourceType'list_Appointment
      -- ^ Appointment
    | ResourceType'list_AppointmentResponse
      -- ^ AppointmentResponse
    | ResourceType'list_AuditEvent
      -- ^ AuditEvent
    | ResourceType'list_Basic
      -- ^ Basic
    | ResourceType'list_Binary
      -- ^ Binary
    | ResourceType'list_BodySite
      -- ^ BodySite
    | ResourceType'list_Bundle
      -- ^ Bundle
    | ResourceType'list_CapabilityStatement
      -- ^ CapabilityStatement
    | ResourceType'list_CarePlan
      -- ^ CarePlan
    | ResourceType'list_CareTeam
      -- ^ CareTeam
    | ResourceType'list_ChargeItem
      -- ^ ChargeItem
    | ResourceType'list_Claim
      -- ^ Claim
    | ResourceType'list_ClaimResponse
      -- ^ ClaimResponse
    | ResourceType'list_ClinicalImpression
      -- ^ ClinicalImpression
    | ResourceType'list_CodeSystem
      -- ^ CodeSystem
    | ResourceType'list_Communication
      -- ^ Communication
    | ResourceType'list_CommunicationRequest
      -- ^ CommunicationRequest
    | ResourceType'list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | ResourceType'list_Composition
      -- ^ Composition
    | ResourceType'list_ConceptMap
      -- ^ ConceptMap
    | ResourceType'list_Condition
      -- ^ Condition
    | ResourceType'list_Consent
      -- ^ Consent
    | ResourceType'list_Contract
      -- ^ Contract
    | ResourceType'list_Coverage
      -- ^ Coverage
    | ResourceType'list_DataElement
      -- ^ DataElement
    | ResourceType'list_DetectedIssue
      -- ^ DetectedIssue
    | ResourceType'list_Device
      -- ^ Device
    | ResourceType'list_DeviceComponent
      -- ^ DeviceComponent
    | ResourceType'list_DeviceMetric
      -- ^ DeviceMetric
    | ResourceType'list_DeviceRequest
      -- ^ DeviceRequest
    | ResourceType'list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | ResourceType'list_DiagnosticReport
      -- ^ DiagnosticReport
    | ResourceType'list_DocumentManifest
      -- ^ DocumentManifest
    | ResourceType'list_DocumentReference
      -- ^ DocumentReference
    | ResourceType'list_DomainResource
      -- ^ DomainResource
    | ResourceType'list_EligibilityRequest
      -- ^ EligibilityRequest
    | ResourceType'list_EligibilityResponse
      -- ^ EligibilityResponse
    | ResourceType'list_Encounter
      -- ^ Encounter
    | ResourceType'list_Endpoint
      -- ^ Endpoint
    | ResourceType'list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | ResourceType'list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | ResourceType'list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | ResourceType'list_ExpansionProfile
      -- ^ ExpansionProfile
    | ResourceType'list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | ResourceType'list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | ResourceType'list_Flag
      -- ^ Flag
    | ResourceType'list_Goal
      -- ^ Goal
    | ResourceType'list_GraphDefinition
      -- ^ GraphDefinition
    | ResourceType'list_Group
      -- ^ Group
    | ResourceType'list_GuidanceResponse
      -- ^ GuidanceResponse
    | ResourceType'list_HealthcareService
      -- ^ HealthcareService
    | ResourceType'list_ImagingManifest
      -- ^ ImagingManifest
    | ResourceType'list_ImagingStudy
      -- ^ ImagingStudy
    | ResourceType'list_Immunization
      -- ^ Immunization
    | ResourceType'list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | ResourceType'list_ImplementationGuide
      -- ^ ImplementationGuide
    | ResourceType'list_Library
      -- ^ Library
    | ResourceType'list_Linkage
      -- ^ Linkage
    | ResourceType'list_List
      -- ^ List
    | ResourceType'list_Location
      -- ^ Location
    | ResourceType'list_Measure
      -- ^ Measure
    | ResourceType'list_MeasureReport
      -- ^ MeasureReport
    | ResourceType'list_Media
      -- ^ Media
    | ResourceType'list_Medication
      -- ^ Medication
    | ResourceType'list_MedicationAdministration
      -- ^ MedicationAdministration
    | ResourceType'list_MedicationDispense
      -- ^ MedicationDispense
    | ResourceType'list_MedicationRequest
      -- ^ MedicationRequest
    | ResourceType'list_MedicationStatement
      -- ^ MedicationStatement
    | ResourceType'list_MessageDefinition
      -- ^ MessageDefinition
    | ResourceType'list_MessageHeader
      -- ^ MessageHeader
    | ResourceType'list_NamingSystem
      -- ^ NamingSystem
    | ResourceType'list_NutritionOrder
      -- ^ NutritionOrder
    | ResourceType'list_Observation
      -- ^ Observation
    | ResourceType'list_OperationDefinition
      -- ^ OperationDefinition
    | ResourceType'list_OperationOutcome
      -- ^ OperationOutcome
    | ResourceType'list_Organization
      -- ^ Organization
    | ResourceType'list_Parameters
      -- ^ Parameters
    | ResourceType'list_Patient
      -- ^ Patient
    | ResourceType'list_PaymentNotice
      -- ^ PaymentNotice
    | ResourceType'list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | ResourceType'list_Person
      -- ^ Person
    | ResourceType'list_PlanDefinition
      -- ^ PlanDefinition
    | ResourceType'list_Practitioner
      -- ^ Practitioner
    | ResourceType'list_PractitionerRole
      -- ^ PractitionerRole
    | ResourceType'list_Procedure
      -- ^ Procedure
    | ResourceType'list_ProcedureRequest
      -- ^ ProcedureRequest
    | ResourceType'list_ProcessRequest
      -- ^ ProcessRequest
    | ResourceType'list_ProcessResponse
      -- ^ ProcessResponse
    | ResourceType'list_Provenance
      -- ^ Provenance
    | ResourceType'list_Questionnaire
      -- ^ Questionnaire
    | ResourceType'list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | ResourceType'list_ReferralRequest
      -- ^ ReferralRequest
    | ResourceType'list_RelatedPerson
      -- ^ RelatedPerson
    | ResourceType'list_RequestGroup
      -- ^ RequestGroup
    | ResourceType'list_ResearchStudy
      -- ^ ResearchStudy
    | ResourceType'list_ResearchSubject
      -- ^ ResearchSubject
    | ResourceType'list_Resource
      -- ^ Resource
    | ResourceType'list_RiskAssessment
      -- ^ RiskAssessment
    | ResourceType'list_Schedule
      -- ^ Schedule
    | ResourceType'list_SearchParameter
      -- ^ SearchParameter
    | ResourceType'list_Sequence
      -- ^ Sequence
    | ResourceType'list_ServiceDefinition
      -- ^ ServiceDefinition
    | ResourceType'list_Slot
      -- ^ Slot
    | ResourceType'list_Specimen
      -- ^ Specimen
    | ResourceType'list_StructureDefinition
      -- ^ StructureDefinition
    | ResourceType'list_StructureMap
      -- ^ StructureMap
    | ResourceType'list_Subscription
      -- ^ Subscription
    | ResourceType'list_Substance
      -- ^ Substance
    | ResourceType'list_SupplyDelivery
      -- ^ SupplyDelivery
    | ResourceType'list_SupplyRequest
      -- ^ SupplyRequest
    | ResourceType'list_Task
      -- ^ Task
    | ResourceType'list_TestReport
      -- ^ TestReport
    | ResourceType'list_TestScript
      -- ^ TestScript
    | ResourceType'list_ValueSet
      -- ^ ValueSet
    | ResourceType'list_VisionPrescription
      -- ^ VisionPrescription
    deriving (Eq,Show,Enum)
instance SchemaType ResourceType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResourceType'list where
    acceptingParser =  do literal "Account"; return ResourceType'list_Account
                      `onFail` do literal "ActivityDefinition"; return ResourceType'list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return ResourceType'list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return ResourceType'list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return ResourceType'list_Appointment
                      `onFail` do literal "AppointmentResponse"; return ResourceType'list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return ResourceType'list_AuditEvent
                      `onFail` do literal "Basic"; return ResourceType'list_Basic
                      `onFail` do literal "Binary"; return ResourceType'list_Binary
                      `onFail` do literal "BodySite"; return ResourceType'list_BodySite
                      `onFail` do literal "Bundle"; return ResourceType'list_Bundle
                      `onFail` do literal "CapabilityStatement"; return ResourceType'list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return ResourceType'list_CarePlan
                      `onFail` do literal "CareTeam"; return ResourceType'list_CareTeam
                      `onFail` do literal "ChargeItem"; return ResourceType'list_ChargeItem
                      `onFail` do literal "Claim"; return ResourceType'list_Claim
                      `onFail` do literal "ClaimResponse"; return ResourceType'list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return ResourceType'list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return ResourceType'list_CodeSystem
                      `onFail` do literal "Communication"; return ResourceType'list_Communication
                      `onFail` do literal "CommunicationRequest"; return ResourceType'list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return ResourceType'list_CompartmentDefinition
                      `onFail` do literal "Composition"; return ResourceType'list_Composition
                      `onFail` do literal "ConceptMap"; return ResourceType'list_ConceptMap
                      `onFail` do literal "Condition"; return ResourceType'list_Condition
                      `onFail` do literal "Consent"; return ResourceType'list_Consent
                      `onFail` do literal "Contract"; return ResourceType'list_Contract
                      `onFail` do literal "Coverage"; return ResourceType'list_Coverage
                      `onFail` do literal "DataElement"; return ResourceType'list_DataElement
                      `onFail` do literal "DetectedIssue"; return ResourceType'list_DetectedIssue
                      `onFail` do literal "Device"; return ResourceType'list_Device
                      `onFail` do literal "DeviceComponent"; return ResourceType'list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return ResourceType'list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return ResourceType'list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return ResourceType'list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return ResourceType'list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return ResourceType'list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return ResourceType'list_DocumentReference
                      `onFail` do literal "DomainResource"; return ResourceType'list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return ResourceType'list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return ResourceType'list_EligibilityResponse
                      `onFail` do literal "Encounter"; return ResourceType'list_Encounter
                      `onFail` do literal "Endpoint"; return ResourceType'list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return ResourceType'list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return ResourceType'list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return ResourceType'list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return ResourceType'list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return ResourceType'list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return ResourceType'list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return ResourceType'list_Flag
                      `onFail` do literal "Goal"; return ResourceType'list_Goal
                      `onFail` do literal "GraphDefinition"; return ResourceType'list_GraphDefinition
                      `onFail` do literal "Group"; return ResourceType'list_Group
                      `onFail` do literal "GuidanceResponse"; return ResourceType'list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return ResourceType'list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return ResourceType'list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return ResourceType'list_ImagingStudy
                      `onFail` do literal "Immunization"; return ResourceType'list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return ResourceType'list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return ResourceType'list_ImplementationGuide
                      `onFail` do literal "Library"; return ResourceType'list_Library
                      `onFail` do literal "Linkage"; return ResourceType'list_Linkage
                      `onFail` do literal "List"; return ResourceType'list_List
                      `onFail` do literal "Location"; return ResourceType'list_Location
                      `onFail` do literal "Measure"; return ResourceType'list_Measure
                      `onFail` do literal "MeasureReport"; return ResourceType'list_MeasureReport
                      `onFail` do literal "Media"; return ResourceType'list_Media
                      `onFail` do literal "Medication"; return ResourceType'list_Medication
                      `onFail` do literal "MedicationAdministration"; return ResourceType'list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return ResourceType'list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return ResourceType'list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return ResourceType'list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return ResourceType'list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return ResourceType'list_MessageHeader
                      `onFail` do literal "NamingSystem"; return ResourceType'list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return ResourceType'list_NutritionOrder
                      `onFail` do literal "Observation"; return ResourceType'list_Observation
                      `onFail` do literal "OperationDefinition"; return ResourceType'list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return ResourceType'list_OperationOutcome
                      `onFail` do literal "Organization"; return ResourceType'list_Organization
                      `onFail` do literal "Parameters"; return ResourceType'list_Parameters
                      `onFail` do literal "Patient"; return ResourceType'list_Patient
                      `onFail` do literal "PaymentNotice"; return ResourceType'list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return ResourceType'list_PaymentReconciliation
                      `onFail` do literal "Person"; return ResourceType'list_Person
                      `onFail` do literal "PlanDefinition"; return ResourceType'list_PlanDefinition
                      `onFail` do literal "Practitioner"; return ResourceType'list_Practitioner
                      `onFail` do literal "PractitionerRole"; return ResourceType'list_PractitionerRole
                      `onFail` do literal "Procedure"; return ResourceType'list_Procedure
                      `onFail` do literal "ProcedureRequest"; return ResourceType'list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return ResourceType'list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return ResourceType'list_ProcessResponse
                      `onFail` do literal "Provenance"; return ResourceType'list_Provenance
                      `onFail` do literal "Questionnaire"; return ResourceType'list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return ResourceType'list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return ResourceType'list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return ResourceType'list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return ResourceType'list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return ResourceType'list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return ResourceType'list_ResearchSubject
                      `onFail` do literal "Resource"; return ResourceType'list_Resource
                      `onFail` do literal "RiskAssessment"; return ResourceType'list_RiskAssessment
                      `onFail` do literal "Schedule"; return ResourceType'list_Schedule
                      `onFail` do literal "SearchParameter"; return ResourceType'list_SearchParameter
                      `onFail` do literal "Sequence"; return ResourceType'list_Sequence
                      `onFail` do literal "ServiceDefinition"; return ResourceType'list_ServiceDefinition
                      `onFail` do literal "Slot"; return ResourceType'list_Slot
                      `onFail` do literal "Specimen"; return ResourceType'list_Specimen
                      `onFail` do literal "StructureDefinition"; return ResourceType'list_StructureDefinition
                      `onFail` do literal "StructureMap"; return ResourceType'list_StructureMap
                      `onFail` do literal "Subscription"; return ResourceType'list_Subscription
                      `onFail` do literal "Substance"; return ResourceType'list_Substance
                      `onFail` do literal "SupplyDelivery"; return ResourceType'list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return ResourceType'list_SupplyRequest
                      `onFail` do literal "Task"; return ResourceType'list_Task
                      `onFail` do literal "TestReport"; return ResourceType'list_TestReport
                      `onFail` do literal "TestScript"; return ResourceType'list_TestScript
                      `onFail` do literal "ValueSet"; return ResourceType'list_ValueSet
                      `onFail` do literal "VisionPrescription"; return ResourceType'list_VisionPrescription
                      
    simpleTypeText ResourceType'list_Account = "Account"
    simpleTypeText ResourceType'list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText ResourceType'list_AdverseEvent = "AdverseEvent"
    simpleTypeText ResourceType'list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText ResourceType'list_Appointment = "Appointment"
    simpleTypeText ResourceType'list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText ResourceType'list_AuditEvent = "AuditEvent"
    simpleTypeText ResourceType'list_Basic = "Basic"
    simpleTypeText ResourceType'list_Binary = "Binary"
    simpleTypeText ResourceType'list_BodySite = "BodySite"
    simpleTypeText ResourceType'list_Bundle = "Bundle"
    simpleTypeText ResourceType'list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText ResourceType'list_CarePlan = "CarePlan"
    simpleTypeText ResourceType'list_CareTeam = "CareTeam"
    simpleTypeText ResourceType'list_ChargeItem = "ChargeItem"
    simpleTypeText ResourceType'list_Claim = "Claim"
    simpleTypeText ResourceType'list_ClaimResponse = "ClaimResponse"
    simpleTypeText ResourceType'list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText ResourceType'list_CodeSystem = "CodeSystem"
    simpleTypeText ResourceType'list_Communication = "Communication"
    simpleTypeText ResourceType'list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText ResourceType'list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText ResourceType'list_Composition = "Composition"
    simpleTypeText ResourceType'list_ConceptMap = "ConceptMap"
    simpleTypeText ResourceType'list_Condition = "Condition"
    simpleTypeText ResourceType'list_Consent = "Consent"
    simpleTypeText ResourceType'list_Contract = "Contract"
    simpleTypeText ResourceType'list_Coverage = "Coverage"
    simpleTypeText ResourceType'list_DataElement = "DataElement"
    simpleTypeText ResourceType'list_DetectedIssue = "DetectedIssue"
    simpleTypeText ResourceType'list_Device = "Device"
    simpleTypeText ResourceType'list_DeviceComponent = "DeviceComponent"
    simpleTypeText ResourceType'list_DeviceMetric = "DeviceMetric"
    simpleTypeText ResourceType'list_DeviceRequest = "DeviceRequest"
    simpleTypeText ResourceType'list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText ResourceType'list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText ResourceType'list_DocumentManifest = "DocumentManifest"
    simpleTypeText ResourceType'list_DocumentReference = "DocumentReference"
    simpleTypeText ResourceType'list_DomainResource = "DomainResource"
    simpleTypeText ResourceType'list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText ResourceType'list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText ResourceType'list_Encounter = "Encounter"
    simpleTypeText ResourceType'list_Endpoint = "Endpoint"
    simpleTypeText ResourceType'list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText ResourceType'list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText ResourceType'list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText ResourceType'list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText ResourceType'list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText ResourceType'list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText ResourceType'list_Flag = "Flag"
    simpleTypeText ResourceType'list_Goal = "Goal"
    simpleTypeText ResourceType'list_GraphDefinition = "GraphDefinition"
    simpleTypeText ResourceType'list_Group = "Group"
    simpleTypeText ResourceType'list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText ResourceType'list_HealthcareService = "HealthcareService"
    simpleTypeText ResourceType'list_ImagingManifest = "ImagingManifest"
    simpleTypeText ResourceType'list_ImagingStudy = "ImagingStudy"
    simpleTypeText ResourceType'list_Immunization = "Immunization"
    simpleTypeText ResourceType'list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText ResourceType'list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText ResourceType'list_Library = "Library"
    simpleTypeText ResourceType'list_Linkage = "Linkage"
    simpleTypeText ResourceType'list_List = "List"
    simpleTypeText ResourceType'list_Location = "Location"
    simpleTypeText ResourceType'list_Measure = "Measure"
    simpleTypeText ResourceType'list_MeasureReport = "MeasureReport"
    simpleTypeText ResourceType'list_Media = "Media"
    simpleTypeText ResourceType'list_Medication = "Medication"
    simpleTypeText ResourceType'list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText ResourceType'list_MedicationDispense = "MedicationDispense"
    simpleTypeText ResourceType'list_MedicationRequest = "MedicationRequest"
    simpleTypeText ResourceType'list_MedicationStatement = "MedicationStatement"
    simpleTypeText ResourceType'list_MessageDefinition = "MessageDefinition"
    simpleTypeText ResourceType'list_MessageHeader = "MessageHeader"
    simpleTypeText ResourceType'list_NamingSystem = "NamingSystem"
    simpleTypeText ResourceType'list_NutritionOrder = "NutritionOrder"
    simpleTypeText ResourceType'list_Observation = "Observation"
    simpleTypeText ResourceType'list_OperationDefinition = "OperationDefinition"
    simpleTypeText ResourceType'list_OperationOutcome = "OperationOutcome"
    simpleTypeText ResourceType'list_Organization = "Organization"
    simpleTypeText ResourceType'list_Parameters = "Parameters"
    simpleTypeText ResourceType'list_Patient = "Patient"
    simpleTypeText ResourceType'list_PaymentNotice = "PaymentNotice"
    simpleTypeText ResourceType'list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText ResourceType'list_Person = "Person"
    simpleTypeText ResourceType'list_PlanDefinition = "PlanDefinition"
    simpleTypeText ResourceType'list_Practitioner = "Practitioner"
    simpleTypeText ResourceType'list_PractitionerRole = "PractitionerRole"
    simpleTypeText ResourceType'list_Procedure = "Procedure"
    simpleTypeText ResourceType'list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText ResourceType'list_ProcessRequest = "ProcessRequest"
    simpleTypeText ResourceType'list_ProcessResponse = "ProcessResponse"
    simpleTypeText ResourceType'list_Provenance = "Provenance"
    simpleTypeText ResourceType'list_Questionnaire = "Questionnaire"
    simpleTypeText ResourceType'list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText ResourceType'list_ReferralRequest = "ReferralRequest"
    simpleTypeText ResourceType'list_RelatedPerson = "RelatedPerson"
    simpleTypeText ResourceType'list_RequestGroup = "RequestGroup"
    simpleTypeText ResourceType'list_ResearchStudy = "ResearchStudy"
    simpleTypeText ResourceType'list_ResearchSubject = "ResearchSubject"
    simpleTypeText ResourceType'list_Resource = "Resource"
    simpleTypeText ResourceType'list_RiskAssessment = "RiskAssessment"
    simpleTypeText ResourceType'list_Schedule = "Schedule"
    simpleTypeText ResourceType'list_SearchParameter = "SearchParameter"
    simpleTypeText ResourceType'list_Sequence = "Sequence"
    simpleTypeText ResourceType'list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText ResourceType'list_Slot = "Slot"
    simpleTypeText ResourceType'list_Specimen = "Specimen"
    simpleTypeText ResourceType'list_StructureDefinition = "StructureDefinition"
    simpleTypeText ResourceType'list_StructureMap = "StructureMap"
    simpleTypeText ResourceType'list_Subscription = "Subscription"
    simpleTypeText ResourceType'list_Substance = "Substance"
    simpleTypeText ResourceType'list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText ResourceType'list_SupplyRequest = "SupplyRequest"
    simpleTypeText ResourceType'list_Task = "Task"
    simpleTypeText ResourceType'list_TestReport = "TestReport"
    simpleTypeText ResourceType'list_TestScript = "TestScript"
    simpleTypeText ResourceType'list_ValueSet = "ValueSet"
    simpleTypeText ResourceType'list_VisionPrescription = "VisionPrescription"
 
data ResourceType = ResourceType
        { resourceType_id :: Maybe String'primitive
        , resourceType_value :: Maybe ResourceType'list
        , resourceType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResourceType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResourceType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResourceType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ resourceType_id x
                       , maybe [] (toXMLAttribute "value") $ resourceType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ resourceType_extension x
            ]
instance Extension ResourceType Element where
    supertype (ResourceType a0 a1 e0) =
               Element a0 e0
 
-- | Actual or potential/avoided event causing unintended 
--   physical injury resulting from or contributed to by medical 
--   care, a research study or other healthcare setting factors 
--   that requires additional monitoring, treatment, or 
--   hospitalization, or that results in death.
elementAdverseEvent :: XMLParser AdverseEvent
elementAdverseEvent = parseSchemaType "AdverseEvent"
elementToXMLAdverseEvent :: AdverseEvent -> [Content ()]
elementToXMLAdverseEvent = schemaTypeToXML "AdverseEvent"
 
data AdverseEvent = AdverseEvent
        { adverseEvent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , adverseEvent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , adverseEvent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , adverseEvent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , adverseEvent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , adverseEvent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , adverseEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , adverseEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , adverseEvent_identifier :: Maybe Identifier
          -- ^ The identifier(s) of this adverse event that are assigned 
          --   by business processes and/or used to refer to it when a 
          --   direct URL reference to the resource itsefl is not 
          --   appropriate.
        , adverseEvent_category :: Maybe AdverseEventCategory
          -- ^ The type of event which is important to characterize what 
          --   occurred and caused harm to the subject, or had the 
          --   potential to cause harm to the subject.
        , adverseEvent_type :: Maybe CodeableConcept
          -- ^ This element defines the specific type of event that 
          --   occurred or that was prevented from occurring.
        , adverseEvent_subject :: Maybe Reference
          -- ^ This subject or group impacted by the event. With a 
          --   prospective adverse event, there will be no subject as the 
          --   adverse event was prevented.
        , adverseEvent_date :: Maybe DateTime
          -- ^ The date (and perhaps time) when the adverse event 
          --   occurred.
        , adverseEvent_reaction :: [Reference]
          -- ^ Includes information about the reaction that occurred as a 
          --   result of exposure to a substance (for example, a drug or a 
          --   chemical).
        , adverseEvent_location :: Maybe Reference
          -- ^ The information about where the adverse event occurred.
        , adverseEvent_seriousness :: Maybe CodeableConcept
          -- ^ Describes the seriousness or severity of the adverse event.
        , adverseEvent_outcome :: Maybe CodeableConcept
          -- ^ Describes the type of outcome from the adverse event.
        , adverseEvent_recorder :: Maybe Reference
          -- ^ Information on who recorded the adverse event. May be the 
          --   patient or a practitioner.
        , adverseEvent_eventParticipant :: Maybe Reference
          -- ^ Parties that may or should contribute or have contributed 
          --   information to the Act. Such information includes 
          --   information leading to the decision to perform the Act and 
          --   how to perform the Act (e.g. consultant), information that 
          --   the Act itself seeks to reveal (e.g. informant of clinical 
          --   history), or information about what Act was performed (e.g. 
          --   informant witness).
        , adverseEvent_description :: Maybe Xsd.XsdString
          -- ^ Describes the adverse event in text.
        , adverseEvent_suspectEntity :: [AdverseEvent'SuspectEntity]
          -- ^ Describes the entity that is suspected to have caused the 
          --   adverse event.
        , adverseEvent_subjectMedicalHistory :: [Reference]
          -- ^ AdverseEvent.subjectMedicalHistory.
        , adverseEvent_referenceDocument :: [Reference]
          -- ^ AdverseEvent.referenceDocument.
        , adverseEvent_study :: [Reference]
          -- ^ AdverseEvent.study.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AdverseEvent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "date")
            `apply` many (parseSchemaType "reaction")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "seriousness")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "recorder")
            `apply` optional (parseSchemaType "eventParticipant")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "suspectEntity")
            `apply` many (parseSchemaType "subjectMedicalHistory")
            `apply` many (parseSchemaType "referenceDocument")
            `apply` many (parseSchemaType "study")
    schemaTypeToXML s x@AdverseEvent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ adverseEvent_id x
            , maybe [] (schemaTypeToXML "meta") $ adverseEvent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ adverseEvent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ adverseEvent_language x
            , maybe [] (schemaTypeToXML "text") $ adverseEvent_text x
            , concatMap (schemaTypeToXML "contained") $ adverseEvent_contained x
            , concatMap (schemaTypeToXML "extension") $ adverseEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ adverseEvent_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ adverseEvent_identifier x
            , maybe [] (schemaTypeToXML "category") $ adverseEvent_category x
            , maybe [] (schemaTypeToXML "type") $ adverseEvent_type x
            , maybe [] (schemaTypeToXML "subject") $ adverseEvent_subject x
            , maybe [] (schemaTypeToXML "date") $ adverseEvent_date x
            , concatMap (schemaTypeToXML "reaction") $ adverseEvent_reaction x
            , maybe [] (schemaTypeToXML "location") $ adverseEvent_location x
            , maybe [] (schemaTypeToXML "seriousness") $ adverseEvent_seriousness x
            , maybe [] (schemaTypeToXML "outcome") $ adverseEvent_outcome x
            , maybe [] (schemaTypeToXML "recorder") $ adverseEvent_recorder x
            , maybe [] (schemaTypeToXML "eventParticipant") $ adverseEvent_eventParticipant x
            , maybe [] (schemaTypeToXML "description") $ adverseEvent_description x
            , concatMap (schemaTypeToXML "suspectEntity") $ adverseEvent_suspectEntity x
            , concatMap (schemaTypeToXML "subjectMedicalHistory") $ adverseEvent_subjectMedicalHistory x
            , concatMap (schemaTypeToXML "referenceDocument") $ adverseEvent_referenceDocument x
            , concatMap (schemaTypeToXML "study") $ adverseEvent_study x
            ]
instance Extension AdverseEvent DomainResource where
    supertype (AdverseEvent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AdverseEvent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AdverseEvent -> DomainResource)
              
 
-- | Actual or potential/avoided event causing unintended 
--   physical injury resulting from or contributed to by medical 
--   care, a research study or other healthcare setting factors 
--   that requires additional monitoring, treatment, or 
--   hospitalization, or that results in death.
data AdverseEvent'SuspectEntity = AdverseEvent'SuspectEntity
        { adverseEvent'SuspectEntity_id :: Maybe String'primitive
        , adverseEvent'SuspectEntity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , adverseEvent'SuspectEntity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , adverseEvent'SuspectEntity_instance :: Reference
          -- ^ Identifies the actual instance of what caused the adverse 
          --   event. May be a substance, medication, medication 
          --   administration, medication statement or a device.
        , adverseEvent'SuspectEntity_causality :: Maybe AdverseEventCausality
          -- ^ causality1 | causality2.
        , adverseEvent'SuspectEntity_causalityAssessment :: Maybe CodeableConcept
          -- ^ assess1 | assess2.
        , adverseEvent'SuspectEntity_causalityProductRelatedness :: Maybe Xsd.XsdString
          -- ^ AdverseEvent.suspectEntity.causalityProductRelatedness.
        , adverseEvent'SuspectEntity_causalityMethod :: Maybe CodeableConcept
          -- ^ method1 | method2.
        , adverseEvent'SuspectEntity_causalityAuthor :: Maybe Reference
          -- ^ AdverseEvent.suspectEntity.causalityAuthor.
        , adverseEvent'SuspectEntity_causalityResult :: Maybe CodeableConcept
          -- ^ result1 | result2.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEvent'SuspectEntity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AdverseEvent'SuspectEntity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "instance"
            `apply` optional (parseSchemaType "causality")
            `apply` optional (parseSchemaType "causalityAssessment")
            `apply` optional (parseSchemaType "causalityProductRelatedness")
            `apply` optional (parseSchemaType "causalityMethod")
            `apply` optional (parseSchemaType "causalityAuthor")
            `apply` optional (parseSchemaType "causalityResult")
    schemaTypeToXML s x@AdverseEvent'SuspectEntity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEvent'SuspectEntity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEvent'SuspectEntity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ adverseEvent'SuspectEntity_modifierExtension x
            , schemaTypeToXML "instance" $ adverseEvent'SuspectEntity_instance x
            , maybe [] (schemaTypeToXML "causality") $ adverseEvent'SuspectEntity_causality x
            , maybe [] (schemaTypeToXML "causalityAssessment") $ adverseEvent'SuspectEntity_causalityAssessment x
            , maybe [] (schemaTypeToXML "causalityProductRelatedness") $ adverseEvent'SuspectEntity_causalityProductRelatedness x
            , maybe [] (schemaTypeToXML "causalityMethod") $ adverseEvent'SuspectEntity_causalityMethod x
            , maybe [] (schemaTypeToXML "causalityAuthor") $ adverseEvent'SuspectEntity_causalityAuthor x
            , maybe [] (schemaTypeToXML "causalityResult") $ adverseEvent'SuspectEntity_causalityResult x
            ]
instance Extension AdverseEvent'SuspectEntity BackboneElement where
    supertype (AdverseEvent'SuspectEntity a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension AdverseEvent'SuspectEntity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AdverseEvent'SuspectEntity -> BackboneElement)
              
 
data AdverseEventCausality'list
    = AdverseEventCausality'list_Causality1
      -- ^ causality1 placeholder
    | AdverseEventCausality'list_Causality2
      -- ^ causality2 placeholder
    deriving (Eq,Show,Enum)
instance SchemaType AdverseEventCausality'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdverseEventCausality'list where
    acceptingParser =  do literal "causality1"; return AdverseEventCausality'list_Causality1
                      `onFail` do literal "causality2"; return AdverseEventCausality'list_Causality2
                      
    simpleTypeText AdverseEventCausality'list_Causality1 = "causality1"
    simpleTypeText AdverseEventCausality'list_Causality2 = "causality2"
 
data AdverseEventCausality = AdverseEventCausality
        { adverseEventCausality_id :: Maybe String'primitive
        , adverseEventCausality_value :: Maybe AdverseEventCausality'list
        , adverseEventCausality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEventCausality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdverseEventCausality a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdverseEventCausality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEventCausality_id x
                       , maybe [] (toXMLAttribute "value") $ adverseEventCausality_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEventCausality_extension x
            ]
instance Extension AdverseEventCausality Element where
    supertype (AdverseEventCausality a0 a1 e0) =
               Element a0 e0
 
data AdverseEventCategory'list
    = AdverseEventCategory'list_AE
      -- ^ Adverse Event
    | AdverseEventCategory'list_PAE
      -- ^ Potential Adverse Event
    deriving (Eq,Show,Enum)
instance SchemaType AdverseEventCategory'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdverseEventCategory'list where
    acceptingParser =  do literal "AE"; return AdverseEventCategory'list_AE
                      `onFail` do literal "PAE"; return AdverseEventCategory'list_PAE
                      
    simpleTypeText AdverseEventCategory'list_AE = "AE"
    simpleTypeText AdverseEventCategory'list_PAE = "PAE"
 
data AdverseEventCategory = AdverseEventCategory
        { adverseEventCategory_id :: Maybe String'primitive
        , adverseEventCategory_value :: Maybe AdverseEventCategory'list
        , adverseEventCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEventCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdverseEventCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdverseEventCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEventCategory_id x
                       , maybe [] (toXMLAttribute "value") $ adverseEventCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEventCategory_extension x
            ]
instance Extension AdverseEventCategory Element where
    supertype (AdverseEventCategory a0 a1 e0) =
               Element a0 e0
 
-- | Risk of harmful or undesirable, physiological response 
--   which is unique to an individual and associated with 
--   exposure to a substance.
elementAllergyIntolerance :: XMLParser AllergyIntolerance
elementAllergyIntolerance = parseSchemaType "AllergyIntolerance"
elementToXMLAllergyIntolerance :: AllergyIntolerance -> [Content ()]
elementToXMLAllergyIntolerance = schemaTypeToXML "AllergyIntolerance"
 
data AllergyIntolerance = AllergyIntolerance
        { allergyIntolerance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , allergyIntolerance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , allergyIntolerance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , allergyIntolerance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , allergyIntolerance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , allergyIntolerance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , allergyIntolerance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , allergyIntolerance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , allergyIntolerance_identifier :: [Identifier]
          -- ^ This records identifiers associated with this 
          --   allergy/intolerance concern that are defined by business 
          --   processes and/or used to refer to it when a direct URL 
          --   reference to the resource itself is not appropriate (e.g. 
          --   in CDA documents, or in written / printed documentation).
        , allergyIntolerance_clinicalStatus :: Maybe AllergyIntoleranceClinicalStatus
          -- ^ The clinical status of the allergy or intolerance.
        , allergyIntolerance_verificationStatus :: AllergyIntoleranceVerificationStatus
          -- ^ Assertion about certainty associated with the propensity, 
          --   or potential risk, of a reaction to the identified 
          --   substance (including pharmaceutical product).
        , allergyIntolerance_type :: Maybe AllergyIntoleranceType
          -- ^ Identification of the underlying physiological mechanism 
          --   for the reaction risk.
        , allergyIntolerance_category :: [AllergyIntoleranceCategory]
          -- ^ Category of the identified substance.
        , allergyIntolerance_criticality :: Maybe AllergyIntoleranceCriticality
          -- ^ Estimate of the potential clinical harm, or seriousness, of 
          --   the reaction to the identified substance.
        , allergyIntolerance_code :: Maybe CodeableConcept
          -- ^ Code for an allergy or intolerance statement (either a 
          --   positive or a negated/excluded statement). This may be a 
          --   code for a substance or pharmaceutical product that is 
          --   considered to be responsible for the adverse reaction risk 
          --   (e.g., &quot;Latex&quot;), an allergy or intolerance 
          --   condition (e.g., &quot;Latex allergy&quot;), or a 
          --   negated/excluded code for a specific substance or class 
          --   (e.g., &quot;No latex allergy&quot;) or a general or 
          --   categorical negated statement (e.g., &quot;No known 
          --   allergy&quot;, &quot;No known drug allergies&quot;).
        , allergyIntolerance_patient :: Reference
          -- ^ The patient who has the allergy or intolerance.
        , allergyIntolerance_choice16 :: (Maybe (OneOf5 DateTime Age Period Range Xsd.XsdString))
          -- ^ Estimated or actual date, date-time, or age when allergy or 
          --   intolerance was identified.
          --   
          --   Choice between:
          --   
          --   (1) onsetDateTime
          --   
          --   (2) onsetAge
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetRange
          --   
          --   (5) onsetString
        , allergyIntolerance_assertedDate :: Maybe DateTime
          -- ^ The date on which the existance of the AllergyIntolerance 
          --   was first asserted or acknowledged.
        , allergyIntolerance_recorder :: Maybe Reference
          -- ^ Individual who recorded the record and takes responsibility 
          --   for its content.
        , allergyIntolerance_asserter :: Maybe Reference
          -- ^ The source of the information about the allergy that is 
          --   recorded.
        , allergyIntolerance_lastOccurrence :: Maybe DateTime
          -- ^ Represents the date and/or time of the last known 
          --   occurrence of a reaction event.
        , allergyIntolerance_note :: [Annotation]
          -- ^ Additional narrative about the propensity for the Adverse 
          --   Reaction, not captured in other fields.
        , allergyIntolerance_reaction :: [AllergyIntolerance'Reaction]
          -- ^ Details about each adverse reaction event linked to 
          --   exposure to the identified substance.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntolerance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AllergyIntolerance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "clinicalStatus")
            `apply` parseSchemaType "verificationStatus"
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "criticality")
            `apply` optional (parseSchemaType "code")
            `apply` parseSchemaType "patient"
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "onsetDateTime"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "onsetAge"))
                                     , ("Period", fmap ThreeOf5 (parseSchemaType "onsetPeriod"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "onsetRange"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "onsetString"))
                                     ])
            `apply` optional (parseSchemaType "assertedDate")
            `apply` optional (parseSchemaType "recorder")
            `apply` optional (parseSchemaType "asserter")
            `apply` optional (parseSchemaType "lastOccurrence")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "reaction")
    schemaTypeToXML s x@AllergyIntolerance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ allergyIntolerance_id x
            , maybe [] (schemaTypeToXML "meta") $ allergyIntolerance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ allergyIntolerance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ allergyIntolerance_language x
            , maybe [] (schemaTypeToXML "text") $ allergyIntolerance_text x
            , concatMap (schemaTypeToXML "contained") $ allergyIntolerance_contained x
            , concatMap (schemaTypeToXML "extension") $ allergyIntolerance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ allergyIntolerance_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ allergyIntolerance_identifier x
            , maybe [] (schemaTypeToXML "clinicalStatus") $ allergyIntolerance_clinicalStatus x
            , schemaTypeToXML "verificationStatus" $ allergyIntolerance_verificationStatus x
            , maybe [] (schemaTypeToXML "type") $ allergyIntolerance_type x
            , concatMap (schemaTypeToXML "category") $ allergyIntolerance_category x
            , maybe [] (schemaTypeToXML "criticality") $ allergyIntolerance_criticality x
            , maybe [] (schemaTypeToXML "code") $ allergyIntolerance_code x
            , schemaTypeToXML "patient" $ allergyIntolerance_patient x
            , maybe [] (foldOneOf5  (schemaTypeToXML "onsetDateTime")
                                    (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetString")
                                   ) $ allergyIntolerance_choice16 x
            , maybe [] (schemaTypeToXML "assertedDate") $ allergyIntolerance_assertedDate x
            , maybe [] (schemaTypeToXML "recorder") $ allergyIntolerance_recorder x
            , maybe [] (schemaTypeToXML "asserter") $ allergyIntolerance_asserter x
            , maybe [] (schemaTypeToXML "lastOccurrence") $ allergyIntolerance_lastOccurrence x
            , concatMap (schemaTypeToXML "note") $ allergyIntolerance_note x
            , concatMap (schemaTypeToXML "reaction") $ allergyIntolerance_reaction x
            ]
instance Extension AllergyIntolerance DomainResource where
    supertype (AllergyIntolerance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AllergyIntolerance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AllergyIntolerance -> DomainResource)
              
 
-- | Risk of harmful or undesirable, physiological response 
--   which is unique to an individual and associated with 
--   exposure to a substance.
data AllergyIntolerance'Reaction = AllergyIntolerance'Reaction
        { allergyIntolerance'Reaction_id :: Maybe String'primitive
        , allergyIntolerance'Reaction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , allergyIntolerance'Reaction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , allergyIntolerance'Reaction_substance :: Maybe CodeableConcept
          -- ^ Identification of the specific substance (or pharmaceutical 
          --   product) considered to be responsible for the Adverse 
          --   Reaction event. Note: the substance for a specific reaction 
          --   may be different from the substance identified as the cause 
          --   of the risk, but it must be consistent with it. For 
          --   instance, it may be a more specific substance (e.g. a brand 
          --   medication) or a composite product that includes the 
          --   identified substance. It must be clinically safe to only 
          --   process the 'code' and ignore the 'reaction.substance'.
        , allergyIntolerance'Reaction_manifestation :: [CodeableConcept]
          -- ^ Clinical symptoms and/or signs that are observed or 
          --   associated with the adverse reaction event.
        , allergyIntolerance'Reaction_description :: Maybe Xsd.XsdString
          -- ^ Text description about the reaction as a whole, including 
          --   details of the manifestation if required.
        , allergyIntolerance'Reaction_onset :: Maybe DateTime
          -- ^ Record of the date and/or time of the onset of the 
          --   Reaction.
        , allergyIntolerance'Reaction_severity :: Maybe AllergyIntoleranceSeverity
          -- ^ Clinical assessment of the severity of the reaction event 
          --   as a whole, potentially considering multiple different 
          --   manifestations.
        , allergyIntolerance'Reaction_exposureRoute :: Maybe CodeableConcept
          -- ^ Identification of the route by which the subject was 
          --   exposed to the substance.
        , allergyIntolerance'Reaction_note :: [Annotation]
          -- ^ Additional text about the adverse reaction event not 
          --   captured in other fields.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntolerance'Reaction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AllergyIntolerance'Reaction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "substance")
            `apply` many1 (parseSchemaType "manifestation")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "onset")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "exposureRoute")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@AllergyIntolerance'Reaction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntolerance'Reaction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntolerance'Reaction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ allergyIntolerance'Reaction_modifierExtension x
            , maybe [] (schemaTypeToXML "substance") $ allergyIntolerance'Reaction_substance x
            , concatMap (schemaTypeToXML "manifestation") $ allergyIntolerance'Reaction_manifestation x
            , maybe [] (schemaTypeToXML "description") $ allergyIntolerance'Reaction_description x
            , maybe [] (schemaTypeToXML "onset") $ allergyIntolerance'Reaction_onset x
            , maybe [] (schemaTypeToXML "severity") $ allergyIntolerance'Reaction_severity x
            , maybe [] (schemaTypeToXML "exposureRoute") $ allergyIntolerance'Reaction_exposureRoute x
            , concatMap (schemaTypeToXML "note") $ allergyIntolerance'Reaction_note x
            ]
instance Extension AllergyIntolerance'Reaction BackboneElement where
    supertype (AllergyIntolerance'Reaction a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension AllergyIntolerance'Reaction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AllergyIntolerance'Reaction -> BackboneElement)
              
 
data AllergyIntoleranceCriticality'list
    = AllergyIntoleranceCriticality'list_Low
      -- ^ Low Risk
    | AllergyIntoleranceCriticality'list_High
      -- ^ High Risk
    | AllergyIntoleranceCriticality'list_Unable'to'assess
      -- ^ Unable to Assess Risk
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceCriticality'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceCriticality'list where
    acceptingParser =  do literal "low"; return AllergyIntoleranceCriticality'list_Low
                      `onFail` do literal "high"; return AllergyIntoleranceCriticality'list_High
                      `onFail` do literal "unable-to-assess"; return AllergyIntoleranceCriticality'list_Unable'to'assess
                      
    simpleTypeText AllergyIntoleranceCriticality'list_Low = "low"
    simpleTypeText AllergyIntoleranceCriticality'list_High = "high"
    simpleTypeText AllergyIntoleranceCriticality'list_Unable'to'assess = "unable-to-assess"
 
data AllergyIntoleranceCriticality = AllergyIntoleranceCriticality
        { allergyIntoleranceCriticality_id :: Maybe String'primitive
        , allergyIntoleranceCriticality_value :: Maybe AllergyIntoleranceCriticality'list
        , allergyIntoleranceCriticality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceCriticality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceCriticality a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceCriticality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceCriticality_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceCriticality_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceCriticality_extension x
            ]
instance Extension AllergyIntoleranceCriticality Element where
    supertype (AllergyIntoleranceCriticality a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceType'list
    = AllergyIntoleranceType'list_Allergy
      -- ^ Allergy
    | AllergyIntoleranceType'list_Intolerance
      -- ^ Intolerance
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceType'list where
    acceptingParser =  do literal "allergy"; return AllergyIntoleranceType'list_Allergy
                      `onFail` do literal "intolerance"; return AllergyIntoleranceType'list_Intolerance
                      
    simpleTypeText AllergyIntoleranceType'list_Allergy = "allergy"
    simpleTypeText AllergyIntoleranceType'list_Intolerance = "intolerance"
 
data AllergyIntoleranceType = AllergyIntoleranceType
        { allergyIntoleranceType_id :: Maybe String'primitive
        , allergyIntoleranceType_value :: Maybe AllergyIntoleranceType'list
        , allergyIntoleranceType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceType_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceType_extension x
            ]
instance Extension AllergyIntoleranceType Element where
    supertype (AllergyIntoleranceType a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceCategory'list
    = AllergyIntoleranceCategory'list_Food
      -- ^ Food
    | AllergyIntoleranceCategory'list_Medication
      -- ^ Medication
    | AllergyIntoleranceCategory'list_Environment
      -- ^ Environment
    | AllergyIntoleranceCategory'list_Biologic
      -- ^ Biologic
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceCategory'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceCategory'list where
    acceptingParser =  do literal "food"; return AllergyIntoleranceCategory'list_Food
                      `onFail` do literal "medication"; return AllergyIntoleranceCategory'list_Medication
                      `onFail` do literal "environment"; return AllergyIntoleranceCategory'list_Environment
                      `onFail` do literal "biologic"; return AllergyIntoleranceCategory'list_Biologic
                      
    simpleTypeText AllergyIntoleranceCategory'list_Food = "food"
    simpleTypeText AllergyIntoleranceCategory'list_Medication = "medication"
    simpleTypeText AllergyIntoleranceCategory'list_Environment = "environment"
    simpleTypeText AllergyIntoleranceCategory'list_Biologic = "biologic"
 
data AllergyIntoleranceCategory = AllergyIntoleranceCategory
        { allergyIntoleranceCategory_id :: Maybe String'primitive
        , allergyIntoleranceCategory_value :: Maybe AllergyIntoleranceCategory'list
        , allergyIntoleranceCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceCategory_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceCategory_extension x
            ]
instance Extension AllergyIntoleranceCategory Element where
    supertype (AllergyIntoleranceCategory a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceVerificationStatus'list
    = AllergyIntoleranceVerificationStatus'list_Unconfirmed
      -- ^ Unconfirmed
    | AllergyIntoleranceVerificationStatus'list_Confirmed
      -- ^ Confirmed
    | AllergyIntoleranceVerificationStatus'list_Refuted
      -- ^ Refuted
    | AllergyIntoleranceVerificationStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceVerificationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceVerificationStatus'list where
    acceptingParser =  do literal "unconfirmed"; return AllergyIntoleranceVerificationStatus'list_Unconfirmed
                      `onFail` do literal "confirmed"; return AllergyIntoleranceVerificationStatus'list_Confirmed
                      `onFail` do literal "refuted"; return AllergyIntoleranceVerificationStatus'list_Refuted
                      `onFail` do literal "entered-in-error"; return AllergyIntoleranceVerificationStatus'list_Entered'in'error
                      
    simpleTypeText AllergyIntoleranceVerificationStatus'list_Unconfirmed = "unconfirmed"
    simpleTypeText AllergyIntoleranceVerificationStatus'list_Confirmed = "confirmed"
    simpleTypeText AllergyIntoleranceVerificationStatus'list_Refuted = "refuted"
    simpleTypeText AllergyIntoleranceVerificationStatus'list_Entered'in'error = "entered-in-error"
 
data AllergyIntoleranceVerificationStatus = AllergyIntoleranceVerificationStatus
        { allergyIntoleranceVerificationStatus_id :: Maybe String'primitive
        , allergyIntoleranceVerificationStatus_value :: Maybe AllergyIntoleranceVerificationStatus'list
        , allergyIntoleranceVerificationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceVerificationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceVerificationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceVerificationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceVerificationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceVerificationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceVerificationStatus_extension x
            ]
instance Extension AllergyIntoleranceVerificationStatus Element where
    supertype (AllergyIntoleranceVerificationStatus a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceSeverity'list
    = AllergyIntoleranceSeverity'list_Mild
      -- ^ Mild
    | AllergyIntoleranceSeverity'list_Moderate
      -- ^ Moderate
    | AllergyIntoleranceSeverity'list_Severe
      -- ^ Severe
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceSeverity'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceSeverity'list where
    acceptingParser =  do literal "mild"; return AllergyIntoleranceSeverity'list_Mild
                      `onFail` do literal "moderate"; return AllergyIntoleranceSeverity'list_Moderate
                      `onFail` do literal "severe"; return AllergyIntoleranceSeverity'list_Severe
                      
    simpleTypeText AllergyIntoleranceSeverity'list_Mild = "mild"
    simpleTypeText AllergyIntoleranceSeverity'list_Moderate = "moderate"
    simpleTypeText AllergyIntoleranceSeverity'list_Severe = "severe"
 
data AllergyIntoleranceSeverity = AllergyIntoleranceSeverity
        { allergyIntoleranceSeverity_id :: Maybe String'primitive
        , allergyIntoleranceSeverity_value :: Maybe AllergyIntoleranceSeverity'list
        , allergyIntoleranceSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceSeverity_extension x
            ]
instance Extension AllergyIntoleranceSeverity Element where
    supertype (AllergyIntoleranceSeverity a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceClinicalStatus'list
    = AllergyIntoleranceClinicalStatus'list_Active
      -- ^ Active
    | AllergyIntoleranceClinicalStatus'list_Inactive
      -- ^ Inactive
    | AllergyIntoleranceClinicalStatus'list_Resolved
      -- ^ Resolved
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceClinicalStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceClinicalStatus'list where
    acceptingParser =  do literal "active"; return AllergyIntoleranceClinicalStatus'list_Active
                      `onFail` do literal "inactive"; return AllergyIntoleranceClinicalStatus'list_Inactive
                      `onFail` do literal "resolved"; return AllergyIntoleranceClinicalStatus'list_Resolved
                      
    simpleTypeText AllergyIntoleranceClinicalStatus'list_Active = "active"
    simpleTypeText AllergyIntoleranceClinicalStatus'list_Inactive = "inactive"
    simpleTypeText AllergyIntoleranceClinicalStatus'list_Resolved = "resolved"
 
data AllergyIntoleranceClinicalStatus = AllergyIntoleranceClinicalStatus
        { allergyIntoleranceClinicalStatus_id :: Maybe String'primitive
        , allergyIntoleranceClinicalStatus_value :: Maybe AllergyIntoleranceClinicalStatus'list
        , allergyIntoleranceClinicalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceClinicalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceClinicalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceClinicalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceClinicalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceClinicalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceClinicalStatus_extension x
            ]
instance Extension AllergyIntoleranceClinicalStatus Element where
    supertype (AllergyIntoleranceClinicalStatus a0 a1 e0) =
               Element a0 e0
 
-- | A booking of a healthcare event among patient(s), 
--   practitioner(s), related person(s) and/or device(s) for a 
--   specific date/time. This may result in one or more 
--   Encounter(s).
elementAppointment :: XMLParser Appointment
elementAppointment = parseSchemaType "Appointment"
elementToXMLAppointment :: Appointment -> [Content ()]
elementToXMLAppointment = schemaTypeToXML "Appointment"
 
data Appointment = Appointment
        { appointment_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , appointment_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , appointment_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , appointment_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , appointment_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , appointment_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , appointment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointment_identifier :: [Identifier]
          -- ^ This records identifiers associated with this appointment 
          --   concern that are defined by business processes and/or used 
          --   to refer to it when a direct URL reference to the resource 
          --   itself is not appropriate (e.g. in CDA documents, or in 
          --   written / printed documentation).
        , appointment_status :: AppointmentStatus
          -- ^ The overall status of the Appointment. Each of the 
          --   participants has their own participation status which 
          --   indicates their involvement in the process, however this 
          --   status indicates the shared status.
        , appointment_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , appointment_serviceType :: [CodeableConcept]
          -- ^ The specific service that is to be performed during this 
          --   appointment.
        , appointment_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , appointment_appointmentType :: Maybe CodeableConcept
          -- ^ The style of appointment or patient that has been booked in 
          --   the slot (not service type).
        , appointment_reason :: [CodeableConcept]
          -- ^ The reason that this appointment is being scheduled. This 
          --   is more clinical than administrative.
        , appointment_indication :: [Reference]
          -- ^ Reason the appointment has been scheduled to take place, as 
          --   specified using information from another resource. When the 
          --   patient arrives and the encounter begins it may be used as 
          --   the admission diagnosis. The indication will typically be a 
          --   Condition (with other resources referenced in the 
          --   evidence.detail), or a Procedure.
        , appointment_priority :: Maybe UnsignedInt
          -- ^ The priority of the appointment. Can be used to make 
          --   informed decisions if needing to re-prioritize 
          --   appointments. (The iCal Standard specifies 0 as undefined, 
          --   1 as highest, 9 as lowest priority).
        , appointment_description :: Maybe Xsd.XsdString
          -- ^ The brief description of the appointment as would be shown 
          --   on a subject line in a meeting request, or appointment 
          --   list. Detailed or expanded information should be put in the 
          --   comment field.
        , appointment_supportingInformation :: [Reference]
          -- ^ Additional information to support the appointment provided 
          --   when making the appointment.
        , appointment_start :: Maybe Instant
          -- ^ Date/Time that the appointment is to take place.
        , appointment_end :: Maybe Instant
          -- ^ Date/Time that the appointment is to conclude.
        , appointment_minutesDuration :: Maybe PositiveInt
          -- ^ Number of minutes that the appointment is to take. This can 
          --   be less than the duration between the start and end times 
          --   (where actual time of appointment is only an estimate or is 
          --   a planned appointment request).
        , appointment_slot :: [Reference]
          -- ^ The slots from the participants' schedules that will be 
          --   filled by the appointment.
        , appointment_created :: Maybe DateTime
          -- ^ The date that this appointment was initially created. This 
          --   could be different to the meta.lastModified value on the 
          --   initial entry, as this could have been before the resource 
          --   was created on the FHIR server, and should remain unchanged 
          --   over the lifespan of the appointment.
        , appointment_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the appointment.
        , appointment_incomingReferral :: [Reference]
          -- ^ The referral request this appointment is allocated to 
          --   assess (incoming referral).
        , appointment_participant :: [Appointment'Participant]
          -- ^ List of participants involved in the appointment.
        , appointment_requestedPeriod :: [Period]
          -- ^ A set of date ranges (potentially including times) that the 
          --   appointment is preferred to be scheduled within. When using 
          --   these values, the minutes duration should be provided to 
          --   indicate the length of the appointment to fill and populate 
          --   the start/end times for the actual allocated time.
        }
        deriving (Eq,Show)
instance SchemaType Appointment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Appointment
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` optional (parseSchemaType "appointmentType")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "indication")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "minutesDuration")
            `apply` many (parseSchemaType "slot")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "comment")
            `apply` many (parseSchemaType "incomingReferral")
            `apply` many1 (parseSchemaType "participant")
            `apply` many (parseSchemaType "requestedPeriod")
    schemaTypeToXML s x@Appointment{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ appointment_id x
            , maybe [] (schemaTypeToXML "meta") $ appointment_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ appointment_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ appointment_language x
            , maybe [] (schemaTypeToXML "text") $ appointment_text x
            , concatMap (schemaTypeToXML "contained") $ appointment_contained x
            , concatMap (schemaTypeToXML "extension") $ appointment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointment_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ appointment_identifier x
            , schemaTypeToXML "status" $ appointment_status x
            , maybe [] (schemaTypeToXML "serviceCategory") $ appointment_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ appointment_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ appointment_specialty x
            , maybe [] (schemaTypeToXML "appointmentType") $ appointment_appointmentType x
            , concatMap (schemaTypeToXML "reason") $ appointment_reason x
            , concatMap (schemaTypeToXML "indication") $ appointment_indication x
            , maybe [] (schemaTypeToXML "priority") $ appointment_priority x
            , maybe [] (schemaTypeToXML "description") $ appointment_description x
            , concatMap (schemaTypeToXML "supportingInformation") $ appointment_supportingInformation x
            , maybe [] (schemaTypeToXML "start") $ appointment_start x
            , maybe [] (schemaTypeToXML "end") $ appointment_end x
            , maybe [] (schemaTypeToXML "minutesDuration") $ appointment_minutesDuration x
            , concatMap (schemaTypeToXML "slot") $ appointment_slot x
            , maybe [] (schemaTypeToXML "created") $ appointment_created x
            , maybe [] (schemaTypeToXML "comment") $ appointment_comment x
            , concatMap (schemaTypeToXML "incomingReferral") $ appointment_incomingReferral x
            , concatMap (schemaTypeToXML "participant") $ appointment_participant x
            , concatMap (schemaTypeToXML "requestedPeriod") $ appointment_requestedPeriod x
            ]
instance Extension Appointment DomainResource where
    supertype (Appointment e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Appointment Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Appointment -> DomainResource)
              
 
-- | A booking of a healthcare event among patient(s), 
--   practitioner(s), related person(s) and/or device(s) for a 
--   specific date/time. This may result in one or more 
--   Encounter(s).
data Appointment'Participant = Appointment'Participant
        { appointment'Participant_id :: Maybe String'primitive
        , appointment'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointment'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointment'Participant_type :: [CodeableConcept]
          -- ^ Role of participant in the appointment.
        , appointment'Participant_actor :: Maybe Reference
          -- ^ A Person, Location/HealthcareService or Device that is 
          --   participating in the appointment.
        , appointment'Participant_required :: Maybe ParticipantRequired
          -- ^ Is this participant required to be present at the meeting. 
          --   This covers a use-case where 2 doctors need to meet to 
          --   discuss the results for a specific patient, and the patient 
          --   is not required to be present.
        , appointment'Participant_status :: ParticipationStatus
          -- ^ Participation status of the actor.
        }
        deriving (Eq,Show)
instance SchemaType Appointment'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Appointment'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "actor")
            `apply` optional (parseSchemaType "required")
            `apply` parseSchemaType "status"
    schemaTypeToXML s x@Appointment'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ appointment'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ appointment'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointment'Participant_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ appointment'Participant_type x
            , maybe [] (schemaTypeToXML "actor") $ appointment'Participant_actor x
            , maybe [] (schemaTypeToXML "required") $ appointment'Participant_required x
            , schemaTypeToXML "status" $ appointment'Participant_status x
            ]
instance Extension Appointment'Participant BackboneElement where
    supertype (Appointment'Participant a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Appointment'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Appointment'Participant -> BackboneElement)
              
 
data ParticipantRequired'list
    = ParticipantRequired'list_Required
      -- ^ Required
    | ParticipantRequired'list_Optional
      -- ^ Optional
    | ParticipantRequired'list_Information'only
      -- ^ Information Only
    deriving (Eq,Show,Enum)
instance SchemaType ParticipantRequired'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ParticipantRequired'list where
    acceptingParser =  do literal "required"; return ParticipantRequired'list_Required
                      `onFail` do literal "optional"; return ParticipantRequired'list_Optional
                      `onFail` do literal "information-only"; return ParticipantRequired'list_Information'only
                      
    simpleTypeText ParticipantRequired'list_Required = "required"
    simpleTypeText ParticipantRequired'list_Optional = "optional"
    simpleTypeText ParticipantRequired'list_Information'only = "information-only"
 
data ParticipantRequired = ParticipantRequired
        { participantRequired_id :: Maybe String'primitive
        , participantRequired_value :: Maybe ParticipantRequired'list
        , participantRequired_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ParticipantRequired where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ParticipantRequired a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ParticipantRequired{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ participantRequired_id x
                       , maybe [] (toXMLAttribute "value") $ participantRequired_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ participantRequired_extension x
            ]
instance Extension ParticipantRequired Element where
    supertype (ParticipantRequired a0 a1 e0) =
               Element a0 e0
 
data AppointmentStatus'list
    = AppointmentStatus'list_Proposed
      -- ^ Proposed
    | AppointmentStatus'list_Pending
      -- ^ Pending
    | AppointmentStatus'list_Booked
      -- ^ Booked
    | AppointmentStatus'list_Arrived
      -- ^ Arrived
    | AppointmentStatus'list_Fulfilled
      -- ^ Fulfilled
    | AppointmentStatus'list_Cancelled
      -- ^ Cancelled
    | AppointmentStatus'list_Noshow
      -- ^ No Show
    | AppointmentStatus'list_Entered'in'error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType AppointmentStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AppointmentStatus'list where
    acceptingParser =  do literal "proposed"; return AppointmentStatus'list_Proposed
                      `onFail` do literal "pending"; return AppointmentStatus'list_Pending
                      `onFail` do literal "booked"; return AppointmentStatus'list_Booked
                      `onFail` do literal "arrived"; return AppointmentStatus'list_Arrived
                      `onFail` do literal "fulfilled"; return AppointmentStatus'list_Fulfilled
                      `onFail` do literal "cancelled"; return AppointmentStatus'list_Cancelled
                      `onFail` do literal "noshow"; return AppointmentStatus'list_Noshow
                      `onFail` do literal "entered-in-error"; return AppointmentStatus'list_Entered'in'error
                      
    simpleTypeText AppointmentStatus'list_Proposed = "proposed"
    simpleTypeText AppointmentStatus'list_Pending = "pending"
    simpleTypeText AppointmentStatus'list_Booked = "booked"
    simpleTypeText AppointmentStatus'list_Arrived = "arrived"
    simpleTypeText AppointmentStatus'list_Fulfilled = "fulfilled"
    simpleTypeText AppointmentStatus'list_Cancelled = "cancelled"
    simpleTypeText AppointmentStatus'list_Noshow = "noshow"
    simpleTypeText AppointmentStatus'list_Entered'in'error = "entered-in-error"
 
data AppointmentStatus = AppointmentStatus
        { appointmentStatus_id :: Maybe String'primitive
        , appointmentStatus_value :: Maybe AppointmentStatus'list
        , appointmentStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AppointmentStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AppointmentStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AppointmentStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ appointmentStatus_id x
                       , maybe [] (toXMLAttribute "value") $ appointmentStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ appointmentStatus_extension x
            ]
instance Extension AppointmentStatus Element where
    supertype (AppointmentStatus a0 a1 e0) =
               Element a0 e0
 
data ParticipationStatus'list
    = ParticipationStatus'list_Accepted
      -- ^ Accepted
    | ParticipationStatus'list_Declined
      -- ^ Declined
    | ParticipationStatus'list_Tentative
      -- ^ Tentative
    | ParticipationStatus'list_Needs'action
      -- ^ Needs Action
    deriving (Eq,Show,Enum)
instance SchemaType ParticipationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ParticipationStatus'list where
    acceptingParser =  do literal "accepted"; return ParticipationStatus'list_Accepted
                      `onFail` do literal "declined"; return ParticipationStatus'list_Declined
                      `onFail` do literal "tentative"; return ParticipationStatus'list_Tentative
                      `onFail` do literal "needs-action"; return ParticipationStatus'list_Needs'action
                      
    simpleTypeText ParticipationStatus'list_Accepted = "accepted"
    simpleTypeText ParticipationStatus'list_Declined = "declined"
    simpleTypeText ParticipationStatus'list_Tentative = "tentative"
    simpleTypeText ParticipationStatus'list_Needs'action = "needs-action"
 
data ParticipationStatus = ParticipationStatus
        { participationStatus_id :: Maybe String'primitive
        , participationStatus_value :: Maybe ParticipationStatus'list
        , participationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ParticipationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ParticipationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ParticipationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ participationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ participationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ participationStatus_extension x
            ]
instance Extension ParticipationStatus Element where
    supertype (ParticipationStatus a0 a1 e0) =
               Element a0 e0
 
-- | A reply to an appointment request for a patient and/or 
--   practitioner(s), such as a confirmation or rejection.
elementAppointmentResponse :: XMLParser AppointmentResponse
elementAppointmentResponse = parseSchemaType "AppointmentResponse"
elementToXMLAppointmentResponse :: AppointmentResponse -> [Content ()]
elementToXMLAppointmentResponse = schemaTypeToXML "AppointmentResponse"
 
data AppointmentResponse = AppointmentResponse
        { appointmentResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , appointmentResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , appointmentResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , appointmentResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , appointmentResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , appointmentResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , appointmentResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointmentResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointmentResponse_identifier :: [Identifier]
          -- ^ This records identifiers associated with this appointment 
          --   response concern that are defined by business processes 
          --   and/ or used to refer to it when a direct URL reference to 
          --   the resource itself is not appropriate.
        , appointmentResponse_appointment :: Reference
          -- ^ Appointment that this response is replying to.
        , appointmentResponse_start :: Maybe Instant
          -- ^ Date/Time that the appointment is to take place, or 
          --   requested new start time.
        , appointmentResponse_end :: Maybe Instant
          -- ^ This may be either the same as the appointment request to 
          --   confirm the details of the appointment, or alternately a 
          --   new time to request a re-negotiation of the end time.
        , appointmentResponse_participantType :: [CodeableConcept]
          -- ^ Role of participant in the appointment.
        , appointmentResponse_actor :: Maybe Reference
          -- ^ A Person, Location/HealthcareService or Device that is 
          --   participating in the appointment.
        , appointmentResponse_participantStatus :: ParticipationStatus
          -- ^ Participation status of the participant. When the status is 
          --   declined or tentative if the start/end times are different 
          --   to the appointment, then these times should be interpreted 
          --   as a requested time change. When the status is accepted, 
          --   the times can either be the time of the appointment (as a 
          --   confirmation of the time) or can be empty.
        , appointmentResponse_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the appointment.
        }
        deriving (Eq,Show)
instance SchemaType AppointmentResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AppointmentResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "appointment"
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` many (parseSchemaType "participantType")
            `apply` optional (parseSchemaType "actor")
            `apply` parseSchemaType "participantStatus"
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@AppointmentResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ appointmentResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ appointmentResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ appointmentResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ appointmentResponse_language x
            , maybe [] (schemaTypeToXML "text") $ appointmentResponse_text x
            , concatMap (schemaTypeToXML "contained") $ appointmentResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ appointmentResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointmentResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ appointmentResponse_identifier x
            , schemaTypeToXML "appointment" $ appointmentResponse_appointment x
            , maybe [] (schemaTypeToXML "start") $ appointmentResponse_start x
            , maybe [] (schemaTypeToXML "end") $ appointmentResponse_end x
            , concatMap (schemaTypeToXML "participantType") $ appointmentResponse_participantType x
            , maybe [] (schemaTypeToXML "actor") $ appointmentResponse_actor x
            , schemaTypeToXML "participantStatus" $ appointmentResponse_participantStatus x
            , maybe [] (schemaTypeToXML "comment") $ appointmentResponse_comment x
            ]
instance Extension AppointmentResponse DomainResource where
    supertype (AppointmentResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AppointmentResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AppointmentResponse -> DomainResource)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
elementAuditEvent :: XMLParser AuditEvent
elementAuditEvent = parseSchemaType "AuditEvent"
elementToXMLAuditEvent :: AuditEvent -> [Content ()]
elementToXMLAuditEvent = schemaTypeToXML "AuditEvent"
 
data AuditEvent = AuditEvent
        { auditEvent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , auditEvent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , auditEvent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , auditEvent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , auditEvent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , auditEvent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , auditEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent_type :: Coding
          -- ^ Identifier for a family of the event. For example, a menu 
          --   item, program, rule, policy, function code, application 
          --   name or URL. It identifies the performed function.
        , auditEvent_subtype :: [Coding]
          -- ^ Identifier for the category of event.
        , auditEvent_action :: Maybe AuditEventAction
          -- ^ Indicator for type of action performed during the event 
          --   that generated the audit.
        , auditEvent_recorded :: Instant
          -- ^ The time when the event occurred on the source.
        , auditEvent_outcome :: Maybe AuditEventOutcome
          -- ^ Indicates whether the event succeeded or failed.
        , auditEvent_outcomeDesc :: Maybe Xsd.XsdString
          -- ^ A free text description of the outcome of the event.
        , auditEvent_purposeOfEvent :: [CodeableConcept]
          -- ^ The purposeOfUse (reason) that was used during the event 
          --   being recorded.
        , auditEvent_agent :: [AuditEvent'Agent]
          -- ^ An actor taking an active role in the event or activity 
          --   that is logged.
        , auditEvent_source :: AuditEvent'Source
          -- ^ The system that is reporting the event.
        , auditEvent_entity :: [AuditEvent'Entity]
          -- ^ Specific instances of data or objects that have been 
          --   accessed.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AuditEvent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "subtype")
            `apply` optional (parseSchemaType "action")
            `apply` parseSchemaType "recorded"
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "outcomeDesc")
            `apply` many (parseSchemaType "purposeOfEvent")
            `apply` many1 (parseSchemaType "agent")
            `apply` parseSchemaType "source"
            `apply` many (parseSchemaType "entity")
    schemaTypeToXML s x@AuditEvent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ auditEvent_id x
            , maybe [] (schemaTypeToXML "meta") $ auditEvent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ auditEvent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ auditEvent_language x
            , maybe [] (schemaTypeToXML "text") $ auditEvent_text x
            , concatMap (schemaTypeToXML "contained") $ auditEvent_contained x
            , concatMap (schemaTypeToXML "extension") $ auditEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent_modifierExtension x
            , schemaTypeToXML "type" $ auditEvent_type x
            , concatMap (schemaTypeToXML "subtype") $ auditEvent_subtype x
            , maybe [] (schemaTypeToXML "action") $ auditEvent_action x
            , schemaTypeToXML "recorded" $ auditEvent_recorded x
            , maybe [] (schemaTypeToXML "outcome") $ auditEvent_outcome x
            , maybe [] (schemaTypeToXML "outcomeDesc") $ auditEvent_outcomeDesc x
            , concatMap (schemaTypeToXML "purposeOfEvent") $ auditEvent_purposeOfEvent x
            , concatMap (schemaTypeToXML "agent") $ auditEvent_agent x
            , schemaTypeToXML "source" $ auditEvent_source x
            , concatMap (schemaTypeToXML "entity") $ auditEvent_entity x
            ]
instance Extension AuditEvent DomainResource where
    supertype (AuditEvent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AuditEvent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AuditEvent -> DomainResource)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEvent'Agent = AuditEvent'Agent
        { auditEvent'Agent_id :: Maybe String'primitive
        , auditEvent'Agent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent'Agent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent'Agent_role :: [CodeableConcept]
          -- ^ The security role that the user was acting under, that come 
          --   from local codes defined by the access control security 
          --   system (e.g. RBAC, ABAC) used in the local context.
        , auditEvent'Agent_reference :: Maybe Reference
          -- ^ Direct reference to a resource that identifies the agent.
        , auditEvent'Agent_userId :: Maybe Identifier
          -- ^ Unique identifier for the user actively participating in 
          --   the event.
        , auditEvent'Agent_altId :: Maybe Xsd.XsdString
          -- ^ Alternative agent Identifier. For a human, this should be a 
          --   user identifier text string from authentication system. 
          --   This identifier would be one known to a common 
          --   authentication system (e.g. single sign-on), if available.
        , auditEvent'Agent_name :: Maybe Xsd.XsdString
          -- ^ Human-meaningful name for the agent.
        , auditEvent'Agent_requestor :: Boolean
          -- ^ Indicator that the user is or is not the requestor, or 
          --   initiator, for the event being audited.
        , auditEvent'Agent_location :: Maybe Reference
          -- ^ Where the event occurred.
        , auditEvent'Agent_policy :: [Uri]
          -- ^ The policy or plan that authorized the activity being 
          --   recorded. Typically, a single activity may have multiple 
          --   applicable policies, such as patient consent, guarantor 
          --   funding, etc. The policy would also indicate the security 
          --   token used.
        , auditEvent'Agent_media :: Maybe Coding
          -- ^ Type of media involved. Used when the event is about 
          --   exporting/importing onto media.
        , auditEvent'Agent_network :: Maybe AuditEvent'Network
          -- ^ Logical network location for application activity, if the 
          --   activity has a network location.
        , auditEvent'Agent_purposeOfUse :: [CodeableConcept]
          -- ^ The reason (purpose of use), specific to this agent, that 
          --   was used during the event being recorded.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent'Agent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEvent'Agent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "role")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "userId")
            `apply` optional (parseSchemaType "altId")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "requestor"
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "media")
            `apply` optional (parseSchemaType "network")
            `apply` many (parseSchemaType "purposeOfUse")
    schemaTypeToXML s x@AuditEvent'Agent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEvent'Agent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEvent'Agent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent'Agent_modifierExtension x
            , concatMap (schemaTypeToXML "role") $ auditEvent'Agent_role x
            , maybe [] (schemaTypeToXML "reference") $ auditEvent'Agent_reference x
            , maybe [] (schemaTypeToXML "userId") $ auditEvent'Agent_userId x
            , maybe [] (schemaTypeToXML "altId") $ auditEvent'Agent_altId x
            , maybe [] (schemaTypeToXML "name") $ auditEvent'Agent_name x
            , schemaTypeToXML "requestor" $ auditEvent'Agent_requestor x
            , maybe [] (schemaTypeToXML "location") $ auditEvent'Agent_location x
            , concatMap (schemaTypeToXML "policy") $ auditEvent'Agent_policy x
            , maybe [] (schemaTypeToXML "media") $ auditEvent'Agent_media x
            , maybe [] (schemaTypeToXML "network") $ auditEvent'Agent_network x
            , concatMap (schemaTypeToXML "purposeOfUse") $ auditEvent'Agent_purposeOfUse x
            ]
instance Extension AuditEvent'Agent BackboneElement where
    supertype (AuditEvent'Agent a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               BackboneElement a0 e0 e1
instance Extension AuditEvent'Agent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEvent'Agent -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEvent'Network = AuditEvent'Network
        { auditEvent'Network_id :: Maybe String'primitive
        , auditEvent'Network_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent'Network_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent'Network_address :: Maybe Xsd.XsdString
          -- ^ An identifier for the network access point of the user 
          --   device for the audit event.
        , auditEvent'Network_type :: Maybe AuditEventAgentNetworkType
          -- ^ An identifier for the type of network access point that 
          --   originated the audit event.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent'Network where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEvent'Network a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "type")
    schemaTypeToXML s x@AuditEvent'Network{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEvent'Network_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEvent'Network_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent'Network_modifierExtension x
            , maybe [] (schemaTypeToXML "address") $ auditEvent'Network_address x
            , maybe [] (schemaTypeToXML "type") $ auditEvent'Network_type x
            ]
instance Extension AuditEvent'Network BackboneElement where
    supertype (AuditEvent'Network a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension AuditEvent'Network Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEvent'Network -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEvent'Source = AuditEvent'Source
        { auditEvent'Source_id :: Maybe String'primitive
        , auditEvent'Source_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent'Source_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent'Source_site :: Maybe Xsd.XsdString
          -- ^ Logical source location within the healthcare enterprise 
          --   network. For example, a hospital or other provider location 
          --   within a multi-entity provider group.
        , auditEvent'Source_identifier :: Identifier
          -- ^ Identifier of the source where the event was detected.
        , auditEvent'Source_type :: [Coding]
          -- ^ Code specifying the type of source where event originated.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent'Source where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEvent'Source a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "site")
            `apply` parseSchemaType "identifier"
            `apply` many (parseSchemaType "type")
    schemaTypeToXML s x@AuditEvent'Source{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEvent'Source_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEvent'Source_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent'Source_modifierExtension x
            , maybe [] (schemaTypeToXML "site") $ auditEvent'Source_site x
            , schemaTypeToXML "identifier" $ auditEvent'Source_identifier x
            , concatMap (schemaTypeToXML "type") $ auditEvent'Source_type x
            ]
instance Extension AuditEvent'Source BackboneElement where
    supertype (AuditEvent'Source a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension AuditEvent'Source Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEvent'Source -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEvent'Entity = AuditEvent'Entity
        { auditEvent'Entity_id :: Maybe String'primitive
        , auditEvent'Entity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent'Entity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent'Entity_identifier :: Maybe Identifier
          -- ^ Identifies a specific instance of the entity. The reference 
          --   should always be version specific.
        , auditEvent'Entity_reference :: Maybe Reference
          -- ^ Identifies a specific instance of the entity. The reference 
          --   should be version specific.
        , auditEvent'Entity_type :: Maybe Coding
          -- ^ The type of the object that was involved in this audit 
          --   event.
        , auditEvent'Entity_role :: Maybe Coding
          -- ^ Code representing the role the entity played in the event 
          --   being audited.
        , auditEvent'Entity_lifecycle :: Maybe Coding
          -- ^ Identifier for the data life-cycle stage for the entity.
        , auditEvent'Entity_securityLabel :: [Coding]
          -- ^ Security labels for the identified entity.
        , auditEvent'Entity_name :: Maybe Xsd.XsdString
          -- ^ A name of the entity in the audit event.
        , auditEvent'Entity_description :: Maybe Xsd.XsdString
          -- ^ Text that describes the entity in more detail.
        , auditEvent'Entity_query :: Maybe Base64Binary
          -- ^ The query parameters for a query-type entities.
        , auditEvent'Entity_detail :: [AuditEvent'Detail]
          -- ^ Tagged value pairs for conveying additional information 
          --   about the entity.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent'Entity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEvent'Entity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "lifecycle")
            `apply` many (parseSchemaType "securityLabel")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "query")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@AuditEvent'Entity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEvent'Entity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEvent'Entity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent'Entity_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ auditEvent'Entity_identifier x
            , maybe [] (schemaTypeToXML "reference") $ auditEvent'Entity_reference x
            , maybe [] (schemaTypeToXML "type") $ auditEvent'Entity_type x
            , maybe [] (schemaTypeToXML "role") $ auditEvent'Entity_role x
            , maybe [] (schemaTypeToXML "lifecycle") $ auditEvent'Entity_lifecycle x
            , concatMap (schemaTypeToXML "securityLabel") $ auditEvent'Entity_securityLabel x
            , maybe [] (schemaTypeToXML "name") $ auditEvent'Entity_name x
            , maybe [] (schemaTypeToXML "description") $ auditEvent'Entity_description x
            , maybe [] (schemaTypeToXML "query") $ auditEvent'Entity_query x
            , concatMap (schemaTypeToXML "detail") $ auditEvent'Entity_detail x
            ]
instance Extension AuditEvent'Entity BackboneElement where
    supertype (AuditEvent'Entity a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension AuditEvent'Entity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEvent'Entity -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEvent'Detail = AuditEvent'Detail
        { auditEvent'Detail_id :: Maybe String'primitive
        , auditEvent'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent'Detail_type :: Xsd.XsdString
          -- ^ The type of extra detail provided in the value.
        , auditEvent'Detail_value :: Base64Binary
          -- ^ The details, base64 encoded. Used to carry bulk 
          --   information.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEvent'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@AuditEvent'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEvent'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEvent'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent'Detail_modifierExtension x
            , schemaTypeToXML "type" $ auditEvent'Detail_type x
            , schemaTypeToXML "value" $ auditEvent'Detail_value x
            ]
instance Extension AuditEvent'Detail BackboneElement where
    supertype (AuditEvent'Detail a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension AuditEvent'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEvent'Detail -> BackboneElement)
              
 
data AuditEventOutcome'list
    = AuditEventOutcome'list_V0
      -- ^ Success
    | AuditEventOutcome'list_V4
      -- ^ Minor failure
    | AuditEventOutcome'list_V8
      -- ^ Serious failure
    | AuditEventOutcome'list_V12
      -- ^ Major failure
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventOutcome'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventOutcome'list where
    acceptingParser =  do literal "0"; return AuditEventOutcome'list_V0
                      `onFail` do literal "4"; return AuditEventOutcome'list_V4
                      `onFail` do literal "8"; return AuditEventOutcome'list_V8
                      `onFail` do literal "12"; return AuditEventOutcome'list_V12
                      
    simpleTypeText AuditEventOutcome'list_V0 = "0"
    simpleTypeText AuditEventOutcome'list_V4 = "4"
    simpleTypeText AuditEventOutcome'list_V8 = "8"
    simpleTypeText AuditEventOutcome'list_V12 = "12"
 
data AuditEventOutcome = AuditEventOutcome
        { auditEventOutcome_id :: Maybe String'primitive
        , auditEventOutcome_value :: Maybe AuditEventOutcome'list
        , auditEventOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventOutcome a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventOutcome{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventOutcome_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventOutcome_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventOutcome_extension x
            ]
instance Extension AuditEventOutcome Element where
    supertype (AuditEventOutcome a0 a1 e0) =
               Element a0 e0
 
data AuditEventAction'list
    = AuditEventAction'list_C
      -- ^ Create
    | AuditEventAction'list_R
      -- ^ Read/View/Print
    | AuditEventAction'list_U
      -- ^ Update
    | AuditEventAction'list_D
      -- ^ Delete
    | AuditEventAction'list_E
      -- ^ Execute
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventAction'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventAction'list where
    acceptingParser =  do literal "C"; return AuditEventAction'list_C
                      `onFail` do literal "R"; return AuditEventAction'list_R
                      `onFail` do literal "U"; return AuditEventAction'list_U
                      `onFail` do literal "D"; return AuditEventAction'list_D
                      `onFail` do literal "E"; return AuditEventAction'list_E
                      
    simpleTypeText AuditEventAction'list_C = "C"
    simpleTypeText AuditEventAction'list_R = "R"
    simpleTypeText AuditEventAction'list_U = "U"
    simpleTypeText AuditEventAction'list_D = "D"
    simpleTypeText AuditEventAction'list_E = "E"
 
data AuditEventAction = AuditEventAction
        { auditEventAction_id :: Maybe String'primitive
        , auditEventAction_value :: Maybe AuditEventAction'list
        , auditEventAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventAction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventAction_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventAction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventAction_extension x
            ]
instance Extension AuditEventAction Element where
    supertype (AuditEventAction a0 a1 e0) =
               Element a0 e0
 
data AuditEventAgentNetworkType'list
    = AuditEventAgentNetworkType'list_V1
      -- ^ Machine Name
    | AuditEventAgentNetworkType'list_V2
      -- ^ IP Address
    | AuditEventAgentNetworkType'list_V3
      -- ^ Telephone Number
    | AuditEventAgentNetworkType'list_V4
      -- ^ Email address
    | AuditEventAgentNetworkType'list_V5
      -- ^ URI
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventAgentNetworkType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventAgentNetworkType'list where
    acceptingParser =  do literal "1"; return AuditEventAgentNetworkType'list_V1
                      `onFail` do literal "2"; return AuditEventAgentNetworkType'list_V2
                      `onFail` do literal "3"; return AuditEventAgentNetworkType'list_V3
                      `onFail` do literal "4"; return AuditEventAgentNetworkType'list_V4
                      `onFail` do literal "5"; return AuditEventAgentNetworkType'list_V5
                      
    simpleTypeText AuditEventAgentNetworkType'list_V1 = "1"
    simpleTypeText AuditEventAgentNetworkType'list_V2 = "2"
    simpleTypeText AuditEventAgentNetworkType'list_V3 = "3"
    simpleTypeText AuditEventAgentNetworkType'list_V4 = "4"
    simpleTypeText AuditEventAgentNetworkType'list_V5 = "5"
 
data AuditEventAgentNetworkType = AuditEventAgentNetworkType
        { auditEventAgentNetworkType_id :: Maybe String'primitive
        , auditEventAgentNetworkType_value :: Maybe AuditEventAgentNetworkType'list
        , auditEventAgentNetworkType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventAgentNetworkType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventAgentNetworkType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventAgentNetworkType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventAgentNetworkType_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventAgentNetworkType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventAgentNetworkType_extension x
            ]
instance Extension AuditEventAgentNetworkType Element where
    supertype (AuditEventAgentNetworkType a0 a1 e0) =
               Element a0 e0
 
-- | Basic is used for handling concepts not yet defined in 
--   FHIR, narrative-only resources that don't map to an 
--   existing resource, and custom resources not appropriate for 
--   inclusion in the FHIR specification.
elementBasic :: XMLParser Basic
elementBasic = parseSchemaType "Basic"
elementToXMLBasic :: Basic -> [Content ()]
elementToXMLBasic = schemaTypeToXML "Basic"
 
data Basic = Basic
        { basic_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , basic_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , basic_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , basic_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , basic_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , basic_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , basic_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , basic_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , basic_identifier :: [Identifier]
          -- ^ Identifier assigned to the resource for business purposes, 
          --   outside the context of FHIR.
        , basic_code :: CodeableConcept
          -- ^ Identifies the 'type' of resource - equivalent to the 
          --   resource name for other resources.
        , basic_subject :: Maybe Reference
          -- ^ Identifies the patient, practitioner, device or any other 
          --   resource that is the &quot;focus&quot; of this resource.
        , basic_created :: Maybe Date
          -- ^ Identifies when the resource was first created.
        , basic_author :: Maybe Reference
          -- ^ Indicates who was responsible for creating the resource 
          --   instance.
        }
        deriving (Eq,Show)
instance SchemaType Basic where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Basic
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@Basic{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ basic_id x
            , maybe [] (schemaTypeToXML "meta") $ basic_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ basic_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ basic_language x
            , maybe [] (schemaTypeToXML "text") $ basic_text x
            , concatMap (schemaTypeToXML "contained") $ basic_contained x
            , concatMap (schemaTypeToXML "extension") $ basic_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ basic_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ basic_identifier x
            , schemaTypeToXML "code" $ basic_code x
            , maybe [] (schemaTypeToXML "subject") $ basic_subject x
            , maybe [] (schemaTypeToXML "created") $ basic_created x
            , maybe [] (schemaTypeToXML "author") $ basic_author x
            ]
instance Extension Basic DomainResource where
    supertype (Basic e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Basic Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Basic -> DomainResource)
              
 
-- | A binary resource can contain any content, whether text, 
--   image, pdf, zip archive, etc.
elementBinary :: XMLParser Binary
elementBinary = parseSchemaType "Binary"
elementToXMLBinary :: Binary -> [Content ()]
elementToXMLBinary = schemaTypeToXML "Binary"
 
data Binary = Binary
        { binary_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , binary_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , binary_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , binary_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , binary_contentType :: Code
          -- ^ MimeType of the binary content represented as a standard 
          --   MimeType (BCP 13).
        , binary_securityContext :: Maybe Reference
          -- ^ Treat this binary as if it was this other resource for 
          --   access control purposes.
        , binary_content :: Base64Binary
          -- ^ The actual content, base64 encoded.
        }
        deriving (Eq,Show)
instance SchemaType Binary where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Binary
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` parseSchemaType "contentType"
            `apply` optional (parseSchemaType "securityContext")
            `apply` parseSchemaType "content"
    schemaTypeToXML s x@Binary{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ binary_id x
            , maybe [] (schemaTypeToXML "meta") $ binary_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ binary_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ binary_language x
            , schemaTypeToXML "contentType" $ binary_contentType x
            , maybe [] (schemaTypeToXML "securityContext") $ binary_securityContext x
            , schemaTypeToXML "content" $ binary_content x
            ]
instance Extension Binary Resource where
    supertype (Binary e0 e1 e2 e3 e4 e5 e6) =
               Resource e0 e1 e2 e3
 
-- | Record details about the anatomical location of a specimen 
--   or body part. This resource may be used when a coded 
--   concept does not provide the necessary detail needed for 
--   the use case.
elementBodySite :: XMLParser BodySite
elementBodySite = parseSchemaType "BodySite"
elementToXMLBodySite :: BodySite -> [Content ()]
elementToXMLBodySite = schemaTypeToXML "BodySite"
 
data BodySite = BodySite
        { bodySite_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , bodySite_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , bodySite_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , bodySite_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , bodySite_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , bodySite_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , bodySite_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bodySite_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bodySite_identifier :: [Identifier]
          -- ^ Identifier for this instance of the anatomical location.
        , bodySite_active :: Maybe Boolean
          -- ^ Whether this body site is in active use.
        , bodySite_code :: Maybe CodeableConcept
          -- ^ Named anatomical location - ideally coded where possible.
        , bodySite_qualifier :: [CodeableConcept]
          -- ^ Qualifier to refine the anatomical location. These include 
          --   qualifiers for laterality, relative location, 
          --   directionality, number, and plane.
        , bodySite_description :: Maybe Xsd.XsdString
          -- ^ A summary, charactarization or explanation of the anatomic 
          --   location.
        , bodySite_image :: [Attachment]
          -- ^ Image or images used to identify a location.
        , bodySite_patient :: Reference
          -- ^ The person to which the body site belongs.
        }
        deriving (Eq,Show)
instance SchemaType BodySite where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return BodySite
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "qualifier")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "image")
            `apply` parseSchemaType "patient"
    schemaTypeToXML s x@BodySite{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ bodySite_id x
            , maybe [] (schemaTypeToXML "meta") $ bodySite_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ bodySite_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ bodySite_language x
            , maybe [] (schemaTypeToXML "text") $ bodySite_text x
            , concatMap (schemaTypeToXML "contained") $ bodySite_contained x
            , concatMap (schemaTypeToXML "extension") $ bodySite_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bodySite_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ bodySite_identifier x
            , maybe [] (schemaTypeToXML "active") $ bodySite_active x
            , maybe [] (schemaTypeToXML "code") $ bodySite_code x
            , concatMap (schemaTypeToXML "qualifier") $ bodySite_qualifier x
            , maybe [] (schemaTypeToXML "description") $ bodySite_description x
            , concatMap (schemaTypeToXML "image") $ bodySite_image x
            , schemaTypeToXML "patient" $ bodySite_patient x
            ]
instance Extension BodySite DomainResource where
    supertype (BodySite e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension BodySite Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: BodySite -> DomainResource)
              
 
-- | A container for a collection of resources.
elementBundle :: XMLParser Bundle
elementBundle = parseSchemaType "Bundle"
elementToXMLBundle :: Bundle -> [Content ()]
elementToXMLBundle = schemaTypeToXML "Bundle"
 
data Bundle = Bundle
        { bundle_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , bundle_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , bundle_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , bundle_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , bundle_identifier :: Maybe Identifier
          -- ^ A persistent identifier for the batch that won't change as 
          --   a batch is copied from server to server.
        , bundle_type :: BundleType
          -- ^ Indicates the purpose of this bundle - how it was intended 
          --   to be used.
        , bundle_total :: Maybe UnsignedInt
          -- ^ If a set of search matches, this is the total number of 
          --   matches for the search (as opposed to the number of results 
          --   in this bundle).
        , bundle_link :: [Bundle'Link]
          -- ^ A series of links that provide context to this bundle.
        , bundle_entry :: [Bundle'Entry]
          -- ^ An entry in a bundle resource - will either contain a 
          --   resource, or information about a resource (transactions and 
          --   history only).
        , bundle_signature :: Maybe Signature
          -- ^ Digital Signature - base64 encoded. XML-DSIg or a JWT.
        }
        deriving (Eq,Show)
instance SchemaType Bundle where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Bundle
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "total")
            `apply` many (parseSchemaType "link")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "signature")
    schemaTypeToXML s x@Bundle{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ bundle_id x
            , maybe [] (schemaTypeToXML "meta") $ bundle_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ bundle_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ bundle_language x
            , maybe [] (schemaTypeToXML "identifier") $ bundle_identifier x
            , schemaTypeToXML "type" $ bundle_type x
            , maybe [] (schemaTypeToXML "total") $ bundle_total x
            , concatMap (schemaTypeToXML "link") $ bundle_link x
            , concatMap (schemaTypeToXML "entry") $ bundle_entry x
            , maybe [] (schemaTypeToXML "signature") $ bundle_signature x
            ]
instance Extension Bundle Resource where
    supertype (Bundle e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               Resource e0 e1 e2 e3
 
-- | A container for a collection of resources.
data Bundle'Link = Bundle'Link
        { bundle'Link_id :: Maybe String'primitive
        , bundle'Link_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundle'Link_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundle'Link_relation :: Xsd.XsdString
          -- ^ A name which details the functional use for this link - see 
          --   [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
        , bundle'Link_url :: Uri
          -- ^ The reference details for the link.
        }
        deriving (Eq,Show)
instance SchemaType Bundle'Link where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Bundle'Link a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "relation"
            `apply` parseSchemaType "url"
    schemaTypeToXML s x@Bundle'Link{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundle'Link_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundle'Link_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundle'Link_modifierExtension x
            , schemaTypeToXML "relation" $ bundle'Link_relation x
            , schemaTypeToXML "url" $ bundle'Link_url x
            ]
instance Extension Bundle'Link BackboneElement where
    supertype (Bundle'Link a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Bundle'Link Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Bundle'Link -> BackboneElement)
              
 
-- | A container for a collection of resources.
data Bundle'Entry = Bundle'Entry
        { bundle'Entry_id :: Maybe String'primitive
        , bundle'Entry_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundle'Entry_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundle'Entry_link :: [Bundle'Link]
          -- ^ A series of links that provide context to this entry.
        , bundle'Entry_fullUrl :: Maybe Uri
          -- ^ The Absolute URL for the resource. The fullUrl SHALL not 
          --   disagree with the id in the resource. The fullUrl is a 
          --   version independent reference to the resource. The fullUrl 
          --   element SHALL have a value except that: * fullUrl can be 
          --   empty on a POST (although it does not need to when 
          --   specifying a temporary id for reference in the bundle) * 
          --   Results from operations might involve resources that are 
          --   not identified.
        , bundle'Entry_resource :: Maybe ResourceContainer
          -- ^ The Resources for the entry.
        , bundle'Entry_search :: Maybe Bundle'Search
          -- ^ Information about the search process that lead to the 
          --   creation of this entry.
        , bundle'Entry_request :: Maybe Bundle'Request
          -- ^ Additional information about how this entry should be 
          --   processed as part of a transaction.
        , bundle'Entry_response :: Maybe Bundle'Response
          -- ^ Additional information about how this entry should be 
          --   processed as part of a transaction.
        }
        deriving (Eq,Show)
instance SchemaType Bundle'Entry where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Bundle'Entry a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "link")
            `apply` optional (parseSchemaType "fullUrl")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "search")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
    schemaTypeToXML s x@Bundle'Entry{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundle'Entry_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundle'Entry_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundle'Entry_modifierExtension x
            , concatMap (schemaTypeToXML "link") $ bundle'Entry_link x
            , maybe [] (schemaTypeToXML "fullUrl") $ bundle'Entry_fullUrl x
            , maybe [] (schemaTypeToXML "resource") $ bundle'Entry_resource x
            , maybe [] (schemaTypeToXML "search") $ bundle'Entry_search x
            , maybe [] (schemaTypeToXML "request") $ bundle'Entry_request x
            , maybe [] (schemaTypeToXML "response") $ bundle'Entry_response x
            ]
instance Extension Bundle'Entry BackboneElement where
    supertype (Bundle'Entry a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Bundle'Entry Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Bundle'Entry -> BackboneElement)
              
 
-- | A container for a collection of resources.
data Bundle'Search = Bundle'Search
        { bundle'Search_id :: Maybe String'primitive
        , bundle'Search_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundle'Search_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundle'Search_mode :: Maybe SearchEntryMode
          -- ^ Why this entry is in the result set - whether it's included 
          --   as a match or because of an _include requirement.
        , bundle'Search_score :: Maybe Decimal
          -- ^ When searching, the server's search ranking score for the 
          --   entry.
        }
        deriving (Eq,Show)
instance SchemaType Bundle'Search where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Bundle'Search a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "score")
    schemaTypeToXML s x@Bundle'Search{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundle'Search_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundle'Search_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundle'Search_modifierExtension x
            , maybe [] (schemaTypeToXML "mode") $ bundle'Search_mode x
            , maybe [] (schemaTypeToXML "score") $ bundle'Search_score x
            ]
instance Extension Bundle'Search BackboneElement where
    supertype (Bundle'Search a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Bundle'Search Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Bundle'Search -> BackboneElement)
              
 
-- | A container for a collection of resources.
data Bundle'Request = Bundle'Request
        { bundle'Request_id :: Maybe String'primitive
        , bundle'Request_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundle'Request_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundle'Request_method :: HTTPVerb
          -- ^ The HTTP verb for this entry in either a change history, or 
          --   a transaction/ transaction response.
        , bundle'Request_url :: Uri
          -- ^ The URL for this entry, relative to the root (the address 
          --   to which the request is posted).
        , bundle'Request_ifNoneMatch :: Maybe Xsd.XsdString
          -- ^ If the ETag values match, return a 304 Not Modified status. 
          --   See the API documentation for [&quot;Conditional 
          --   Read&quot;](http.html#cread).
        , bundle'Request_ifModifiedSince :: Maybe Instant
          -- ^ Only perform the operation if the last updated date 
          --   matches. See the API documentation for [&quot;Conditional 
          --   Read&quot;](http.html#cread).
        , bundle'Request_ifMatch :: Maybe Xsd.XsdString
          -- ^ Only perform the operation if the Etag value matches. For 
          --   more information, see the API section [&quot;Managing 
          --   Resource Contention&quot;](http.html#concurrency).
        , bundle'Request_ifNoneExist :: Maybe Xsd.XsdString
          -- ^ Instruct the server not to perform the create if a 
          --   specified resource already exists. For further information, 
          --   see the API documentation for [&quot;Conditional 
          --   Create&quot;](http.html#ccreate). This is just the query 
          --   portion of the URL - what follows the &quot;?&quot; (not 
          --   including the &quot;?&quot;).
        }
        deriving (Eq,Show)
instance SchemaType Bundle'Request where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Bundle'Request a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "method"
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "ifNoneMatch")
            `apply` optional (parseSchemaType "ifModifiedSince")
            `apply` optional (parseSchemaType "ifMatch")
            `apply` optional (parseSchemaType "ifNoneExist")
    schemaTypeToXML s x@Bundle'Request{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundle'Request_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundle'Request_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundle'Request_modifierExtension x
            , schemaTypeToXML "method" $ bundle'Request_method x
            , schemaTypeToXML "url" $ bundle'Request_url x
            , maybe [] (schemaTypeToXML "ifNoneMatch") $ bundle'Request_ifNoneMatch x
            , maybe [] (schemaTypeToXML "ifModifiedSince") $ bundle'Request_ifModifiedSince x
            , maybe [] (schemaTypeToXML "ifMatch") $ bundle'Request_ifMatch x
            , maybe [] (schemaTypeToXML "ifNoneExist") $ bundle'Request_ifNoneExist x
            ]
instance Extension Bundle'Request BackboneElement where
    supertype (Bundle'Request a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Bundle'Request Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Bundle'Request -> BackboneElement)
              
 
-- | A container for a collection of resources.
data Bundle'Response = Bundle'Response
        { bundle'Response_id :: Maybe String'primitive
        , bundle'Response_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundle'Response_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundle'Response_status :: Xsd.XsdString
          -- ^ The status code returned by processing this entry. The 
          --   status SHALL start with a 3 digit HTTP code (e.g. 404) and 
          --   may contain the standard HTTP description associated with 
          --   the status code.
        , bundle'Response_location :: Maybe Uri
          -- ^ The location header created by processing this operation.
        , bundle'Response_etag :: Maybe Xsd.XsdString
          -- ^ The etag for the resource, it the operation for the entry 
          --   produced a versioned resource (see [Resource Metadata and 
          --   Versioning](http.html#versioning) and [Managing Resource 
          --   Contention](http.html#concurrency)).
        , bundle'Response_lastModified :: Maybe Instant
          -- ^ The date/time that the resource was modified on the server.
        , bundle'Response_outcome :: Maybe ResourceContainer
          -- ^ An OperationOutcome containing hints and warnings produced 
          --   as part of processing this entry in a batch or transaction.
        }
        deriving (Eq,Show)
instance SchemaType Bundle'Response where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Bundle'Response a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "etag")
            `apply` optional (parseSchemaType "lastModified")
            `apply` optional (parseSchemaType "outcome")
    schemaTypeToXML s x@Bundle'Response{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundle'Response_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundle'Response_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundle'Response_modifierExtension x
            , schemaTypeToXML "status" $ bundle'Response_status x
            , maybe [] (schemaTypeToXML "location") $ bundle'Response_location x
            , maybe [] (schemaTypeToXML "etag") $ bundle'Response_etag x
            , maybe [] (schemaTypeToXML "lastModified") $ bundle'Response_lastModified x
            , maybe [] (schemaTypeToXML "outcome") $ bundle'Response_outcome x
            ]
instance Extension Bundle'Response BackboneElement where
    supertype (Bundle'Response a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Bundle'Response Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Bundle'Response -> BackboneElement)
              
 
data HTTPVerb'list
    = HTTPVerb'list_GET
      -- ^ GET
    | HTTPVerb'list_POST
      -- ^ POST
    | HTTPVerb'list_PUT
      -- ^ PUT
    | HTTPVerb'list_DELETE
      -- ^ DELETE
    deriving (Eq,Show,Enum)
instance SchemaType HTTPVerb'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType HTTPVerb'list where
    acceptingParser =  do literal "GET"; return HTTPVerb'list_GET
                      `onFail` do literal "POST"; return HTTPVerb'list_POST
                      `onFail` do literal "PUT"; return HTTPVerb'list_PUT
                      `onFail` do literal "DELETE"; return HTTPVerb'list_DELETE
                      
    simpleTypeText HTTPVerb'list_GET = "GET"
    simpleTypeText HTTPVerb'list_POST = "POST"
    simpleTypeText HTTPVerb'list_PUT = "PUT"
    simpleTypeText HTTPVerb'list_DELETE = "DELETE"
 
data HTTPVerb = HTTPVerb
        { hTTPVerb_id :: Maybe String'primitive
        , hTTPVerb_value :: Maybe HTTPVerb'list
        , hTTPVerb_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType HTTPVerb where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (HTTPVerb a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@HTTPVerb{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ hTTPVerb_id x
                       , maybe [] (toXMLAttribute "value") $ hTTPVerb_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ hTTPVerb_extension x
            ]
instance Extension HTTPVerb Element where
    supertype (HTTPVerb a0 a1 e0) =
               Element a0 e0
 
data BundleType'list
    = BundleType'list_Document
      -- ^ Document
    | BundleType'list_Message
      -- ^ Message
    | BundleType'list_Transaction
      -- ^ Transaction
    | BundleType'list_Transaction'response
      -- ^ Transaction Response
    | BundleType'list_Batch
      -- ^ Batch
    | BundleType'list_Batch'response
      -- ^ Batch Response
    | BundleType'list_History
      -- ^ History List
    | BundleType'list_Searchset
      -- ^ Search Results
    | BundleType'list_Collection
      -- ^ Collection
    deriving (Eq,Show,Enum)
instance SchemaType BundleType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType BundleType'list where
    acceptingParser =  do literal "document"; return BundleType'list_Document
                      `onFail` do literal "message"; return BundleType'list_Message
                      `onFail` do literal "transaction"; return BundleType'list_Transaction
                      `onFail` do literal "transaction-response"; return BundleType'list_Transaction'response
                      `onFail` do literal "batch"; return BundleType'list_Batch
                      `onFail` do literal "batch-response"; return BundleType'list_Batch'response
                      `onFail` do literal "history"; return BundleType'list_History
                      `onFail` do literal "searchset"; return BundleType'list_Searchset
                      `onFail` do literal "collection"; return BundleType'list_Collection
                      
    simpleTypeText BundleType'list_Document = "document"
    simpleTypeText BundleType'list_Message = "message"
    simpleTypeText BundleType'list_Transaction = "transaction"
    simpleTypeText BundleType'list_Transaction'response = "transaction-response"
    simpleTypeText BundleType'list_Batch = "batch"
    simpleTypeText BundleType'list_Batch'response = "batch-response"
    simpleTypeText BundleType'list_History = "history"
    simpleTypeText BundleType'list_Searchset = "searchset"
    simpleTypeText BundleType'list_Collection = "collection"
 
data BundleType = BundleType
        { bundleType_id :: Maybe String'primitive
        , bundleType_value :: Maybe BundleType'list
        , bundleType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType BundleType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (BundleType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@BundleType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleType_id x
                       , maybe [] (toXMLAttribute "value") $ bundleType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleType_extension x
            ]
instance Extension BundleType Element where
    supertype (BundleType a0 a1 e0) =
               Element a0 e0
 
data SearchEntryMode'list
    = SearchEntryMode'list_Match
      -- ^ Match
    | SearchEntryMode'list_Include
      -- ^ Include
    | SearchEntryMode'list_Outcome
      -- ^ Outcome
    deriving (Eq,Show,Enum)
instance SchemaType SearchEntryMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchEntryMode'list where
    acceptingParser =  do literal "match"; return SearchEntryMode'list_Match
                      `onFail` do literal "include"; return SearchEntryMode'list_Include
                      `onFail` do literal "outcome"; return SearchEntryMode'list_Outcome
                      
    simpleTypeText SearchEntryMode'list_Match = "match"
    simpleTypeText SearchEntryMode'list_Include = "include"
    simpleTypeText SearchEntryMode'list_Outcome = "outcome"
 
data SearchEntryMode = SearchEntryMode
        { searchEntryMode_id :: Maybe String'primitive
        , searchEntryMode_value :: Maybe SearchEntryMode'list
        , searchEntryMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchEntryMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchEntryMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchEntryMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchEntryMode_id x
                       , maybe [] (toXMLAttribute "value") $ searchEntryMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchEntryMode_extension x
            ]
instance Extension SearchEntryMode Element where
    supertype (SearchEntryMode a0 a1 e0) =
               Element a0 e0
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
elementCapabilityStatement :: XMLParser CapabilityStatement
elementCapabilityStatement = parseSchemaType "CapabilityStatement"
elementToXMLCapabilityStatement :: CapabilityStatement -> [Content ()]
elementToXMLCapabilityStatement = schemaTypeToXML "CapabilityStatement"
 
data CapabilityStatement = CapabilityStatement
        { capabilityStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , capabilityStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , capabilityStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , capabilityStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , capabilityStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , capabilityStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , capabilityStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this capability 
          --   statement when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   capability statement is (or will be) published. The URL 
          --   SHOULD include the major version of the capability 
          --   statement. For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , capabilityStatement_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   capability statement when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the capability statement author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , capabilityStatement_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the capability 
          --   statement. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , capabilityStatement_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   capability statement.
        , capabilityStatement_status :: PublicationStatus
          -- ^ The status of this capability statement. Enables tracking 
          --   the life-cycle of the content.
        , capabilityStatement_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this capability statement 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , capabilityStatement_date :: DateTime
          -- ^ The date (and optionally time) when the capability 
          --   statement was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the capability statement changes.
        , capabilityStatement_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the capability statement.
        , capabilityStatement_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , capabilityStatement_description :: Maybe Markdown
          -- ^ A free text natural language description of the capability 
          --   statement from a consumer's perspective. Typically, this is 
          --   used when the capability statement describes a desired 
          --   rather than an actual solution, for example as a formal 
          --   expression of requirements as part of an RFP.
        , capabilityStatement_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   capability statement instances.
        , capabilityStatement_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the capability 
          --   statement is intended to be used.
        , capabilityStatement_purpose :: Maybe Markdown
          -- ^ Explaination of why this capability statement is needed and 
          --   why it has been designed as it has.
        , capabilityStatement_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the capability statement 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   capability statement.
        , capabilityStatement_kind :: CapabilityStatementKind
          -- ^ The way that this statement is intended to be used, to 
          --   describe an actual running instance of software, a 
          --   particular product (kind not instance of software) or a 
          --   class of implementation (e.g. a desired purchase).
        , capabilityStatement_instantiates :: [Uri]
          -- ^ Reference to a canonical URL of another CapabilityStatement 
          --   that this software implements or uses. This capability 
          --   statement is a published API description that corresponds 
          --   to a business service. The rest of the capability statement 
          --   does not need to repeat the details of the referenced 
          --   resource, but can do so.
        , capabilityStatement_software :: Maybe CapabilityStatement'Software
          -- ^ Software that is covered by this capability statement. It 
          --   is used when the capability statement describes the 
          --   capabilities of a particular software version, independent 
          --   of an installation.
        , capabilityStatement_implementation :: Maybe CapabilityStatement'Implementation
          -- ^ Identifies a specific implementation instance that is 
          --   described by the capability statement - i.e. a particular 
          --   installation, rather than the capabilities of a software 
          --   program.
        , capabilityStatement_fhirVersion :: Id
          -- ^ The version of the FHIR specification on which this 
          --   capability statement is based.
        , capabilityStatement_acceptUnknown :: UnknownContentCode
          -- ^ A code that indicates whether the application accepts 
          --   unknown elements or extensions when reading resources.
        , capabilityStatement_format :: [Code]
          -- ^ A list of the formats supported by this implementation 
          --   using their content types.
        , capabilityStatement_patchFormat :: [Code]
          -- ^ A list of the patch formats supported by this 
          --   implementation using their content types.
        , capabilityStatement_implementationGuide :: [Uri]
          -- ^ A list of implementation guides that the server does (or 
          --   should) support in their entirety.
        , capabilityStatement_profile :: [Reference]
          -- ^ A list of profiles that represent different use cases 
          --   supported by the system. For a server, &quot;supported by 
          --   the system&quot; means the system hosts/produces a set of 
          --   resources that are conformant to a particular profile, and 
          --   allows clients that use its services to search using this 
          --   profile and to find appropriate data. For a client, it 
          --   means the system will search by this profile and process 
          --   data according to the guidance implicit in the profile. See 
          --   further discussion in [Using 
          --   Profiles](profiling.html#profile-uses).
        , capabilityStatement_rest :: [CapabilityStatement'Rest]
          -- ^ A definition of the restful capabilities of the solution, 
          --   if any.
        , capabilityStatement_messaging :: [CapabilityStatement'Messaging]
          -- ^ A description of the messaging capabilities of the 
          --   solution.
        , capabilityStatement_document :: [CapabilityStatement'Document]
          -- ^ A document definition.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CapabilityStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` parseSchemaType "kind"
            `apply` many (parseSchemaType "instantiates")
            `apply` optional (parseSchemaType "software")
            `apply` optional (parseSchemaType "implementation")
            `apply` parseSchemaType "fhirVersion"
            `apply` parseSchemaType "acceptUnknown"
            `apply` many1 (parseSchemaType "format")
            `apply` many (parseSchemaType "patchFormat")
            `apply` many (parseSchemaType "implementationGuide")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "rest")
            `apply` many (parseSchemaType "messaging")
            `apply` many (parseSchemaType "document")
    schemaTypeToXML s x@CapabilityStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ capabilityStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ capabilityStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ capabilityStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ capabilityStatement_language x
            , maybe [] (schemaTypeToXML "text") $ capabilityStatement_text x
            , concatMap (schemaTypeToXML "contained") $ capabilityStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ capabilityStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ capabilityStatement_url x
            , maybe [] (schemaTypeToXML "version") $ capabilityStatement_version x
            , maybe [] (schemaTypeToXML "name") $ capabilityStatement_name x
            , maybe [] (schemaTypeToXML "title") $ capabilityStatement_title x
            , schemaTypeToXML "status" $ capabilityStatement_status x
            , maybe [] (schemaTypeToXML "experimental") $ capabilityStatement_experimental x
            , schemaTypeToXML "date" $ capabilityStatement_date x
            , maybe [] (schemaTypeToXML "publisher") $ capabilityStatement_publisher x
            , concatMap (schemaTypeToXML "contact") $ capabilityStatement_contact x
            , maybe [] (schemaTypeToXML "description") $ capabilityStatement_description x
            , concatMap (schemaTypeToXML "useContext") $ capabilityStatement_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ capabilityStatement_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ capabilityStatement_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ capabilityStatement_copyright x
            , schemaTypeToXML "kind" $ capabilityStatement_kind x
            , concatMap (schemaTypeToXML "instantiates") $ capabilityStatement_instantiates x
            , maybe [] (schemaTypeToXML "software") $ capabilityStatement_software x
            , maybe [] (schemaTypeToXML "implementation") $ capabilityStatement_implementation x
            , schemaTypeToXML "fhirVersion" $ capabilityStatement_fhirVersion x
            , schemaTypeToXML "acceptUnknown" $ capabilityStatement_acceptUnknown x
            , concatMap (schemaTypeToXML "format") $ capabilityStatement_format x
            , concatMap (schemaTypeToXML "patchFormat") $ capabilityStatement_patchFormat x
            , concatMap (schemaTypeToXML "implementationGuide") $ capabilityStatement_implementationGuide x
            , concatMap (schemaTypeToXML "profile") $ capabilityStatement_profile x
            , concatMap (schemaTypeToXML "rest") $ capabilityStatement_rest x
            , concatMap (schemaTypeToXML "messaging") $ capabilityStatement_messaging x
            , concatMap (schemaTypeToXML "document") $ capabilityStatement_document x
            ]
instance Extension CapabilityStatement DomainResource where
    supertype (CapabilityStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CapabilityStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CapabilityStatement -> DomainResource)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Software = CapabilityStatement'Software
        { capabilityStatement'Software_id :: Maybe String'primitive
        , capabilityStatement'Software_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Software_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Software_name :: Xsd.XsdString
          -- ^ Name software is known by.
        , capabilityStatement'Software_version :: Maybe Xsd.XsdString
          -- ^ The version identifier for the software covered by this 
          --   statement.
        , capabilityStatement'Software_releaseDate :: Maybe DateTime
          -- ^ Date this version of the software was released.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Software where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Software a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "releaseDate")
    schemaTypeToXML s x@CapabilityStatement'Software{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Software_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Software_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Software_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatement'Software_name x
            , maybe [] (schemaTypeToXML "version") $ capabilityStatement'Software_version x
            , maybe [] (schemaTypeToXML "releaseDate") $ capabilityStatement'Software_releaseDate x
            ]
instance Extension CapabilityStatement'Software BackboneElement where
    supertype (CapabilityStatement'Software a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Software Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Software -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Implementation = CapabilityStatement'Implementation
        { capabilityStatement'Implementation_id :: Maybe String'primitive
        , capabilityStatement'Implementation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Implementation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Implementation_description :: Xsd.XsdString
          -- ^ Information about the specific installation that this 
          --   capability statement relates to.
        , capabilityStatement'Implementation_url :: Maybe Uri
          -- ^ An absolute base URL for the implementation. This forms the 
          --   base for REST interfaces as well as the mailbox and 
          --   document interfaces.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Implementation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Implementation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@CapabilityStatement'Implementation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Implementation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Implementation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Implementation_modifierExtension x
            , schemaTypeToXML "description" $ capabilityStatement'Implementation_description x
            , maybe [] (schemaTypeToXML "url") $ capabilityStatement'Implementation_url x
            ]
instance Extension CapabilityStatement'Implementation BackboneElement where
    supertype (CapabilityStatement'Implementation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Implementation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Implementation -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Rest = CapabilityStatement'Rest
        { capabilityStatement'Rest_id :: Maybe String'primitive
        , capabilityStatement'Rest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Rest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Rest_mode :: RestfulCapabilityMode
          -- ^ Identifies whether this portion of the statement is 
          --   describing the ability to initiate or receive restful 
          --   operations.
        , capabilityStatement'Rest_documentation :: Maybe Xsd.XsdString
          -- ^ Information about the system's restful capabilities that 
          --   apply across all applications, such as security.
        , capabilityStatement'Rest_security :: Maybe CapabilityStatement'Security
          -- ^ Information about security implementation from an interface 
          --   perspective - what a client needs to know.
        , capabilityStatement'Rest_resource :: [CapabilityStatement'Resource]
          -- ^ A specification of the restful capabilities of the solution 
          --   for a specific resource type.
        , capabilityStatement'Rest_interaction :: [CapabilityStatement'Interaction1]
          -- ^ A specification of restful operations supported by the 
          --   system.
        , capabilityStatement'Rest_searchParam :: [CapabilityStatement'SearchParam]
          -- ^ Search parameters that are supported for searching all 
          --   resources for implementations to support and/or make use of 
          --   - either references to ones defined in the specification, 
          --   or additional ones defined for/by the implementation.
        , capabilityStatement'Rest_operation :: [CapabilityStatement'Operation]
          -- ^ Definition of an operation or a named query together with 
          --   its parameters and their meaning and type.
        , capabilityStatement'Rest_compartment :: [Uri]
          -- ^ An absolute URI which is a reference to the definition of a 
          --   compartment that the system supports. The reference is to a 
          --   CompartmentDefinition resource by its canonical URL .
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Rest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Rest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
            `apply` optional (parseSchemaType "security")
            `apply` many (parseSchemaType "resource")
            `apply` many (parseSchemaType "interaction")
            `apply` many (parseSchemaType "searchParam")
            `apply` many (parseSchemaType "operation")
            `apply` many (parseSchemaType "compartment")
    schemaTypeToXML s x@CapabilityStatement'Rest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Rest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Rest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Rest_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatement'Rest_mode x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Rest_documentation x
            , maybe [] (schemaTypeToXML "security") $ capabilityStatement'Rest_security x
            , concatMap (schemaTypeToXML "resource") $ capabilityStatement'Rest_resource x
            , concatMap (schemaTypeToXML "interaction") $ capabilityStatement'Rest_interaction x
            , concatMap (schemaTypeToXML "searchParam") $ capabilityStatement'Rest_searchParam x
            , concatMap (schemaTypeToXML "operation") $ capabilityStatement'Rest_operation x
            , concatMap (schemaTypeToXML "compartment") $ capabilityStatement'Rest_compartment x
            ]
instance Extension CapabilityStatement'Rest BackboneElement where
    supertype (CapabilityStatement'Rest a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Rest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Rest -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Security = CapabilityStatement'Security
        { capabilityStatement'Security_id :: Maybe String'primitive
        , capabilityStatement'Security_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Security_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Security_cors :: Maybe Boolean
          -- ^ Server adds CORS headers when responding to requests - this 
          --   enables javascript applications to use the server.
        , capabilityStatement'Security_service :: [CodeableConcept]
          -- ^ Types of security services that are supported/required by 
          --   the system.
        , capabilityStatement'Security_description :: Maybe Xsd.XsdString
          -- ^ General description of how security works.
        , capabilityStatement'Security_certificate :: [CapabilityStatement'Certificate]
          -- ^ Certificates associated with security profiles.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Security where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Security a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "cors")
            `apply` many (parseSchemaType "service")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "certificate")
    schemaTypeToXML s x@CapabilityStatement'Security{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Security_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Security_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Security_modifierExtension x
            , maybe [] (schemaTypeToXML "cors") $ capabilityStatement'Security_cors x
            , concatMap (schemaTypeToXML "service") $ capabilityStatement'Security_service x
            , maybe [] (schemaTypeToXML "description") $ capabilityStatement'Security_description x
            , concatMap (schemaTypeToXML "certificate") $ capabilityStatement'Security_certificate x
            ]
instance Extension CapabilityStatement'Security BackboneElement where
    supertype (CapabilityStatement'Security a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Security Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Security -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Certificate = CapabilityStatement'Certificate
        { capabilityStatement'Certificate_id :: Maybe String'primitive
        , capabilityStatement'Certificate_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Certificate_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Certificate_type :: Maybe Code
          -- ^ Mime type for a certificate.
        , capabilityStatement'Certificate_blob :: Maybe Base64Binary
          -- ^ Actual certificate.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Certificate where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Certificate a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "blob")
    schemaTypeToXML s x@CapabilityStatement'Certificate{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Certificate_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Certificate_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Certificate_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ capabilityStatement'Certificate_type x
            , maybe [] (schemaTypeToXML "blob") $ capabilityStatement'Certificate_blob x
            ]
instance Extension CapabilityStatement'Certificate BackboneElement where
    supertype (CapabilityStatement'Certificate a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Certificate Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Certificate -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Resource = CapabilityStatement'Resource
        { capabilityStatement'Resource_id :: Maybe String'primitive
        , capabilityStatement'Resource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Resource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Resource_type :: ResourceType
          -- ^ A type of resource exposed via the restful interface.
        , capabilityStatement'Resource_profile :: Maybe Reference
          -- ^ A specification of the profile that describes the 
          --   solution's overall support for the resource, including any 
          --   constraints on cardinality, bindings, lengths or other 
          --   limitations. See further discussion in [Using 
          --   Profiles](profiling.html#profile-uses).
        , capabilityStatement'Resource_documentation :: Maybe Markdown
          -- ^ Additional information about the resource type used by the 
          --   system.
        , capabilityStatement'Resource_interaction :: [CapabilityStatement'Interaction]
          -- ^ Identifies a restful operation supported by the solution.
        , capabilityStatement'Resource_versioning :: Maybe ResourceVersionPolicy
          -- ^ This field is set to no-version to specify that the system 
          --   does not support (server) or use (client) versioning for 
          --   this resource type. If this has some other value, the 
          --   server must at least correctly track and populate the 
          --   versionId meta-property on resources. If the value is 
          --   'versioned-update', then the server supports all the 
          --   versioning features, including using e-tags for version 
          --   integrity in the API.
        , capabilityStatement'Resource_readHistory :: Maybe Boolean
          -- ^ A flag for whether the server is able to return past 
          --   versions as part of the vRead operation.
        , capabilityStatement'Resource_updateCreate :: Maybe Boolean
          -- ^ A flag to indicate that the server allows or needs to allow 
          --   the client to create new identities on the server (e.g. 
          --   that is, the client PUTs to a location where there is no 
          --   existing resource). Allowing this operation means that the 
          --   server allows the client to create new identities on the 
          --   server.
        , capabilityStatement'Resource_conditionalCreate :: Maybe Boolean
          -- ^ A flag that indicates that the server supports conditional 
          --   create.
        , capabilityStatement'Resource_conditionalRead :: Maybe ConditionalReadStatus
          -- ^ A code that indicates how the server supports conditional 
          --   read.
        , capabilityStatement'Resource_conditionalUpdate :: Maybe Boolean
          -- ^ A flag that indicates that the server supports conditional 
          --   update.
        , capabilityStatement'Resource_conditionalDelete :: Maybe ConditionalDeleteStatus
          -- ^ A code that indicates how the server supports conditional 
          --   delete.
        , capabilityStatement'Resource_referencePolicy :: [ReferenceHandlingPolicy]
          -- ^ A set of flags that defines how references are supported.
        , capabilityStatement'Resource_searchInclude :: [Xsd.XsdString]
          -- ^ A list of _include values supported by the server.
        , capabilityStatement'Resource_searchRevInclude :: [Xsd.XsdString]
          -- ^ A list of _revinclude (reverse include) values supported by 
          --   the server.
        , capabilityStatement'Resource_searchParam :: [CapabilityStatement'SearchParam]
          -- ^ Search parameters for implementations to support and/or 
          --   make use of - either references to ones defined in the 
          --   specification, or additional ones defined for/by the 
          --   implementation.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Resource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Resource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "documentation")
            `apply` many1 (parseSchemaType "interaction")
            `apply` optional (parseSchemaType "versioning")
            `apply` optional (parseSchemaType "readHistory")
            `apply` optional (parseSchemaType "updateCreate")
            `apply` optional (parseSchemaType "conditionalCreate")
            `apply` optional (parseSchemaType "conditionalRead")
            `apply` optional (parseSchemaType "conditionalUpdate")
            `apply` optional (parseSchemaType "conditionalDelete")
            `apply` many (parseSchemaType "referencePolicy")
            `apply` many (parseSchemaType "searchInclude")
            `apply` many (parseSchemaType "searchRevInclude")
            `apply` many (parseSchemaType "searchParam")
    schemaTypeToXML s x@CapabilityStatement'Resource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Resource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Resource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Resource_modifierExtension x
            , schemaTypeToXML "type" $ capabilityStatement'Resource_type x
            , maybe [] (schemaTypeToXML "profile") $ capabilityStatement'Resource_profile x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Resource_documentation x
            , concatMap (schemaTypeToXML "interaction") $ capabilityStatement'Resource_interaction x
            , maybe [] (schemaTypeToXML "versioning") $ capabilityStatement'Resource_versioning x
            , maybe [] (schemaTypeToXML "readHistory") $ capabilityStatement'Resource_readHistory x
            , maybe [] (schemaTypeToXML "updateCreate") $ capabilityStatement'Resource_updateCreate x
            , maybe [] (schemaTypeToXML "conditionalCreate") $ capabilityStatement'Resource_conditionalCreate x
            , maybe [] (schemaTypeToXML "conditionalRead") $ capabilityStatement'Resource_conditionalRead x
            , maybe [] (schemaTypeToXML "conditionalUpdate") $ capabilityStatement'Resource_conditionalUpdate x
            , maybe [] (schemaTypeToXML "conditionalDelete") $ capabilityStatement'Resource_conditionalDelete x
            , concatMap (schemaTypeToXML "referencePolicy") $ capabilityStatement'Resource_referencePolicy x
            , concatMap (schemaTypeToXML "searchInclude") $ capabilityStatement'Resource_searchInclude x
            , concatMap (schemaTypeToXML "searchRevInclude") $ capabilityStatement'Resource_searchRevInclude x
            , concatMap (schemaTypeToXML "searchParam") $ capabilityStatement'Resource_searchParam x
            ]
instance Extension CapabilityStatement'Resource BackboneElement where
    supertype (CapabilityStatement'Resource a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Resource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Resource -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Interaction = CapabilityStatement'Interaction
        { capabilityStatement'Interaction_id :: Maybe String'primitive
        , capabilityStatement'Interaction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Interaction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Interaction_code :: TypeRestfulInteraction
          -- ^ Coded identifier of the operation, supported by the system 
          --   resource.
        , capabilityStatement'Interaction_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance specific to the implementation of this operation, 
          --   such as 'delete is a logical delete' or 'updates are only 
          --   allowed with version id' or 'creates permitted from 
          --   pre-authorized certificates only'.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Interaction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Interaction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatement'Interaction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Interaction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Interaction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Interaction_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatement'Interaction_code x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Interaction_documentation x
            ]
instance Extension CapabilityStatement'Interaction BackboneElement where
    supertype (CapabilityStatement'Interaction a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Interaction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Interaction -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'SearchParam = CapabilityStatement'SearchParam
        { capabilityStatement'SearchParam_id :: Maybe String'primitive
        , capabilityStatement'SearchParam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'SearchParam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'SearchParam_name :: Xsd.XsdString
          -- ^ The name of the search parameter used in the interface.
        , capabilityStatement'SearchParam_definition :: Maybe Uri
          -- ^ An absolute URI that is a formal reference to where this 
          --   parameter was first defined, so that a client can be 
          --   confident of the meaning of the search parameter (a 
          --   reference to [[[SearchParameter.url]]]).
        , capabilityStatement'SearchParam_type :: SearchParamType
          -- ^ The type of value a search parameter refers to, and how the 
          --   content is interpreted.
        , capabilityStatement'SearchParam_documentation :: Maybe Xsd.XsdString
          -- ^ This allows documentation of any distinct behaviors about 
          --   how the search parameter is used. For example, text 
          --   matching algorithms.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'SearchParam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'SearchParam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "definition")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatement'SearchParam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'SearchParam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'SearchParam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'SearchParam_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatement'SearchParam_name x
            , maybe [] (schemaTypeToXML "definition") $ capabilityStatement'SearchParam_definition x
            , schemaTypeToXML "type" $ capabilityStatement'SearchParam_type x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'SearchParam_documentation x
            ]
instance Extension CapabilityStatement'SearchParam BackboneElement where
    supertype (CapabilityStatement'SearchParam a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'SearchParam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'SearchParam -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Interaction1 = CapabilityStatement'Interaction1
        { capabilityStatement'Interaction1_id :: Maybe String'primitive
        , capabilityStatement'Interaction1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Interaction1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Interaction1_code :: SystemRestfulInteraction
          -- ^ A coded identifier of the operation, supported by the 
          --   system.
        , capabilityStatement'Interaction1_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance specific to the implementation of this operation, 
          --   such as limitations on the kind of transactions allowed, or 
          --   information about system wide search is implemented.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Interaction1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Interaction1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatement'Interaction1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Interaction1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Interaction1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Interaction1_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatement'Interaction1_code x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Interaction1_documentation x
            ]
instance Extension CapabilityStatement'Interaction1 BackboneElement where
    supertype (CapabilityStatement'Interaction1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Interaction1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Interaction1 -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Operation = CapabilityStatement'Operation
        { capabilityStatement'Operation_id :: Maybe String'primitive
        , capabilityStatement'Operation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Operation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Operation_name :: Xsd.XsdString
          -- ^ The name of the operation or query. For an operation, this 
          --   is the name prefixed with $ and used in the URL. For a 
          --   query, this is the name used in the _query parameter when 
          --   the query is called.
        , capabilityStatement'Operation_definition :: Reference
          -- ^ Where the formal definition can be found.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Operation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Operation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "definition"
    schemaTypeToXML s x@CapabilityStatement'Operation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Operation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Operation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Operation_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatement'Operation_name x
            , schemaTypeToXML "definition" $ capabilityStatement'Operation_definition x
            ]
instance Extension CapabilityStatement'Operation BackboneElement where
    supertype (CapabilityStatement'Operation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Operation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Operation -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Messaging = CapabilityStatement'Messaging
        { capabilityStatement'Messaging_id :: Maybe String'primitive
        , capabilityStatement'Messaging_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Messaging_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Messaging_endpoint :: [CapabilityStatement'Endpoint]
          -- ^ An endpoint (network accessible address) to which messages 
          --   and/or replies are to be sent.
        , capabilityStatement'Messaging_reliableCache :: Maybe UnsignedInt
          -- ^ Length if the receiver's reliable messaging cache in 
          --   minutes (if a receiver) or how long the cache length on the 
          --   receiver should be (if a sender).
        , capabilityStatement'Messaging_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation about the system's messaging capabilities for 
          --   this endpoint not otherwise documented by the capability 
          --   statement. For example, the process for becoming an 
          --   authorized messaging exchange partner.
        , capabilityStatement'Messaging_supportedMessage :: [CapabilityStatement'SupportedMessage]
          -- ^ References to message definitions for messages this system 
          --   can send or receive.
        , capabilityStatement'Messaging_event :: [CapabilityStatement'Event]
          -- ^ A description of the solution's support for an event at 
          --   this end-point.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Messaging where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Messaging a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "reliableCache")
            `apply` optional (parseSchemaType "documentation")
            `apply` many (parseSchemaType "supportedMessage")
            `apply` many (parseSchemaType "event")
    schemaTypeToXML s x@CapabilityStatement'Messaging{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Messaging_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Messaging_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Messaging_modifierExtension x
            , concatMap (schemaTypeToXML "endpoint") $ capabilityStatement'Messaging_endpoint x
            , maybe [] (schemaTypeToXML "reliableCache") $ capabilityStatement'Messaging_reliableCache x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Messaging_documentation x
            , concatMap (schemaTypeToXML "supportedMessage") $ capabilityStatement'Messaging_supportedMessage x
            , concatMap (schemaTypeToXML "event") $ capabilityStatement'Messaging_event x
            ]
instance Extension CapabilityStatement'Messaging BackboneElement where
    supertype (CapabilityStatement'Messaging a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Messaging Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Messaging -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Endpoint = CapabilityStatement'Endpoint
        { capabilityStatement'Endpoint_id :: Maybe String'primitive
        , capabilityStatement'Endpoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Endpoint_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Endpoint_protocol :: Coding
          -- ^ A list of the messaging transport protocol(s) identifiers, 
          --   supported by this endpoint.
        , capabilityStatement'Endpoint_address :: Uri
          -- ^ The network address of the end-point. For solutions that do 
          --   not use network addresses for routing, it can be just an 
          --   identifier.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Endpoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Endpoint a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "protocol"
            `apply` parseSchemaType "address"
    schemaTypeToXML s x@CapabilityStatement'Endpoint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Endpoint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Endpoint_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Endpoint_modifierExtension x
            , schemaTypeToXML "protocol" $ capabilityStatement'Endpoint_protocol x
            , schemaTypeToXML "address" $ capabilityStatement'Endpoint_address x
            ]
instance Extension CapabilityStatement'Endpoint BackboneElement where
    supertype (CapabilityStatement'Endpoint a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Endpoint Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Endpoint -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'SupportedMessage = CapabilityStatement'SupportedMessage
        { capabilityStatement'SupportedMessage_id :: Maybe String'primitive
        , capabilityStatement'SupportedMessage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'SupportedMessage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'SupportedMessage_mode :: EventCapabilityMode
          -- ^ The mode of this event declaration - whether application is 
          --   sender or receiver.
        , capabilityStatement'SupportedMessage_definition :: Reference
          -- ^ Points to a message definition that identifies the 
          --   messaging event, message structure, allowed responses, etc.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'SupportedMessage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'SupportedMessage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` parseSchemaType "definition"
    schemaTypeToXML s x@CapabilityStatement'SupportedMessage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'SupportedMessage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'SupportedMessage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'SupportedMessage_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatement'SupportedMessage_mode x
            , schemaTypeToXML "definition" $ capabilityStatement'SupportedMessage_definition x
            ]
instance Extension CapabilityStatement'SupportedMessage BackboneElement where
    supertype (CapabilityStatement'SupportedMessage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'SupportedMessage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'SupportedMessage -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Event = CapabilityStatement'Event
        { capabilityStatement'Event_id :: Maybe String'primitive
        , capabilityStatement'Event_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Event_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Event_code :: Coding
          -- ^ A coded identifier of a supported messaging event.
        , capabilityStatement'Event_category :: Maybe MessageSignificanceCategory
          -- ^ The impact of the content of the message.
        , capabilityStatement'Event_mode :: EventCapabilityMode
          -- ^ The mode of this event declaration - whether an application 
          --   is a sender or receiver.
        , capabilityStatement'Event_focus :: ResourceType
          -- ^ A resource associated with the event. This is the resource 
          --   that defines the event.
        , capabilityStatement'Event_request :: Reference
          -- ^ Information about the request for this event.
        , capabilityStatement'Event_response :: Reference
          -- ^ Information about the response for this event.
        , capabilityStatement'Event_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance on how this event is handled, such as internal 
          --   system trigger points, business rules, etc.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Event where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Event a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "mode"
            `apply` parseSchemaType "focus"
            `apply` parseSchemaType "request"
            `apply` parseSchemaType "response"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatement'Event{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Event_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Event_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Event_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatement'Event_code x
            , maybe [] (schemaTypeToXML "category") $ capabilityStatement'Event_category x
            , schemaTypeToXML "mode" $ capabilityStatement'Event_mode x
            , schemaTypeToXML "focus" $ capabilityStatement'Event_focus x
            , schemaTypeToXML "request" $ capabilityStatement'Event_request x
            , schemaTypeToXML "response" $ capabilityStatement'Event_response x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Event_documentation x
            ]
instance Extension CapabilityStatement'Event BackboneElement where
    supertype (CapabilityStatement'Event a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Event Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Event -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatement'Document = CapabilityStatement'Document
        { capabilityStatement'Document_id :: Maybe String'primitive
        , capabilityStatement'Document_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement'Document_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement'Document_mode :: DocumentMode
          -- ^ Mode of this document declaration - whether an application 
          --   is a producer or consumer.
        , capabilityStatement'Document_documentation :: Maybe Xsd.XsdString
          -- ^ A description of how the application supports or uses the 
          --   specified document profile. For example, when documents are 
          --   created, what action is taken with consumed documents, etc.
        , capabilityStatement'Document_profile :: Reference
          -- ^ A constraint on a resource used in the document.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement'Document where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatement'Document a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@CapabilityStatement'Document{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatement'Document_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatement'Document_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement'Document_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatement'Document_mode x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatement'Document_documentation x
            , schemaTypeToXML "profile" $ capabilityStatement'Document_profile x
            ]
instance Extension CapabilityStatement'Document BackboneElement where
    supertype (CapabilityStatement'Document a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatement'Document Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatement'Document -> BackboneElement)
              
 
data CapabilityStatementKind'list
    = CapabilityStatementKind'list_Instance
      -- ^ Instance
    | CapabilityStatementKind'list_Capability
      -- ^ Capability
    | CapabilityStatementKind'list_Requirements
      -- ^ Requirements
    deriving (Eq,Show,Enum)
instance SchemaType CapabilityStatementKind'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CapabilityStatementKind'list where
    acceptingParser =  do literal "instance"; return CapabilityStatementKind'list_Instance
                      `onFail` do literal "capability"; return CapabilityStatementKind'list_Capability
                      `onFail` do literal "requirements"; return CapabilityStatementKind'list_Requirements
                      
    simpleTypeText CapabilityStatementKind'list_Instance = "instance"
    simpleTypeText CapabilityStatementKind'list_Capability = "capability"
    simpleTypeText CapabilityStatementKind'list_Requirements = "requirements"
 
data CapabilityStatementKind = CapabilityStatementKind
        { capabilityStatementKind_id :: Maybe String'primitive
        , capabilityStatementKind_value :: Maybe CapabilityStatementKind'list
        , capabilityStatementKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CapabilityStatementKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CapabilityStatementKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementKind_id x
                       , maybe [] (toXMLAttribute "value") $ capabilityStatementKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementKind_extension x
            ]
instance Extension CapabilityStatementKind Element where
    supertype (CapabilityStatementKind a0 a1 e0) =
               Element a0 e0
 
data EventCapabilityMode'list
    = EventCapabilityMode'list_Sender
      -- ^ Sender
    | EventCapabilityMode'list_Receiver
      -- ^ Receiver
    deriving (Eq,Show,Enum)
instance SchemaType EventCapabilityMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventCapabilityMode'list where
    acceptingParser =  do literal "sender"; return EventCapabilityMode'list_Sender
                      `onFail` do literal "receiver"; return EventCapabilityMode'list_Receiver
                      
    simpleTypeText EventCapabilityMode'list_Sender = "sender"
    simpleTypeText EventCapabilityMode'list_Receiver = "receiver"
 
data EventCapabilityMode = EventCapabilityMode
        { eventCapabilityMode_id :: Maybe String'primitive
        , eventCapabilityMode_value :: Maybe EventCapabilityMode'list
        , eventCapabilityMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventCapabilityMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventCapabilityMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventCapabilityMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventCapabilityMode_id x
                       , maybe [] (toXMLAttribute "value") $ eventCapabilityMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventCapabilityMode_extension x
            ]
instance Extension EventCapabilityMode Element where
    supertype (EventCapabilityMode a0 a1 e0) =
               Element a0 e0
 
data ResourceVersionPolicy'list
    = ResourceVersionPolicy'list_No'version
      -- ^ No VersionId Support
    | ResourceVersionPolicy'list_Versioned
      -- ^ Versioned
    | ResourceVersionPolicy'list_Versioned'update
      -- ^ VersionId tracked fully
    deriving (Eq,Show,Enum)
instance SchemaType ResourceVersionPolicy'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResourceVersionPolicy'list where
    acceptingParser =  do literal "no-version"; return ResourceVersionPolicy'list_No'version
                      `onFail` do literal "versioned"; return ResourceVersionPolicy'list_Versioned
                      `onFail` do literal "versioned-update"; return ResourceVersionPolicy'list_Versioned'update
                      
    simpleTypeText ResourceVersionPolicy'list_No'version = "no-version"
    simpleTypeText ResourceVersionPolicy'list_Versioned = "versioned"
    simpleTypeText ResourceVersionPolicy'list_Versioned'update = "versioned-update"
 
data ResourceVersionPolicy = ResourceVersionPolicy
        { resourceVersionPolicy_id :: Maybe String'primitive
        , resourceVersionPolicy_value :: Maybe ResourceVersionPolicy'list
        , resourceVersionPolicy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResourceVersionPolicy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResourceVersionPolicy a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResourceVersionPolicy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ resourceVersionPolicy_id x
                       , maybe [] (toXMLAttribute "value") $ resourceVersionPolicy_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ resourceVersionPolicy_extension x
            ]
instance Extension ResourceVersionPolicy Element where
    supertype (ResourceVersionPolicy a0 a1 e0) =
               Element a0 e0
 
data MessageSignificanceCategory'list
    = MessageSignificanceCategory'list_Consequence
      -- ^ Consequence
    | MessageSignificanceCategory'list_Currency
      -- ^ Currency
    | MessageSignificanceCategory'list_Notification
      -- ^ Notification
    deriving (Eq,Show,Enum)
instance SchemaType MessageSignificanceCategory'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MessageSignificanceCategory'list where
    acceptingParser =  do literal "Consequence"; return MessageSignificanceCategory'list_Consequence
                      `onFail` do literal "Currency"; return MessageSignificanceCategory'list_Currency
                      `onFail` do literal "Notification"; return MessageSignificanceCategory'list_Notification
                      
    simpleTypeText MessageSignificanceCategory'list_Consequence = "Consequence"
    simpleTypeText MessageSignificanceCategory'list_Currency = "Currency"
    simpleTypeText MessageSignificanceCategory'list_Notification = "Notification"
 
data MessageSignificanceCategory = MessageSignificanceCategory
        { messageSignificanceCategory_id :: Maybe String'primitive
        , messageSignificanceCategory_value :: Maybe MessageSignificanceCategory'list
        , messageSignificanceCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MessageSignificanceCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MessageSignificanceCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MessageSignificanceCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageSignificanceCategory_id x
                       , maybe [] (toXMLAttribute "value") $ messageSignificanceCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageSignificanceCategory_extension x
            ]
instance Extension MessageSignificanceCategory Element where
    supertype (MessageSignificanceCategory a0 a1 e0) =
               Element a0 e0
 
data DocumentMode'list
    = DocumentMode'list_Producer
      -- ^ Producer
    | DocumentMode'list_Consumer
      -- ^ Consumer
    deriving (Eq,Show,Enum)
instance SchemaType DocumentMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentMode'list where
    acceptingParser =  do literal "producer"; return DocumentMode'list_Producer
                      `onFail` do literal "consumer"; return DocumentMode'list_Consumer
                      
    simpleTypeText DocumentMode'list_Producer = "producer"
    simpleTypeText DocumentMode'list_Consumer = "consumer"
 
data DocumentMode = DocumentMode
        { documentMode_id :: Maybe String'primitive
        , documentMode_value :: Maybe DocumentMode'list
        , documentMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentMode_id x
                       , maybe [] (toXMLAttribute "value") $ documentMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentMode_extension x
            ]
instance Extension DocumentMode Element where
    supertype (DocumentMode a0 a1 e0) =
               Element a0 e0
 
data RestfulCapabilityMode'list
    = RestfulCapabilityMode'list_Client
      -- ^ Client
    | RestfulCapabilityMode'list_Server
      -- ^ Server
    deriving (Eq,Show,Enum)
instance SchemaType RestfulCapabilityMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RestfulCapabilityMode'list where
    acceptingParser =  do literal "client"; return RestfulCapabilityMode'list_Client
                      `onFail` do literal "server"; return RestfulCapabilityMode'list_Server
                      
    simpleTypeText RestfulCapabilityMode'list_Client = "client"
    simpleTypeText RestfulCapabilityMode'list_Server = "server"
 
data RestfulCapabilityMode = RestfulCapabilityMode
        { restfulCapabilityMode_id :: Maybe String'primitive
        , restfulCapabilityMode_value :: Maybe RestfulCapabilityMode'list
        , restfulCapabilityMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RestfulCapabilityMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RestfulCapabilityMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RestfulCapabilityMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ restfulCapabilityMode_id x
                       , maybe [] (toXMLAttribute "value") $ restfulCapabilityMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ restfulCapabilityMode_extension x
            ]
instance Extension RestfulCapabilityMode Element where
    supertype (RestfulCapabilityMode a0 a1 e0) =
               Element a0 e0
 
data UnknownContentCode'list
    = UnknownContentCode'list_No
      -- ^ Neither Elements or Extensions
    | UnknownContentCode'list_Extensions
      -- ^ Unknown Extensions
    | UnknownContentCode'list_Elements
      -- ^ Unknown Elements
    | UnknownContentCode'list_Both
      -- ^ Unknown Elements and Extensions
    deriving (Eq,Show,Enum)
instance SchemaType UnknownContentCode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnknownContentCode'list where
    acceptingParser =  do literal "no"; return UnknownContentCode'list_No
                      `onFail` do literal "extensions"; return UnknownContentCode'list_Extensions
                      `onFail` do literal "elements"; return UnknownContentCode'list_Elements
                      `onFail` do literal "both"; return UnknownContentCode'list_Both
                      
    simpleTypeText UnknownContentCode'list_No = "no"
    simpleTypeText UnknownContentCode'list_Extensions = "extensions"
    simpleTypeText UnknownContentCode'list_Elements = "elements"
    simpleTypeText UnknownContentCode'list_Both = "both"
 
data UnknownContentCode = UnknownContentCode
        { unknownContentCode_id :: Maybe String'primitive
        , unknownContentCode_value :: Maybe UnknownContentCode'list
        , unknownContentCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnknownContentCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnknownContentCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnknownContentCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unknownContentCode_id x
                       , maybe [] (toXMLAttribute "value") $ unknownContentCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unknownContentCode_extension x
            ]
instance Extension UnknownContentCode Element where
    supertype (UnknownContentCode a0 a1 e0) =
               Element a0 e0
 
data TypeRestfulInteraction'list
    = TypeRestfulInteraction'list_Read
      -- ^ read
    | TypeRestfulInteraction'list_Vread
      -- ^ vread
    | TypeRestfulInteraction'list_Update
      -- ^ update
    | TypeRestfulInteraction'list_Patch
      -- ^ patch
    | TypeRestfulInteraction'list_Delete
      -- ^ delete
    | TypeRestfulInteraction'list_History'instance
      -- ^ history-instance
    | TypeRestfulInteraction'list_History'type
      -- ^ history-type
    | TypeRestfulInteraction'list_Create
      -- ^ create
    | TypeRestfulInteraction'list_Search'type
      -- ^ search-type
    deriving (Eq,Show,Enum)
instance SchemaType TypeRestfulInteraction'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TypeRestfulInteraction'list where
    acceptingParser =  do literal "read"; return TypeRestfulInteraction'list_Read
                      `onFail` do literal "vread"; return TypeRestfulInteraction'list_Vread
                      `onFail` do literal "update"; return TypeRestfulInteraction'list_Update
                      `onFail` do literal "patch"; return TypeRestfulInteraction'list_Patch
                      `onFail` do literal "delete"; return TypeRestfulInteraction'list_Delete
                      `onFail` do literal "history-instance"; return TypeRestfulInteraction'list_History'instance
                      `onFail` do literal "history-type"; return TypeRestfulInteraction'list_History'type
                      `onFail` do literal "create"; return TypeRestfulInteraction'list_Create
                      `onFail` do literal "search-type"; return TypeRestfulInteraction'list_Search'type
                      
    simpleTypeText TypeRestfulInteraction'list_Read = "read"
    simpleTypeText TypeRestfulInteraction'list_Vread = "vread"
    simpleTypeText TypeRestfulInteraction'list_Update = "update"
    simpleTypeText TypeRestfulInteraction'list_Patch = "patch"
    simpleTypeText TypeRestfulInteraction'list_Delete = "delete"
    simpleTypeText TypeRestfulInteraction'list_History'instance = "history-instance"
    simpleTypeText TypeRestfulInteraction'list_History'type = "history-type"
    simpleTypeText TypeRestfulInteraction'list_Create = "create"
    simpleTypeText TypeRestfulInteraction'list_Search'type = "search-type"
 
data TypeRestfulInteraction = TypeRestfulInteraction
        { typeRestfulInteraction_id :: Maybe String'primitive
        , typeRestfulInteraction_value :: Maybe TypeRestfulInteraction'list
        , typeRestfulInteraction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TypeRestfulInteraction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TypeRestfulInteraction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TypeRestfulInteraction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ typeRestfulInteraction_id x
                       , maybe [] (toXMLAttribute "value") $ typeRestfulInteraction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ typeRestfulInteraction_extension x
            ]
instance Extension TypeRestfulInteraction Element where
    supertype (TypeRestfulInteraction a0 a1 e0) =
               Element a0 e0
 
data SystemRestfulInteraction'list
    = SystemRestfulInteraction'list_Transaction
      -- ^ transaction
    | SystemRestfulInteraction'list_Batch
      -- ^ batch
    | SystemRestfulInteraction'list_Search'system
      -- ^ search-system
    | SystemRestfulInteraction'list_History'system
      -- ^ history-system
    deriving (Eq,Show,Enum)
instance SchemaType SystemRestfulInteraction'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SystemRestfulInteraction'list where
    acceptingParser =  do literal "transaction"; return SystemRestfulInteraction'list_Transaction
                      `onFail` do literal "batch"; return SystemRestfulInteraction'list_Batch
                      `onFail` do literal "search-system"; return SystemRestfulInteraction'list_Search'system
                      `onFail` do literal "history-system"; return SystemRestfulInteraction'list_History'system
                      
    simpleTypeText SystemRestfulInteraction'list_Transaction = "transaction"
    simpleTypeText SystemRestfulInteraction'list_Batch = "batch"
    simpleTypeText SystemRestfulInteraction'list_Search'system = "search-system"
    simpleTypeText SystemRestfulInteraction'list_History'system = "history-system"
 
data SystemRestfulInteraction = SystemRestfulInteraction
        { systemRestfulInteraction_id :: Maybe String'primitive
        , systemRestfulInteraction_value :: Maybe SystemRestfulInteraction'list
        , systemRestfulInteraction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SystemRestfulInteraction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SystemRestfulInteraction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SystemRestfulInteraction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ systemRestfulInteraction_id x
                       , maybe [] (toXMLAttribute "value") $ systemRestfulInteraction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ systemRestfulInteraction_extension x
            ]
instance Extension SystemRestfulInteraction Element where
    supertype (SystemRestfulInteraction a0 a1 e0) =
               Element a0 e0
 
data ConditionalReadStatus'list
    = ConditionalReadStatus'list_Not'supported
      -- ^ Not Supported
    | ConditionalReadStatus'list_Modified'since
      -- ^ If-Modified-Since
    | ConditionalReadStatus'list_Not'match
      -- ^ If-None-Match
    | ConditionalReadStatus'list_Full'support
      -- ^ Full Support
    deriving (Eq,Show,Enum)
instance SchemaType ConditionalReadStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionalReadStatus'list where
    acceptingParser =  do literal "not-supported"; return ConditionalReadStatus'list_Not'supported
                      `onFail` do literal "modified-since"; return ConditionalReadStatus'list_Modified'since
                      `onFail` do literal "not-match"; return ConditionalReadStatus'list_Not'match
                      `onFail` do literal "full-support"; return ConditionalReadStatus'list_Full'support
                      
    simpleTypeText ConditionalReadStatus'list_Not'supported = "not-supported"
    simpleTypeText ConditionalReadStatus'list_Modified'since = "modified-since"
    simpleTypeText ConditionalReadStatus'list_Not'match = "not-match"
    simpleTypeText ConditionalReadStatus'list_Full'support = "full-support"
 
data ConditionalReadStatus = ConditionalReadStatus
        { conditionalReadStatus_id :: Maybe String'primitive
        , conditionalReadStatus_value :: Maybe ConditionalReadStatus'list
        , conditionalReadStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionalReadStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionalReadStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionalReadStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionalReadStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionalReadStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionalReadStatus_extension x
            ]
instance Extension ConditionalReadStatus Element where
    supertype (ConditionalReadStatus a0 a1 e0) =
               Element a0 e0
 
data ReferenceHandlingPolicy'list
    = ReferenceHandlingPolicy'list_Literal
      -- ^ Literal References
    | ReferenceHandlingPolicy'list_Logical
      -- ^ Logical References
    | ReferenceHandlingPolicy'list_Resolves
      -- ^ Resolves References
    | ReferenceHandlingPolicy'list_Enforced
      -- ^ Reference Integrity Enforced
    | ReferenceHandlingPolicy'list_Local
      -- ^ Local References Only
    deriving (Eq,Show,Enum)
instance SchemaType ReferenceHandlingPolicy'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ReferenceHandlingPolicy'list where
    acceptingParser =  do literal "literal"; return ReferenceHandlingPolicy'list_Literal
                      `onFail` do literal "logical"; return ReferenceHandlingPolicy'list_Logical
                      `onFail` do literal "resolves"; return ReferenceHandlingPolicy'list_Resolves
                      `onFail` do literal "enforced"; return ReferenceHandlingPolicy'list_Enforced
                      `onFail` do literal "local"; return ReferenceHandlingPolicy'list_Local
                      
    simpleTypeText ReferenceHandlingPolicy'list_Literal = "literal"
    simpleTypeText ReferenceHandlingPolicy'list_Logical = "logical"
    simpleTypeText ReferenceHandlingPolicy'list_Resolves = "resolves"
    simpleTypeText ReferenceHandlingPolicy'list_Enforced = "enforced"
    simpleTypeText ReferenceHandlingPolicy'list_Local = "local"
 
data ReferenceHandlingPolicy = ReferenceHandlingPolicy
        { referenceHandlingPolicy_id :: Maybe String'primitive
        , referenceHandlingPolicy_value :: Maybe ReferenceHandlingPolicy'list
        , referenceHandlingPolicy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ReferenceHandlingPolicy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ReferenceHandlingPolicy a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ReferenceHandlingPolicy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referenceHandlingPolicy_id x
                       , maybe [] (toXMLAttribute "value") $ referenceHandlingPolicy_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referenceHandlingPolicy_extension x
            ]
instance Extension ReferenceHandlingPolicy Element where
    supertype (ReferenceHandlingPolicy a0 a1 e0) =
               Element a0 e0
 
data ConditionalDeleteStatus'list
    = ConditionalDeleteStatus'list_Not'supported
      -- ^ Not Supported
    | ConditionalDeleteStatus'list_Single
      -- ^ Single Deletes Supported
    | ConditionalDeleteStatus'list_Multiple
      -- ^ Multiple Deletes Supported
    deriving (Eq,Show,Enum)
instance SchemaType ConditionalDeleteStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionalDeleteStatus'list where
    acceptingParser =  do literal "not-supported"; return ConditionalDeleteStatus'list_Not'supported
                      `onFail` do literal "single"; return ConditionalDeleteStatus'list_Single
                      `onFail` do literal "multiple"; return ConditionalDeleteStatus'list_Multiple
                      
    simpleTypeText ConditionalDeleteStatus'list_Not'supported = "not-supported"
    simpleTypeText ConditionalDeleteStatus'list_Single = "single"
    simpleTypeText ConditionalDeleteStatus'list_Multiple = "multiple"
 
data ConditionalDeleteStatus = ConditionalDeleteStatus
        { conditionalDeleteStatus_id :: Maybe String'primitive
        , conditionalDeleteStatus_value :: Maybe ConditionalDeleteStatus'list
        , conditionalDeleteStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionalDeleteStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionalDeleteStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionalDeleteStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionalDeleteStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionalDeleteStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionalDeleteStatus_extension x
            ]
instance Extension ConditionalDeleteStatus Element where
    supertype (ConditionalDeleteStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
elementCarePlan :: XMLParser CarePlan
elementCarePlan = parseSchemaType "CarePlan"
elementToXMLCarePlan :: CarePlan -> [Content ()]
elementToXMLCarePlan = schemaTypeToXML "CarePlan"
 
data CarePlan = CarePlan
        { carePlan_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , carePlan_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , carePlan_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , carePlan_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , carePlan_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , carePlan_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , carePlan_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlan_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlan_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care plan 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , carePlan_definition :: [Reference]
          -- ^ Identifies the protocol, questionnaire, guideline or other 
          --   specification the care plan should be conducted in 
          --   accordance with.
        , carePlan_basedOn :: [Reference]
          -- ^ A care plan that is fulfilled in whole or in part by this 
          --   care plan.
        , carePlan_replaces :: [Reference]
          -- ^ Completed or terminated care plan whose function is taken 
          --   by this new care plan.
        , carePlan_partOf :: [Reference]
          -- ^ A larger care plan of which this particular care plan is a 
          --   component or step.
        , carePlan_status :: CarePlanStatus
          -- ^ Indicates whether the plan is currently being acted upon, 
          --   represents future intentions or is now a historical record.
        , carePlan_intent :: CarePlanIntent
          -- ^ Indicates the level of authority/intentionality associated 
          --   with the care plan and where the care plan fits into the 
          --   workflow chain.
        , carePlan_category :: [CodeableConcept]
          -- ^ Identifies what &quot;kind&quot; of plan this is to support 
          --   differentiation between multiple co-existing plans; e.g. 
          --   &quot;Home health&quot;, &quot;psychiatric&quot;, 
          --   &quot;asthma&quot;, &quot;disease management&quot;, 
          --   &quot;wellness plan&quot;, etc.
        , carePlan_title :: Maybe Xsd.XsdString
          -- ^ Human-friendly name for the CarePlan.
        , carePlan_description :: Maybe Xsd.XsdString
          -- ^ A description of the scope and nature of the plan.
        , carePlan_subject :: Reference
          -- ^ Identifies the patient or group whose intended care is 
          --   described by the plan.
        , carePlan_context :: Maybe Reference
          -- ^ Identifies the original context in which this particular 
          --   CarePlan was created.
        , carePlan_period :: Maybe Period
          -- ^ Indicates when the plan did (or is intended to) come into 
          --   effect and end.
        , carePlan_author :: [Reference]
          -- ^ Identifies the individual(s) or ogranization who is 
          --   responsible for the content of the care plan.
        , carePlan_careTeam :: [Reference]
          -- ^ Identifies all people and organizations who are expected to 
          --   be involved in the care envisioned by this plan.
        , carePlan_addresses :: [Reference]
          -- ^ Identifies the conditions/problems/concerns/diagnoses/etc. 
          --   whose management and/or mitigation are handled by this 
          --   plan.
        , carePlan_supportingInfo :: [Reference]
          -- ^ Identifies portions of the patient's record that 
          --   specifically influenced the formation of the plan. These 
          --   might include co-morbidities, recent procedures, 
          --   limitations, recent assessments, etc.
        , carePlan_goal :: [Reference]
          -- ^ Describes the intended objective(s) of carrying out the 
          --   care plan.
        , carePlan_activity :: [CarePlan'Activity]
          -- ^ Identifies a planned action to occur as part of the plan. 
          --   For example, a medication to be used, lab tests to perform, 
          --   self-monitoring, education, etc.
        , carePlan_note :: [Annotation]
          -- ^ General notes about the care plan not covered elsewhere.
        }
        deriving (Eq,Show)
instance SchemaType CarePlan where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CarePlan
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "author")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "goal")
            `apply` many (parseSchemaType "activity")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CarePlan{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ carePlan_id x
            , maybe [] (schemaTypeToXML "meta") $ carePlan_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ carePlan_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ carePlan_language x
            , maybe [] (schemaTypeToXML "text") $ carePlan_text x
            , concatMap (schemaTypeToXML "contained") $ carePlan_contained x
            , concatMap (schemaTypeToXML "extension") $ carePlan_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlan_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ carePlan_identifier x
            , concatMap (schemaTypeToXML "definition") $ carePlan_definition x
            , concatMap (schemaTypeToXML "basedOn") $ carePlan_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ carePlan_replaces x
            , concatMap (schemaTypeToXML "partOf") $ carePlan_partOf x
            , schemaTypeToXML "status" $ carePlan_status x
            , schemaTypeToXML "intent" $ carePlan_intent x
            , concatMap (schemaTypeToXML "category") $ carePlan_category x
            , maybe [] (schemaTypeToXML "title") $ carePlan_title x
            , maybe [] (schemaTypeToXML "description") $ carePlan_description x
            , schemaTypeToXML "subject" $ carePlan_subject x
            , maybe [] (schemaTypeToXML "context") $ carePlan_context x
            , maybe [] (schemaTypeToXML "period") $ carePlan_period x
            , concatMap (schemaTypeToXML "author") $ carePlan_author x
            , concatMap (schemaTypeToXML "careTeam") $ carePlan_careTeam x
            , concatMap (schemaTypeToXML "addresses") $ carePlan_addresses x
            , concatMap (schemaTypeToXML "supportingInfo") $ carePlan_supportingInfo x
            , concatMap (schemaTypeToXML "goal") $ carePlan_goal x
            , concatMap (schemaTypeToXML "activity") $ carePlan_activity x
            , concatMap (schemaTypeToXML "note") $ carePlan_note x
            ]
instance Extension CarePlan DomainResource where
    supertype (CarePlan e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CarePlan Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CarePlan -> DomainResource)
              
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
data CarePlan'Activity = CarePlan'Activity
        { carePlan'Activity_id :: Maybe String'primitive
        , carePlan'Activity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlan'Activity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlan'Activity_outcomeCodeableConcept :: [CodeableConcept]
          -- ^ Identifies the outcome at the point when the status of the 
          --   activity is assessed. For example, the outcome of an 
          --   education activity could be patient understands (or not).
        , carePlan'Activity_outcomeReference :: [Reference]
          -- ^ Details of the outcome or action resulting from the 
          --   activity. The reference to an &quot;event&quot; resource, 
          --   such as Procedure or Encounter or Observation, is the 
          --   result/outcome of the activity itself. The activity can be 
          --   conveyed using CarePlan.activity.detail OR using the 
          --   CarePlan.activity.reference (a reference to a â€œrequestâ€ 
          --   resource).
        , carePlan'Activity_progress :: [Annotation]
          -- ^ Notes about the adherence/status/progress of the activity.
        , carePlan'Activity_reference :: Maybe Reference
          -- ^ The details of the proposed activity represented in a 
          --   specific resource.
        , carePlan'Activity_detail :: Maybe CarePlan'Detail
          -- ^ A simple summary of a planned activity suitable for a 
          --   general care plan system (e.g. form driven) that doesn't 
          --   know about specific resources such as procedure etc.
        }
        deriving (Eq,Show)
instance SchemaType CarePlan'Activity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CarePlan'Activity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "outcomeCodeableConcept")
            `apply` many (parseSchemaType "outcomeReference")
            `apply` many (parseSchemaType "progress")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@CarePlan'Activity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlan'Activity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlan'Activity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlan'Activity_modifierExtension x
            , concatMap (schemaTypeToXML "outcomeCodeableConcept") $ carePlan'Activity_outcomeCodeableConcept x
            , concatMap (schemaTypeToXML "outcomeReference") $ carePlan'Activity_outcomeReference x
            , concatMap (schemaTypeToXML "progress") $ carePlan'Activity_progress x
            , maybe [] (schemaTypeToXML "reference") $ carePlan'Activity_reference x
            , maybe [] (schemaTypeToXML "detail") $ carePlan'Activity_detail x
            ]
instance Extension CarePlan'Activity BackboneElement where
    supertype (CarePlan'Activity a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension CarePlan'Activity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CarePlan'Activity -> BackboneElement)
              
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
data CarePlan'Detail = CarePlan'Detail
        { carePlan'Detail_id :: Maybe String'primitive
        , carePlan'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlan'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlan'Detail_category :: Maybe CodeableConcept
          -- ^ High-level categorization of the type of activity in a care 
          --   plan.
        , carePlan'Detail_definition :: Maybe Reference
          -- ^ Identifies the protocol, questionnaire, guideline or other 
          --   specification the planned activity should be conducted in 
          --   accordance with.
        , carePlan'Detail_code :: Maybe CodeableConcept
          -- ^ Detailed description of the type of planned activity; e.g. 
          --   What lab test, what procedure, what kind of encounter.
        , carePlan'Detail_reasonCode :: [CodeableConcept]
          -- ^ Provides the rationale that drove the inclusion of this 
          --   particular activity as part of the plan or the reason why 
          --   the activity was prohibited.
        , carePlan'Detail_reasonReference :: [Reference]
          -- ^ Provides the health condition(s) that drove the inclusion 
          --   of this particular activity as part of the plan.
        , carePlan'Detail_goal :: [Reference]
          -- ^ Internal reference that identifies the goals that this 
          --   activity is intended to contribute towards meeting.
        , carePlan'Detail_status :: CarePlanActivityStatus
          -- ^ Identifies what progress is being made for the specific 
          --   activity.
        , carePlan'Detail_statusReason :: Maybe Xsd.XsdString
          -- ^ Provides reason why the activity isn't yet started, is on 
          --   hold, was cancelled, etc.
        , carePlan'Detail_prohibited :: Maybe Boolean
          -- ^ If true, indicates that the described activity is one that 
          --   must NOT be engaged in when following the plan. If false, 
          --   indicates that the described activity is one that should be 
          --   engaged in when following the plan.
        , carePlan'Detail_choice11 :: (Maybe (OneOf3 Timing Period Xsd.XsdString))
          -- ^ The period, timing or frequency upon which the described 
          --   activity is to occur.
          --   
          --   Choice between:
          --   
          --   (1) scheduledTiming
          --   
          --   (2) scheduledPeriod
          --   
          --   (3) scheduledString
        , carePlan'Detail_location :: Maybe Reference
          -- ^ Identifies the facility where the activity will occur; e.g. 
          --   home, hospital, specific clinic, etc.
        , carePlan'Detail_performer :: [Reference]
          -- ^ Identifies who's expected to be involved in the activity.
        , carePlan'Detail_choice14 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Identifies the food, drug or other product to be consumed 
          --   or supplied in the activity.
          --   
          --   Choice between:
          --   
          --   (1) productCodeableConcept
          --   
          --   (2) productReference
        , carePlan'Detail_dailyAmount :: Maybe Quantity
          -- ^ Identifies the quantity expected to be consumed in a given 
          --   day.
        , carePlan'Detail_quantity :: Maybe Quantity
          -- ^ Identifies the quantity expected to be supplied, 
          --   administered or consumed by the subject.
        , carePlan'Detail_description :: Maybe Xsd.XsdString
          -- ^ This provides a textual description of constraints on the 
          --   intended activity occurrence, including relation to other 
          --   activities. It may also include objectives, pre-conditions 
          --   and end-conditions. Finally, it may convey specifics about 
          --   the activity such as body site, method, route, etc.
        }
        deriving (Eq,Show)
instance SchemaType CarePlan'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CarePlan'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "goal")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "prohibited")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf3 (parseSchemaType "scheduledTiming"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "scheduledPeriod"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "scheduledString"))
                                     ])
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "productCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "productReference"))
                                     ])
            `apply` optional (parseSchemaType "dailyAmount")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@CarePlan'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlan'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlan'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlan'Detail_modifierExtension x
            , maybe [] (schemaTypeToXML "category") $ carePlan'Detail_category x
            , maybe [] (schemaTypeToXML "definition") $ carePlan'Detail_definition x
            , maybe [] (schemaTypeToXML "code") $ carePlan'Detail_code x
            , concatMap (schemaTypeToXML "reasonCode") $ carePlan'Detail_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ carePlan'Detail_reasonReference x
            , concatMap (schemaTypeToXML "goal") $ carePlan'Detail_goal x
            , schemaTypeToXML "status" $ carePlan'Detail_status x
            , maybe [] (schemaTypeToXML "statusReason") $ carePlan'Detail_statusReason x
            , maybe [] (schemaTypeToXML "prohibited") $ carePlan'Detail_prohibited x
            , maybe [] (foldOneOf3  (schemaTypeToXML "scheduledTiming")
                                    (schemaTypeToXML "scheduledPeriod")
                                    (schemaTypeToXML "scheduledString")
                                   ) $ carePlan'Detail_choice11 x
            , maybe [] (schemaTypeToXML "location") $ carePlan'Detail_location x
            , concatMap (schemaTypeToXML "performer") $ carePlan'Detail_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "productCodeableConcept")
                                    (schemaTypeToXML "productReference")
                                   ) $ carePlan'Detail_choice14 x
            , maybe [] (schemaTypeToXML "dailyAmount") $ carePlan'Detail_dailyAmount x
            , maybe [] (schemaTypeToXML "quantity") $ carePlan'Detail_quantity x
            , maybe [] (schemaTypeToXML "description") $ carePlan'Detail_description x
            ]
instance Extension CarePlan'Detail BackboneElement where
    supertype (CarePlan'Detail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               BackboneElement a0 e0 e1
instance Extension CarePlan'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CarePlan'Detail -> BackboneElement)
              
 
data CarePlanStatus'list
    = CarePlanStatus'list_Draft
      -- ^ Pending
    | CarePlanStatus'list_Active
      -- ^ Active
    | CarePlanStatus'list_Suspended
      -- ^ Suspended
    | CarePlanStatus'list_Completed
      -- ^ Completed
    | CarePlanStatus'list_Entered'in'error
      -- ^ Entered In Error
    | CarePlanStatus'list_Cancelled
      -- ^ Cancelled
    | CarePlanStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanStatus'list where
    acceptingParser =  do literal "draft"; return CarePlanStatus'list_Draft
                      `onFail` do literal "active"; return CarePlanStatus'list_Active
                      `onFail` do literal "suspended"; return CarePlanStatus'list_Suspended
                      `onFail` do literal "completed"; return CarePlanStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return CarePlanStatus'list_Entered'in'error
                      `onFail` do literal "cancelled"; return CarePlanStatus'list_Cancelled
                      `onFail` do literal "unknown"; return CarePlanStatus'list_Unknown
                      
    simpleTypeText CarePlanStatus'list_Draft = "draft"
    simpleTypeText CarePlanStatus'list_Active = "active"
    simpleTypeText CarePlanStatus'list_Suspended = "suspended"
    simpleTypeText CarePlanStatus'list_Completed = "completed"
    simpleTypeText CarePlanStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText CarePlanStatus'list_Cancelled = "cancelled"
    simpleTypeText CarePlanStatus'list_Unknown = "unknown"
 
data CarePlanStatus = CarePlanStatus
        { carePlanStatus_id :: Maybe String'primitive
        , carePlanStatus_value :: Maybe CarePlanStatus'list
        , carePlanStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanStatus_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanStatus_extension x
            ]
instance Extension CarePlanStatus Element where
    supertype (CarePlanStatus a0 a1 e0) =
               Element a0 e0
 
data CarePlanActivityStatus'list
    = CarePlanActivityStatus'list_Not'started
      -- ^ Not Started
    | CarePlanActivityStatus'list_Scheduled
      -- ^ Scheduled
    | CarePlanActivityStatus'list_In'progress
      -- ^ In Progress
    | CarePlanActivityStatus'list_On'hold
      -- ^ On Hold
    | CarePlanActivityStatus'list_Completed
      -- ^ Completed
    | CarePlanActivityStatus'list_Cancelled
      -- ^ Cancelled
    | CarePlanActivityStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanActivityStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanActivityStatus'list where
    acceptingParser =  do literal "not-started"; return CarePlanActivityStatus'list_Not'started
                      `onFail` do literal "scheduled"; return CarePlanActivityStatus'list_Scheduled
                      `onFail` do literal "in-progress"; return CarePlanActivityStatus'list_In'progress
                      `onFail` do literal "on-hold"; return CarePlanActivityStatus'list_On'hold
                      `onFail` do literal "completed"; return CarePlanActivityStatus'list_Completed
                      `onFail` do literal "cancelled"; return CarePlanActivityStatus'list_Cancelled
                      `onFail` do literal "unknown"; return CarePlanActivityStatus'list_Unknown
                      
    simpleTypeText CarePlanActivityStatus'list_Not'started = "not-started"
    simpleTypeText CarePlanActivityStatus'list_Scheduled = "scheduled"
    simpleTypeText CarePlanActivityStatus'list_In'progress = "in-progress"
    simpleTypeText CarePlanActivityStatus'list_On'hold = "on-hold"
    simpleTypeText CarePlanActivityStatus'list_Completed = "completed"
    simpleTypeText CarePlanActivityStatus'list_Cancelled = "cancelled"
    simpleTypeText CarePlanActivityStatus'list_Unknown = "unknown"
 
data CarePlanActivityStatus = CarePlanActivityStatus
        { carePlanActivityStatus_id :: Maybe String'primitive
        , carePlanActivityStatus_value :: Maybe CarePlanActivityStatus'list
        , carePlanActivityStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanActivityStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanActivityStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanActivityStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanActivityStatus_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanActivityStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanActivityStatus_extension x
            ]
instance Extension CarePlanActivityStatus Element where
    supertype (CarePlanActivityStatus a0 a1 e0) =
               Element a0 e0
 
data CarePlanIntent'list
    = CarePlanIntent'list_Proposal
      -- ^ Proposal
    | CarePlanIntent'list_Plan
      -- ^ Plan
    | CarePlanIntent'list_Order
      -- ^ Order
    | CarePlanIntent'list_Option
      -- ^ Option
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanIntent'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanIntent'list where
    acceptingParser =  do literal "proposal"; return CarePlanIntent'list_Proposal
                      `onFail` do literal "plan"; return CarePlanIntent'list_Plan
                      `onFail` do literal "order"; return CarePlanIntent'list_Order
                      `onFail` do literal "option"; return CarePlanIntent'list_Option
                      
    simpleTypeText CarePlanIntent'list_Proposal = "proposal"
    simpleTypeText CarePlanIntent'list_Plan = "plan"
    simpleTypeText CarePlanIntent'list_Order = "order"
    simpleTypeText CarePlanIntent'list_Option = "option"
 
data CarePlanIntent = CarePlanIntent
        { carePlanIntent_id :: Maybe String'primitive
        , carePlanIntent_value :: Maybe CarePlanIntent'list
        , carePlanIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanIntent_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanIntent_extension x
            ]
instance Extension CarePlanIntent Element where
    supertype (CarePlanIntent a0 a1 e0) =
               Element a0 e0
 
-- | The Care Team includes all the people and organizations who 
--   plan to participate in the coordination and delivery of 
--   care for a patient.
elementCareTeam :: XMLParser CareTeam
elementCareTeam = parseSchemaType "CareTeam"
elementToXMLCareTeam :: CareTeam -> [Content ()]
elementToXMLCareTeam = schemaTypeToXML "CareTeam"
 
data CareTeam = CareTeam
        { careTeam_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , careTeam_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , careTeam_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , careTeam_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , careTeam_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , careTeam_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , careTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , careTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , careTeam_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care team 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate.
        , careTeam_status :: Maybe CareTeamStatus
          -- ^ Indicates the current state of the care team.
        , careTeam_category :: [CodeableConcept]
          -- ^ Identifies what kind of team. This is to support 
          --   differentiation between multiple co-existing teams, such as 
          --   care plan team, episode of care team, longitudinal care 
          --   team.
        , careTeam_name :: Maybe Xsd.XsdString
          -- ^ A label for human use intended to distinguish like teams. 
          --   E.g. the &quot;red&quot; vs. &quot;green&quot; trauma 
          --   teams.
        , careTeam_subject :: Maybe Reference
          -- ^ Identifies the patient or group whose intended care is 
          --   handled by the team.
        , careTeam_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this care team.
        , careTeam_period :: Maybe Period
          -- ^ Indicates when the team did (or is intended to) come into 
          --   effect and end.
        , careTeam_participant :: [CareTeam'Participant]
          -- ^ Identifies all people and organizations who are expected to 
          --   be involved in the care team.
        , careTeam_reasonCode :: [CodeableConcept]
          -- ^ Describes why the care team exists.
        , careTeam_reasonReference :: [Reference]
          -- ^ Condition(s) that this care team addresses.
        , careTeam_managingOrganization :: [Reference]
          -- ^ The organization responsible for the care team.
        , careTeam_note :: [Annotation]
          -- ^ Comments made about the CareTeam.
        }
        deriving (Eq,Show)
instance SchemaType CareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CareTeam
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "participant")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CareTeam{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ careTeam_id x
            , maybe [] (schemaTypeToXML "meta") $ careTeam_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ careTeam_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ careTeam_language x
            , maybe [] (schemaTypeToXML "text") $ careTeam_text x
            , concatMap (schemaTypeToXML "contained") $ careTeam_contained x
            , concatMap (schemaTypeToXML "extension") $ careTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ careTeam_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ careTeam_identifier x
            , maybe [] (schemaTypeToXML "status") $ careTeam_status x
            , concatMap (schemaTypeToXML "category") $ careTeam_category x
            , maybe [] (schemaTypeToXML "name") $ careTeam_name x
            , maybe [] (schemaTypeToXML "subject") $ careTeam_subject x
            , maybe [] (schemaTypeToXML "context") $ careTeam_context x
            , maybe [] (schemaTypeToXML "period") $ careTeam_period x
            , concatMap (schemaTypeToXML "participant") $ careTeam_participant x
            , concatMap (schemaTypeToXML "reasonCode") $ careTeam_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ careTeam_reasonReference x
            , concatMap (schemaTypeToXML "managingOrganization") $ careTeam_managingOrganization x
            , concatMap (schemaTypeToXML "note") $ careTeam_note x
            ]
instance Extension CareTeam DomainResource where
    supertype (CareTeam e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CareTeam Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CareTeam -> DomainResource)
              
 
-- | The Care Team includes all the people and organizations who 
--   plan to participate in the coordination and delivery of 
--   care for a patient.
data CareTeam'Participant = CareTeam'Participant
        { careTeam'Participant_id :: Maybe String'primitive
        , careTeam'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , careTeam'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , careTeam'Participant_role :: Maybe CodeableConcept
          -- ^ Indicates specific responsibility of an individual within 
          --   the care team, such as &quot;Primary care physician&quot;, 
          --   &quot;Trained social worker counselor&quot;, 
          --   &quot;Caregiver&quot;, etc.
        , careTeam'Participant_member :: Maybe Reference
          -- ^ The specific person or organization who is 
          --   participating/expected to participate in the care team.
        , careTeam'Participant_onBehalfOf :: Maybe Reference
          -- ^ The organization of the practitioner.
        , careTeam'Participant_period :: Maybe Period
          -- ^ Indicates when the specific member or organization did (or 
          --   is intended to) come into effect and end.
        }
        deriving (Eq,Show)
instance SchemaType CareTeam'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CareTeam'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "member")
            `apply` optional (parseSchemaType "onBehalfOf")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@CareTeam'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ careTeam'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ careTeam'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ careTeam'Participant_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ careTeam'Participant_role x
            , maybe [] (schemaTypeToXML "member") $ careTeam'Participant_member x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ careTeam'Participant_onBehalfOf x
            , maybe [] (schemaTypeToXML "period") $ careTeam'Participant_period x
            ]
instance Extension CareTeam'Participant BackboneElement where
    supertype (CareTeam'Participant a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CareTeam'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CareTeam'Participant -> BackboneElement)
              
 
data CareTeamStatus'list
    = CareTeamStatus'list_Proposed
      -- ^ Proposed
    | CareTeamStatus'list_Active
      -- ^ Active
    | CareTeamStatus'list_Suspended
      -- ^ Suspended
    | CareTeamStatus'list_Inactive
      -- ^ Inactive
    | CareTeamStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType CareTeamStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CareTeamStatus'list where
    acceptingParser =  do literal "proposed"; return CareTeamStatus'list_Proposed
                      `onFail` do literal "active"; return CareTeamStatus'list_Active
                      `onFail` do literal "suspended"; return CareTeamStatus'list_Suspended
                      `onFail` do literal "inactive"; return CareTeamStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return CareTeamStatus'list_Entered'in'error
                      
    simpleTypeText CareTeamStatus'list_Proposed = "proposed"
    simpleTypeText CareTeamStatus'list_Active = "active"
    simpleTypeText CareTeamStatus'list_Suspended = "suspended"
    simpleTypeText CareTeamStatus'list_Inactive = "inactive"
    simpleTypeText CareTeamStatus'list_Entered'in'error = "entered-in-error"
 
data CareTeamStatus = CareTeamStatus
        { careTeamStatus_id :: Maybe String'primitive
        , careTeamStatus_value :: Maybe CareTeamStatus'list
        , careTeamStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CareTeamStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CareTeamStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CareTeamStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ careTeamStatus_id x
                       , maybe [] (toXMLAttribute "value") $ careTeamStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ careTeamStatus_extension x
            ]
instance Extension CareTeamStatus Element where
    supertype (CareTeamStatus a0 a1 e0) =
               Element a0 e0
 
-- | The resource ChargeItem describes the provision of 
--   healthcare provider products for a certain patient, 
--   therefore referring not only to the product, but containing 
--   in addition details of the provision, like date, time, 
--   amounts and participating organizations and persons. Main 
--   Usage of the ChargeItem is to enable the billing process 
--   and internal cost allocation.
elementChargeItem :: XMLParser ChargeItem
elementChargeItem = parseSchemaType "ChargeItem"
elementToXMLChargeItem :: ChargeItem -> [Content ()]
elementToXMLChargeItem = schemaTypeToXML "ChargeItem"
 
data ChargeItem = ChargeItem
        { chargeItem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , chargeItem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , chargeItem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , chargeItem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , chargeItem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , chargeItem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , chargeItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , chargeItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , chargeItem_identifier :: Maybe Identifier
          -- ^ Identifiers assigned to this event performer or other 
          --   systems.
        , chargeItem_definition :: [Uri]
          -- ^ References the source of pricing information, rules of 
          --   application for the code this ChargeItem uses.
        , chargeItem_status :: ChargeItemStatus
          -- ^ The current state of the ChargeItem.
        , chargeItem_partOf :: [Reference]
          -- ^ ChargeItems can be grouped to larger ChargeItems covering 
          --   the whole set.
        , chargeItem_code :: CodeableConcept
          -- ^ A code that identifies the charge, like a billing code.
        , chargeItem_subject :: Reference
          -- ^ The individual or set of individuals the action is being or 
          --   was performed on.
        , chargeItem_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this event.
        , chargeItem_choice15 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ Date/time(s) or duration when the charged service was 
          --   applied.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , chargeItem_participant :: [ChargeItem'Participant]
          -- ^ Indicates who or what performed or participated in the 
          --   charged service.
        , chargeItem_performingOrganization :: Maybe Reference
          -- ^ The organization requesting the service.
        , chargeItem_requestingOrganization :: Maybe Reference
          -- ^ The organization performing the service.
        , chargeItem_quantity :: Maybe Quantity
          -- ^ Quantity of which the charge item has been serviced.
        , chargeItem_bodysite :: [CodeableConcept]
          -- ^ The anatomical location where the related service has been 
          --   applied.
        , chargeItem_factorOverride :: Maybe Decimal
          -- ^ Factor overriding the factor determined by the rules 
          --   associated with the code.
        , chargeItem_priceOverride :: Maybe Money
          -- ^ Total price of the charge overriding the list price 
          --   associated with the code.
        , chargeItem_overrideReason :: Maybe Xsd.XsdString
          -- ^ If the list price or the rule based factor associated with 
          --   the code is overridden, this attribute can capture a text 
          --   to indicate the reason for this action.
        , chargeItem_enterer :: Maybe Reference
          -- ^ The device, practitioner, etc. who entered the charge item.
        , chargeItem_enteredDate :: Maybe DateTime
          -- ^ Date the charge item was entered.
        , chargeItem_reason :: [CodeableConcept]
          -- ^ Describes why the event occurred in coded or textual form.
        , chargeItem_service :: [Reference]
          -- ^ Indicated the rendered service that caused this charge.
        , chargeItem_account :: [Reference]
          -- ^ Account into which this ChargeItems belongs.
        , chargeItem_note :: [Annotation]
          -- ^ Comments made about the event by the performer, subject or 
          --   other participants.
        , chargeItem_supportingInformation :: [Reference]
          -- ^ Further information supporting the this charge.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ChargeItem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "performingOrganization")
            `apply` optional (parseSchemaType "requestingOrganization")
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "bodysite")
            `apply` optional (parseSchemaType "factorOverride")
            `apply` optional (parseSchemaType "priceOverride")
            `apply` optional (parseSchemaType "overrideReason")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "enteredDate")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "service")
            `apply` many (parseSchemaType "account")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "supportingInformation")
    schemaTypeToXML s x@ChargeItem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ chargeItem_id x
            , maybe [] (schemaTypeToXML "meta") $ chargeItem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ chargeItem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ chargeItem_language x
            , maybe [] (schemaTypeToXML "text") $ chargeItem_text x
            , concatMap (schemaTypeToXML "contained") $ chargeItem_contained x
            , concatMap (schemaTypeToXML "extension") $ chargeItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ chargeItem_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ chargeItem_identifier x
            , concatMap (schemaTypeToXML "definition") $ chargeItem_definition x
            , schemaTypeToXML "status" $ chargeItem_status x
            , concatMap (schemaTypeToXML "partOf") $ chargeItem_partOf x
            , schemaTypeToXML "code" $ chargeItem_code x
            , schemaTypeToXML "subject" $ chargeItem_subject x
            , maybe [] (schemaTypeToXML "context") $ chargeItem_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ chargeItem_choice15 x
            , concatMap (schemaTypeToXML "participant") $ chargeItem_participant x
            , maybe [] (schemaTypeToXML "performingOrganization") $ chargeItem_performingOrganization x
            , maybe [] (schemaTypeToXML "requestingOrganization") $ chargeItem_requestingOrganization x
            , maybe [] (schemaTypeToXML "quantity") $ chargeItem_quantity x
            , concatMap (schemaTypeToXML "bodysite") $ chargeItem_bodysite x
            , maybe [] (schemaTypeToXML "factorOverride") $ chargeItem_factorOverride x
            , maybe [] (schemaTypeToXML "priceOverride") $ chargeItem_priceOverride x
            , maybe [] (schemaTypeToXML "overrideReason") $ chargeItem_overrideReason x
            , maybe [] (schemaTypeToXML "enterer") $ chargeItem_enterer x
            , maybe [] (schemaTypeToXML "enteredDate") $ chargeItem_enteredDate x
            , concatMap (schemaTypeToXML "reason") $ chargeItem_reason x
            , concatMap (schemaTypeToXML "service") $ chargeItem_service x
            , concatMap (schemaTypeToXML "account") $ chargeItem_account x
            , concatMap (schemaTypeToXML "note") $ chargeItem_note x
            , concatMap (schemaTypeToXML "supportingInformation") $ chargeItem_supportingInformation x
            ]
instance Extension ChargeItem DomainResource where
    supertype (ChargeItem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ChargeItem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ChargeItem -> DomainResource)
              
 
-- | The resource ChargeItem describes the provision of 
--   healthcare provider products for a certain patient, 
--   therefore referring not only to the product, but containing 
--   in addition details of the provision, like date, time, 
--   amounts and participating organizations and persons. Main 
--   Usage of the ChargeItem is to enable the billing process 
--   and internal cost allocation.
data ChargeItem'Participant = ChargeItem'Participant
        { chargeItem'Participant_id :: Maybe String'primitive
        , chargeItem'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , chargeItem'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , chargeItem'Participant_role :: Maybe CodeableConcept
          -- ^ Describes the type of performance or participation(e.g. 
          --   primary surgeon, anaesthesiologiest, etc.).
        , chargeItem'Participant_actor :: Reference
          -- ^ The device, practitioner, etc. who performed or 
          --   participated in the service.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItem'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ChargeItem'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@ChargeItem'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ chargeItem'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ chargeItem'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ chargeItem'Participant_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ chargeItem'Participant_role x
            , schemaTypeToXML "actor" $ chargeItem'Participant_actor x
            ]
instance Extension ChargeItem'Participant BackboneElement where
    supertype (ChargeItem'Participant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ChargeItem'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ChargeItem'Participant -> BackboneElement)
              
 
data ChargeItemStatus'list
    = ChargeItemStatus'list_Planned
      -- ^ Planned
    | ChargeItemStatus'list_Billable
      -- ^ Billable
    | ChargeItemStatus'list_Not'billable
      -- ^ Not billable
    | ChargeItemStatus'list_Aborted
      -- ^ Aborted
    | ChargeItemStatus'list_Billed
      -- ^ Billed
    | ChargeItemStatus'list_Entered'in'error
      -- ^ Entered in Error
    | ChargeItemStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ChargeItemStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ChargeItemStatus'list where
    acceptingParser =  do literal "planned"; return ChargeItemStatus'list_Planned
                      `onFail` do literal "billable"; return ChargeItemStatus'list_Billable
                      `onFail` do literal "not-billable"; return ChargeItemStatus'list_Not'billable
                      `onFail` do literal "aborted"; return ChargeItemStatus'list_Aborted
                      `onFail` do literal "billed"; return ChargeItemStatus'list_Billed
                      `onFail` do literal "entered-in-error"; return ChargeItemStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return ChargeItemStatus'list_Unknown
                      
    simpleTypeText ChargeItemStatus'list_Planned = "planned"
    simpleTypeText ChargeItemStatus'list_Billable = "billable"
    simpleTypeText ChargeItemStatus'list_Not'billable = "not-billable"
    simpleTypeText ChargeItemStatus'list_Aborted = "aborted"
    simpleTypeText ChargeItemStatus'list_Billed = "billed"
    simpleTypeText ChargeItemStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText ChargeItemStatus'list_Unknown = "unknown"
 
data ChargeItemStatus = ChargeItemStatus
        { chargeItemStatus_id :: Maybe String'primitive
        , chargeItemStatus_value :: Maybe ChargeItemStatus'list
        , chargeItemStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItemStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ChargeItemStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ChargeItemStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ chargeItemStatus_id x
                       , maybe [] (toXMLAttribute "value") $ chargeItemStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ chargeItemStatus_extension x
            ]
instance Extension ChargeItemStatus Element where
    supertype (ChargeItemStatus a0 a1 e0) =
               Element a0 e0
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
elementClaim :: XMLParser Claim
elementClaim = parseSchemaType "Claim"
elementToXMLClaim :: Claim -> [Content ()]
elementToXMLClaim = schemaTypeToXML "Claim"
 
data Claim = Claim
        { claim_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , claim_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , claim_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , claim_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , claim_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , claim_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , claim_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim_identifier :: [Identifier]
          -- ^ The business identifier for the instance: claim number, 
          --   pre-determination or pre-authorization number.
        , claim_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , claim_type :: Maybe CodeableConcept
          -- ^ The category of claim, eg, oral, pharmacy, vision, 
          --   insitutional, professional.
        , claim_subType :: [CodeableConcept]
          -- ^ A finer grained suite of claim subtype codes which may 
          --   convey Inpatient vs Outpatient and/or a specialty service. 
          --   In the US the BillType.
        , claim_use :: Maybe Use
          -- ^ Complete (Bill or Claim), Proposed (Pre-Authorization), 
          --   Exploratory (Pre-determination).
        , claim_patient :: Maybe Reference
          -- ^ Patient Resource.
        , claim_billablePeriod :: Maybe Period
          -- ^ The billable period for which charges are being submitted.
        , claim_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , claim_enterer :: Maybe Reference
          -- ^ Person who created the invoice/claim/pre-determination or 
          --   pre-authorization.
        , claim_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , claim_provider :: Maybe Reference
          -- ^ The provider which is responsible for the bill, claim 
          --   pre-determination, pre-authorization.
        , claim_organization :: Maybe Reference
          -- ^ The organization which is responsible for the bill, claim 
          --   pre-determination, pre-authorization.
        , claim_priority :: Maybe CodeableConcept
          -- ^ Immediate (STAT), best effort (NORMAL), deferred (DEFER).
        , claim_fundsReserve :: Maybe CodeableConcept
          -- ^ In the case of a Pre-Determination/Pre-Authorization the 
          --   provider may request that funds in the amount of the 
          --   expected Benefit be reserved ('Patient' or 'Provider') to 
          --   pay for the Benefits determined on the subsequent claim(s). 
          --   'None' explicitly indicates no funds reserving is 
          --   requested.
        , claim_related :: [Claim'Related]
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , claim_prescription :: Maybe Reference
          -- ^ Prescription to support the dispensing of Pharmacy or 
          --   Vision products.
        , claim_originalPrescription :: Maybe Reference
          -- ^ Original prescription which has been superceded by this 
          --   prescription to support the dispensing of pharmacy 
          --   services, medications or products. For example, a physician 
          --   may prescribe a medication which the pharmacy determines is 
          --   contraindicated, or for which the patient has an 
          --   intolerance, and therefor issues a new precription for an 
          --   alternate medication which has the same theraputic intent. 
          --   The prescription from the pharmacy becomes the 
          --   'prescription' and that from the physician becomes the 
          --   'original prescription'.
        , claim_payee :: Maybe Claim'Payee
          -- ^ The party to be reimbursed for the services.
        , claim_referral :: Maybe Reference
          -- ^ The referral resource which lists the date, practitioner, 
          --   reason and other supporting information.
        , claim_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , claim_careTeam :: [Claim'CareTeam]
          -- ^ The members of the team who provided the overall service as 
          --   well as their role and whether responsible and 
          --   qualifications.
        , claim_information :: [Claim'Information]
          -- ^ Additional information codes regarding exceptions, special 
          --   considerations, the condition, situation, prior or 
          --   concurrent issues. Often there are mutiple jurisdiction 
          --   specific valuesets which are required.
        , claim_diagnosis :: [Claim'Diagnosis]
          -- ^ List of patient diagnosis for which care is sought.
        , claim_procedure :: [Claim'Procedure]
          -- ^ Ordered list of patient procedures performed to support the 
          --   adjudication.
        , claim_insurance :: [Claim'Insurance]
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , claim_accident :: Maybe Claim'Accident
          -- ^ An accident which resulted in the need for healthcare 
          --   services.
        , claim_employmentImpacted :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   precluded from working due to the treatable condition(s).
        , claim_hospitalization :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   confined to a treatment center.
        , claim_item :: [Claim'Item]
          -- ^ First tier of goods and services.
        , claim_total :: Maybe Money
          -- ^ The total value of the claim.
        }
        deriving (Eq,Show)
instance SchemaType Claim where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Claim
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "billablePeriod")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "fundsReserve")
            `apply` many (parseSchemaType "related")
            `apply` optional (parseSchemaType "prescription")
            `apply` optional (parseSchemaType "originalPrescription")
            `apply` optional (parseSchemaType "payee")
            `apply` optional (parseSchemaType "referral")
            `apply` optional (parseSchemaType "facility")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "information")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "procedure")
            `apply` many (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "accident")
            `apply` optional (parseSchemaType "employmentImpacted")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "item")
            `apply` optional (parseSchemaType "total")
    schemaTypeToXML s x@Claim{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ claim_id x
            , maybe [] (schemaTypeToXML "meta") $ claim_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ claim_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ claim_language x
            , maybe [] (schemaTypeToXML "text") $ claim_text x
            , concatMap (schemaTypeToXML "contained") $ claim_contained x
            , concatMap (schemaTypeToXML "extension") $ claim_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ claim_identifier x
            , maybe [] (schemaTypeToXML "status") $ claim_status x
            , maybe [] (schemaTypeToXML "type") $ claim_type x
            , concatMap (schemaTypeToXML "subType") $ claim_subType x
            , maybe [] (schemaTypeToXML "use") $ claim_use x
            , maybe [] (schemaTypeToXML "patient") $ claim_patient x
            , maybe [] (schemaTypeToXML "billablePeriod") $ claim_billablePeriod x
            , maybe [] (schemaTypeToXML "created") $ claim_created x
            , maybe [] (schemaTypeToXML "enterer") $ claim_enterer x
            , maybe [] (schemaTypeToXML "insurer") $ claim_insurer x
            , maybe [] (schemaTypeToXML "provider") $ claim_provider x
            , maybe [] (schemaTypeToXML "organization") $ claim_organization x
            , maybe [] (schemaTypeToXML "priority") $ claim_priority x
            , maybe [] (schemaTypeToXML "fundsReserve") $ claim_fundsReserve x
            , concatMap (schemaTypeToXML "related") $ claim_related x
            , maybe [] (schemaTypeToXML "prescription") $ claim_prescription x
            , maybe [] (schemaTypeToXML "originalPrescription") $ claim_originalPrescription x
            , maybe [] (schemaTypeToXML "payee") $ claim_payee x
            , maybe [] (schemaTypeToXML "referral") $ claim_referral x
            , maybe [] (schemaTypeToXML "facility") $ claim_facility x
            , concatMap (schemaTypeToXML "careTeam") $ claim_careTeam x
            , concatMap (schemaTypeToXML "information") $ claim_information x
            , concatMap (schemaTypeToXML "diagnosis") $ claim_diagnosis x
            , concatMap (schemaTypeToXML "procedure") $ claim_procedure x
            , concatMap (schemaTypeToXML "insurance") $ claim_insurance x
            , maybe [] (schemaTypeToXML "accident") $ claim_accident x
            , maybe [] (schemaTypeToXML "employmentImpacted") $ claim_employmentImpacted x
            , maybe [] (schemaTypeToXML "hospitalization") $ claim_hospitalization x
            , concatMap (schemaTypeToXML "item") $ claim_item x
            , maybe [] (schemaTypeToXML "total") $ claim_total x
            ]
instance Extension Claim DomainResource where
    supertype (Claim e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Claim Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Claim -> DomainResource)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Related = Claim'Related
        { claim'Related_id :: Maybe String'primitive
        , claim'Related_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Related_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Related_claim :: Maybe Reference
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , claim'Related_relationship :: Maybe CodeableConcept
          -- ^ For example prior or umbrella.
        , claim'Related_reference :: Maybe Identifier
          -- ^ An alternate organizational reference to the case or file 
          --   to which this particular claim pertains - eg 
          --   Property/Casualy insurer claim # or Workers Compensation 
          --   case # .
        }
        deriving (Eq,Show)
instance SchemaType Claim'Related where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Related a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "reference")
    schemaTypeToXML s x@Claim'Related{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Related_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Related_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Related_modifierExtension x
            , maybe [] (schemaTypeToXML "claim") $ claim'Related_claim x
            , maybe [] (schemaTypeToXML "relationship") $ claim'Related_relationship x
            , maybe [] (schemaTypeToXML "reference") $ claim'Related_reference x
            ]
instance Extension Claim'Related BackboneElement where
    supertype (Claim'Related a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Claim'Related Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Related -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Payee = Claim'Payee
        { claim'Payee_id :: Maybe String'primitive
        , claim'Payee_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Payee_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Payee_type :: CodeableConcept
          -- ^ Type of Party to be reimbursed: Subscriber, provider, 
          --   other.
        , claim'Payee_resourceType :: Maybe Coding
          -- ^ organization | patient | practitioner | relatedperson.
        , claim'Payee_party :: Maybe Reference
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Payee where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Payee a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "resourceType")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@Claim'Payee{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Payee_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Payee_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Payee_modifierExtension x
            , schemaTypeToXML "type" $ claim'Payee_type x
            , maybe [] (schemaTypeToXML "resourceType") $ claim'Payee_resourceType x
            , maybe [] (schemaTypeToXML "party") $ claim'Payee_party x
            ]
instance Extension Claim'Payee BackboneElement where
    supertype (Claim'Payee a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Claim'Payee Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Payee -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'CareTeam = Claim'CareTeam
        { claim'CareTeam_id :: Maybe String'primitive
        , claim'CareTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'CareTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'CareTeam_sequence :: PositiveInt
          -- ^ Sequence of the careTeam which serves to order and provide 
          --   a link.
        , claim'CareTeam_provider :: Reference
          -- ^ Member of the team who provided the overall service.
        , claim'CareTeam_responsible :: Maybe Boolean
          -- ^ The party who is billing and responsible for the claimed 
          --   good or service rendered to the patient.
        , claim'CareTeam_role :: Maybe CodeableConcept
          -- ^ The lead, assisting or supervising practitioner and their 
          --   discipline if a multidisiplinary team.
        , claim'CareTeam_qualification :: Maybe CodeableConcept
          -- ^ The qualification which is applicable for this service.
        }
        deriving (Eq,Show)
instance SchemaType Claim'CareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'CareTeam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "provider"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "qualification")
    schemaTypeToXML s x@Claim'CareTeam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'CareTeam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'CareTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'CareTeam_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'CareTeam_sequence x
            , schemaTypeToXML "provider" $ claim'CareTeam_provider x
            , maybe [] (schemaTypeToXML "responsible") $ claim'CareTeam_responsible x
            , maybe [] (schemaTypeToXML "role") $ claim'CareTeam_role x
            , maybe [] (schemaTypeToXML "qualification") $ claim'CareTeam_qualification x
            ]
instance Extension Claim'CareTeam BackboneElement where
    supertype (Claim'CareTeam a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Claim'CareTeam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'CareTeam -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Information = Claim'Information
        { claim'Information_id :: Maybe String'primitive
        , claim'Information_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Information_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Information_sequence :: PositiveInt
          -- ^ Sequence of the information element which serves to provide 
          --   a link.
        , claim'Information_category :: CodeableConcept
          -- ^ The general class of the information supplied: information; 
          --   exception; accident, employment; onset, etc.
        , claim'Information_code :: Maybe CodeableConcept
          -- ^ System and code pertaining to the specific information 
          --   regarding special conditions relating to the setting, 
          --   treatment or patient for which care is sought which may 
          --   influence the adjudication.
        , claim'Information_choice5 :: (Maybe (OneOf2 Date Period))
          -- ^ The date when or period to which this information refers.
          --   
          --   Choice between:
          --   
          --   (1) timingDate
          --   
          --   (2) timingPeriod
        , claim'Information_choice6 :: (Maybe (OneOf4 Xsd.XsdString Quantity Attachment Reference))
          -- ^ Additional data or information such as resources, 
          --   documents, images etc. including references to the data or 
          --   the actual inclusion of the data.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueAttachment
          --   
          --   (4) valueReference
        , claim'Information_reason :: Maybe CodeableConcept
          -- ^ For example, provides the reason for: the additional stay, 
          --   or missing tooth or any other situation where a reason code 
          --   is required in addition to the content.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Information where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Information a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "timingDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timingPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf4 (parseSchemaType "valueString"))
                                     , ("Quantity", fmap TwoOf4 (parseSchemaType "valueQuantity"))
                                     , ("Attachment", fmap ThreeOf4 (parseSchemaType "valueAttachment"))
                                     , ("Reference", fmap FourOf4 (parseSchemaType "valueReference"))
                                     ])
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@Claim'Information{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Information_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Information_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Information_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Information_sequence x
            , schemaTypeToXML "category" $ claim'Information_category x
            , maybe [] (schemaTypeToXML "code") $ claim'Information_code x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timingDate")
                                    (schemaTypeToXML "timingPeriod")
                                   ) $ claim'Information_choice5 x
            , maybe [] (foldOneOf4  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueQuantity")
                                    (schemaTypeToXML "valueAttachment")
                                    (schemaTypeToXML "valueReference")
                                   ) $ claim'Information_choice6 x
            , maybe [] (schemaTypeToXML "reason") $ claim'Information_reason x
            ]
instance Extension Claim'Information BackboneElement where
    supertype (Claim'Information a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Claim'Information Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Information -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Diagnosis = Claim'Diagnosis
        { claim'Diagnosis_id :: Maybe String'primitive
        , claim'Diagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Diagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Diagnosis_sequence :: PositiveInt
          -- ^ Sequence of diagnosis which serves to provide a link.
        , claim'Diagnosis_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ The diagnosis.
          --   
          --   Choice between:
          --   
          --   (1) diagnosisCodeableConcept
          --   
          --   (2) diagnosisReference
        , claim'Diagnosis_type :: [CodeableConcept]
          -- ^ The type of the Diagnosis, for example: admitting, primary, 
          --   secondary, discharge.
        , claim'Diagnosis_packageCode :: Maybe CodeableConcept
          -- ^ The package billing code, for example DRG, based on the 
          --   assigned grouping code system.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Diagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Diagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "diagnosisCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "diagnosisReference"))
                           ]
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "packageCode")
    schemaTypeToXML s x@Claim'Diagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Diagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Diagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Diagnosis_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Diagnosis_sequence x
            , foldOneOf2  (schemaTypeToXML "diagnosisCodeableConcept")
                          (schemaTypeToXML "diagnosisReference")
                          $ claim'Diagnosis_choice3 x
            , concatMap (schemaTypeToXML "type") $ claim'Diagnosis_type x
            , maybe [] (schemaTypeToXML "packageCode") $ claim'Diagnosis_packageCode x
            ]
instance Extension Claim'Diagnosis BackboneElement where
    supertype (Claim'Diagnosis a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Claim'Diagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Diagnosis -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Procedure = Claim'Procedure
        { claim'Procedure_id :: Maybe String'primitive
        , claim'Procedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Procedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Procedure_sequence :: PositiveInt
          -- ^ Sequence of procedures which serves to order and provide a 
          --   link.
        , claim'Procedure_date :: Maybe DateTime
          -- ^ Date and optionally time the procedure was performed .
        , claim'Procedure_choice4 :: OneOf2 CodeableConcept Reference
          -- ^ The procedure code.
          --   
          --   Choice between:
          --   
          --   (1) procedureCodeableConcept
          --   
          --   (2) procedureReference
        }
        deriving (Eq,Show)
instance SchemaType Claim'Procedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Procedure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "date")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "procedureCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "procedureReference"))
                           ]
    schemaTypeToXML s x@Claim'Procedure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Procedure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Procedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Procedure_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Procedure_sequence x
            , maybe [] (schemaTypeToXML "date") $ claim'Procedure_date x
            , foldOneOf2  (schemaTypeToXML "procedureCodeableConcept")
                          (schemaTypeToXML "procedureReference")
                          $ claim'Procedure_choice4 x
            ]
instance Extension Claim'Procedure BackboneElement where
    supertype (Claim'Procedure a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Claim'Procedure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Procedure -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Insurance = Claim'Insurance
        { claim'Insurance_id :: Maybe String'primitive
        , claim'Insurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Insurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Insurance_sequence :: PositiveInt
          -- ^ Sequence of coverage which serves to provide a link and 
          --   convey coordination of benefit order.
        , claim'Insurance_focal :: Boolean
          -- ^ A flag to indicate that this Coverage is the focus for 
          --   adjudication. The Coverage against which the claim is to be 
          --   adjudicated.
        , claim'Insurance_coverage :: Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , claim'Insurance_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , claim'Insurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        , claim'Insurance_claimResponse :: Maybe Reference
          -- ^ The Coverages adjudication details.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Insurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Insurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "focal"
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` many (parseSchemaType "preAuthRef")
            `apply` optional (parseSchemaType "claimResponse")
    schemaTypeToXML s x@Claim'Insurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Insurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Insurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Insurance_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Insurance_sequence x
            , schemaTypeToXML "focal" $ claim'Insurance_focal x
            , schemaTypeToXML "coverage" $ claim'Insurance_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ claim'Insurance_businessArrangement x
            , concatMap (schemaTypeToXML "preAuthRef") $ claim'Insurance_preAuthRef x
            , maybe [] (schemaTypeToXML "claimResponse") $ claim'Insurance_claimResponse x
            ]
instance Extension Claim'Insurance BackboneElement where
    supertype (Claim'Insurance a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Claim'Insurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Insurance -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Accident = Claim'Accident
        { claim'Accident_id :: Maybe String'primitive
        , claim'Accident_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Accident_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Accident_date :: Date
          -- ^ Date of an accident which these services are addressing.
        , claim'Accident_type :: Maybe CodeableConcept
          -- ^ Type of accident: work, auto, etc.
        , claim'Accident_choice4 :: (Maybe (OneOf2 Address Reference))
          -- ^ Accident Place.
          --   
          --   Choice between:
          --   
          --   (1) locationAddress
          --   
          --   (2) locationReference
        }
        deriving (Eq,Show)
instance SchemaType Claim'Accident where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Accident a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Address", fmap OneOf2 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "locationReference"))
                                     ])
    schemaTypeToXML s x@Claim'Accident{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Accident_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Accident_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Accident_modifierExtension x
            , schemaTypeToXML "date" $ claim'Accident_date x
            , maybe [] (schemaTypeToXML "type") $ claim'Accident_type x
            , maybe [] (foldOneOf2  (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ claim'Accident_choice4 x
            ]
instance Extension Claim'Accident BackboneElement where
    supertype (Claim'Accident a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Claim'Accident Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Accident -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Item = Claim'Item
        { claim'Item_id :: Maybe String'primitive
        , claim'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Item_sequence :: PositiveInt
          -- ^ A service line number.
        , claim'Item_careTeamLinkId :: [PositiveInt]
          -- ^ CareTeam applicable for this service or product line.
        , claim'Item_diagnosisLinkId :: [PositiveInt]
          -- ^ Diagnosis applicable for this service or product line.
        , claim'Item_procedureLinkId :: [PositiveInt]
          -- ^ Procedures applicable for this service or product line.
        , claim'Item_informationLinkId :: [PositiveInt]
          -- ^ Exceptions, special conditions and supporting information 
          --   pplicable for this service or product line.
        , claim'Item_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claim'Item_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claim'Item_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a 
          --   group code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , claim'Item_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claim'Item_programCode :: [CodeableConcept]
          -- ^ For programs which require reason codes for the inclusion 
          --   or covering of this billed item under the program or 
          --   sub-program.
        , claim'Item_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , claim'Item_choice13 :: (Maybe (OneOf3 CodeableConcept Address Reference))
          -- ^ Where the service was provided.
          --   
          --   Choice between:
          --   
          --   (1) locationCodeableConcept
          --   
          --   (2) locationAddress
          --   
          --   (3) locationReference
        , claim'Item_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claim'Item_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , claim'Item_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claim'Item_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claim'Item_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , claim'Item_bodySite :: Maybe CodeableConcept
          -- ^ Physical service site on the patient (limb, tooth, etc).
        , claim'Item_subSite :: [CodeableConcept]
          -- ^ A region or surface of the site, eg. limb region or tooth 
          --   surface(s).
        , claim'Item_encounter :: [Reference]
          -- ^ A billed item may include goods or services provided in 
          --   multiple encounters.
        , claim'Item_detail :: [Claim'Detail]
          -- ^ Second tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` many (parseSchemaType "careTeamLinkId")
            `apply` many (parseSchemaType "diagnosisLinkId")
            `apply` many (parseSchemaType "procedureLinkId")
            `apply` many (parseSchemaType "informationLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf3 (parseSchemaType "locationCodeableConcept"))
                                     , ("Address", fmap TwoOf3 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "locationReference"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "subSite")
            `apply` many (parseSchemaType "encounter")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@Claim'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Item_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Item_sequence x
            , concatMap (schemaTypeToXML "careTeamLinkId") $ claim'Item_careTeamLinkId x
            , concatMap (schemaTypeToXML "diagnosisLinkId") $ claim'Item_diagnosisLinkId x
            , concatMap (schemaTypeToXML "procedureLinkId") $ claim'Item_procedureLinkId x
            , concatMap (schemaTypeToXML "informationLinkId") $ claim'Item_informationLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ claim'Item_revenue x
            , maybe [] (schemaTypeToXML "category") $ claim'Item_category x
            , maybe [] (schemaTypeToXML "service") $ claim'Item_service x
            , concatMap (schemaTypeToXML "modifier") $ claim'Item_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claim'Item_programCode x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ claim'Item_choice12 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "locationCodeableConcept")
                                    (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ claim'Item_choice13 x
            , maybe [] (schemaTypeToXML "quantity") $ claim'Item_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claim'Item_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claim'Item_factor x
            , maybe [] (schemaTypeToXML "net") $ claim'Item_net x
            , concatMap (schemaTypeToXML "udi") $ claim'Item_udi x
            , maybe [] (schemaTypeToXML "bodySite") $ claim'Item_bodySite x
            , concatMap (schemaTypeToXML "subSite") $ claim'Item_subSite x
            , concatMap (schemaTypeToXML "encounter") $ claim'Item_encounter x
            , concatMap (schemaTypeToXML "detail") $ claim'Item_detail x
            ]
instance Extension Claim'Item BackboneElement where
    supertype (Claim'Item a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               BackboneElement a0 e0 e1
instance Extension Claim'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Item -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'Detail = Claim'Detail
        { claim'Detail_id :: Maybe String'primitive
        , claim'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'Detail_sequence :: PositiveInt
          -- ^ A service line number.
        , claim'Detail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claim'Detail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claim'Detail_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , claim'Detail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claim'Detail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , claim'Detail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claim'Detail_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , claim'Detail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claim'Detail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claim'Detail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , claim'Detail_subDetail :: [Claim'SubDetail]
          -- ^ Third tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType Claim'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@Claim'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'Detail_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'Detail_sequence x
            , maybe [] (schemaTypeToXML "revenue") $ claim'Detail_revenue x
            , maybe [] (schemaTypeToXML "category") $ claim'Detail_category x
            , maybe [] (schemaTypeToXML "service") $ claim'Detail_service x
            , concatMap (schemaTypeToXML "modifier") $ claim'Detail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claim'Detail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ claim'Detail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claim'Detail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claim'Detail_factor x
            , maybe [] (schemaTypeToXML "net") $ claim'Detail_net x
            , concatMap (schemaTypeToXML "udi") $ claim'Detail_udi x
            , concatMap (schemaTypeToXML "subDetail") $ claim'Detail_subDetail x
            ]
instance Extension Claim'Detail BackboneElement where
    supertype (Claim'Detail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension Claim'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'Detail -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data Claim'SubDetail = Claim'SubDetail
        { claim'SubDetail_id :: Maybe String'primitive
        , claim'SubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim'SubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim'SubDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , claim'SubDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claim'SubDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claim'SubDetail_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , claim'SubDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claim'SubDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , claim'SubDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claim'SubDetail_unitPrice :: Maybe Money
          -- ^ The fee for an addittional service or product or charge.
        , claim'SubDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claim'SubDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claim'SubDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        }
        deriving (Eq,Show)
instance SchemaType Claim'SubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Claim'SubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
    schemaTypeToXML s x@Claim'SubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claim'SubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claim'SubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim'SubDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ claim'SubDetail_sequence x
            , maybe [] (schemaTypeToXML "revenue") $ claim'SubDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ claim'SubDetail_category x
            , maybe [] (schemaTypeToXML "service") $ claim'SubDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ claim'SubDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claim'SubDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ claim'SubDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claim'SubDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claim'SubDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ claim'SubDetail_net x
            , concatMap (schemaTypeToXML "udi") $ claim'SubDetail_udi x
            ]
instance Extension Claim'SubDetail BackboneElement where
    supertype (Claim'SubDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               BackboneElement a0 e0 e1
instance Extension Claim'SubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Claim'SubDetail -> BackboneElement)
              
 
data Use'list
    = Use'list_Complete
      -- ^ Complete
    | Use'list_Proposed
      -- ^ Proposed
    | Use'list_Exploratory
      -- ^ Exploratory
    | Use'list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType Use'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Use'list where
    acceptingParser =  do literal "complete"; return Use'list_Complete
                      `onFail` do literal "proposed"; return Use'list_Proposed
                      `onFail` do literal "exploratory"; return Use'list_Exploratory
                      `onFail` do literal "other"; return Use'list_Other
                      
    simpleTypeText Use'list_Complete = "complete"
    simpleTypeText Use'list_Proposed = "proposed"
    simpleTypeText Use'list_Exploratory = "exploratory"
    simpleTypeText Use'list_Other = "other"
 
data Use = Use
        { use_id :: Maybe String'primitive
        , use_value :: Maybe Use'list
        , use_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Use where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Use a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Use{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ use_id x
                       , maybe [] (toXMLAttribute "value") $ use_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ use_extension x
            ]
instance Extension Use Element where
    supertype (Use a0 a1 e0) =
               Element a0 e0
 
data FinancialResourceStatusCodes'list
    = FinancialResourceStatusCodes'list_Active
      -- ^ Active
    | FinancialResourceStatusCodes'list_Cancelled
      -- ^ Cancelled
    | FinancialResourceStatusCodes'list_Draft
      -- ^ Draft
    | FinancialResourceStatusCodes'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FinancialResourceStatusCodes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FinancialResourceStatusCodes'list where
    acceptingParser =  do literal "active"; return FinancialResourceStatusCodes'list_Active
                      `onFail` do literal "cancelled"; return FinancialResourceStatusCodes'list_Cancelled
                      `onFail` do literal "draft"; return FinancialResourceStatusCodes'list_Draft
                      `onFail` do literal "entered-in-error"; return FinancialResourceStatusCodes'list_Entered'in'error
                      
    simpleTypeText FinancialResourceStatusCodes'list_Active = "active"
    simpleTypeText FinancialResourceStatusCodes'list_Cancelled = "cancelled"
    simpleTypeText FinancialResourceStatusCodes'list_Draft = "draft"
    simpleTypeText FinancialResourceStatusCodes'list_Entered'in'error = "entered-in-error"
 
data FinancialResourceStatusCodes = FinancialResourceStatusCodes
        { financialResourceStatusCodes_id :: Maybe String'primitive
        , financialResourceStatusCodes_value :: Maybe FinancialResourceStatusCodes'list
        , financialResourceStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FinancialResourceStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FinancialResourceStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FinancialResourceStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ financialResourceStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ financialResourceStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ financialResourceStatusCodes_extension x
            ]
instance Extension FinancialResourceStatusCodes Element where
    supertype (FinancialResourceStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
elementClaimResponse :: XMLParser ClaimResponse
elementClaimResponse = parseSchemaType "ClaimResponse"
elementToXMLClaimResponse :: ClaimResponse -> [Content ()]
elementToXMLClaimResponse = schemaTypeToXML "ClaimResponse"
 
data ClaimResponse = ClaimResponse
        { claimResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , claimResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , claimResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , claimResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , claimResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , claimResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , claimResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , claimResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , claimResponse_patient :: Maybe Reference
          -- ^ Patient Resource.
        , claimResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , claimResponse_insurer :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , claimResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , claimResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , claimResponse_request :: Maybe Reference
          -- ^ Original request resource referrence.
        , claimResponse_outcome :: Maybe CodeableConcept
          -- ^ Processing outcome errror, partial or complete processing.
        , claimResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , claimResponse_payeeType :: Maybe CodeableConcept
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        , claimResponse_item :: [ClaimResponse'Item]
          -- ^ The first tier service adjudications for submitted 
          --   services.
        , claimResponse_addItem :: [ClaimResponse'AddItem]
          -- ^ The first tier service adjudications for payor added 
          --   services.
        , claimResponse_error :: [ClaimResponse'Error]
          -- ^ Mutually exclusive with Services Provided (Item).
        , claimResponse_totalCost :: Maybe Money
          -- ^ The total cost of the services reported.
        , claimResponse_unallocDeductable :: Maybe Money
          -- ^ The amount of deductible applied which was not allocated to 
          --   any particular service line.
        , claimResponse_totalBenefit :: Maybe Money
          -- ^ Total amount of benefit payable (Equal to sum of the 
          --   Benefit amounts from all detail lines and additions less 
          --   the Unallocated Deductible).
        , claimResponse_payment :: Maybe ClaimResponse'Payment
          -- ^ Payment details for the claim if the claim has been paid.
        , claimResponse_reserved :: Maybe Coding
          -- ^ Status of funds reservation (For provider, for Patient, 
          --   None).
        , claimResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , claimResponse_processNote :: [ClaimResponse'ProcessNote]
          -- ^ Note text.
        , claimResponse_communicationRequest :: [Reference]
          -- ^ Request for additional supporting or authorizing 
          --   information, such as: documents, images or resources.
        , claimResponse_insurance :: [ClaimResponse'Insurance]
          -- ^ Financial instrument by which payment information for 
          --   health care.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ClaimResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "payeeType")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "addItem")
            `apply` many (parseSchemaType "error")
            `apply` optional (parseSchemaType "totalCost")
            `apply` optional (parseSchemaType "unallocDeductable")
            `apply` optional (parseSchemaType "totalBenefit")
            `apply` optional (parseSchemaType "payment")
            `apply` optional (parseSchemaType "reserved")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "communicationRequest")
            `apply` many (parseSchemaType "insurance")
    schemaTypeToXML s x@ClaimResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ claimResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ claimResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ claimResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ claimResponse_language x
            , maybe [] (schemaTypeToXML "text") $ claimResponse_text x
            , concatMap (schemaTypeToXML "contained") $ claimResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ claimResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ claimResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ claimResponse_status x
            , maybe [] (schemaTypeToXML "patient") $ claimResponse_patient x
            , maybe [] (schemaTypeToXML "created") $ claimResponse_created x
            , maybe [] (schemaTypeToXML "insurer") $ claimResponse_insurer x
            , maybe [] (schemaTypeToXML "requestProvider") $ claimResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ claimResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "request") $ claimResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ claimResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ claimResponse_disposition x
            , maybe [] (schemaTypeToXML "payeeType") $ claimResponse_payeeType x
            , concatMap (schemaTypeToXML "item") $ claimResponse_item x
            , concatMap (schemaTypeToXML "addItem") $ claimResponse_addItem x
            , concatMap (schemaTypeToXML "error") $ claimResponse_error x
            , maybe [] (schemaTypeToXML "totalCost") $ claimResponse_totalCost x
            , maybe [] (schemaTypeToXML "unallocDeductable") $ claimResponse_unallocDeductable x
            , maybe [] (schemaTypeToXML "totalBenefit") $ claimResponse_totalBenefit x
            , maybe [] (schemaTypeToXML "payment") $ claimResponse_payment x
            , maybe [] (schemaTypeToXML "reserved") $ claimResponse_reserved x
            , maybe [] (schemaTypeToXML "form") $ claimResponse_form x
            , concatMap (schemaTypeToXML "processNote") $ claimResponse_processNote x
            , concatMap (schemaTypeToXML "communicationRequest") $ claimResponse_communicationRequest x
            , concatMap (schemaTypeToXML "insurance") $ claimResponse_insurance x
            ]
instance Extension ClaimResponse DomainResource where
    supertype (ClaimResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ClaimResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ClaimResponse -> DomainResource)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Item = ClaimResponse'Item
        { claimResponse'Item_id :: Maybe String'primitive
        , claimResponse'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Item_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponse'Item_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponse'Item_adjudication :: [ClaimResponse'Adjudication]
          -- ^ The adjudication results.
        , claimResponse'Item_detail :: [ClaimResponse'Detail]
          -- ^ The second tier service adjudications for submitted 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ClaimResponse'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Item_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponse'Item_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponse'Item_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponse'Item_adjudication x
            , concatMap (schemaTypeToXML "detail") $ claimResponse'Item_detail x
            ]
instance Extension ClaimResponse'Item BackboneElement where
    supertype (ClaimResponse'Item a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Item -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Adjudication = ClaimResponse'Adjudication
        { claimResponse'Adjudication_id :: Maybe String'primitive
        , claimResponse'Adjudication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Adjudication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Adjudication_category :: CodeableConcept
          -- ^ Code indicating: Co-Pay, deductible, eligible, benefit, 
          --   tax, etc.
        , claimResponse'Adjudication_reason :: Maybe CodeableConcept
          -- ^ Adjudication reason such as limit reached.
        , claimResponse'Adjudication_amount :: Maybe Money
          -- ^ Monetary amount associated with the code.
        , claimResponse'Adjudication_value :: Maybe Decimal
          -- ^ A non-monetary value for example a percentage. Mutually 
          --   exclusive to the amount element above.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Adjudication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Adjudication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@ClaimResponse'Adjudication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Adjudication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Adjudication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Adjudication_modifierExtension x
            , schemaTypeToXML "category" $ claimResponse'Adjudication_category x
            , maybe [] (schemaTypeToXML "reason") $ claimResponse'Adjudication_reason x
            , maybe [] (schemaTypeToXML "amount") $ claimResponse'Adjudication_amount x
            , maybe [] (schemaTypeToXML "value") $ claimResponse'Adjudication_value x
            ]
instance Extension ClaimResponse'Adjudication BackboneElement where
    supertype (ClaimResponse'Adjudication a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Adjudication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Adjudication -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Detail = ClaimResponse'Detail
        { claimResponse'Detail_id :: Maybe String'primitive
        , claimResponse'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Detail_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponse'Detail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponse'Detail_adjudication :: [ClaimResponse'Adjudication]
          -- ^ The adjudications results.
        , claimResponse'Detail_subDetail :: [ClaimResponse'SubDetail]
          -- ^ The third tier service adjudications for submitted 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@ClaimResponse'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Detail_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponse'Detail_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponse'Detail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponse'Detail_adjudication x
            , concatMap (schemaTypeToXML "subDetail") $ claimResponse'Detail_subDetail x
            ]
instance Extension ClaimResponse'Detail BackboneElement where
    supertype (ClaimResponse'Detail a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Detail -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'SubDetail = ClaimResponse'SubDetail
        { claimResponse'SubDetail_id :: Maybe String'primitive
        , claimResponse'SubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'SubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'SubDetail_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponse'SubDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponse'SubDetail_adjudication :: [ClaimResponse'Adjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'SubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'SubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ClaimResponse'SubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'SubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'SubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'SubDetail_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponse'SubDetail_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponse'SubDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponse'SubDetail_adjudication x
            ]
instance Extension ClaimResponse'SubDetail BackboneElement where
    supertype (ClaimResponse'SubDetail a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'SubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'SubDetail -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'AddItem = ClaimResponse'AddItem
        { claimResponse'AddItem_id :: Maybe String'primitive
        , claimResponse'AddItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'AddItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'AddItem_sequenceLinkId :: [PositiveInt]
          -- ^ List of input service items which this service line is 
          --   intended to replace.
        , claimResponse'AddItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimResponse'AddItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimResponse'AddItem_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied.
        , claimResponse'AddItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimResponse'AddItem_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product..
        , claimResponse'AddItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponse'AddItem_adjudication :: [ClaimResponse'Adjudication]
          -- ^ The adjudications results.
        , claimResponse'AddItem_detail :: [ClaimResponse'Detail1]
          -- ^ The second tier service adjudications for payor added 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'AddItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'AddItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ClaimResponse'AddItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'AddItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'AddItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'AddItem_modifierExtension x
            , concatMap (schemaTypeToXML "sequenceLinkId") $ claimResponse'AddItem_sequenceLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ claimResponse'AddItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimResponse'AddItem_category x
            , maybe [] (schemaTypeToXML "service") $ claimResponse'AddItem_service x
            , concatMap (schemaTypeToXML "modifier") $ claimResponse'AddItem_modifier x
            , maybe [] (schemaTypeToXML "fee") $ claimResponse'AddItem_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponse'AddItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponse'AddItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ claimResponse'AddItem_detail x
            ]
instance Extension ClaimResponse'AddItem BackboneElement where
    supertype (ClaimResponse'AddItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'AddItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'AddItem -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Detail1 = ClaimResponse'Detail1
        { claimResponse'Detail1_id :: Maybe String'primitive
        , claimResponse'Detail1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Detail1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Detail1_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimResponse'Detail1_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimResponse'Detail1_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied.
        , claimResponse'Detail1_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimResponse'Detail1_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product..
        , claimResponse'Detail1_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponse'Detail1_adjudication :: [ClaimResponse'Adjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Detail1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Detail1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ClaimResponse'Detail1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Detail1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Detail1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Detail1_modifierExtension x
            , maybe [] (schemaTypeToXML "revenue") $ claimResponse'Detail1_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimResponse'Detail1_category x
            , maybe [] (schemaTypeToXML "service") $ claimResponse'Detail1_service x
            , concatMap (schemaTypeToXML "modifier") $ claimResponse'Detail1_modifier x
            , maybe [] (schemaTypeToXML "fee") $ claimResponse'Detail1_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponse'Detail1_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponse'Detail1_adjudication x
            ]
instance Extension ClaimResponse'Detail1 BackboneElement where
    supertype (ClaimResponse'Detail1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Detail1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Detail1 -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Error = ClaimResponse'Error
        { claimResponse'Error_id :: Maybe String'primitive
        , claimResponse'Error_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Error_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Error_sequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the line item submitted which 
          --   contains the error. This value is omitted when the error is 
          --   elsewhere.
        , claimResponse'Error_detailSequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the addition within the line item 
          --   submitted which contains the error. This value is omitted 
          --   when the error is not related to an Addition.
        , claimResponse'Error_subdetailSequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the addition within the line item 
          --   submitted which contains the error. This value is omitted 
          --   when the error is not related to an Addition.
        , claimResponse'Error_code :: CodeableConcept
          -- ^ An error code,from a specified code system, which details 
          --   why the claim could not be adjudicated.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Error where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Error a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "detailSequenceLinkId")
            `apply` optional (parseSchemaType "subdetailSequenceLinkId")
            `apply` parseSchemaType "code"
    schemaTypeToXML s x@ClaimResponse'Error{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Error_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Error_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Error_modifierExtension x
            , maybe [] (schemaTypeToXML "sequenceLinkId") $ claimResponse'Error_sequenceLinkId x
            , maybe [] (schemaTypeToXML "detailSequenceLinkId") $ claimResponse'Error_detailSequenceLinkId x
            , maybe [] (schemaTypeToXML "subdetailSequenceLinkId") $ claimResponse'Error_subdetailSequenceLinkId x
            , schemaTypeToXML "code" $ claimResponse'Error_code x
            ]
instance Extension ClaimResponse'Error BackboneElement where
    supertype (ClaimResponse'Error a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Error Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Error -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Payment = ClaimResponse'Payment
        { claimResponse'Payment_id :: Maybe String'primitive
        , claimResponse'Payment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Payment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Payment_type :: Maybe CodeableConcept
          -- ^ Whether this represents partial or complete payment of the 
          --   claim.
        , claimResponse'Payment_adjustment :: Maybe Money
          -- ^ Adjustment to the payment of this transaction which is not 
          --   related to adjudication of this transaction.
        , claimResponse'Payment_adjustmentReason :: Maybe CodeableConcept
          -- ^ Reason for the payment adjustment.
        , claimResponse'Payment_date :: Maybe Date
          -- ^ Estimated payment data.
        , claimResponse'Payment_amount :: Maybe Money
          -- ^ Payable less any payment adjustment.
        , claimResponse'Payment_identifier :: Maybe Identifier
          -- ^ Payment identifier.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Payment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Payment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "adjustment")
            `apply` optional (parseSchemaType "adjustmentReason")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "identifier")
    schemaTypeToXML s x@ClaimResponse'Payment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Payment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Payment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Payment_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ claimResponse'Payment_type x
            , maybe [] (schemaTypeToXML "adjustment") $ claimResponse'Payment_adjustment x
            , maybe [] (schemaTypeToXML "adjustmentReason") $ claimResponse'Payment_adjustmentReason x
            , maybe [] (schemaTypeToXML "date") $ claimResponse'Payment_date x
            , maybe [] (schemaTypeToXML "amount") $ claimResponse'Payment_amount x
            , maybe [] (schemaTypeToXML "identifier") $ claimResponse'Payment_identifier x
            ]
instance Extension ClaimResponse'Payment BackboneElement where
    supertype (ClaimResponse'Payment a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Payment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Payment -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'ProcessNote = ClaimResponse'ProcessNote
        { claimResponse'ProcessNote_id :: Maybe String'primitive
        , claimResponse'ProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'ProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'ProcessNote_number :: Maybe PositiveInt
          -- ^ An integer associated with each note which may be referred 
          --   to from each service line item.
        , claimResponse'ProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , claimResponse'ProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        , claimResponse'ProcessNote_language :: Maybe CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'ProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'ProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "number")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@ClaimResponse'ProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'ProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'ProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'ProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "number") $ claimResponse'ProcessNote_number x
            , maybe [] (schemaTypeToXML "type") $ claimResponse'ProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ claimResponse'ProcessNote_text x
            , maybe [] (schemaTypeToXML "language") $ claimResponse'ProcessNote_language x
            ]
instance Extension ClaimResponse'ProcessNote BackboneElement where
    supertype (ClaimResponse'ProcessNote a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'ProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'ProcessNote -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponse'Insurance = ClaimResponse'Insurance
        { claimResponse'Insurance_id :: Maybe String'primitive
        , claimResponse'Insurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse'Insurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse'Insurance_sequence :: PositiveInt
          -- ^ A service line item.
        , claimResponse'Insurance_focal :: Boolean
          -- ^ The instance number of the Coverage which is the focus for 
          --   adjudication. The Coverage against which the claim is to be 
          --   adjudicated.
        , claimResponse'Insurance_coverage :: Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , claimResponse'Insurance_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , claimResponse'Insurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        , claimResponse'Insurance_claimResponse :: Maybe Reference
          -- ^ The Coverages adjudication details.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse'Insurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponse'Insurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "focal"
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` many (parseSchemaType "preAuthRef")
            `apply` optional (parseSchemaType "claimResponse")
    schemaTypeToXML s x@ClaimResponse'Insurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponse'Insurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponse'Insurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse'Insurance_modifierExtension x
            , schemaTypeToXML "sequence" $ claimResponse'Insurance_sequence x
            , schemaTypeToXML "focal" $ claimResponse'Insurance_focal x
            , schemaTypeToXML "coverage" $ claimResponse'Insurance_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ claimResponse'Insurance_businessArrangement x
            , concatMap (schemaTypeToXML "preAuthRef") $ claimResponse'Insurance_preAuthRef x
            , maybe [] (schemaTypeToXML "claimResponse") $ claimResponse'Insurance_claimResponse x
            ]
instance Extension ClaimResponse'Insurance BackboneElement where
    supertype (ClaimResponse'Insurance a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponse'Insurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponse'Insurance -> BackboneElement)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
elementClinicalImpression :: XMLParser ClinicalImpression
elementClinicalImpression = parseSchemaType "ClinicalImpression"
elementToXMLClinicalImpression :: ClinicalImpression -> [Content ()]
elementToXMLClinicalImpression = schemaTypeToXML "ClinicalImpression"
 
data ClinicalImpression = ClinicalImpression
        { clinicalImpression_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , clinicalImpression_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , clinicalImpression_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , clinicalImpression_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , clinicalImpression_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , clinicalImpression_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , clinicalImpression_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpression_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpression_identifier :: [Identifier]
          -- ^ A unique identifier assigned to the clinical impression 
          --   that remains consistent regardless of what server the 
          --   impression is stored on.
        , clinicalImpression_status :: ClinicalImpressionStatus
          -- ^ Identifies the workflow status of the assessment.
        , clinicalImpression_code :: Maybe CodeableConcept
          -- ^ Categorizes the type of clinical assessment performed.
        , clinicalImpression_description :: Maybe Xsd.XsdString
          -- ^ A summary of the context and/or cause of the assessment - 
          --   why / where was it performed, and what patient 
          --   events/status prompted it.
        , clinicalImpression_subject :: Reference
          -- ^ The patient or group of individuals assessed as part of 
          --   this record.
        , clinicalImpression_context :: Maybe Reference
          -- ^ The encounter or episode of care this impression was 
          --   created as part of.
        , clinicalImpression_choice14 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The point in time or period over which the subject was 
          --   assessed.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , clinicalImpression_date :: Maybe DateTime
          -- ^ Indicates when the documentation of the assessment was 
          --   complete.
        , clinicalImpression_assessor :: Maybe Reference
          -- ^ The clinician performing the assessment.
        , clinicalImpression_previous :: Maybe Reference
          -- ^ A reference to the last assesment that was conducted bon 
          --   this patient. Assessments are often/usually ongoing in 
          --   nature; a care provider (practitioner or team) will make 
          --   new assessments on an ongoing basis as new data arises or 
          --   the patient's conditions changes.
        , clinicalImpression_problem :: [Reference]
          -- ^ This a list of the relevant problems/conditions for a 
          --   patient.
        , clinicalImpression_investigation :: [ClinicalImpression'Investigation]
          -- ^ One or more sets of investigations (signs, symptions, 
          --   etc.). The actual grouping of investigations vary greatly 
          --   depending on the type and context of the assessment. These 
          --   investigations may include data generated during the 
          --   assessment process, or data previously generated and 
          --   recorded that is pertinent to the outcomes.
        , clinicalImpression_protocol :: [Uri]
          -- ^ Reference to a specific published clinical protocol that 
          --   was followed during this assessment, and/or that provides 
          --   evidence in support of the diagnosis.
        , clinicalImpression_summary :: Maybe Xsd.XsdString
          -- ^ A text summary of the investigations and the diagnosis.
        , clinicalImpression_finding :: [ClinicalImpression'Finding]
          -- ^ Specific findings or diagnoses that was considered likely 
          --   or relevant to ongoing treatment.
        , clinicalImpression_prognosisCodeableConcept :: [CodeableConcept]
          -- ^ Estimate of likely outcome.
        , clinicalImpression_prognosisReference :: [Reference]
          -- ^ RiskAssessment expressing likely outcome.
        , clinicalImpression_action :: [Reference]
          -- ^ Action taken as part of assessment procedure.
        , clinicalImpression_note :: [Annotation]
          -- ^ Commentary about the impression, typically recorded after 
          --   the impression itself was made, though supplemental notes 
          --   by the original author could also appear.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpression where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ClinicalImpression
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "assessor")
            `apply` optional (parseSchemaType "previous")
            `apply` many (parseSchemaType "problem")
            `apply` many (parseSchemaType "investigation")
            `apply` many (parseSchemaType "protocol")
            `apply` optional (parseSchemaType "summary")
            `apply` many (parseSchemaType "finding")
            `apply` many (parseSchemaType "prognosisCodeableConcept")
            `apply` many (parseSchemaType "prognosisReference")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@ClinicalImpression{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ clinicalImpression_id x
            , maybe [] (schemaTypeToXML "meta") $ clinicalImpression_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ clinicalImpression_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ clinicalImpression_language x
            , maybe [] (schemaTypeToXML "text") $ clinicalImpression_text x
            , concatMap (schemaTypeToXML "contained") $ clinicalImpression_contained x
            , concatMap (schemaTypeToXML "extension") $ clinicalImpression_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpression_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ clinicalImpression_identifier x
            , schemaTypeToXML "status" $ clinicalImpression_status x
            , maybe [] (schemaTypeToXML "code") $ clinicalImpression_code x
            , maybe [] (schemaTypeToXML "description") $ clinicalImpression_description x
            , schemaTypeToXML "subject" $ clinicalImpression_subject x
            , maybe [] (schemaTypeToXML "context") $ clinicalImpression_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ clinicalImpression_choice14 x
            , maybe [] (schemaTypeToXML "date") $ clinicalImpression_date x
            , maybe [] (schemaTypeToXML "assessor") $ clinicalImpression_assessor x
            , maybe [] (schemaTypeToXML "previous") $ clinicalImpression_previous x
            , concatMap (schemaTypeToXML "problem") $ clinicalImpression_problem x
            , concatMap (schemaTypeToXML "investigation") $ clinicalImpression_investigation x
            , concatMap (schemaTypeToXML "protocol") $ clinicalImpression_protocol x
            , maybe [] (schemaTypeToXML "summary") $ clinicalImpression_summary x
            , concatMap (schemaTypeToXML "finding") $ clinicalImpression_finding x
            , concatMap (schemaTypeToXML "prognosisCodeableConcept") $ clinicalImpression_prognosisCodeableConcept x
            , concatMap (schemaTypeToXML "prognosisReference") $ clinicalImpression_prognosisReference x
            , concatMap (schemaTypeToXML "action") $ clinicalImpression_action x
            , concatMap (schemaTypeToXML "note") $ clinicalImpression_note x
            ]
instance Extension ClinicalImpression DomainResource where
    supertype (ClinicalImpression e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ClinicalImpression Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ClinicalImpression -> DomainResource)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
data ClinicalImpression'Investigation = ClinicalImpression'Investigation
        { clinicalImpression'Investigation_id :: Maybe String'primitive
        , clinicalImpression'Investigation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpression'Investigation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpression'Investigation_code :: CodeableConcept
          -- ^ A name/code for the group (&quot;set&quot;) of 
          --   investigations. Typically, this will be something like 
          --   &quot;signs&quot;, &quot;symptoms&quot;, 
          --   &quot;clinical&quot;, &quot;diagnostic&quot;, but the list 
          --   is not constrained, and others such groups such as 
          --   (exposure|family|travel|nutitirional) history may be used.
        , clinicalImpression'Investigation_item :: [Reference]
          -- ^ A record of a specific investigation that was undertaken.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpression'Investigation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClinicalImpression'Investigation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@ClinicalImpression'Investigation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpression'Investigation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpression'Investigation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpression'Investigation_modifierExtension x
            , schemaTypeToXML "code" $ clinicalImpression'Investigation_code x
            , concatMap (schemaTypeToXML "item") $ clinicalImpression'Investigation_item x
            ]
instance Extension ClinicalImpression'Investigation BackboneElement where
    supertype (ClinicalImpression'Investigation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ClinicalImpression'Investigation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClinicalImpression'Investigation -> BackboneElement)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
data ClinicalImpression'Finding = ClinicalImpression'Finding
        { clinicalImpression'Finding_id :: Maybe String'primitive
        , clinicalImpression'Finding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpression'Finding_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpression'Finding_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ Specific text, code or reference for finding or diagnosis, 
          --   which may include ruled-out or resolved conditions.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , clinicalImpression'Finding_basis :: Maybe Xsd.XsdString
          -- ^ Which investigations support finding or diagnosis.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpression'Finding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClinicalImpression'Finding a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "basis")
    schemaTypeToXML s x@ClinicalImpression'Finding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpression'Finding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpression'Finding_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpression'Finding_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ clinicalImpression'Finding_choice2 x
            , maybe [] (schemaTypeToXML "basis") $ clinicalImpression'Finding_basis x
            ]
instance Extension ClinicalImpression'Finding BackboneElement where
    supertype (ClinicalImpression'Finding a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ClinicalImpression'Finding Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClinicalImpression'Finding -> BackboneElement)
              
 
data ClinicalImpressionStatus'list
    = ClinicalImpressionStatus'list_Draft
      -- ^ In progress
    | ClinicalImpressionStatus'list_Completed
      -- ^ Completed
    | ClinicalImpressionStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ClinicalImpressionStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ClinicalImpressionStatus'list where
    acceptingParser =  do literal "draft"; return ClinicalImpressionStatus'list_Draft
                      `onFail` do literal "completed"; return ClinicalImpressionStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return ClinicalImpressionStatus'list_Entered'in'error
                      
    simpleTypeText ClinicalImpressionStatus'list_Draft = "draft"
    simpleTypeText ClinicalImpressionStatus'list_Completed = "completed"
    simpleTypeText ClinicalImpressionStatus'list_Entered'in'error = "entered-in-error"
 
data ClinicalImpressionStatus = ClinicalImpressionStatus
        { clinicalImpressionStatus_id :: Maybe String'primitive
        , clinicalImpressionStatus_value :: Maybe ClinicalImpressionStatus'list
        , clinicalImpressionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpressionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ClinicalImpressionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ClinicalImpressionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpressionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ clinicalImpressionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpressionStatus_extension x
            ]
instance Extension ClinicalImpressionStatus Element where
    supertype (ClinicalImpressionStatus a0 a1 e0) =
               Element a0 e0
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
elementCodeSystem :: XMLParser CodeSystem
elementCodeSystem = parseSchemaType "CodeSystem"
elementToXMLCodeSystem :: CodeSystem -> [Content ()]
elementToXMLCodeSystem = schemaTypeToXML "CodeSystem"
 
data CodeSystem = CodeSystem
        { codeSystem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , codeSystem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , codeSystem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , codeSystem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , codeSystem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , codeSystem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , codeSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this code system 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this code system 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the code system. For more information see 
          --   [Technical and Business Versions](resource.html#versions). 
          --   This is used in [Coding]{datatypes.html#Coding}.system.
        , codeSystem_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this code 
          --   system when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , codeSystem_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   code system when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the code system author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. This is used in 
          --   [Coding]{datatypes.html#Coding}.version.
        , codeSystem_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the code system. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , codeSystem_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the code 
          --   system.
        , codeSystem_status :: PublicationStatus
          -- ^ The status of this code system. Enables tracking the 
          --   life-cycle of the content.
        , codeSystem_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this code system is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , codeSystem_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the code system was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the code system changes.
        , codeSystem_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the code system.
        , codeSystem_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , codeSystem_description :: Maybe Markdown
          -- ^ A free text natural language description of the code system 
          --   from a consumer's perspective.
        , codeSystem_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   code system instances.
        , codeSystem_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the code system is 
          --   intended to be used.
        , codeSystem_purpose :: Maybe Markdown
          -- ^ Explaination of why this code system is needed and why it 
          --   has been designed as it has.
        , codeSystem_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the code system and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the code system.
        , codeSystem_caseSensitive :: Maybe Boolean
          -- ^ If code comparison is case sensitive when codes within this 
          --   system are compared to each other.
        , codeSystem_valueSet :: Maybe Uri
          -- ^ Canonical URL of value set that contains the entire code 
          --   system.
        , codeSystem_hierarchyMeaning :: Maybe CodeSystemHierarchyMeaning
          -- ^ The meaning of the hierarchy of concepts.
        , codeSystem_compositional :: Maybe Boolean
          -- ^ True If code system defines a post-composition grammar.
        , codeSystem_versionNeeded :: Maybe Boolean
          -- ^ This flag is used to signify that the code system has not 
          --   (or does not) maintain the definitions, and a version must 
          --   be specified when referencing this code system.
        , codeSystem_content :: CodeSystemContentMode
          -- ^ How much of the content of the code system - the concepts 
          --   and codes it defines - are represented in this resource.
        , codeSystem_count :: Maybe UnsignedInt
          -- ^ The total number of concepts defined by the code system. 
          --   Where the code system has a compositional grammar, the 
          --   count refers to the number of base (primitive) concepts.
        , codeSystem_filter :: [CodeSystem'Filter]
          -- ^ A filter that can be used in a value set compose statement 
          --   when selecting concepts using a filter.
        , codeSystem_property :: [CodeSystem'Property]
          -- ^ A property defines an additional slot through which 
          --   additional information can be provided about a concept.
        , codeSystem_concept :: [CodeSystem'Concept]
          -- ^ Concepts that are in the code system. The concept 
          --   definitions are inherently hierarchical, but the 
          --   definitions must be consulted to determine what the meaning 
          --   of the hierarchical relationships are.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CodeSystem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "caseSensitive")
            `apply` optional (parseSchemaType "valueSet")
            `apply` optional (parseSchemaType "hierarchyMeaning")
            `apply` optional (parseSchemaType "compositional")
            `apply` optional (parseSchemaType "versionNeeded")
            `apply` parseSchemaType "content"
            `apply` optional (parseSchemaType "count")
            `apply` many (parseSchemaType "filter")
            `apply` many (parseSchemaType "property")
            `apply` many (parseSchemaType "concept")
    schemaTypeToXML s x@CodeSystem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ codeSystem_id x
            , maybe [] (schemaTypeToXML "meta") $ codeSystem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ codeSystem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ codeSystem_language x
            , maybe [] (schemaTypeToXML "text") $ codeSystem_text x
            , concatMap (schemaTypeToXML "contained") $ codeSystem_contained x
            , concatMap (schemaTypeToXML "extension") $ codeSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ codeSystem_url x
            , maybe [] (schemaTypeToXML "identifier") $ codeSystem_identifier x
            , maybe [] (schemaTypeToXML "version") $ codeSystem_version x
            , maybe [] (schemaTypeToXML "name") $ codeSystem_name x
            , maybe [] (schemaTypeToXML "title") $ codeSystem_title x
            , schemaTypeToXML "status" $ codeSystem_status x
            , maybe [] (schemaTypeToXML "experimental") $ codeSystem_experimental x
            , maybe [] (schemaTypeToXML "date") $ codeSystem_date x
            , maybe [] (schemaTypeToXML "publisher") $ codeSystem_publisher x
            , concatMap (schemaTypeToXML "contact") $ codeSystem_contact x
            , maybe [] (schemaTypeToXML "description") $ codeSystem_description x
            , concatMap (schemaTypeToXML "useContext") $ codeSystem_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ codeSystem_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ codeSystem_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ codeSystem_copyright x
            , maybe [] (schemaTypeToXML "caseSensitive") $ codeSystem_caseSensitive x
            , maybe [] (schemaTypeToXML "valueSet") $ codeSystem_valueSet x
            , maybe [] (schemaTypeToXML "hierarchyMeaning") $ codeSystem_hierarchyMeaning x
            , maybe [] (schemaTypeToXML "compositional") $ codeSystem_compositional x
            , maybe [] (schemaTypeToXML "versionNeeded") $ codeSystem_versionNeeded x
            , schemaTypeToXML "content" $ codeSystem_content x
            , maybe [] (schemaTypeToXML "count") $ codeSystem_count x
            , concatMap (schemaTypeToXML "filter") $ codeSystem_filter x
            , concatMap (schemaTypeToXML "property") $ codeSystem_property x
            , concatMap (schemaTypeToXML "concept") $ codeSystem_concept x
            ]
instance Extension CodeSystem DomainResource where
    supertype (CodeSystem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CodeSystem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CodeSystem -> DomainResource)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystem'Filter = CodeSystem'Filter
        { codeSystem'Filter_id :: Maybe String'primitive
        , codeSystem'Filter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem'Filter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem'Filter_code :: Code
          -- ^ The code that identifies this filter when it is used in the 
          --   instance.
        , codeSystem'Filter_description :: Maybe Xsd.XsdString
          -- ^ A description of how or why the filter is used.
        , codeSystem'Filter_operator :: [FilterOperator]
          -- ^ A list of operators that can be used with the filter.
        , codeSystem'Filter_value :: Xsd.XsdString
          -- ^ A description of what the value for the filter should be.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem'Filter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystem'Filter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "operator")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@CodeSystem'Filter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystem'Filter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystem'Filter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem'Filter_modifierExtension x
            , schemaTypeToXML "code" $ codeSystem'Filter_code x
            , maybe [] (schemaTypeToXML "description") $ codeSystem'Filter_description x
            , concatMap (schemaTypeToXML "operator") $ codeSystem'Filter_operator x
            , schemaTypeToXML "value" $ codeSystem'Filter_value x
            ]
instance Extension CodeSystem'Filter BackboneElement where
    supertype (CodeSystem'Filter a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CodeSystem'Filter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystem'Filter -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystem'Property = CodeSystem'Property
        { codeSystem'Property_id :: Maybe String'primitive
        , codeSystem'Property_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem'Property_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem'Property_code :: Code
          -- ^ A code that is used to identify the property. The code is 
          --   used internally (in CodeSystem.concept.property.code) and 
          --   also externally, such as in property filters.
        , codeSystem'Property_uri :: Maybe Uri
          -- ^ Reference to the formal meaning of the property. One 
          --   possible source of meaning is the [Concept 
          --   Properties](codesystem-concept-properties.html) code 
          --   system.
        , codeSystem'Property_description :: Maybe Xsd.XsdString
          -- ^ A description of the property- why it is defined, and how 
          --   its value might be used.
        , codeSystem'Property_type :: PropertyType
          -- ^ The type of the property value. Properties of type 
          --   &quot;code&quot; contain a code defined by the code system 
          --   (e.g. a reference to anotherr defined concept).
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem'Property where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystem'Property a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "type"
    schemaTypeToXML s x@CodeSystem'Property{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystem'Property_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystem'Property_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem'Property_modifierExtension x
            , schemaTypeToXML "code" $ codeSystem'Property_code x
            , maybe [] (schemaTypeToXML "uri") $ codeSystem'Property_uri x
            , maybe [] (schemaTypeToXML "description") $ codeSystem'Property_description x
            , schemaTypeToXML "type" $ codeSystem'Property_type x
            ]
instance Extension CodeSystem'Property BackboneElement where
    supertype (CodeSystem'Property a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CodeSystem'Property Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystem'Property -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystem'Concept = CodeSystem'Concept
        { codeSystem'Concept_id :: Maybe String'primitive
        , codeSystem'Concept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem'Concept_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem'Concept_code :: Code
          -- ^ A code - a text symbol - that uniquely identifies the 
          --   concept within the code system.
        , codeSystem'Concept_display :: Maybe Xsd.XsdString
          -- ^ A human readable string that is the recommended default way 
          --   to present this concept to a user.
        , codeSystem'Concept_definition :: Maybe Xsd.XsdString
          -- ^ The formal definition of the concept. The code system 
          --   resource does not make formal definitions required, because 
          --   of the prevalence of legacy systems. However, they are 
          --   highly recommended, as without them there is no formal 
          --   meaning associated with the concept.
        , codeSystem'Concept_designation :: [CodeSystem'Designation]
          -- ^ Additional representations for the concept - other 
          --   languages, aliases, specialized purposes, used for 
          --   particular purposes, etc.
        , codeSystem'Concept_property :: [CodeSystem'Property1]
          -- ^ A property value for this concept.
        , codeSystem'Concept_concept :: [CodeSystem'Concept]
          -- ^ Defines children of a concept to produce a hierarchy of 
          --   concepts. The nature of the relationships is variable 
          --   (is-a/contains/categorizes) - see hierarchyMeaning.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem'Concept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystem'Concept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "definition")
            `apply` many (parseSchemaType "designation")
            `apply` many (parseSchemaType "property")
            `apply` many (parseSchemaType "concept")
    schemaTypeToXML s x@CodeSystem'Concept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystem'Concept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystem'Concept_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem'Concept_modifierExtension x
            , schemaTypeToXML "code" $ codeSystem'Concept_code x
            , maybe [] (schemaTypeToXML "display") $ codeSystem'Concept_display x
            , maybe [] (schemaTypeToXML "definition") $ codeSystem'Concept_definition x
            , concatMap (schemaTypeToXML "designation") $ codeSystem'Concept_designation x
            , concatMap (schemaTypeToXML "property") $ codeSystem'Concept_property x
            , concatMap (schemaTypeToXML "concept") $ codeSystem'Concept_concept x
            ]
instance Extension CodeSystem'Concept BackboneElement where
    supertype (CodeSystem'Concept a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension CodeSystem'Concept Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystem'Concept -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystem'Designation = CodeSystem'Designation
        { codeSystem'Designation_id :: Maybe String'primitive
        , codeSystem'Designation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem'Designation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem'Designation_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , codeSystem'Designation_use :: Maybe Coding
          -- ^ A code that details how this designation would be used.
        , codeSystem'Designation_value :: Xsd.XsdString
          -- ^ The text value for this designation.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem'Designation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystem'Designation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@CodeSystem'Designation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystem'Designation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystem'Designation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem'Designation_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ codeSystem'Designation_language x
            , maybe [] (schemaTypeToXML "use") $ codeSystem'Designation_use x
            , schemaTypeToXML "value" $ codeSystem'Designation_value x
            ]
instance Extension CodeSystem'Designation BackboneElement where
    supertype (CodeSystem'Designation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CodeSystem'Designation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystem'Designation -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystem'Property1 = CodeSystem'Property1
        { codeSystem'Property1_id :: Maybe String'primitive
        , codeSystem'Property1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem'Property1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem'Property1_code :: Code
          -- ^ A code that is a reference to CodeSystem.property.code.
        , codeSystem'Property1_choice3 :: OneOf6 Code Coding Xsd.XsdString Integer Boolean DateTime
          -- ^ The value of this property.
          --   
          --   Choice between:
          --   
          --   (1) valueCode
          --   
          --   (2) valueCoding
          --   
          --   (3) valueString
          --   
          --   (4) valueInteger
          --   
          --   (5) valueBoolean
          --   
          --   (6) valueDateTime
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem'Property1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystem'Property1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("Code", fmap OneOf6 (parseSchemaType "valueCode"))
                           , ("Coding", fmap TwoOf6 (parseSchemaType "valueCoding"))
                           , ("Xsd.XsdString", fmap ThreeOf6 (parseSchemaType "valueString"))
                           , ("Integer", fmap FourOf6 (parseSchemaType "valueInteger"))
                           , ("Boolean", fmap FiveOf6 (parseSchemaType "valueBoolean"))
                           , ("DateTime", fmap SixOf6 (parseSchemaType "valueDateTime"))
                           ]
    schemaTypeToXML s x@CodeSystem'Property1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystem'Property1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystem'Property1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem'Property1_modifierExtension x
            , schemaTypeToXML "code" $ codeSystem'Property1_code x
            , foldOneOf6  (schemaTypeToXML "valueCode")
                          (schemaTypeToXML "valueCoding")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueDateTime")
                          $ codeSystem'Property1_choice3 x
            ]
instance Extension CodeSystem'Property1 BackboneElement where
    supertype (CodeSystem'Property1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CodeSystem'Property1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystem'Property1 -> BackboneElement)
              
 
data FilterOperator'list
    = FilterOperator'list_V'
      -- ^ Equals
    | FilterOperator'list_Is'a
      -- ^ Is A (by subsumption)
    | FilterOperator'list_Descendent'of
      -- ^ Descendent Of (by subsumption)
    | FilterOperator'list_Is'not'a
      -- ^ Not (Is A) (by subsumption)
    | FilterOperator'list_Regex
      -- ^ Regular Expression
    | FilterOperator'list_In
      -- ^ In Set
    | FilterOperator'list_Not'in
      -- ^ Not in Set
    | FilterOperator'list_Generalizes
      -- ^ Generalizes (by Subsumption)
    | FilterOperator'list_Exists
      -- ^ Exists
    deriving (Eq,Show,Enum)
instance SchemaType FilterOperator'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FilterOperator'list where
    acceptingParser =  do literal "="; return FilterOperator'list_V'
                      `onFail` do literal "is-a"; return FilterOperator'list_Is'a
                      `onFail` do literal "descendent-of"; return FilterOperator'list_Descendent'of
                      `onFail` do literal "is-not-a"; return FilterOperator'list_Is'not'a
                      `onFail` do literal "regex"; return FilterOperator'list_Regex
                      `onFail` do literal "in"; return FilterOperator'list_In
                      `onFail` do literal "not-in"; return FilterOperator'list_Not'in
                      `onFail` do literal "generalizes"; return FilterOperator'list_Generalizes
                      `onFail` do literal "exists"; return FilterOperator'list_Exists
                      
    simpleTypeText FilterOperator'list_V' = "="
    simpleTypeText FilterOperator'list_Is'a = "is-a"
    simpleTypeText FilterOperator'list_Descendent'of = "descendent-of"
    simpleTypeText FilterOperator'list_Is'not'a = "is-not-a"
    simpleTypeText FilterOperator'list_Regex = "regex"
    simpleTypeText FilterOperator'list_In = "in"
    simpleTypeText FilterOperator'list_Not'in = "not-in"
    simpleTypeText FilterOperator'list_Generalizes = "generalizes"
    simpleTypeText FilterOperator'list_Exists = "exists"
 
data FilterOperator = FilterOperator
        { filterOperator_id :: Maybe String'primitive
        , filterOperator_value :: Maybe FilterOperator'list
        , filterOperator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FilterOperator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FilterOperator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FilterOperator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ filterOperator_id x
                       , maybe [] (toXMLAttribute "value") $ filterOperator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ filterOperator_extension x
            ]
instance Extension FilterOperator Element where
    supertype (FilterOperator a0 a1 e0) =
               Element a0 e0
 
data PropertyType'list
    = PropertyType'list_Code
      -- ^ code (internal reference)
    | PropertyType'list_Coding
      -- ^ Coding (external reference)
    | PropertyType'list_Xsd.XsdString
      -- ^ string
    | PropertyType'list_Integer
      -- ^ integer
    | PropertyType'list_Boolean
      -- ^ boolean
    | PropertyType'list_DateTime
      -- ^ dateTime
    deriving (Eq,Show,Enum)
instance SchemaType PropertyType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PropertyType'list where
    acceptingParser =  do literal "code"; return PropertyType'list_Code
                      `onFail` do literal "Coding"; return PropertyType'list_Coding
                      `onFail` do literal "string"; return PropertyType'list_Xsd.XsdString
                      `onFail` do literal "integer"; return PropertyType'list_Integer
                      `onFail` do literal "boolean"; return PropertyType'list_Boolean
                      `onFail` do literal "dateTime"; return PropertyType'list_DateTime
                      
    simpleTypeText PropertyType'list_Code = "code"
    simpleTypeText PropertyType'list_Coding = "Coding"
    simpleTypeText PropertyType'list_Xsd.XsdString = "string"
    simpleTypeText PropertyType'list_Integer = "integer"
    simpleTypeText PropertyType'list_Boolean = "boolean"
    simpleTypeText PropertyType'list_DateTime = "dateTime"
 
data PropertyType = PropertyType
        { propertyType_id :: Maybe String'primitive
        , propertyType_value :: Maybe PropertyType'list
        , propertyType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PropertyType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PropertyType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PropertyType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ propertyType_id x
                       , maybe [] (toXMLAttribute "value") $ propertyType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ propertyType_extension x
            ]
instance Extension PropertyType Element where
    supertype (PropertyType a0 a1 e0) =
               Element a0 e0
 
data CodeSystemHierarchyMeaning'list
    = CodeSystemHierarchyMeaning'list_Grouped'by
      -- ^ Grouped By
    | CodeSystemHierarchyMeaning'list_Is'a
      -- ^ Is-A
    | CodeSystemHierarchyMeaning'list_Part'of
      -- ^ Part Of
    | CodeSystemHierarchyMeaning'list_Classified'with
      -- ^ Classified With
    deriving (Eq,Show,Enum)
instance SchemaType CodeSystemHierarchyMeaning'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CodeSystemHierarchyMeaning'list where
    acceptingParser =  do literal "grouped-by"; return CodeSystemHierarchyMeaning'list_Grouped'by
                      `onFail` do literal "is-a"; return CodeSystemHierarchyMeaning'list_Is'a
                      `onFail` do literal "part-of"; return CodeSystemHierarchyMeaning'list_Part'of
                      `onFail` do literal "classified-with"; return CodeSystemHierarchyMeaning'list_Classified'with
                      
    simpleTypeText CodeSystemHierarchyMeaning'list_Grouped'by = "grouped-by"
    simpleTypeText CodeSystemHierarchyMeaning'list_Is'a = "is-a"
    simpleTypeText CodeSystemHierarchyMeaning'list_Part'of = "part-of"
    simpleTypeText CodeSystemHierarchyMeaning'list_Classified'with = "classified-with"
 
data CodeSystemHierarchyMeaning = CodeSystemHierarchyMeaning
        { codeSystemHierarchyMeaning_id :: Maybe String'primitive
        , codeSystemHierarchyMeaning_value :: Maybe CodeSystemHierarchyMeaning'list
        , codeSystemHierarchyMeaning_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemHierarchyMeaning where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CodeSystemHierarchyMeaning a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CodeSystemHierarchyMeaning{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemHierarchyMeaning_id x
                       , maybe [] (toXMLAttribute "value") $ codeSystemHierarchyMeaning_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemHierarchyMeaning_extension x
            ]
instance Extension CodeSystemHierarchyMeaning Element where
    supertype (CodeSystemHierarchyMeaning a0 a1 e0) =
               Element a0 e0
 
data CodeSystemContentMode'list
    = CodeSystemContentMode'list_Not'present
      -- ^ Not Present
    | CodeSystemContentMode'list_Example
      -- ^ Example
    | CodeSystemContentMode'list_Fragment
      -- ^ Fragment
    | CodeSystemContentMode'list_Complete
      -- ^ Complete
    deriving (Eq,Show,Enum)
instance SchemaType CodeSystemContentMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CodeSystemContentMode'list where
    acceptingParser =  do literal "not-present"; return CodeSystemContentMode'list_Not'present
                      `onFail` do literal "example"; return CodeSystemContentMode'list_Example
                      `onFail` do literal "fragment"; return CodeSystemContentMode'list_Fragment
                      `onFail` do literal "complete"; return CodeSystemContentMode'list_Complete
                      
    simpleTypeText CodeSystemContentMode'list_Not'present = "not-present"
    simpleTypeText CodeSystemContentMode'list_Example = "example"
    simpleTypeText CodeSystemContentMode'list_Fragment = "fragment"
    simpleTypeText CodeSystemContentMode'list_Complete = "complete"
 
data CodeSystemContentMode = CodeSystemContentMode
        { codeSystemContentMode_id :: Maybe String'primitive
        , codeSystemContentMode_value :: Maybe CodeSystemContentMode'list
        , codeSystemContentMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemContentMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CodeSystemContentMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CodeSystemContentMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemContentMode_id x
                       , maybe [] (toXMLAttribute "value") $ codeSystemContentMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemContentMode_extension x
            ]
instance Extension CodeSystemContentMode Element where
    supertype (CodeSystemContentMode a0 a1 e0) =
               Element a0 e0
 
-- | An occurrence of information being transmitted; e.g. an 
--   alert that was sent to a responsible provider, a public 
--   health agency was notified about a reportable condition.
elementCommunication :: XMLParser Communication
elementCommunication = parseSchemaType "Communication"
elementToXMLCommunication :: Communication -> [Content ()]
elementToXMLCommunication = schemaTypeToXML "Communication"
 
data Communication = Communication
        { communication_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , communication_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , communication_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , communication_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , communication_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , communication_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , communication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communication_identifier :: [Identifier]
          -- ^ Identifiers associated with this Communication that are 
          --   defined by business processes and/ or used to refer to it 
          --   when a direct URL reference to the resource itself is not 
          --   appropriate (e.g. in CDA documents, or in written / printed 
          --   documentation).
        , communication_definition :: [Reference]
          -- ^ A protocol, guideline, or other definition that was adhered 
          --   to in whole or in part by this communication event.
        , communication_basedOn :: [Reference]
          -- ^ An order, proposal or plan fulfilled in whole or in part by 
          --   this Communication.
        , communication_partOf :: [Reference]
          -- ^ Part of this action.
        , communication_status :: EventStatus
          -- ^ The status of the transmission.
        , communication_notDone :: Maybe Boolean
          -- ^ If true, indicates that the described communication event 
          --   did not actually occur.
        , communication_notDoneReason :: Maybe CodeableConcept
          -- ^ Describes why the communication event did not occur in 
          --   coded and/or textual form.
        , communication_category :: [CodeableConcept]
          -- ^ The type of message conveyed such as alert, notification, 
          --   reminder, instruction, etc.
        , communication_medium :: [CodeableConcept]
          -- ^ A channel that was used for this communication (e.g. email, 
          --   fax).
        , communication_subject :: Maybe Reference
          -- ^ The patient or group that was the focus of this 
          --   communication.
        , communication_recipient :: [Reference]
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which was the target of the 
          --   communication. If receipts need to be tracked by 
          --   individual, a separate resource instance will need to be 
          --   created for each recipient. Multiple recipient 
          --   communications are intended where either a receipt(s) is 
          --   not tracked (e.g. a mass mail-out) or is captured in 
          --   aggregate (all emails confirmed received by a particular 
          --   time).
        , communication_topic :: [Reference]
          -- ^ The resources which were responsible for or related to 
          --   producing this communication.
        , communication_context :: Maybe Reference
          -- ^ The encounter within which the communication was sent.
        , communication_sent :: Maybe DateTime
          -- ^ The time when this communication was sent.
        , communication_received :: Maybe DateTime
          -- ^ The time when this communication arrived at the 
          --   destination.
        , communication_sender :: Maybe Reference
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which was the source of the 
          --   communication.
        , communication_reasonCode :: [CodeableConcept]
          -- ^ The reason or justification for the communication.
        , communication_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   communication.
        , communication_payload :: [Communication'Payload]
          -- ^ Text, attachment(s), or resource(s) that was communicated 
          --   to the recipient.
        , communication_note :: [Annotation]
          -- ^ Additional notes or commentary about the communication by 
          --   the sender, receiver or other interested parties.
        }
        deriving (Eq,Show)
instance SchemaType Communication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Communication
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` many (parseSchemaType "category")
            `apply` many (parseSchemaType "medium")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "topic")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "sent")
            `apply` optional (parseSchemaType "received")
            `apply` optional (parseSchemaType "sender")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "payload")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Communication{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ communication_id x
            , maybe [] (schemaTypeToXML "meta") $ communication_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ communication_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ communication_language x
            , maybe [] (schemaTypeToXML "text") $ communication_text x
            , concatMap (schemaTypeToXML "contained") $ communication_contained x
            , concatMap (schemaTypeToXML "extension") $ communication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communication_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ communication_identifier x
            , concatMap (schemaTypeToXML "definition") $ communication_definition x
            , concatMap (schemaTypeToXML "basedOn") $ communication_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ communication_partOf x
            , schemaTypeToXML "status" $ communication_status x
            , maybe [] (schemaTypeToXML "notDone") $ communication_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ communication_notDoneReason x
            , concatMap (schemaTypeToXML "category") $ communication_category x
            , concatMap (schemaTypeToXML "medium") $ communication_medium x
            , maybe [] (schemaTypeToXML "subject") $ communication_subject x
            , concatMap (schemaTypeToXML "recipient") $ communication_recipient x
            , concatMap (schemaTypeToXML "topic") $ communication_topic x
            , maybe [] (schemaTypeToXML "context") $ communication_context x
            , maybe [] (schemaTypeToXML "sent") $ communication_sent x
            , maybe [] (schemaTypeToXML "received") $ communication_received x
            , maybe [] (schemaTypeToXML "sender") $ communication_sender x
            , concatMap (schemaTypeToXML "reasonCode") $ communication_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ communication_reasonReference x
            , concatMap (schemaTypeToXML "payload") $ communication_payload x
            , concatMap (schemaTypeToXML "note") $ communication_note x
            ]
instance Extension Communication DomainResource where
    supertype (Communication e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Communication Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Communication -> DomainResource)
              
 
-- | An occurrence of information being transmitted; e.g. an 
--   alert that was sent to a responsible provider, a public 
--   health agency was notified about a reportable condition.
data Communication'Payload = Communication'Payload
        { communication'Payload_id :: Maybe String'primitive
        , communication'Payload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communication'Payload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communication'Payload_choice2 :: OneOf3 Xsd.XsdString Attachment Reference
          -- ^ A communicated content (or for multi-part communications, 
          --   one portion of the communication).
          --   
          --   Choice between:
          --   
          --   (1) contentString
          --   
          --   (2) contentAttachment
          --   
          --   (3) contentReference
        }
        deriving (Eq,Show)
instance SchemaType Communication'Payload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Communication'Payload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Xsd.XsdString", fmap OneOf3 (parseSchemaType "contentString"))
                           , ("Attachment", fmap TwoOf3 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap ThreeOf3 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@Communication'Payload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communication'Payload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communication'Payload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communication'Payload_modifierExtension x
            , foldOneOf3  (schemaTypeToXML "contentString")
                          (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ communication'Payload_choice2 x
            ]
instance Extension Communication'Payload BackboneElement where
    supertype (Communication'Payload a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension Communication'Payload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Communication'Payload -> BackboneElement)
              
 
data EventStatus'list
    = EventStatus'list_Preparation
      -- ^ Preparation
    | EventStatus'list_In'progress
      -- ^ In Progress
    | EventStatus'list_Suspended
      -- ^ Suspended
    | EventStatus'list_Aborted
      -- ^ Aborted
    | EventStatus'list_Completed
      -- ^ Completed
    | EventStatus'list_Entered'in'error
      -- ^ Entered in Error
    | EventStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType EventStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventStatus'list where
    acceptingParser =  do literal "preparation"; return EventStatus'list_Preparation
                      `onFail` do literal "in-progress"; return EventStatus'list_In'progress
                      `onFail` do literal "suspended"; return EventStatus'list_Suspended
                      `onFail` do literal "aborted"; return EventStatus'list_Aborted
                      `onFail` do literal "completed"; return EventStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return EventStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return EventStatus'list_Unknown
                      
    simpleTypeText EventStatus'list_Preparation = "preparation"
    simpleTypeText EventStatus'list_In'progress = "in-progress"
    simpleTypeText EventStatus'list_Suspended = "suspended"
    simpleTypeText EventStatus'list_Aborted = "aborted"
    simpleTypeText EventStatus'list_Completed = "completed"
    simpleTypeText EventStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText EventStatus'list_Unknown = "unknown"
 
data EventStatus = EventStatus
        { eventStatus_id :: Maybe String'primitive
        , eventStatus_value :: Maybe EventStatus'list
        , eventStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventStatus_id x
                       , maybe [] (toXMLAttribute "value") $ eventStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventStatus_extension x
            ]
instance Extension EventStatus Element where
    supertype (EventStatus a0 a1 e0) =
               Element a0 e0
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
elementCommunicationRequest :: XMLParser CommunicationRequest
elementCommunicationRequest = parseSchemaType "CommunicationRequest"
elementToXMLCommunicationRequest :: CommunicationRequest -> [Content ()]
elementToXMLCommunicationRequest = schemaTypeToXML "CommunicationRequest"
 
data CommunicationRequest = CommunicationRequest
        { communicationRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , communicationRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , communicationRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , communicationRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , communicationRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , communicationRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , communicationRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequest_identifier :: [Identifier]
          -- ^ A unique ID of this request for reference purposes. It must 
          --   be provided if user wants it returned as part of any 
          --   output, otherwise it will be autogenerated, if needed, by 
          --   CDS system. Does not need to be the actual ID of the source 
          --   system.
        , communicationRequest_basedOn :: [Reference]
          -- ^ A plan or proposal that is fulfilled in whole or in part by 
          --   this request.
        , communicationRequest_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , communicationRequest_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition, 
          --   prescription or similar form.
        , communicationRequest_status :: RequestStatus
          -- ^ The status of the proposal or order.
        , communicationRequest_category :: [CodeableConcept]
          -- ^ The type of message to be sent such as alert, notification, 
          --   reminder, instruction, etc.
        , communicationRequest_priority :: Maybe RequestPriority
          -- ^ Characterizes how quickly the proposed act must be 
          --   initiated. Includes concepts such as stat, urgent, routine.
        , communicationRequest_medium :: [CodeableConcept]
          -- ^ A channel that was used for this communication (e.g. email, 
          --   fax).
        , communicationRequest_subject :: Maybe Reference
          -- ^ The patient or group that is the focus of this 
          --   communication request.
        , communicationRequest_recipient :: [Reference]
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, device, group, or care team) which is the intended 
          --   target of the communication.
        , communicationRequest_topic :: [Reference]
          -- ^ The resources which were related to producing this 
          --   communication request.
        , communicationRequest_context :: Maybe Reference
          -- ^ The encounter or episode of care within which the 
          --   communication request was created.
        , communicationRequest_payload :: [CommunicationRequest'Payload]
          -- ^ Text, attachment(s), or resource(s) to be communicated to 
          --   the recipient.
        , communicationRequest_choice21 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time when this communication is to occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , communicationRequest_authoredOn :: Maybe DateTime
          -- ^ For draft requests, indicates the date of initial creation. 
          --   For requests with other statuses, indicates the date of 
          --   activation.
        , communicationRequest_sender :: Maybe Reference
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which is to be the source of the 
          --   communication.
        , communicationRequest_requester :: Maybe CommunicationRequest'Requester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , communicationRequest_reasonCode :: [CodeableConcept]
          -- ^ Describes why the request is being made in coded or textual 
          --   form.
        , communicationRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   request.
        , communicationRequest_note :: [Annotation]
          -- ^ Comments made about the request by the requester, sender, 
          --   recipient, subject or other participants.
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CommunicationRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` many (parseSchemaType "medium")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "topic")
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "payload")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "sender")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CommunicationRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ communicationRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ communicationRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ communicationRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ communicationRequest_language x
            , maybe [] (schemaTypeToXML "text") $ communicationRequest_text x
            , concatMap (schemaTypeToXML "contained") $ communicationRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ communicationRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ communicationRequest_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ communicationRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ communicationRequest_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ communicationRequest_groupIdentifier x
            , schemaTypeToXML "status" $ communicationRequest_status x
            , concatMap (schemaTypeToXML "category") $ communicationRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ communicationRequest_priority x
            , concatMap (schemaTypeToXML "medium") $ communicationRequest_medium x
            , maybe [] (schemaTypeToXML "subject") $ communicationRequest_subject x
            , concatMap (schemaTypeToXML "recipient") $ communicationRequest_recipient x
            , concatMap (schemaTypeToXML "topic") $ communicationRequest_topic x
            , maybe [] (schemaTypeToXML "context") $ communicationRequest_context x
            , concatMap (schemaTypeToXML "payload") $ communicationRequest_payload x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ communicationRequest_choice21 x
            , maybe [] (schemaTypeToXML "authoredOn") $ communicationRequest_authoredOn x
            , maybe [] (schemaTypeToXML "sender") $ communicationRequest_sender x
            , maybe [] (schemaTypeToXML "requester") $ communicationRequest_requester x
            , concatMap (schemaTypeToXML "reasonCode") $ communicationRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ communicationRequest_reasonReference x
            , concatMap (schemaTypeToXML "note") $ communicationRequest_note x
            ]
instance Extension CommunicationRequest DomainResource where
    supertype (CommunicationRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CommunicationRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CommunicationRequest -> DomainResource)
              
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
data CommunicationRequest'Payload = CommunicationRequest'Payload
        { communicationRequest'Payload_id :: Maybe String'primitive
        , communicationRequest'Payload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequest'Payload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequest'Payload_choice2 :: OneOf3 Xsd.XsdString Attachment Reference
          -- ^ The communicated content (or for multi-part communications, 
          --   one portion of the communication).
          --   
          --   Choice between:
          --   
          --   (1) contentString
          --   
          --   (2) contentAttachment
          --   
          --   (3) contentReference
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequest'Payload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CommunicationRequest'Payload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Xsd.XsdString", fmap OneOf3 (parseSchemaType "contentString"))
                           , ("Attachment", fmap TwoOf3 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap ThreeOf3 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@CommunicationRequest'Payload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communicationRequest'Payload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communicationRequest'Payload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequest'Payload_modifierExtension x
            , foldOneOf3  (schemaTypeToXML "contentString")
                          (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ communicationRequest'Payload_choice2 x
            ]
instance Extension CommunicationRequest'Payload BackboneElement where
    supertype (CommunicationRequest'Payload a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension CommunicationRequest'Payload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CommunicationRequest'Payload -> BackboneElement)
              
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
data CommunicationRequest'Requester = CommunicationRequest'Requester
        { communicationRequest'Requester_id :: Maybe String'primitive
        , communicationRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequest'Requester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , communicationRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CommunicationRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@CommunicationRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communicationRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communicationRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ communicationRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ communicationRequest'Requester_onBehalfOf x
            ]
instance Extension CommunicationRequest'Requester BackboneElement where
    supertype (CommunicationRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CommunicationRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CommunicationRequest'Requester -> BackboneElement)
              
 
data RequestStatus'list
    = RequestStatus'list_Draft
      -- ^ Draft
    | RequestStatus'list_Active
      -- ^ Active
    | RequestStatus'list_Suspended
      -- ^ Suspended
    | RequestStatus'list_Cancelled
      -- ^ Cancelled
    | RequestStatus'list_Completed
      -- ^ Completed
    | RequestStatus'list_Entered'in'error
      -- ^ Entered in Error
    | RequestStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType RequestStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestStatus'list where
    acceptingParser =  do literal "draft"; return RequestStatus'list_Draft
                      `onFail` do literal "active"; return RequestStatus'list_Active
                      `onFail` do literal "suspended"; return RequestStatus'list_Suspended
                      `onFail` do literal "cancelled"; return RequestStatus'list_Cancelled
                      `onFail` do literal "completed"; return RequestStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return RequestStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return RequestStatus'list_Unknown
                      
    simpleTypeText RequestStatus'list_Draft = "draft"
    simpleTypeText RequestStatus'list_Active = "active"
    simpleTypeText RequestStatus'list_Suspended = "suspended"
    simpleTypeText RequestStatus'list_Cancelled = "cancelled"
    simpleTypeText RequestStatus'list_Completed = "completed"
    simpleTypeText RequestStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText RequestStatus'list_Unknown = "unknown"
 
data RequestStatus = RequestStatus
        { requestStatus_id :: Maybe String'primitive
        , requestStatus_value :: Maybe RequestStatus'list
        , requestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ requestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestStatus_extension x
            ]
instance Extension RequestStatus Element where
    supertype (RequestStatus a0 a1 e0) =
               Element a0 e0
 
data RequestPriority'list
    = RequestPriority'list_Routine
      -- ^ Routine
    | RequestPriority'list_Urgent
      -- ^ Urgent
    | RequestPriority'list_Asap
      -- ^ ASAP
    | RequestPriority'list_Stat
      -- ^ STAT
    deriving (Eq,Show,Enum)
instance SchemaType RequestPriority'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestPriority'list where
    acceptingParser =  do literal "routine"; return RequestPriority'list_Routine
                      `onFail` do literal "urgent"; return RequestPriority'list_Urgent
                      `onFail` do literal "asap"; return RequestPriority'list_Asap
                      `onFail` do literal "stat"; return RequestPriority'list_Stat
                      
    simpleTypeText RequestPriority'list_Routine = "routine"
    simpleTypeText RequestPriority'list_Urgent = "urgent"
    simpleTypeText RequestPriority'list_Asap = "asap"
    simpleTypeText RequestPriority'list_Stat = "stat"
 
data RequestPriority = RequestPriority
        { requestPriority_id :: Maybe String'primitive
        , requestPriority_value :: Maybe RequestPriority'list
        , requestPriority_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestPriority where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestPriority a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestPriority{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestPriority_id x
                       , maybe [] (toXMLAttribute "value") $ requestPriority_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestPriority_extension x
            ]
instance Extension RequestPriority Element where
    supertype (RequestPriority a0 a1 e0) =
               Element a0 e0
 
-- | A compartment definition that defines how resources are 
--   accessed on a server.
elementCompartmentDefinition :: XMLParser CompartmentDefinition
elementCompartmentDefinition = parseSchemaType "CompartmentDefinition"
elementToXMLCompartmentDefinition :: CompartmentDefinition -> [Content ()]
elementToXMLCompartmentDefinition = schemaTypeToXML "CompartmentDefinition"
 
data CompartmentDefinition = CompartmentDefinition
        { compartmentDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , compartmentDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , compartmentDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , compartmentDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , compartmentDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , compartmentDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , compartmentDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compartmentDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compartmentDefinition_url :: Uri
          -- ^ An absolute URI that is used to identify this compartment 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   compartment definition is (or will be) published. The URL 
          --   SHOULD include the major version of the compartment 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , compartmentDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the compartment 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , compartmentDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   compartment definition.
        , compartmentDefinition_status :: PublicationStatus
          -- ^ The status of this compartment definition. Enables tracking 
          --   the life-cycle of the content.
        , compartmentDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this compartment 
          --   definition is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , compartmentDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the compartment 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the compartment definition changes.
        , compartmentDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the compartment definition.
        , compartmentDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , compartmentDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the compartment 
          --   definition from a consumer's perspective.
        , compartmentDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this compartment definition is needed 
          --   and why it has been designed as it has.
        , compartmentDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   compartment definition instances.
        , compartmentDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the compartment 
          --   definition is intended to be used.
        , compartmentDefinition_code :: CompartmentType
          -- ^ Which compartment this definition describes.
        , compartmentDefinition_search :: Boolean
          -- ^ Whether the search syntax is supported,.
        , compartmentDefinition_resource :: [CompartmentDefinition'Resource]
          -- ^ Information about how a resource is related to the 
          --   compartment.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CompartmentDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "search"
            `apply` many (parseSchemaType "resource")
    schemaTypeToXML s x@CompartmentDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ compartmentDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ compartmentDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ compartmentDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ compartmentDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ compartmentDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ compartmentDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ compartmentDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compartmentDefinition_modifierExtension x
            , schemaTypeToXML "url" $ compartmentDefinition_url x
            , schemaTypeToXML "name" $ compartmentDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ compartmentDefinition_title x
            , schemaTypeToXML "status" $ compartmentDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ compartmentDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ compartmentDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ compartmentDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ compartmentDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ compartmentDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ compartmentDefinition_purpose x
            , concatMap (schemaTypeToXML "useContext") $ compartmentDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ compartmentDefinition_jurisdiction x
            , schemaTypeToXML "code" $ compartmentDefinition_code x
            , schemaTypeToXML "search" $ compartmentDefinition_search x
            , concatMap (schemaTypeToXML "resource") $ compartmentDefinition_resource x
            ]
instance Extension CompartmentDefinition DomainResource where
    supertype (CompartmentDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CompartmentDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CompartmentDefinition -> DomainResource)
              
 
-- | A compartment definition that defines how resources are 
--   accessed on a server.
data CompartmentDefinition'Resource = CompartmentDefinition'Resource
        { compartmentDefinition'Resource_id :: Maybe String'primitive
        , compartmentDefinition'Resource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compartmentDefinition'Resource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compartmentDefinition'Resource_code :: ResourceType
          -- ^ The name of a resource supported by the server.
        , compartmentDefinition'Resource_param :: [Xsd.XsdString]
          -- ^ The name of a search parameter that represents the link to 
          --   the compartment. More than one may be listed because a 
          --   resource may be linked to a compartment in more than one 
          --   way,.
        , compartmentDefinition'Resource_documentation :: Maybe Xsd.XsdString
          -- ^ Additional documentation about the resource and 
          --   compartment.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentDefinition'Resource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompartmentDefinition'Resource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` many (parseSchemaType "param")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CompartmentDefinition'Resource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compartmentDefinition'Resource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compartmentDefinition'Resource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compartmentDefinition'Resource_modifierExtension x
            , schemaTypeToXML "code" $ compartmentDefinition'Resource_code x
            , concatMap (schemaTypeToXML "param") $ compartmentDefinition'Resource_param x
            , maybe [] (schemaTypeToXML "documentation") $ compartmentDefinition'Resource_documentation x
            ]
instance Extension CompartmentDefinition'Resource BackboneElement where
    supertype (CompartmentDefinition'Resource a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CompartmentDefinition'Resource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompartmentDefinition'Resource -> BackboneElement)
              
 
data CompartmentType'list
    = CompartmentType'list_Patient
      -- ^ Patient
    | CompartmentType'list_Encounter
      -- ^ Encounter
    | CompartmentType'list_RelatedPerson
      -- ^ RelatedPerson
    | CompartmentType'list_Practitioner
      -- ^ Practitioner
    | CompartmentType'list_Device
      -- ^ Device
    deriving (Eq,Show,Enum)
instance SchemaType CompartmentType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompartmentType'list where
    acceptingParser =  do literal "Patient"; return CompartmentType'list_Patient
                      `onFail` do literal "Encounter"; return CompartmentType'list_Encounter
                      `onFail` do literal "RelatedPerson"; return CompartmentType'list_RelatedPerson
                      `onFail` do literal "Practitioner"; return CompartmentType'list_Practitioner
                      `onFail` do literal "Device"; return CompartmentType'list_Device
                      
    simpleTypeText CompartmentType'list_Patient = "Patient"
    simpleTypeText CompartmentType'list_Encounter = "Encounter"
    simpleTypeText CompartmentType'list_RelatedPerson = "RelatedPerson"
    simpleTypeText CompartmentType'list_Practitioner = "Practitioner"
    simpleTypeText CompartmentType'list_Device = "Device"
 
data CompartmentType = CompartmentType
        { compartmentType_id :: Maybe String'primitive
        , compartmentType_value :: Maybe CompartmentType'list
        , compartmentType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompartmentType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompartmentType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compartmentType_id x
                       , maybe [] (toXMLAttribute "value") $ compartmentType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compartmentType_extension x
            ]
instance Extension CompartmentType Element where
    supertype (CompartmentType a0 a1 e0) =
               Element a0 e0
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
elementComposition :: XMLParser Composition
elementComposition = parseSchemaType "Composition"
elementToXMLComposition :: Composition -> [Content ()]
elementToXMLComposition = schemaTypeToXML "Composition"
 
data Composition = Composition
        { composition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , composition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , composition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , composition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , composition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , composition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , composition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition_identifier :: Maybe Identifier
          -- ^ Logical identifier for the composition, assigned when 
          --   created. This identifier stays constant as the composition 
          --   is changed over time.
        , composition_status :: CompositionStatus
          -- ^ The workflow/clinical status of this composition. The 
          --   status is a marker for the clinical standing of the 
          --   document.
        , composition_type :: CodeableConcept
          -- ^ Specifies the particular kind of composition (e.g. History 
          --   and Physical, Discharge Summary, Progress Note). This 
          --   usually equates to the purpose of making the composition.
        , composition_class :: Maybe CodeableConcept
          -- ^ A categorization for the type of the composition - helps 
          --   for indexing and searching. This may be implied by or 
          --   derived from the code specified in the Composition Type.
        , composition_subject :: Reference
          -- ^ Who or what the composition is about. The composition can 
          --   be about a person, (patient or healthcare practitioner), a 
          --   device (e.g. a machine) or even a group of subjects (such 
          --   as a document about a herd of livestock, or a set of 
          --   patients that share a common exposure).
        , composition_encounter :: Maybe Reference
          -- ^ Describes the clinical encounter or type of care this 
          --   documentation is associated with.
        , composition_date :: DateTime
          -- ^ The composition editing time, when the composition was last 
          --   logically changed by the author.
        , composition_author :: [Reference]
          -- ^ Identifies who is responsible for the information in the 
          --   composition, not necessarily who typed it in.
        , composition_title :: Xsd.XsdString
          -- ^ Official human-readable label for the composition.
        , composition_confidentiality :: Maybe ConfidentialityClassification
          -- ^ The code specifying the level of confidentiality of the 
          --   Composition.
        , composition_attester :: [Composition'Attester]
          -- ^ A participant who has attested to the accuracy of the 
          --   composition/document.
        , composition_custodian :: Maybe Reference
          -- ^ Identifies the organization or group who is responsible for 
          --   ongoing maintenance of and access to the 
          --   composition/document information.
        , composition_relatesTo :: [Composition'RelatesTo]
          -- ^ Relationships that this composition has with other 
          --   compositions or documents that already exist.
        , composition_event :: [Composition'Event]
          -- ^ The clinical service, such as a colonoscopy or an 
          --   appendectomy, being documented.
        , composition_section :: [Composition'Section]
          -- ^ The root of the sections that make up the composition.
        }
        deriving (Eq,Show)
instance SchemaType Composition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Composition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "class")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "encounter")
            `apply` parseSchemaType "date"
            `apply` many1 (parseSchemaType "author")
            `apply` parseSchemaType "title"
            `apply` optional (parseSchemaType "confidentiality")
            `apply` many (parseSchemaType "attester")
            `apply` optional (parseSchemaType "custodian")
            `apply` many (parseSchemaType "relatesTo")
            `apply` many (parseSchemaType "event")
            `apply` many (parseSchemaType "section")
    schemaTypeToXML s x@Composition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ composition_id x
            , maybe [] (schemaTypeToXML "meta") $ composition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ composition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ composition_language x
            , maybe [] (schemaTypeToXML "text") $ composition_text x
            , concatMap (schemaTypeToXML "contained") $ composition_contained x
            , concatMap (schemaTypeToXML "extension") $ composition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ composition_identifier x
            , schemaTypeToXML "status" $ composition_status x
            , schemaTypeToXML "type" $ composition_type x
            , maybe [] (schemaTypeToXML "class") $ composition_class x
            , schemaTypeToXML "subject" $ composition_subject x
            , maybe [] (schemaTypeToXML "encounter") $ composition_encounter x
            , schemaTypeToXML "date" $ composition_date x
            , concatMap (schemaTypeToXML "author") $ composition_author x
            , schemaTypeToXML "title" $ composition_title x
            , maybe [] (schemaTypeToXML "confidentiality") $ composition_confidentiality x
            , concatMap (schemaTypeToXML "attester") $ composition_attester x
            , maybe [] (schemaTypeToXML "custodian") $ composition_custodian x
            , concatMap (schemaTypeToXML "relatesTo") $ composition_relatesTo x
            , concatMap (schemaTypeToXML "event") $ composition_event x
            , concatMap (schemaTypeToXML "section") $ composition_section x
            ]
instance Extension Composition DomainResource where
    supertype (Composition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Composition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Composition -> DomainResource)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data Composition'Attester = Composition'Attester
        { composition'Attester_id :: Maybe String'primitive
        , composition'Attester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition'Attester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition'Attester_mode :: [CompositionAttestationMode]
          -- ^ The type of attestation the authenticator offers.
        , composition'Attester_time :: Maybe DateTime
          -- ^ When the composition was attested by the party.
        , composition'Attester_party :: Maybe Reference
          -- ^ Who attested the composition in the specified way.
        }
        deriving (Eq,Show)
instance SchemaType Composition'Attester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Composition'Attester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "mode")
            `apply` optional (parseSchemaType "time")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@Composition'Attester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ composition'Attester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ composition'Attester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition'Attester_modifierExtension x
            , concatMap (schemaTypeToXML "mode") $ composition'Attester_mode x
            , maybe [] (schemaTypeToXML "time") $ composition'Attester_time x
            , maybe [] (schemaTypeToXML "party") $ composition'Attester_party x
            ]
instance Extension Composition'Attester BackboneElement where
    supertype (Composition'Attester a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Composition'Attester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Composition'Attester -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data Composition'RelatesTo = Composition'RelatesTo
        { composition'RelatesTo_id :: Maybe String'primitive
        , composition'RelatesTo_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition'RelatesTo_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition'RelatesTo_code :: DocumentRelationshipType
          -- ^ The type of relationship that this composition has with 
          --   anther composition or document.
        , composition'RelatesTo_choice3 :: OneOf2 Identifier Reference
          -- ^ The target composition/document of this relationship.
          --   
          --   Choice between:
          --   
          --   (1) targetIdentifier
          --   
          --   (2) targetReference
        }
        deriving (Eq,Show)
instance SchemaType Composition'RelatesTo where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Composition'RelatesTo a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("Identifier", fmap OneOf2 (parseSchemaType "targetIdentifier"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "targetReference"))
                           ]
    schemaTypeToXML s x@Composition'RelatesTo{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ composition'RelatesTo_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ composition'RelatesTo_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition'RelatesTo_modifierExtension x
            , schemaTypeToXML "code" $ composition'RelatesTo_code x
            , foldOneOf2  (schemaTypeToXML "targetIdentifier")
                          (schemaTypeToXML "targetReference")
                          $ composition'RelatesTo_choice3 x
            ]
instance Extension Composition'RelatesTo BackboneElement where
    supertype (Composition'RelatesTo a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Composition'RelatesTo Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Composition'RelatesTo -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data Composition'Event = Composition'Event
        { composition'Event_id :: Maybe String'primitive
        , composition'Event_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition'Event_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition'Event_code :: [CodeableConcept]
          -- ^ This list of codes represents the main clinical acts, such 
          --   as a colonoscopy or an appendectomy, being documented. In 
          --   some cases, the event is inherent in the typeCode, such as 
          --   a &quot;History and Physical Report&quot; in which the 
          --   procedure being documented is necessarily a &quot;History 
          --   and Physical&quot; act.
        , composition'Event_period :: Maybe Period
          -- ^ The period of time covered by the documentation. There is 
          --   no assertion that the documentation is a complete 
          --   representation for this period, only that it documents 
          --   events during this time.
        , composition'Event_detail :: [Reference]
          -- ^ The description and/or reference of the event(s) being 
          --   documented. For example, this could be used to document 
          --   such a colonoscopy or an appendectomy.
        }
        deriving (Eq,Show)
instance SchemaType Composition'Event where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Composition'Event a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@Composition'Event{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ composition'Event_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ composition'Event_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition'Event_modifierExtension x
            , concatMap (schemaTypeToXML "code") $ composition'Event_code x
            , maybe [] (schemaTypeToXML "period") $ composition'Event_period x
            , concatMap (schemaTypeToXML "detail") $ composition'Event_detail x
            ]
instance Extension Composition'Event BackboneElement where
    supertype (Composition'Event a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Composition'Event Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Composition'Event -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data Composition'Section = Composition'Section
        { composition'Section_id :: Maybe String'primitive
        , composition'Section_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition'Section_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition'Section_title :: Maybe Xsd.XsdString
          -- ^ The label for this particular section. This will be part of 
          --   the rendered content for the document, and is often used to 
          --   build a table of contents.
        , composition'Section_code :: Maybe CodeableConcept
          -- ^ A code identifying the kind of content contained within the 
          --   section. This must be consistent with the section title.
        , composition'Section_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains the attested 
          --   content of the section, used to represent the content of 
          --   the resource to a human. The narrative need not encode all 
          --   the structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative.
        , composition'Section_mode :: Maybe ListMode
          -- ^ How the entry list was prepared - whether it is a working 
          --   list that is suitable for being maintained on an ongoing 
          --   basis, or if it represents a snapshot of a list of items 
          --   from another source, or whether it is a prepared list where 
          --   items may be marked as added, modified or deleted.
        , composition'Section_orderedBy :: Maybe CodeableConcept
          -- ^ Specifies the order applied to the items in the section 
          --   entries.
        , composition'Section_entry :: [Reference]
          -- ^ A reference to the actual resource from which the narrative 
          --   in the section is derived.
        , composition'Section_emptyReason :: Maybe CodeableConcept
          -- ^ If the section is empty, why the list is empty. An empty 
          --   section typically has some text explaining the empty 
          --   reason.
        , composition'Section_section :: [Composition'Section]
          -- ^ A nested sub-section within this section.
        }
        deriving (Eq,Show)
instance SchemaType Composition'Section where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Composition'Section a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "orderedBy")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "emptyReason")
            `apply` many (parseSchemaType "section")
    schemaTypeToXML s x@Composition'Section{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ composition'Section_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ composition'Section_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition'Section_modifierExtension x
            , maybe [] (schemaTypeToXML "title") $ composition'Section_title x
            , maybe [] (schemaTypeToXML "code") $ composition'Section_code x
            , maybe [] (schemaTypeToXML "text") $ composition'Section_text x
            , maybe [] (schemaTypeToXML "mode") $ composition'Section_mode x
            , maybe [] (schemaTypeToXML "orderedBy") $ composition'Section_orderedBy x
            , concatMap (schemaTypeToXML "entry") $ composition'Section_entry x
            , maybe [] (schemaTypeToXML "emptyReason") $ composition'Section_emptyReason x
            , concatMap (schemaTypeToXML "section") $ composition'Section_section x
            ]
instance Extension Composition'Section BackboneElement where
    supertype (Composition'Section a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension Composition'Section Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Composition'Section -> BackboneElement)
              
 
data CompositionStatus'list
    = CompositionStatus'list_Preliminary
      -- ^ Preliminary
    | CompositionStatus'list_Final
      -- ^ Final
    | CompositionStatus'list_Amended
      -- ^ Amended
    | CompositionStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType CompositionStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompositionStatus'list where
    acceptingParser =  do literal "preliminary"; return CompositionStatus'list_Preliminary
                      `onFail` do literal "final"; return CompositionStatus'list_Final
                      `onFail` do literal "amended"; return CompositionStatus'list_Amended
                      `onFail` do literal "entered-in-error"; return CompositionStatus'list_Entered'in'error
                      
    simpleTypeText CompositionStatus'list_Preliminary = "preliminary"
    simpleTypeText CompositionStatus'list_Final = "final"
    simpleTypeText CompositionStatus'list_Amended = "amended"
    simpleTypeText CompositionStatus'list_Entered'in'error = "entered-in-error"
 
data CompositionStatus = CompositionStatus
        { compositionStatus_id :: Maybe String'primitive
        , compositionStatus_value :: Maybe CompositionStatus'list
        , compositionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompositionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompositionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompositionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ compositionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionStatus_extension x
            ]
instance Extension CompositionStatus Element where
    supertype (CompositionStatus a0 a1 e0) =
               Element a0 e0
 
data ConfidentialityClassification'list
    = ConfidentialityClassification'list_U
      -- ^ unrestricted
    | ConfidentialityClassification'list_L
      -- ^ low
    | ConfidentialityClassification'list_M
      -- ^ moderate
    | ConfidentialityClassification'list_N
      -- ^ normal
    | ConfidentialityClassification'list_R
      -- ^ restricted
    | ConfidentialityClassification'list_V
      -- ^ very restricted
    deriving (Eq,Show,Enum)
instance SchemaType ConfidentialityClassification'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConfidentialityClassification'list where
    acceptingParser =  do literal "U"; return ConfidentialityClassification'list_U
                      `onFail` do literal "L"; return ConfidentialityClassification'list_L
                      `onFail` do literal "M"; return ConfidentialityClassification'list_M
                      `onFail` do literal "N"; return ConfidentialityClassification'list_N
                      `onFail` do literal "R"; return ConfidentialityClassification'list_R
                      `onFail` do literal "V"; return ConfidentialityClassification'list_V
                      
    simpleTypeText ConfidentialityClassification'list_U = "U"
    simpleTypeText ConfidentialityClassification'list_L = "L"
    simpleTypeText ConfidentialityClassification'list_M = "M"
    simpleTypeText ConfidentialityClassification'list_N = "N"
    simpleTypeText ConfidentialityClassification'list_R = "R"
    simpleTypeText ConfidentialityClassification'list_V = "V"
 
data ConfidentialityClassification = ConfidentialityClassification
        { confidentialityClassification_id :: Maybe String'primitive
        , confidentialityClassification_value :: Maybe ConfidentialityClassification'list
        , confidentialityClassification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConfidentialityClassification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConfidentialityClassification a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConfidentialityClassification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ confidentialityClassification_id x
                       , maybe [] (toXMLAttribute "value") $ confidentialityClassification_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ confidentialityClassification_extension x
            ]
instance Extension ConfidentialityClassification Element where
    supertype (ConfidentialityClassification a0 a1 e0) =
               Element a0 e0
 
data DocumentRelationshipType'list
    = DocumentRelationshipType'list_Replaces
      -- ^ Replaces
    | DocumentRelationshipType'list_Transforms
      -- ^ Transforms
    | DocumentRelationshipType'list_Signs
      -- ^ Signs
    | DocumentRelationshipType'list_Appends
      -- ^ Appends
    deriving (Eq,Show,Enum)
instance SchemaType DocumentRelationshipType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentRelationshipType'list where
    acceptingParser =  do literal "replaces"; return DocumentRelationshipType'list_Replaces
                      `onFail` do literal "transforms"; return DocumentRelationshipType'list_Transforms
                      `onFail` do literal "signs"; return DocumentRelationshipType'list_Signs
                      `onFail` do literal "appends"; return DocumentRelationshipType'list_Appends
                      
    simpleTypeText DocumentRelationshipType'list_Replaces = "replaces"
    simpleTypeText DocumentRelationshipType'list_Transforms = "transforms"
    simpleTypeText DocumentRelationshipType'list_Signs = "signs"
    simpleTypeText DocumentRelationshipType'list_Appends = "appends"
 
data DocumentRelationshipType = DocumentRelationshipType
        { documentRelationshipType_id :: Maybe String'primitive
        , documentRelationshipType_value :: Maybe DocumentRelationshipType'list
        , documentRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ documentRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentRelationshipType_extension x
            ]
instance Extension DocumentRelationshipType Element where
    supertype (DocumentRelationshipType a0 a1 e0) =
               Element a0 e0
 
data CompositionAttestationMode'list
    = CompositionAttestationMode'list_Personal
      -- ^ Personal
    | CompositionAttestationMode'list_Professional
      -- ^ Professional
    | CompositionAttestationMode'list_Legal
      -- ^ Legal
    | CompositionAttestationMode'list_Official
      -- ^ Official
    deriving (Eq,Show,Enum)
instance SchemaType CompositionAttestationMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompositionAttestationMode'list where
    acceptingParser =  do literal "personal"; return CompositionAttestationMode'list_Personal
                      `onFail` do literal "professional"; return CompositionAttestationMode'list_Professional
                      `onFail` do literal "legal"; return CompositionAttestationMode'list_Legal
                      `onFail` do literal "official"; return CompositionAttestationMode'list_Official
                      
    simpleTypeText CompositionAttestationMode'list_Personal = "personal"
    simpleTypeText CompositionAttestationMode'list_Professional = "professional"
    simpleTypeText CompositionAttestationMode'list_Legal = "legal"
    simpleTypeText CompositionAttestationMode'list_Official = "official"
 
data CompositionAttestationMode = CompositionAttestationMode
        { compositionAttestationMode_id :: Maybe String'primitive
        , compositionAttestationMode_value :: Maybe CompositionAttestationMode'list
        , compositionAttestationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompositionAttestationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompositionAttestationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompositionAttestationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionAttestationMode_id x
                       , maybe [] (toXMLAttribute "value") $ compositionAttestationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionAttestationMode_extension x
            ]
instance Extension CompositionAttestationMode Element where
    supertype (CompositionAttestationMode a0 a1 e0) =
               Element a0 e0
 
data ListMode'list
    = ListMode'list_Working
      -- ^ Working List
    | ListMode'list_Snapshot
      -- ^ Snapshot List
    | ListMode'list_Changes
      -- ^ Change List
    deriving (Eq,Show,Enum)
instance SchemaType ListMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ListMode'list where
    acceptingParser =  do literal "working"; return ListMode'list_Working
                      `onFail` do literal "snapshot"; return ListMode'list_Snapshot
                      `onFail` do literal "changes"; return ListMode'list_Changes
                      
    simpleTypeText ListMode'list_Working = "working"
    simpleTypeText ListMode'list_Snapshot = "snapshot"
    simpleTypeText ListMode'list_Changes = "changes"
 
data ListMode = ListMode
        { listMode_id :: Maybe String'primitive
        , listMode_value :: Maybe ListMode'list
        , listMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ listMode_id x
                       , maybe [] (toXMLAttribute "value") $ listMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ listMode_extension x
            ]
instance Extension ListMode Element where
    supertype (ListMode a0 a1 e0) =
               Element a0 e0
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
elementConceptMap :: XMLParser ConceptMap
elementConceptMap = parseSchemaType "ConceptMap"
elementToXMLConceptMap :: ConceptMap -> [Content ()]
elementToXMLConceptMap = schemaTypeToXML "ConceptMap"
 
data ConceptMap = ConceptMap
        { conceptMap_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , conceptMap_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , conceptMap_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , conceptMap_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , conceptMap_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , conceptMap_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , conceptMap_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this concept map 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this concept map 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the concept map. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , conceptMap_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this concept 
          --   map when it is represented in other formats, or referenced 
          --   in a specification, model, design or an instance.
        , conceptMap_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   concept map when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the concept map author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , conceptMap_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the concept map. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , conceptMap_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the concept 
          --   map.
        , conceptMap_status :: PublicationStatus
          -- ^ The status of this concept map. Enables tracking the 
          --   life-cycle of the content.
        , conceptMap_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this concept map is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , conceptMap_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the concept map was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the concept map changes.
        , conceptMap_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the concept map.
        , conceptMap_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , conceptMap_description :: Maybe Markdown
          -- ^ A free text natural language description of the concept map 
          --   from a consumer's perspective.
        , conceptMap_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   concept map instances.
        , conceptMap_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the concept map is 
          --   intended to be used.
        , conceptMap_purpose :: Maybe Markdown
          -- ^ Explaination of why this concept map is needed and why it 
          --   has been designed as it has.
        , conceptMap_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the concept map and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the concept map.
        , conceptMap_choice23 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The source value set that specifies the concepts that are 
          --   being mapped.
          --   
          --   Choice between:
          --   
          --   (1) sourceUri
          --   
          --   (2) sourceReference
        , conceptMap_choice24 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The target value set provides context to the mappings. Note 
          --   that the mapping is made between concepts, not between 
          --   value sets, but the value set provides important context 
          --   about how the concept mapping choices are made.
          --   
          --   Choice between:
          --   
          --   (1) targetUri
          --   
          --   (2) targetReference
        , conceptMap_group :: [ConceptMap'Group]
          -- ^ A group of mappings that all have the same source and 
          --   target system.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ConceptMap
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "sourceUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "sourceReference"))
                                     ])
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "targetUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "targetReference"))
                                     ])
            `apply` many (parseSchemaType "group")
    schemaTypeToXML s x@ConceptMap{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ conceptMap_id x
            , maybe [] (schemaTypeToXML "meta") $ conceptMap_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ conceptMap_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ conceptMap_language x
            , maybe [] (schemaTypeToXML "text") $ conceptMap_text x
            , concatMap (schemaTypeToXML "contained") $ conceptMap_contained x
            , concatMap (schemaTypeToXML "extension") $ conceptMap_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ conceptMap_url x
            , maybe [] (schemaTypeToXML "identifier") $ conceptMap_identifier x
            , maybe [] (schemaTypeToXML "version") $ conceptMap_version x
            , maybe [] (schemaTypeToXML "name") $ conceptMap_name x
            , maybe [] (schemaTypeToXML "title") $ conceptMap_title x
            , schemaTypeToXML "status" $ conceptMap_status x
            , maybe [] (schemaTypeToXML "experimental") $ conceptMap_experimental x
            , maybe [] (schemaTypeToXML "date") $ conceptMap_date x
            , maybe [] (schemaTypeToXML "publisher") $ conceptMap_publisher x
            , concatMap (schemaTypeToXML "contact") $ conceptMap_contact x
            , maybe [] (schemaTypeToXML "description") $ conceptMap_description x
            , concatMap (schemaTypeToXML "useContext") $ conceptMap_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ conceptMap_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ conceptMap_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ conceptMap_copyright x
            , maybe [] (foldOneOf2  (schemaTypeToXML "sourceUri")
                                    (schemaTypeToXML "sourceReference")
                                   ) $ conceptMap_choice23 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "targetUri")
                                    (schemaTypeToXML "targetReference")
                                   ) $ conceptMap_choice24 x
            , concatMap (schemaTypeToXML "group") $ conceptMap_group x
            ]
instance Extension ConceptMap DomainResource where
    supertype (ConceptMap e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ConceptMap Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ConceptMap -> DomainResource)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMap'Group = ConceptMap'Group
        { conceptMap'Group_id :: Maybe String'primitive
        , conceptMap'Group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap'Group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap'Group_source :: Maybe Uri
          -- ^ An absolute URI that identifies the Code System (if the 
          --   source is a value set that crosses more than one code 
          --   system).
        , conceptMap'Group_sourceVersion :: Maybe Xsd.XsdString
          -- ^ The specific version of the code system, as determined by 
          --   the code system authority.
        , conceptMap'Group_target :: Maybe Uri
          -- ^ An absolute URI that identifies the code system of the 
          --   target code (if the target is a value set that cross code 
          --   systems).
        , conceptMap'Group_targetVersion :: Maybe Xsd.XsdString
          -- ^ The specific version of the code system, as determined by 
          --   the code system authority.
        , conceptMap'Group_element :: [ConceptMap'Element]
          -- ^ Mappings for an individual concept in the source to one or 
          --   more concepts in the target.
        , conceptMap'Group_unmapped :: Maybe ConceptMap'Unmapped
          -- ^ What to do when there is no match in the mappings in the 
          --   group.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap'Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMap'Group a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "sourceVersion")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "targetVersion")
            `apply` many1 (parseSchemaType "element")
            `apply` optional (parseSchemaType "unmapped")
    schemaTypeToXML s x@ConceptMap'Group{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMap'Group_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMap'Group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap'Group_modifierExtension x
            , maybe [] (schemaTypeToXML "source") $ conceptMap'Group_source x
            , maybe [] (schemaTypeToXML "sourceVersion") $ conceptMap'Group_sourceVersion x
            , maybe [] (schemaTypeToXML "target") $ conceptMap'Group_target x
            , maybe [] (schemaTypeToXML "targetVersion") $ conceptMap'Group_targetVersion x
            , concatMap (schemaTypeToXML "element") $ conceptMap'Group_element x
            , maybe [] (schemaTypeToXML "unmapped") $ conceptMap'Group_unmapped x
            ]
instance Extension ConceptMap'Group BackboneElement where
    supertype (ConceptMap'Group a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ConceptMap'Group Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMap'Group -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMap'Element = ConceptMap'Element
        { conceptMap'Element_id :: Maybe String'primitive
        , conceptMap'Element_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap'Element_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap'Element_code :: Maybe Code
          -- ^ Identity (code or path) or the element/item being mapped.
        , conceptMap'Element_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMap'Element_target :: [ConceptMap'Target]
          -- ^ A concept from the target value set that this concept maps 
          --   to.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap'Element where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMap'Element a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "target")
    schemaTypeToXML s x@ConceptMap'Element{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMap'Element_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMap'Element_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap'Element_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ conceptMap'Element_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMap'Element_display x
            , concatMap (schemaTypeToXML "target") $ conceptMap'Element_target x
            ]
instance Extension ConceptMap'Element BackboneElement where
    supertype (ConceptMap'Element a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ConceptMap'Element Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMap'Element -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMap'Target = ConceptMap'Target
        { conceptMap'Target_id :: Maybe String'primitive
        , conceptMap'Target_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap'Target_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap'Target_code :: Maybe Code
          -- ^ Identity (code or path) or the element/item that the map 
          --   refers to.
        , conceptMap'Target_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMap'Target_equivalence :: Maybe ConceptMapEquivalence
          -- ^ The equivalence between the source and target concepts 
          --   (counting for the dependencies and products). The 
          --   equivalence is read from target to source (e.g. the target 
          --   is 'wider' than the source).
        , conceptMap'Target_comment :: Maybe Xsd.XsdString
          -- ^ A description of status/issues in mapping that conveys 
          --   additional information not represented in the structured 
          --   data.
        , conceptMap'Target_dependsOn :: [ConceptMap'DependsOn]
          -- ^ A set of additional dependencies for this mapping to hold. 
          --   This mapping is only applicable if the specified element 
          --   can be resolved, and it has the specified value.
        , conceptMap'Target_product :: [ConceptMap'DependsOn]
          -- ^ A set of additional outcomes from this mapping to other 
          --   elements. To properly execute this mapping, the specified 
          --   element must be mapped to some data element or source that 
          --   is in context. The mapping may still be useful without a 
          --   place for the additional data elements, but the equivalence 
          --   cannot be relied on.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap'Target where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMap'Target a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "equivalence")
            `apply` optional (parseSchemaType "comment")
            `apply` many (parseSchemaType "dependsOn")
            `apply` many (parseSchemaType "product")
    schemaTypeToXML s x@ConceptMap'Target{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMap'Target_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMap'Target_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap'Target_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ conceptMap'Target_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMap'Target_display x
            , maybe [] (schemaTypeToXML "equivalence") $ conceptMap'Target_equivalence x
            , maybe [] (schemaTypeToXML "comment") $ conceptMap'Target_comment x
            , concatMap (schemaTypeToXML "dependsOn") $ conceptMap'Target_dependsOn x
            , concatMap (schemaTypeToXML "product") $ conceptMap'Target_product x
            ]
instance Extension ConceptMap'Target BackboneElement where
    supertype (ConceptMap'Target a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ConceptMap'Target Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMap'Target -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMap'DependsOn = ConceptMap'DependsOn
        { conceptMap'DependsOn_id :: Maybe String'primitive
        , conceptMap'DependsOn_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap'DependsOn_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap'DependsOn_property :: Uri
          -- ^ A reference to an element that holds a coded value that 
          --   corresponds to a code system property. The idea is that the 
          --   information model carries an element somwhere that is 
          --   labeled to correspond with a code system property.
        , conceptMap'DependsOn_system :: Maybe Uri
          -- ^ An absolute URI that identifies the code system of the 
          --   dependency code (if the source/dependency is a value set 
          --   that crosses code systems).
        , conceptMap'DependsOn_code :: Xsd.XsdString
          -- ^ Identity (code or path) or the element/item/ValueSet that 
          --   the map depends on / refers to.
        , conceptMap'DependsOn_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap'DependsOn where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMap'DependsOn a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "property"
            `apply` optional (parseSchemaType "system")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@ConceptMap'DependsOn{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMap'DependsOn_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMap'DependsOn_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap'DependsOn_modifierExtension x
            , schemaTypeToXML "property" $ conceptMap'DependsOn_property x
            , maybe [] (schemaTypeToXML "system") $ conceptMap'DependsOn_system x
            , schemaTypeToXML "code" $ conceptMap'DependsOn_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMap'DependsOn_display x
            ]
instance Extension ConceptMap'DependsOn BackboneElement where
    supertype (ConceptMap'DependsOn a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ConceptMap'DependsOn Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMap'DependsOn -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMap'Unmapped = ConceptMap'Unmapped
        { conceptMap'Unmapped_id :: Maybe String'primitive
        , conceptMap'Unmapped_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap'Unmapped_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap'Unmapped_mode :: ConceptMapGroupUnmappedMode
          -- ^ Defines which action to take if there is no match in the 
          --   group. One of 3 actions is possible: use the unmapped code 
          --   (this is useful when doing a mapping between versions, and 
          --   only a few codes have changed), use a fixed code (a default 
          --   code), or alternatively, a reference to a different concept 
          --   map can be provided (by canonical URL).
        , conceptMap'Unmapped_code :: Maybe Code
          -- ^ The fixed code to use when the mode = 'fixed' - all 
          --   unmapped codes are mapped to a single fixed code.
        , conceptMap'Unmapped_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMap'Unmapped_url :: Maybe Uri
          -- ^ The canonical URL of the map to use if this map contains no 
          --   mapping.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap'Unmapped where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMap'Unmapped a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@ConceptMap'Unmapped{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMap'Unmapped_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMap'Unmapped_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap'Unmapped_modifierExtension x
            , schemaTypeToXML "mode" $ conceptMap'Unmapped_mode x
            , maybe [] (schemaTypeToXML "code") $ conceptMap'Unmapped_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMap'Unmapped_display x
            , maybe [] (schemaTypeToXML "url") $ conceptMap'Unmapped_url x
            ]
instance Extension ConceptMap'Unmapped BackboneElement where
    supertype (ConceptMap'Unmapped a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ConceptMap'Unmapped Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMap'Unmapped -> BackboneElement)
              
 
data ConceptMapGroupUnmappedMode'list
    = ConceptMapGroupUnmappedMode'list_Provided
      -- ^ Provided Code
    | ConceptMapGroupUnmappedMode'list_Fixed
      -- ^ Fixed Code
    | ConceptMapGroupUnmappedMode'list_Other'map
      -- ^ Other Map
    deriving (Eq,Show,Enum)
instance SchemaType ConceptMapGroupUnmappedMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConceptMapGroupUnmappedMode'list where
    acceptingParser =  do literal "provided"; return ConceptMapGroupUnmappedMode'list_Provided
                      `onFail` do literal "fixed"; return ConceptMapGroupUnmappedMode'list_Fixed
                      `onFail` do literal "other-map"; return ConceptMapGroupUnmappedMode'list_Other'map
                      
    simpleTypeText ConceptMapGroupUnmappedMode'list_Provided = "provided"
    simpleTypeText ConceptMapGroupUnmappedMode'list_Fixed = "fixed"
    simpleTypeText ConceptMapGroupUnmappedMode'list_Other'map = "other-map"
 
data ConceptMapGroupUnmappedMode = ConceptMapGroupUnmappedMode
        { conceptMapGroupUnmappedMode_id :: Maybe String'primitive
        , conceptMapGroupUnmappedMode_value :: Maybe ConceptMapGroupUnmappedMode'list
        , conceptMapGroupUnmappedMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapGroupUnmappedMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConceptMapGroupUnmappedMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConceptMapGroupUnmappedMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapGroupUnmappedMode_id x
                       , maybe [] (toXMLAttribute "value") $ conceptMapGroupUnmappedMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapGroupUnmappedMode_extension x
            ]
instance Extension ConceptMapGroupUnmappedMode Element where
    supertype (ConceptMapGroupUnmappedMode a0 a1 e0) =
               Element a0 e0
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
elementCondition :: XMLParser Condition
elementCondition = parseSchemaType "Condition"
elementToXMLCondition :: Condition -> [Content ()]
elementToXMLCondition = schemaTypeToXML "Condition"
 
data Condition = Condition
        { condition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , condition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , condition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , condition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , condition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , condition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , condition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , condition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , condition_identifier :: [Identifier]
          -- ^ This records identifiers associated with this condition 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , condition_clinicalStatus :: Maybe ConditionClinicalStatusCodes
          -- ^ The clinical status of the condition.
        , condition_verificationStatus :: Maybe ConditionVerificationStatus
          -- ^ The verification status to support the clinical status of 
          --   the condition.
        , condition_category :: [CodeableConcept]
          -- ^ A category assigned to the condition.
        , condition_severity :: Maybe CodeableConcept
          -- ^ A subjective assessment of the severity of the condition as 
          --   evaluated by the clinician.
        , condition_code :: Maybe CodeableConcept
          -- ^ Identification of the condition, problem or diagnosis.
        , condition_bodySite :: [CodeableConcept]
          -- ^ The anatomical location where this condition manifests 
          --   itself.
        , condition_subject :: Reference
          -- ^ Indicates the patient or group who the condition record is 
          --   associated with.
        , condition_context :: Maybe Reference
          -- ^ Encounter during which the condition was first asserted.
        , condition_choice17 :: (Maybe (OneOf5 DateTime Age Period Range Xsd.XsdString))
          -- ^ Estimated or actual date or date-time the condition began, 
          --   in the opinion of the clinician.
          --   
          --   Choice between:
          --   
          --   (1) onsetDateTime
          --   
          --   (2) onsetAge
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetRange
          --   
          --   (5) onsetString
        , condition_choice18 :: (Maybe (OneOf6 DateTime Age Boolean Period Range Xsd.XsdString))
          -- ^ The date or estimated date that the condition resolved or 
          --   went into remission. This is called &quot;abatement&quot; 
          --   because of the many overloaded connotations associated with 
          --   &quot;remission&quot; or &quot;resolution&quot; - 
          --   Conditions are never really resolved, but they can abate.
          --   
          --   Choice between:
          --   
          --   (1) abatementDateTime
          --   
          --   (2) abatementAge
          --   
          --   (3) abatementBoolean
          --   
          --   (4) abatementPeriod
          --   
          --   (5) abatementRange
          --   
          --   (6) abatementString
        , condition_assertedDate :: Maybe DateTime
          -- ^ The date on which the existance of the Condition was first 
          --   asserted or acknowledged.
        , condition_asserter :: Maybe Reference
          -- ^ Individual who is making the condition statement.
        , condition_stage :: Maybe Condition'Stage
          -- ^ Clinical stage or grade of a condition. May include formal 
          --   severity assessments.
        , condition_evidence :: [Condition'Evidence]
          -- ^ Supporting Evidence / manifestations that are the basis on 
          --   which this condition is suspected or confirmed.
        , condition_note :: [Annotation]
          -- ^ Additional information about the Condition. This is a 
          --   general notes/comments entry for description of the 
          --   Condition, its diagnosis and prognosis.
        }
        deriving (Eq,Show)
instance SchemaType Condition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Condition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "clinicalStatus")
            `apply` optional (parseSchemaType "verificationStatus")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "bodySite")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "onsetDateTime"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "onsetAge"))
                                     , ("Period", fmap ThreeOf5 (parseSchemaType "onsetPeriod"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "onsetRange"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "onsetString"))
                                     ])
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf6 (parseSchemaType "abatementDateTime"))
                                     , ("Age", fmap TwoOf6 (parseSchemaType "abatementAge"))
                                     , ("Boolean", fmap ThreeOf6 (parseSchemaType "abatementBoolean"))
                                     , ("Period", fmap FourOf6 (parseSchemaType "abatementPeriod"))
                                     , ("Range", fmap FiveOf6 (parseSchemaType "abatementRange"))
                                     , ("Xsd.XsdString", fmap SixOf6 (parseSchemaType "abatementString"))
                                     ])
            `apply` optional (parseSchemaType "assertedDate")
            `apply` optional (parseSchemaType "asserter")
            `apply` optional (parseSchemaType "stage")
            `apply` many (parseSchemaType "evidence")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Condition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ condition_id x
            , maybe [] (schemaTypeToXML "meta") $ condition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ condition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ condition_language x
            , maybe [] (schemaTypeToXML "text") $ condition_text x
            , concatMap (schemaTypeToXML "contained") $ condition_contained x
            , concatMap (schemaTypeToXML "extension") $ condition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ condition_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ condition_identifier x
            , maybe [] (schemaTypeToXML "clinicalStatus") $ condition_clinicalStatus x
            , maybe [] (schemaTypeToXML "verificationStatus") $ condition_verificationStatus x
            , concatMap (schemaTypeToXML "category") $ condition_category x
            , maybe [] (schemaTypeToXML "severity") $ condition_severity x
            , maybe [] (schemaTypeToXML "code") $ condition_code x
            , concatMap (schemaTypeToXML "bodySite") $ condition_bodySite x
            , schemaTypeToXML "subject" $ condition_subject x
            , maybe [] (schemaTypeToXML "context") $ condition_context x
            , maybe [] (foldOneOf5  (schemaTypeToXML "onsetDateTime")
                                    (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetString")
                                   ) $ condition_choice17 x
            , maybe [] (foldOneOf6  (schemaTypeToXML "abatementDateTime")
                                    (schemaTypeToXML "abatementAge")
                                    (schemaTypeToXML "abatementBoolean")
                                    (schemaTypeToXML "abatementPeriod")
                                    (schemaTypeToXML "abatementRange")
                                    (schemaTypeToXML "abatementString")
                                   ) $ condition_choice18 x
            , maybe [] (schemaTypeToXML "assertedDate") $ condition_assertedDate x
            , maybe [] (schemaTypeToXML "asserter") $ condition_asserter x
            , maybe [] (schemaTypeToXML "stage") $ condition_stage x
            , concatMap (schemaTypeToXML "evidence") $ condition_evidence x
            , concatMap (schemaTypeToXML "note") $ condition_note x
            ]
instance Extension Condition DomainResource where
    supertype (Condition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Condition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Condition -> DomainResource)
              
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
data Condition'Stage = Condition'Stage
        { condition'Stage_id :: Maybe String'primitive
        , condition'Stage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , condition'Stage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , condition'Stage_summary :: Maybe CodeableConcept
          -- ^ A simple summary of the stage such as &quot;Stage 3&quot;. 
          --   The determination of the stage is disease-specific.
        , condition'Stage_assessment :: [Reference]
          -- ^ Reference to a formal record of the evidence on which the 
          --   staging assessment is based.
        }
        deriving (Eq,Show)
instance SchemaType Condition'Stage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Condition'Stage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "summary")
            `apply` many (parseSchemaType "assessment")
    schemaTypeToXML s x@Condition'Stage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ condition'Stage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ condition'Stage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ condition'Stage_modifierExtension x
            , maybe [] (schemaTypeToXML "summary") $ condition'Stage_summary x
            , concatMap (schemaTypeToXML "assessment") $ condition'Stage_assessment x
            ]
instance Extension Condition'Stage BackboneElement where
    supertype (Condition'Stage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Condition'Stage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Condition'Stage -> BackboneElement)
              
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
data Condition'Evidence = Condition'Evidence
        { condition'Evidence_id :: Maybe String'primitive
        , condition'Evidence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , condition'Evidence_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , condition'Evidence_code :: [CodeableConcept]
          -- ^ A manifestation or symptom that led to the recording of 
          --   this condition.
        , condition'Evidence_detail :: [Reference]
          -- ^ Links to other relevant information, including pathology 
          --   reports.
        }
        deriving (Eq,Show)
instance SchemaType Condition'Evidence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Condition'Evidence a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@Condition'Evidence{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ condition'Evidence_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ condition'Evidence_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ condition'Evidence_modifierExtension x
            , concatMap (schemaTypeToXML "code") $ condition'Evidence_code x
            , concatMap (schemaTypeToXML "detail") $ condition'Evidence_detail x
            ]
instance Extension Condition'Evidence BackboneElement where
    supertype (Condition'Evidence a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Condition'Evidence Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Condition'Evidence -> BackboneElement)
              
 
data ConditionVerificationStatus'list
    = ConditionVerificationStatus'list_Provisional
      -- ^ Provisional
    | ConditionVerificationStatus'list_Differential
      -- ^ Differential
    | ConditionVerificationStatus'list_Confirmed
      -- ^ Confirmed
    | ConditionVerificationStatus'list_Refuted
      -- ^ Refuted
    | ConditionVerificationStatus'list_Entered'in'error
      -- ^ Entered In Error
    | ConditionVerificationStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ConditionVerificationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionVerificationStatus'list where
    acceptingParser =  do literal "provisional"; return ConditionVerificationStatus'list_Provisional
                      `onFail` do literal "differential"; return ConditionVerificationStatus'list_Differential
                      `onFail` do literal "confirmed"; return ConditionVerificationStatus'list_Confirmed
                      `onFail` do literal "refuted"; return ConditionVerificationStatus'list_Refuted
                      `onFail` do literal "entered-in-error"; return ConditionVerificationStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return ConditionVerificationStatus'list_Unknown
                      
    simpleTypeText ConditionVerificationStatus'list_Provisional = "provisional"
    simpleTypeText ConditionVerificationStatus'list_Differential = "differential"
    simpleTypeText ConditionVerificationStatus'list_Confirmed = "confirmed"
    simpleTypeText ConditionVerificationStatus'list_Refuted = "refuted"
    simpleTypeText ConditionVerificationStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText ConditionVerificationStatus'list_Unknown = "unknown"
 
data ConditionVerificationStatus = ConditionVerificationStatus
        { conditionVerificationStatus_id :: Maybe String'primitive
        , conditionVerificationStatus_value :: Maybe ConditionVerificationStatus'list
        , conditionVerificationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionVerificationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionVerificationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionVerificationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionVerificationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionVerificationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionVerificationStatus_extension x
            ]
instance Extension ConditionVerificationStatus Element where
    supertype (ConditionVerificationStatus a0 a1 e0) =
               Element a0 e0
 
data ConditionClinicalStatusCodes'list
    = ConditionClinicalStatusCodes'list_Active
      -- ^ Active
    | ConditionClinicalStatusCodes'list_Recurrence
      -- ^ Recurrence
    | ConditionClinicalStatusCodes'list_Inactive
      -- ^ Inactive
    | ConditionClinicalStatusCodes'list_Remission
      -- ^ Remission
    | ConditionClinicalStatusCodes'list_Resolved
      -- ^ Resolved
    deriving (Eq,Show,Enum)
instance SchemaType ConditionClinicalStatusCodes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionClinicalStatusCodes'list where
    acceptingParser =  do literal "active"; return ConditionClinicalStatusCodes'list_Active
                      `onFail` do literal "recurrence"; return ConditionClinicalStatusCodes'list_Recurrence
                      `onFail` do literal "inactive"; return ConditionClinicalStatusCodes'list_Inactive
                      `onFail` do literal "remission"; return ConditionClinicalStatusCodes'list_Remission
                      `onFail` do literal "resolved"; return ConditionClinicalStatusCodes'list_Resolved
                      
    simpleTypeText ConditionClinicalStatusCodes'list_Active = "active"
    simpleTypeText ConditionClinicalStatusCodes'list_Recurrence = "recurrence"
    simpleTypeText ConditionClinicalStatusCodes'list_Inactive = "inactive"
    simpleTypeText ConditionClinicalStatusCodes'list_Remission = "remission"
    simpleTypeText ConditionClinicalStatusCodes'list_Resolved = "resolved"
 
data ConditionClinicalStatusCodes = ConditionClinicalStatusCodes
        { conditionClinicalStatusCodes_id :: Maybe String'primitive
        , conditionClinicalStatusCodes_value :: Maybe ConditionClinicalStatusCodes'list
        , conditionClinicalStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionClinicalStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionClinicalStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionClinicalStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionClinicalStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ conditionClinicalStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionClinicalStatusCodes_extension x
            ]
instance Extension ConditionClinicalStatusCodes Element where
    supertype (ConditionClinicalStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
elementConsent :: XMLParser Consent
elementConsent = parseSchemaType "Consent"
elementToXMLConsent :: Consent -> [Content ()]
elementToXMLConsent = schemaTypeToXML "Consent"
 
data Consent = Consent
        { consent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , consent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , consent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , consent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , consent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , consent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , consent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent_identifier :: Maybe Identifier
          -- ^ Unique identifier for this copy of the Consent Statement.
        , consent_status :: ConsentState
          -- ^ Indicates the current state of this consent.
        , consent_category :: [CodeableConcept]
          -- ^ A classification of the type of consents found in the 
          --   statement. This element supports indexing and retrieval of 
          --   consent statements.
        , consent_patient :: Reference
          -- ^ The patient/healthcare consumer to whom this consent 
          --   applies.
        , consent_period :: Maybe Period
          -- ^ Relevant time or time-period when this Consent is 
          --   applicable.
        , consent_dateTime :: Maybe DateTime
          -- ^ When this Consent was issued / created / indexed.
        , consent_consentingParty :: [Reference]
          -- ^ Either the Grantor, which is the entity responsible for 
          --   granting the rights listed in a Consent Directive or the 
          --   Grantee, which is the entity responsible for complying with 
          --   the Consent Directive, including any obligations or 
          --   limitations on authorizations and enforcement of 
          --   prohibitions.
        , consent_actor :: [Consent'Actor]
          -- ^ Who or what is controlled by this consent. Use group to 
          --   identify a set of actors by some property they share (e.g. 
          --   'admitting officers').
        , consent_action :: [CodeableConcept]
          -- ^ Actions controlled by this consent.
        , consent_organization :: [Reference]
          -- ^ The organization that manages the consent, and the 
          --   framework within which it is executed.
        , consent_choice18 :: (Maybe (OneOf3 Attachment Identifier Reference))
          -- ^ The source on which this consent statement is based. The 
          --   source might be a scanned original paper form, or a 
          --   reference to a consent that links back to such a source, a 
          --   reference to a document repository (e.g. XDS) that stores 
          --   the original consent document.
          --   
          --   Choice between:
          --   
          --   (1) sourceAttachment
          --   
          --   (2) sourceIdentifier
          --   
          --   (3) sourceReference
        , consent_policy :: [Consent'Policy]
          -- ^ The references to the policies that are included in this 
          --   consent scope. Policies may be organizational, but are 
          --   often defined jurisdictionally, or in law.
        , consent_policyRule :: Maybe Uri
          -- ^ A referece to the specific computable policy.
        , consent_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this consent. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , consent_purpose :: [Coding]
          -- ^ The context of the activities a user is taking - why the 
          --   user is accessing the data - that are controlled by this 
          --   consent.
        , consent_dataPeriod :: Maybe Period
          -- ^ Clinical or Operational Relevant period of time that bounds 
          --   the data controlled by this consent.
        , consent_data :: [Consent'Data]
          -- ^ The resources controlled by this consent, if specific 
          --   resources are referenced.
        , consent_except :: [Consent'Except]
          -- ^ An exception to the base policy of this consent. An 
          --   exception can be an addition or removal of access 
          --   permissions.
        }
        deriving (Eq,Show)
instance SchemaType Consent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Consent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "dateTime")
            `apply` many (parseSchemaType "consentingParty")
            `apply` many (parseSchemaType "actor")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "organization")
            `apply` optional (oneOf' [ ("Attachment", fmap OneOf3 (parseSchemaType "sourceAttachment"))
                                     , ("Identifier", fmap TwoOf3 (parseSchemaType "sourceIdentifier"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "sourceReference"))
                                     ])
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "policyRule")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "dataPeriod")
            `apply` many (parseSchemaType "data")
            `apply` many (parseSchemaType "except")
    schemaTypeToXML s x@Consent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ consent_id x
            , maybe [] (schemaTypeToXML "meta") $ consent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ consent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ consent_language x
            , maybe [] (schemaTypeToXML "text") $ consent_text x
            , concatMap (schemaTypeToXML "contained") $ consent_contained x
            , concatMap (schemaTypeToXML "extension") $ consent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ consent_identifier x
            , schemaTypeToXML "status" $ consent_status x
            , concatMap (schemaTypeToXML "category") $ consent_category x
            , schemaTypeToXML "patient" $ consent_patient x
            , maybe [] (schemaTypeToXML "period") $ consent_period x
            , maybe [] (schemaTypeToXML "dateTime") $ consent_dateTime x
            , concatMap (schemaTypeToXML "consentingParty") $ consent_consentingParty x
            , concatMap (schemaTypeToXML "actor") $ consent_actor x
            , concatMap (schemaTypeToXML "action") $ consent_action x
            , concatMap (schemaTypeToXML "organization") $ consent_organization x
            , maybe [] (foldOneOf3  (schemaTypeToXML "sourceAttachment")
                                    (schemaTypeToXML "sourceIdentifier")
                                    (schemaTypeToXML "sourceReference")
                                   ) $ consent_choice18 x
            , concatMap (schemaTypeToXML "policy") $ consent_policy x
            , maybe [] (schemaTypeToXML "policyRule") $ consent_policyRule x
            , concatMap (schemaTypeToXML "securityLabel") $ consent_securityLabel x
            , concatMap (schemaTypeToXML "purpose") $ consent_purpose x
            , maybe [] (schemaTypeToXML "dataPeriod") $ consent_dataPeriod x
            , concatMap (schemaTypeToXML "data") $ consent_data x
            , concatMap (schemaTypeToXML "except") $ consent_except x
            ]
instance Extension Consent DomainResource where
    supertype (Consent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Consent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Consent -> DomainResource)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Actor = Consent'Actor
        { consent'Actor_id :: Maybe String'primitive
        , consent'Actor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Actor_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Actor_role :: CodeableConcept
          -- ^ How the individual is involved in the resources content 
          --   that is described in the consent.
        , consent'Actor_reference :: Reference
          -- ^ The resource that identifies the actor. To identify a 
          --   actors by type, use group to identify a set of actors by 
          --   some property they share (e.g. 'admitting officers').
        }
        deriving (Eq,Show)
instance SchemaType Consent'Actor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Actor a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@Consent'Actor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Actor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Actor_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Actor_modifierExtension x
            , schemaTypeToXML "role" $ consent'Actor_role x
            , schemaTypeToXML "reference" $ consent'Actor_reference x
            ]
instance Extension Consent'Actor BackboneElement where
    supertype (Consent'Actor a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Consent'Actor Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Actor -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Policy = Consent'Policy
        { consent'Policy_id :: Maybe String'primitive
        , consent'Policy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Policy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Policy_authority :: Maybe Uri
          -- ^ Entity or Organization having regulatory jurisdiction or 
          --   accountability for enforcing policies pertaining to Consent 
          --   Directives.
        , consent'Policy_uri :: Maybe Uri
          -- ^ The references to the policies that are included in this 
          --   consent scope. Policies may be organizational, but are 
          --   often defined jurisdictionally, or in law.
        }
        deriving (Eq,Show)
instance SchemaType Consent'Policy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Policy a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "uri")
    schemaTypeToXML s x@Consent'Policy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Policy_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Policy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Policy_modifierExtension x
            , maybe [] (schemaTypeToXML "authority") $ consent'Policy_authority x
            , maybe [] (schemaTypeToXML "uri") $ consent'Policy_uri x
            ]
instance Extension Consent'Policy BackboneElement where
    supertype (Consent'Policy a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Consent'Policy Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Policy -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Data = Consent'Data
        { consent'Data_id :: Maybe String'primitive
        , consent'Data_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Data_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Data_meaning :: ConsentDataMeaning
          -- ^ How the resource reference is interpreted when testing 
          --   consent restrictions.
        , consent'Data_reference :: Reference
          -- ^ A reference to a specific resource that defines which 
          --   resources are covered by this consent.
        }
        deriving (Eq,Show)
instance SchemaType Consent'Data where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Data a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "meaning"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@Consent'Data{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Data_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Data_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Data_modifierExtension x
            , schemaTypeToXML "meaning" $ consent'Data_meaning x
            , schemaTypeToXML "reference" $ consent'Data_reference x
            ]
instance Extension Consent'Data BackboneElement where
    supertype (Consent'Data a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Consent'Data Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Data -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Except = Consent'Except
        { consent'Except_id :: Maybe String'primitive
        , consent'Except_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Except_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Except_type :: ConsentExceptType
          -- ^ Action to take - permit or deny - when the exception 
          --   conditions are met.
        , consent'Except_period :: Maybe Period
          -- ^ The timeframe in this exception is valid.
        , consent'Except_actor :: [Consent'Actor1]
          -- ^ Who or what is controlled by this Exception. Use group to 
          --   identify a set of actors by some property they share (e.g. 
          --   'admitting officers').
        , consent'Except_action :: [CodeableConcept]
          -- ^ Actions controlled by this Exception.
        , consent'Except_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this exception. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , consent'Except_purpose :: [Coding]
          -- ^ The context of the activities a user is taking - why the 
          --   user is accessing the data - that are controlled by this 
          --   exception.
        , consent'Except_class :: [Coding]
          -- ^ The class of information covered by this exception. The 
          --   type can be a FHIR resource type, a profile on a type, or a 
          --   CDA document, or some other type that indicates what sort 
          --   of information the consent relates to.
        , consent'Except_code :: [Coding]
          -- ^ If this code is found in an instance, then the exception 
          --   applies.
        , consent'Except_dataPeriod :: Maybe Period
          -- ^ Clinical or Operational Relevant period of time that bounds 
          --   the data controlled by this exception.
        , consent'Except_data :: [Consent'Data1]
          -- ^ The resources controlled by this exception, if specific 
          --   resources are referenced.
        }
        deriving (Eq,Show)
instance SchemaType Consent'Except where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Except a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "actor")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "purpose")
            `apply` many (parseSchemaType "class")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "dataPeriod")
            `apply` many (parseSchemaType "data")
    schemaTypeToXML s x@Consent'Except{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Except_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Except_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Except_modifierExtension x
            , schemaTypeToXML "type" $ consent'Except_type x
            , maybe [] (schemaTypeToXML "period") $ consent'Except_period x
            , concatMap (schemaTypeToXML "actor") $ consent'Except_actor x
            , concatMap (schemaTypeToXML "action") $ consent'Except_action x
            , concatMap (schemaTypeToXML "securityLabel") $ consent'Except_securityLabel x
            , concatMap (schemaTypeToXML "purpose") $ consent'Except_purpose x
            , concatMap (schemaTypeToXML "class") $ consent'Except_class x
            , concatMap (schemaTypeToXML "code") $ consent'Except_code x
            , maybe [] (schemaTypeToXML "dataPeriod") $ consent'Except_dataPeriod x
            , concatMap (schemaTypeToXML "data") $ consent'Except_data x
            ]
instance Extension Consent'Except BackboneElement where
    supertype (Consent'Except a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension Consent'Except Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Except -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Actor1 = Consent'Actor1
        { consent'Actor1_id :: Maybe String'primitive
        , consent'Actor1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Actor1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Actor1_role :: CodeableConcept
          -- ^ How the individual is involved in the resources content 
          --   that is described in the exception.
        , consent'Actor1_reference :: Reference
          -- ^ The resource that identifies the actor. To identify a 
          --   actors by type, use group to identify a set of actors by 
          --   some property they share (e.g. 'admitting officers').
        }
        deriving (Eq,Show)
instance SchemaType Consent'Actor1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Actor1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@Consent'Actor1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Actor1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Actor1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Actor1_modifierExtension x
            , schemaTypeToXML "role" $ consent'Actor1_role x
            , schemaTypeToXML "reference" $ consent'Actor1_reference x
            ]
instance Extension Consent'Actor1 BackboneElement where
    supertype (Consent'Actor1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Consent'Actor1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Actor1 -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data Consent'Data1 = Consent'Data1
        { consent'Data1_id :: Maybe String'primitive
        , consent'Data1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent'Data1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent'Data1_meaning :: ConsentDataMeaning
          -- ^ How the resource reference is interpreted when testing 
          --   consent restrictions.
        , consent'Data1_reference :: Reference
          -- ^ A reference to a specific resource that defines which 
          --   resources are covered by this consent.
        }
        deriving (Eq,Show)
instance SchemaType Consent'Data1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Consent'Data1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "meaning"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@Consent'Data1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consent'Data1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consent'Data1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent'Data1_modifierExtension x
            , schemaTypeToXML "meaning" $ consent'Data1_meaning x
            , schemaTypeToXML "reference" $ consent'Data1_reference x
            ]
instance Extension Consent'Data1 BackboneElement where
    supertype (Consent'Data1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Consent'Data1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Consent'Data1 -> BackboneElement)
              
 
data ConsentDataMeaning'list
    = ConsentDataMeaning'list_Instance
      -- ^ Instance
    | ConsentDataMeaning'list_Related
      -- ^ Related
    | ConsentDataMeaning'list_Dependents
      -- ^ Dependents
    | ConsentDataMeaning'list_Authoredby
      -- ^ AuthoredBy
    deriving (Eq,Show,Enum)
instance SchemaType ConsentDataMeaning'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentDataMeaning'list where
    acceptingParser =  do literal "instance"; return ConsentDataMeaning'list_Instance
                      `onFail` do literal "related"; return ConsentDataMeaning'list_Related
                      `onFail` do literal "dependents"; return ConsentDataMeaning'list_Dependents
                      `onFail` do literal "authoredby"; return ConsentDataMeaning'list_Authoredby
                      
    simpleTypeText ConsentDataMeaning'list_Instance = "instance"
    simpleTypeText ConsentDataMeaning'list_Related = "related"
    simpleTypeText ConsentDataMeaning'list_Dependents = "dependents"
    simpleTypeText ConsentDataMeaning'list_Authoredby = "authoredby"
 
data ConsentDataMeaning = ConsentDataMeaning
        { consentDataMeaning_id :: Maybe String'primitive
        , consentDataMeaning_value :: Maybe ConsentDataMeaning'list
        , consentDataMeaning_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentDataMeaning where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentDataMeaning a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentDataMeaning{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentDataMeaning_id x
                       , maybe [] (toXMLAttribute "value") $ consentDataMeaning_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentDataMeaning_extension x
            ]
instance Extension ConsentDataMeaning Element where
    supertype (ConsentDataMeaning a0 a1 e0) =
               Element a0 e0
 
data ConsentState'list
    = ConsentState'list_Draft
      -- ^ Pending
    | ConsentState'list_Proposed
      -- ^ Proposed
    | ConsentState'list_Active
      -- ^ Active
    | ConsentState'list_Rejected
      -- ^ Rejected
    | ConsentState'list_Inactive
      -- ^ Inactive
    | ConsentState'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ConsentState'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentState'list where
    acceptingParser =  do literal "draft"; return ConsentState'list_Draft
                      `onFail` do literal "proposed"; return ConsentState'list_Proposed
                      `onFail` do literal "active"; return ConsentState'list_Active
                      `onFail` do literal "rejected"; return ConsentState'list_Rejected
                      `onFail` do literal "inactive"; return ConsentState'list_Inactive
                      `onFail` do literal "entered-in-error"; return ConsentState'list_Entered'in'error
                      
    simpleTypeText ConsentState'list_Draft = "draft"
    simpleTypeText ConsentState'list_Proposed = "proposed"
    simpleTypeText ConsentState'list_Active = "active"
    simpleTypeText ConsentState'list_Rejected = "rejected"
    simpleTypeText ConsentState'list_Inactive = "inactive"
    simpleTypeText ConsentState'list_Entered'in'error = "entered-in-error"
 
data ConsentState = ConsentState
        { consentState_id :: Maybe String'primitive
        , consentState_value :: Maybe ConsentState'list
        , consentState_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentState where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentState a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentState{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentState_id x
                       , maybe [] (toXMLAttribute "value") $ consentState_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentState_extension x
            ]
instance Extension ConsentState Element where
    supertype (ConsentState a0 a1 e0) =
               Element a0 e0
 
data ConsentExceptType'list
    = ConsentExceptType'list_Deny
      -- ^ Opt Out
    | ConsentExceptType'list_Permit
      -- ^ Opt In
    deriving (Eq,Show,Enum)
instance SchemaType ConsentExceptType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentExceptType'list where
    acceptingParser =  do literal "deny"; return ConsentExceptType'list_Deny
                      `onFail` do literal "permit"; return ConsentExceptType'list_Permit
                      
    simpleTypeText ConsentExceptType'list_Deny = "deny"
    simpleTypeText ConsentExceptType'list_Permit = "permit"
 
data ConsentExceptType = ConsentExceptType
        { consentExceptType_id :: Maybe String'primitive
        , consentExceptType_value :: Maybe ConsentExceptType'list
        , consentExceptType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentExceptType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentExceptType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentExceptType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentExceptType_id x
                       , maybe [] (toXMLAttribute "value") $ consentExceptType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentExceptType_extension x
            ]
instance Extension ConsentExceptType Element where
    supertype (ConsentExceptType a0 a1 e0) =
               Element a0 e0
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
elementContract :: XMLParser Contract
elementContract = parseSchemaType "Contract"
elementToXMLContract :: Contract -> [Content ()]
elementToXMLContract = schemaTypeToXML "Contract"
 
data Contract = Contract
        { contract_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , contract_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , contract_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , contract_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , contract_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , contract_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , contract_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract_identifier :: Maybe Identifier
          -- ^ Unique identifier for this Contract.
        , contract_status :: Maybe ContractResourceStatusCodes
          -- ^ The status of the resource instance.
        , contract_issued :: Maybe DateTime
          -- ^ When this Contract was issued.
        , contract_applies :: Maybe Period
          -- ^ Relevant time or time-period when this Contract is 
          --   applicable.
        , contract_subject :: [Reference]
          -- ^ The target entity impacted by or of interest to parties to 
          --   the agreement.
        , contract_topic :: [Reference]
          -- ^ The matter of concern in the context of this agreement.
        , contract_authority :: [Reference]
          -- ^ A formally or informally recognized grouping of people, 
          --   principals, organizations, or jurisdictions formed for the 
          --   purpose of achieving some form of collective action such as 
          --   the promulgation, administration and enforcement of 
          --   contracts and policies.
        , contract_domain :: [Reference]
          -- ^ Recognized governance framework or system operating with a 
          --   circumscribed scope in accordance with specified 
          --   principles, policies, processes or procedures for managing 
          --   rights, actions, or behaviors of parties or principals 
          --   relative to resources.
        , contract_type :: Maybe CodeableConcept
          -- ^ Type of Contract such as an insurance policy, real estate 
          --   contract, a will, power of attorny, Privacy or Security 
          --   policy , trust framework agreement, etc.
        , contract_subType :: [CodeableConcept]
          -- ^ More specific type or specialization of an overarching or 
          --   more general contract such as auto insurance, home owner 
          --   insurance, prenupial agreement, Advanced-Directive, or 
          --   privacy consent.
        , contract_action :: [CodeableConcept]
          -- ^ Action stipulated by this Contract.
        , contract_actionReason :: [CodeableConcept]
          -- ^ Reason for action stipulated by this Contract.
        , contract_decisionType :: Maybe CodeableConcept
          -- ^ The type of decision made by a grantor with respect to an 
          --   offer made by a grantee.
        , contract_contentDerivative :: Maybe CodeableConcept
          -- ^ The minimal content derived from the basal information 
          --   source at a specific stage in its lifecycle.
        , contract_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this consent. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , contract_agent :: [Contract'Agent]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , contract_signer :: [Contract'Signer]
          -- ^ Parties with legal standing in the Contract, including the 
          --   principal parties, the grantor(s) and grantee(s), which are 
          --   any person or organization bound by the contract, and any 
          --   ancillary parties, which facilitate the execution of the 
          --   contract such as a notary or witness.
        , contract_valuedItem :: [Contract'ValuedItem]
          -- ^ Contract Valued Item List.
        , contract_term :: [Contract'Term]
          -- ^ One or more Contract Provisions, which may be related and 
          --   conveyed as a group, and may contain nested groups.
        , contract_choice27 :: (Maybe (OneOf2 Attachment Reference))
          -- ^ Legally binding Contract: This is the signed and legally 
          --   recognized representation of the Contract, which is 
          --   considered the &quot;source of truth&quot; and which would 
          --   be the basis for legal action related to enforcement of 
          --   this Contract.
          --   
          --   Choice between:
          --   
          --   (1) bindingAttachment
          --   
          --   (2) bindingReference
        , contract_friendly :: [Contract'Friendly]
          -- ^ The &quot;patient friendly language&quot; versionof the 
          --   Contract in whole or in parts. &quot;Patient friendly 
          --   language&quot; means the representation of the Contract and 
          --   Contract Provisions in a manner that is readily accessible 
          --   and understandable by a layperson in accordance with best 
          --   practices for communication styles that ensure that those 
          --   agreeing to or signing the Contract understand the roles, 
          --   actions, obligations, responsibilities, and implication of 
          --   the agreement.
        , contract_legal :: [Contract'Legal]
          -- ^ List of Legal expressions or representations of this 
          --   Contract.
        , contract_rule :: [Contract'Rule]
          -- ^ List of Computable Policy Rule Language Representations of 
          --   this Contract.
        }
        deriving (Eq,Show)
instance SchemaType Contract where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Contract
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "issued")
            `apply` optional (parseSchemaType "applies")
            `apply` many (parseSchemaType "subject")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "authority")
            `apply` many (parseSchemaType "domain")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "actionReason")
            `apply` optional (parseSchemaType "decisionType")
            `apply` optional (parseSchemaType "contentDerivative")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "agent")
            `apply` many (parseSchemaType "signer")
            `apply` many (parseSchemaType "valuedItem")
            `apply` many (parseSchemaType "term")
            `apply` optional (oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "bindingAttachment"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "bindingReference"))
                                     ])
            `apply` many (parseSchemaType "friendly")
            `apply` many (parseSchemaType "legal")
            `apply` many (parseSchemaType "rule")
    schemaTypeToXML s x@Contract{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ contract_id x
            , maybe [] (schemaTypeToXML "meta") $ contract_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ contract_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ contract_language x
            , maybe [] (schemaTypeToXML "text") $ contract_text x
            , concatMap (schemaTypeToXML "contained") $ contract_contained x
            , concatMap (schemaTypeToXML "extension") $ contract_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ contract_identifier x
            , maybe [] (schemaTypeToXML "status") $ contract_status x
            , maybe [] (schemaTypeToXML "issued") $ contract_issued x
            , maybe [] (schemaTypeToXML "applies") $ contract_applies x
            , concatMap (schemaTypeToXML "subject") $ contract_subject x
            , concatMap (schemaTypeToXML "topic") $ contract_topic x
            , concatMap (schemaTypeToXML "authority") $ contract_authority x
            , concatMap (schemaTypeToXML "domain") $ contract_domain x
            , maybe [] (schemaTypeToXML "type") $ contract_type x
            , concatMap (schemaTypeToXML "subType") $ contract_subType x
            , concatMap (schemaTypeToXML "action") $ contract_action x
            , concatMap (schemaTypeToXML "actionReason") $ contract_actionReason x
            , maybe [] (schemaTypeToXML "decisionType") $ contract_decisionType x
            , maybe [] (schemaTypeToXML "contentDerivative") $ contract_contentDerivative x
            , concatMap (schemaTypeToXML "securityLabel") $ contract_securityLabel x
            , concatMap (schemaTypeToXML "agent") $ contract_agent x
            , concatMap (schemaTypeToXML "signer") $ contract_signer x
            , concatMap (schemaTypeToXML "valuedItem") $ contract_valuedItem x
            , concatMap (schemaTypeToXML "term") $ contract_term x
            , maybe [] (foldOneOf2  (schemaTypeToXML "bindingAttachment")
                                    (schemaTypeToXML "bindingReference")
                                   ) $ contract_choice27 x
            , concatMap (schemaTypeToXML "friendly") $ contract_friendly x
            , concatMap (schemaTypeToXML "legal") $ contract_legal x
            , concatMap (schemaTypeToXML "rule") $ contract_rule x
            ]
instance Extension Contract DomainResource where
    supertype (Contract e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Contract Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Contract -> DomainResource)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Agent = Contract'Agent
        { contract'Agent_id :: Maybe String'primitive
        , contract'Agent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Agent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Agent_actor :: Reference
          -- ^ Who or what parties are assigned roles in this Contract.
        , contract'Agent_role :: [CodeableConcept]
          -- ^ Role type of agent assigned roles in this Contract.
        }
        deriving (Eq,Show)
instance SchemaType Contract'Agent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Agent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` many (parseSchemaType "role")
    schemaTypeToXML s x@Contract'Agent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Agent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Agent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Agent_modifierExtension x
            , schemaTypeToXML "actor" $ contract'Agent_actor x
            , concatMap (schemaTypeToXML "role") $ contract'Agent_role x
            ]
instance Extension Contract'Agent BackboneElement where
    supertype (Contract'Agent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Contract'Agent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Agent -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Signer = Contract'Signer
        { contract'Signer_id :: Maybe String'primitive
        , contract'Signer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Signer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Signer_type :: Coding
          -- ^ Role of this Contract signer, e.g. notary, grantee.
        , contract'Signer_party :: Reference
          -- ^ Party which is a signator to this Contract.
        , contract'Signer_signature :: [Signature]
          -- ^ Legally binding Contract DSIG signature contents in Base64.
        }
        deriving (Eq,Show)
instance SchemaType Contract'Signer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Signer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "party"
            `apply` many1 (parseSchemaType "signature")
    schemaTypeToXML s x@Contract'Signer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Signer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Signer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Signer_modifierExtension x
            , schemaTypeToXML "type" $ contract'Signer_type x
            , schemaTypeToXML "party" $ contract'Signer_party x
            , concatMap (schemaTypeToXML "signature") $ contract'Signer_signature x
            ]
instance Extension Contract'Signer BackboneElement where
    supertype (Contract'Signer a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Contract'Signer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Signer -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'ValuedItem = Contract'ValuedItem
        { contract'ValuedItem_id :: Maybe String'primitive
        , contract'ValuedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'ValuedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'ValuedItem_choice2 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Specific type of Contract Valued Item that may be priced.
          --   
          --   Choice between:
          --   
          --   (1) entityCodeableConcept
          --   
          --   (2) entityReference
        , contract'ValuedItem_identifier :: Maybe Identifier
          -- ^ Identifies a Contract Valued Item instance.
        , contract'ValuedItem_effectiveTime :: Maybe DateTime
          -- ^ Indicates the time during which this Contract ValuedItem 
          --   information is effective.
        , contract'ValuedItem_quantity :: Maybe Quantity
          -- ^ Specifies the units by which the Contract Valued Item is 
          --   measured or counted, and quantifies the countable or 
          --   measurable Contract Valued Item instances.
        , contract'ValuedItem_unitPrice :: Maybe Money
          -- ^ A Contract Valued Item unit valuation measure.
        , contract'ValuedItem_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of the Contract Valued Item 
          --   delivered. The concept of a Factor allows for a discount or 
          --   surcharge multiplier to be applied to a monetary amount.
        , contract'ValuedItem_points :: Maybe Decimal
          -- ^ An amount that expresses the weighting (based on 
          --   difficulty, cost and/or resource intensiveness) associated 
          --   with the Contract Valued Item delivered. The concept of 
          --   Points allows for assignment of point values for a Contract 
          --   Valued Item, such that a monetary amount can be assigned to 
          --   each point.
        , contract'ValuedItem_net :: Maybe Money
          -- ^ Expresses the product of the Contract Valued Item 
          --   unitQuantity and the unitPriceAmt. For example, the 
          --   formula: unit Quantity * unit Price (Cost per Point) * 
          --   factor Number * points = net Amount. Quantity, factor and 
          --   points are assumed to be 1 if not supplied.
        }
        deriving (Eq,Show)
instance SchemaType Contract'ValuedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'ValuedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "entityCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "entityReference"))
                                     ])
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "effectiveTime")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "points")
            `apply` optional (parseSchemaType "net")
    schemaTypeToXML s x@Contract'ValuedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'ValuedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'ValuedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'ValuedItem_modifierExtension x
            , maybe [] (foldOneOf2  (schemaTypeToXML "entityCodeableConcept")
                                    (schemaTypeToXML "entityReference")
                                   ) $ contract'ValuedItem_choice2 x
            , maybe [] (schemaTypeToXML "identifier") $ contract'ValuedItem_identifier x
            , maybe [] (schemaTypeToXML "effectiveTime") $ contract'ValuedItem_effectiveTime x
            , maybe [] (schemaTypeToXML "quantity") $ contract'ValuedItem_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ contract'ValuedItem_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ contract'ValuedItem_factor x
            , maybe [] (schemaTypeToXML "points") $ contract'ValuedItem_points x
            , maybe [] (schemaTypeToXML "net") $ contract'ValuedItem_net x
            ]
instance Extension Contract'ValuedItem BackboneElement where
    supertype (Contract'ValuedItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension Contract'ValuedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'ValuedItem -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Term = Contract'Term
        { contract'Term_id :: Maybe String'primitive
        , contract'Term_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Term_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Term_identifier :: Maybe Identifier
          -- ^ Unique identifier for this particular Contract Provision.
        , contract'Term_issued :: Maybe DateTime
          -- ^ When this Contract Provision was issued.
        , contract'Term_applies :: Maybe Period
          -- ^ Relevant time or time-period when this Contract Provision 
          --   is applicable.
        , contract'Term_type :: Maybe CodeableConcept
          -- ^ Type of Contract Provision such as specific requirements, 
          --   purposes for actions, obligations, prohibitions, e.g. life 
          --   time maximum benefit.
        , contract'Term_subType :: Maybe CodeableConcept
          -- ^ Subtype of this Contract Provision, e.g. life time maximum 
          --   payment for a contract term for specific valued item, e.g. 
          --   disability payment.
        , contract'Term_topic :: [Reference]
          -- ^ The matter of concern in the context of this provision of 
          --   the agrement.
        , contract'Term_action :: [CodeableConcept]
          -- ^ Action stipulated by this Contract Provision.
        , contract'Term_actionReason :: [CodeableConcept]
          -- ^ Reason or purpose for the action stipulated by this 
          --   Contract Provision.
        , contract'Term_securityLabel :: [Coding]
          -- ^ A set of security labels that define which terms are 
          --   controlled by this condition.
        , contract'Term_agent :: [Contract'Agent1]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , contract'Term_text :: Maybe Xsd.XsdString
          -- ^ Human readable form of this Contract Provision.
        , contract'Term_valuedItem :: [Contract'ValuedItem1]
          -- ^ Contract Provision Valued Item List.
        , contract'Term_group :: [Contract'Term]
          -- ^ Nested group of Contract Provisions.
        }
        deriving (Eq,Show)
instance SchemaType Contract'Term where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Term a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "issued")
            `apply` optional (parseSchemaType "applies")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subType")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "actionReason")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "agent")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "valuedItem")
            `apply` many (parseSchemaType "group")
    schemaTypeToXML s x@Contract'Term{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Term_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Term_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Term_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ contract'Term_identifier x
            , maybe [] (schemaTypeToXML "issued") $ contract'Term_issued x
            , maybe [] (schemaTypeToXML "applies") $ contract'Term_applies x
            , maybe [] (schemaTypeToXML "type") $ contract'Term_type x
            , maybe [] (schemaTypeToXML "subType") $ contract'Term_subType x
            , concatMap (schemaTypeToXML "topic") $ contract'Term_topic x
            , concatMap (schemaTypeToXML "action") $ contract'Term_action x
            , concatMap (schemaTypeToXML "actionReason") $ contract'Term_actionReason x
            , concatMap (schemaTypeToXML "securityLabel") $ contract'Term_securityLabel x
            , concatMap (schemaTypeToXML "agent") $ contract'Term_agent x
            , maybe [] (schemaTypeToXML "text") $ contract'Term_text x
            , concatMap (schemaTypeToXML "valuedItem") $ contract'Term_valuedItem x
            , concatMap (schemaTypeToXML "group") $ contract'Term_group x
            ]
instance Extension Contract'Term BackboneElement where
    supertype (Contract'Term a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               BackboneElement a0 e0 e1
instance Extension Contract'Term Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Term -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Agent1 = Contract'Agent1
        { contract'Agent1_id :: Maybe String'primitive
        , contract'Agent1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Agent1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Agent1_actor :: Reference
          -- ^ The agent assigned a role in this Contract Provision.
        , contract'Agent1_role :: [CodeableConcept]
          -- ^ Role played by the agent assigned this role in the 
          --   execution of this Contract Provision.
        }
        deriving (Eq,Show)
instance SchemaType Contract'Agent1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Agent1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` many (parseSchemaType "role")
    schemaTypeToXML s x@Contract'Agent1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Agent1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Agent1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Agent1_modifierExtension x
            , schemaTypeToXML "actor" $ contract'Agent1_actor x
            , concatMap (schemaTypeToXML "role") $ contract'Agent1_role x
            ]
instance Extension Contract'Agent1 BackboneElement where
    supertype (Contract'Agent1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Contract'Agent1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Agent1 -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'ValuedItem1 = Contract'ValuedItem1
        { contract'ValuedItem1_id :: Maybe String'primitive
        , contract'ValuedItem1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'ValuedItem1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'ValuedItem1_choice2 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Specific type of Contract Provision Valued Item that may be 
          --   priced.
          --   
          --   Choice between:
          --   
          --   (1) entityCodeableConcept
          --   
          --   (2) entityReference
        , contract'ValuedItem1_identifier :: Maybe Identifier
          -- ^ Identifies a Contract Provision Valued Item instance.
        , contract'ValuedItem1_effectiveTime :: Maybe DateTime
          -- ^ Indicates the time during which this Contract Term 
          --   ValuedItem information is effective.
        , contract'ValuedItem1_quantity :: Maybe Quantity
          -- ^ Specifies the units by which the Contract Provision Valued 
          --   Item is measured or counted, and quantifies the countable 
          --   or measurable Contract Term Valued Item instances.
        , contract'ValuedItem1_unitPrice :: Maybe Money
          -- ^ A Contract Provision Valued Item unit valuation measure.
        , contract'ValuedItem1_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of the Contract Provision 
          --   Valued Item delivered. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , contract'ValuedItem1_points :: Maybe Decimal
          -- ^ An amount that expresses the weighting (based on 
          --   difficulty, cost and/or resource intensiveness) associated 
          --   with the Contract Provision Valued Item delivered. The 
          --   concept of Points allows for assignment of point values for 
          --   a Contract ProvisionValued Item, such that a monetary 
          --   amount can be assigned to each point.
        , contract'ValuedItem1_net :: Maybe Money
          -- ^ Expresses the product of the Contract Provision Valued Item 
          --   unitQuantity and the unitPriceAmt. For example, the 
          --   formula: unit Quantity * unit Price (Cost per Point) * 
          --   factor Number * points = net Amount. Quantity, factor and 
          --   points are assumed to be 1 if not supplied.
        }
        deriving (Eq,Show)
instance SchemaType Contract'ValuedItem1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'ValuedItem1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "entityCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "entityReference"))
                                     ])
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "effectiveTime")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "points")
            `apply` optional (parseSchemaType "net")
    schemaTypeToXML s x@Contract'ValuedItem1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'ValuedItem1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'ValuedItem1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'ValuedItem1_modifierExtension x
            , maybe [] (foldOneOf2  (schemaTypeToXML "entityCodeableConcept")
                                    (schemaTypeToXML "entityReference")
                                   ) $ contract'ValuedItem1_choice2 x
            , maybe [] (schemaTypeToXML "identifier") $ contract'ValuedItem1_identifier x
            , maybe [] (schemaTypeToXML "effectiveTime") $ contract'ValuedItem1_effectiveTime x
            , maybe [] (schemaTypeToXML "quantity") $ contract'ValuedItem1_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ contract'ValuedItem1_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ contract'ValuedItem1_factor x
            , maybe [] (schemaTypeToXML "points") $ contract'ValuedItem1_points x
            , maybe [] (schemaTypeToXML "net") $ contract'ValuedItem1_net x
            ]
instance Extension Contract'ValuedItem1 BackboneElement where
    supertype (Contract'ValuedItem1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension Contract'ValuedItem1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'ValuedItem1 -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Friendly = Contract'Friendly
        { contract'Friendly_id :: Maybe String'primitive
        , contract'Friendly_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Friendly_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Friendly_choice2 :: OneOf2 Attachment Reference
          -- ^ Human readable rendering of this Contract in a format and 
          --   representation intended to enhance comprehension and ensure 
          --   understandability.
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType Contract'Friendly where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Friendly a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@Contract'Friendly{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Friendly_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Friendly_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Friendly_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contract'Friendly_choice2 x
            ]
instance Extension Contract'Friendly BackboneElement where
    supertype (Contract'Friendly a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension Contract'Friendly Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Friendly -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Legal = Contract'Legal
        { contract'Legal_id :: Maybe String'primitive
        , contract'Legal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Legal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Legal_choice2 :: OneOf2 Attachment Reference
          -- ^ Contract legal text in human renderable form.
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType Contract'Legal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Legal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@Contract'Legal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Legal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Legal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Legal_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contract'Legal_choice2 x
            ]
instance Extension Contract'Legal BackboneElement where
    supertype (Contract'Legal a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension Contract'Legal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Legal -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data Contract'Rule = Contract'Rule
        { contract'Rule_id :: Maybe String'primitive
        , contract'Rule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract'Rule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract'Rule_choice2 :: OneOf2 Attachment Reference
          -- ^ Computable Contract conveyed using a policy rule language 
          --   (e.g. XACML, DKAL, SecPal).
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType Contract'Rule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contract'Rule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@Contract'Rule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contract'Rule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contract'Rule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract'Rule_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contract'Rule_choice2 x
            ]
instance Extension Contract'Rule BackboneElement where
    supertype (Contract'Rule a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension Contract'Rule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Contract'Rule -> BackboneElement)
              
 
data ContractResourceStatusCodes'list
    = ContractResourceStatusCodes'list_Amended
      -- ^ Amended
    | ContractResourceStatusCodes'list_Appended
      -- ^ Appended
    | ContractResourceStatusCodes'list_Cancelled
      -- ^ Cancelled
    | ContractResourceStatusCodes'list_Disputed
      -- ^ Disputed
    | ContractResourceStatusCodes'list_Entered'in'error
      -- ^ Entered in Error
    | ContractResourceStatusCodes'list_Executable
      -- ^ Executable
    | ContractResourceStatusCodes'list_Executed
      -- ^ Executed
    | ContractResourceStatusCodes'list_Negotiable
      -- ^ Negotiable
    | ContractResourceStatusCodes'list_Offered
      -- ^ Offered
    | ContractResourceStatusCodes'list_Policy
      -- ^ Policy
    | ContractResourceStatusCodes'list_Rejected
      -- ^ Rejected
    | ContractResourceStatusCodes'list_Renewed
      -- ^ Renewed
    | ContractResourceStatusCodes'list_Revoked
      -- ^ Revoked
    | ContractResourceStatusCodes'list_Resolved
      -- ^ Resolved
    | ContractResourceStatusCodes'list_Terminated
      -- ^ Terminated
    deriving (Eq,Show,Enum)
instance SchemaType ContractResourceStatusCodes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContractResourceStatusCodes'list where
    acceptingParser =  do literal "amended"; return ContractResourceStatusCodes'list_Amended
                      `onFail` do literal "appended"; return ContractResourceStatusCodes'list_Appended
                      `onFail` do literal "cancelled"; return ContractResourceStatusCodes'list_Cancelled
                      `onFail` do literal "disputed"; return ContractResourceStatusCodes'list_Disputed
                      `onFail` do literal "entered-in-error"; return ContractResourceStatusCodes'list_Entered'in'error
                      `onFail` do literal "executable"; return ContractResourceStatusCodes'list_Executable
                      `onFail` do literal "executed"; return ContractResourceStatusCodes'list_Executed
                      `onFail` do literal "negotiable"; return ContractResourceStatusCodes'list_Negotiable
                      `onFail` do literal "offered"; return ContractResourceStatusCodes'list_Offered
                      `onFail` do literal "policy"; return ContractResourceStatusCodes'list_Policy
                      `onFail` do literal "rejected"; return ContractResourceStatusCodes'list_Rejected
                      `onFail` do literal "renewed"; return ContractResourceStatusCodes'list_Renewed
                      `onFail` do literal "revoked"; return ContractResourceStatusCodes'list_Revoked
                      `onFail` do literal "resolved"; return ContractResourceStatusCodes'list_Resolved
                      `onFail` do literal "terminated"; return ContractResourceStatusCodes'list_Terminated
                      
    simpleTypeText ContractResourceStatusCodes'list_Amended = "amended"
    simpleTypeText ContractResourceStatusCodes'list_Appended = "appended"
    simpleTypeText ContractResourceStatusCodes'list_Cancelled = "cancelled"
    simpleTypeText ContractResourceStatusCodes'list_Disputed = "disputed"
    simpleTypeText ContractResourceStatusCodes'list_Entered'in'error = "entered-in-error"
    simpleTypeText ContractResourceStatusCodes'list_Executable = "executable"
    simpleTypeText ContractResourceStatusCodes'list_Executed = "executed"
    simpleTypeText ContractResourceStatusCodes'list_Negotiable = "negotiable"
    simpleTypeText ContractResourceStatusCodes'list_Offered = "offered"
    simpleTypeText ContractResourceStatusCodes'list_Policy = "policy"
    simpleTypeText ContractResourceStatusCodes'list_Rejected = "rejected"
    simpleTypeText ContractResourceStatusCodes'list_Renewed = "renewed"
    simpleTypeText ContractResourceStatusCodes'list_Revoked = "revoked"
    simpleTypeText ContractResourceStatusCodes'list_Resolved = "resolved"
    simpleTypeText ContractResourceStatusCodes'list_Terminated = "terminated"
 
data ContractResourceStatusCodes = ContractResourceStatusCodes
        { contractResourceStatusCodes_id :: Maybe String'primitive
        , contractResourceStatusCodes_value :: Maybe ContractResourceStatusCodes'list
        , contractResourceStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContractResourceStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContractResourceStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContractResourceStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractResourceStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ contractResourceStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractResourceStatusCodes_extension x
            ]
instance Extension ContractResourceStatusCodes Element where
    supertype (ContractResourceStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | Financial instrument which may be used to reimburse or pay 
--   for health care products and services.
elementCoverage :: XMLParser Coverage
elementCoverage = parseSchemaType "Coverage"
elementToXMLCoverage :: Coverage -> [Content ()]
elementToXMLCoverage = schemaTypeToXML "Coverage"
 
data Coverage = Coverage
        { coverage_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , coverage_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , coverage_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , coverage_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , coverage_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , coverage_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , coverage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coverage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , coverage_identifier :: [Identifier]
          -- ^ The main (and possibly only) identifier for the coverage - 
          --   often referred to as a Member Id, Certificate number, 
          --   Personal Health Number or Case ID. May be constructed as 
          --   the concatination of the Coverage.SubscriberID and the 
          --   Coverage.dependant.
        , coverage_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , coverage_type :: Maybe CodeableConcept
          -- ^ The type of coverage: social program, medical plan, 
          --   accident coverage (workers compensation, auto), group 
          --   health or payment by an individual or organization.
        , coverage_policyHolder :: Maybe Reference
          -- ^ The party who 'owns' the insurance policy, may be an 
          --   individual, corporation or the subscriber's employer.
        , coverage_subscriber :: Maybe Reference
          -- ^ The party who has signed-up for or 'owns' the contractual 
          --   relationship to the policy or to whom the benefit of the 
          --   policy for services rendered to them or their family is 
          --   due.
        , coverage_subscriberId :: Maybe Xsd.XsdString
          -- ^ The insurer assigned ID for the Subscriber.
        , coverage_beneficiary :: Maybe Reference
          -- ^ The party who benefits from the insurance coverage., the 
          --   patient when services are provided.
        , coverage_relationship :: Maybe CodeableConcept
          -- ^ The relationship of beneficiary (patient) to the 
          --   subscriber.
        , coverage_period :: Maybe Period
          -- ^ Time period during which the coverage is in force. A 
          --   missing start date indicates the start date isn't known, a 
          --   missing end date means the coverage is continuing to be in 
          --   force.
        , coverage_payor :: [Reference]
          -- ^ The program or plan underwriter or payor including both 
          --   insurance and non-insurance agreements, such as patient-pay 
          --   agreements. May provide multiple identifiers such as 
          --   insurance company identifier or business identifier (BIN 
          --   number).
        , coverage_grouping :: Maybe Coverage'Grouping
          -- ^ A suite of underwrite specific classifiers, for example may 
          --   be used to identify a class of coverage or employer group, 
          --   Policy, Plan.
        , coverage_dependent :: Maybe Xsd.XsdString
          -- ^ A unique identifier for a dependent under the coverage.
        , coverage_sequence :: Maybe Xsd.XsdString
          -- ^ An optional counter for a particular instance of the 
          --   identified coverage which increments upon each renewal.
        , coverage_order :: Maybe PositiveInt
          -- ^ The order of applicability of this coverage relative to 
          --   other coverages which are currently inforce. Note, there 
          --   may be gaps in the numbering and this does not imply 
          --   primary, secondard etc. as the specific positioning of 
          --   coverages depends upon the episode of care.
        , coverage_network :: Maybe Xsd.XsdString
          -- ^ The insurer-specific identifier for the insurer-defined 
          --   network of providers to which the beneficiary may seek 
          --   treatment which will be covered at the 'in-network' rate, 
          --   otherwise 'out of network' terms and conditions apply.
        , coverage_contract :: [Reference]
          -- ^ The policy(s) which constitute this insurance coverage.
        }
        deriving (Eq,Show)
instance SchemaType Coverage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Coverage
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "policyHolder")
            `apply` optional (parseSchemaType "subscriber")
            `apply` optional (parseSchemaType "subscriberId")
            `apply` optional (parseSchemaType "beneficiary")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "payor")
            `apply` optional (parseSchemaType "grouping")
            `apply` optional (parseSchemaType "dependent")
            `apply` optional (parseSchemaType "sequence")
            `apply` optional (parseSchemaType "order")
            `apply` optional (parseSchemaType "network")
            `apply` many (parseSchemaType "contract")
    schemaTypeToXML s x@Coverage{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ coverage_id x
            , maybe [] (schemaTypeToXML "meta") $ coverage_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ coverage_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ coverage_language x
            , maybe [] (schemaTypeToXML "text") $ coverage_text x
            , concatMap (schemaTypeToXML "contained") $ coverage_contained x
            , concatMap (schemaTypeToXML "extension") $ coverage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ coverage_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ coverage_identifier x
            , maybe [] (schemaTypeToXML "status") $ coverage_status x
            , maybe [] (schemaTypeToXML "type") $ coverage_type x
            , maybe [] (schemaTypeToXML "policyHolder") $ coverage_policyHolder x
            , maybe [] (schemaTypeToXML "subscriber") $ coverage_subscriber x
            , maybe [] (schemaTypeToXML "subscriberId") $ coverage_subscriberId x
            , maybe [] (schemaTypeToXML "beneficiary") $ coverage_beneficiary x
            , maybe [] (schemaTypeToXML "relationship") $ coverage_relationship x
            , maybe [] (schemaTypeToXML "period") $ coverage_period x
            , concatMap (schemaTypeToXML "payor") $ coverage_payor x
            , maybe [] (schemaTypeToXML "grouping") $ coverage_grouping x
            , maybe [] (schemaTypeToXML "dependent") $ coverage_dependent x
            , maybe [] (schemaTypeToXML "sequence") $ coverage_sequence x
            , maybe [] (schemaTypeToXML "order") $ coverage_order x
            , maybe [] (schemaTypeToXML "network") $ coverage_network x
            , concatMap (schemaTypeToXML "contract") $ coverage_contract x
            ]
instance Extension Coverage DomainResource where
    supertype (Coverage e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Coverage Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Coverage -> DomainResource)
              
 
-- | Financial instrument which may be used to reimburse or pay 
--   for health care products and services.
data Coverage'Grouping = Coverage'Grouping
        { coverage'Grouping_id :: Maybe String'primitive
        , coverage'Grouping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coverage'Grouping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , coverage'Grouping_group :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify an 
          --   employer group. May also be referred to as a Policy or 
          --   Group ID.
        , coverage'Grouping_groupDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the group.
        , coverage'Grouping_subGroup :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify a subset 
          --   of an employer group.
        , coverage'Grouping_subGroupDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subgroup.
        , coverage'Grouping_plan :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify a 
          --   collection of benefits provided to employees. May be 
          --   referred to as a Section or Division ID.
        , coverage'Grouping_planDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the plan.
        , coverage'Grouping_subPlan :: Maybe Xsd.XsdString
          -- ^ Identifies a sub-style or sub-collective of coverage issued 
          --   by the underwriter, for example may be used to identify a 
          --   subset of a collection of benefits provided to employees.
        , coverage'Grouping_subPlanDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subplan.
        , coverage'Grouping_class :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issues by the 
          --   underwriter, for example may be used to identify a class of 
          --   coverage such as a level of deductables or co-payment.
        , coverage'Grouping_classDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the class.
        , coverage'Grouping_subClass :: Maybe Xsd.XsdString
          -- ^ Identifies a sub-style or sub-collective of coverage issues 
          --   by the underwriter, for example may be used to identify a 
          --   subclass of coverage such as a sub-level of deductables or 
          --   co-payment.
        , coverage'Grouping_subClassDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subclass.
        }
        deriving (Eq,Show)
instance SchemaType Coverage'Grouping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Coverage'Grouping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "group")
            `apply` optional (parseSchemaType "groupDisplay")
            `apply` optional (parseSchemaType "subGroup")
            `apply` optional (parseSchemaType "subGroupDisplay")
            `apply` optional (parseSchemaType "plan")
            `apply` optional (parseSchemaType "planDisplay")
            `apply` optional (parseSchemaType "subPlan")
            `apply` optional (parseSchemaType "subPlanDisplay")
            `apply` optional (parseSchemaType "class")
            `apply` optional (parseSchemaType "classDisplay")
            `apply` optional (parseSchemaType "subClass")
            `apply` optional (parseSchemaType "subClassDisplay")
    schemaTypeToXML s x@Coverage'Grouping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ coverage'Grouping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ coverage'Grouping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ coverage'Grouping_modifierExtension x
            , maybe [] (schemaTypeToXML "group") $ coverage'Grouping_group x
            , maybe [] (schemaTypeToXML "groupDisplay") $ coverage'Grouping_groupDisplay x
            , maybe [] (schemaTypeToXML "subGroup") $ coverage'Grouping_subGroup x
            , maybe [] (schemaTypeToXML "subGroupDisplay") $ coverage'Grouping_subGroupDisplay x
            , maybe [] (schemaTypeToXML "plan") $ coverage'Grouping_plan x
            , maybe [] (schemaTypeToXML "planDisplay") $ coverage'Grouping_planDisplay x
            , maybe [] (schemaTypeToXML "subPlan") $ coverage'Grouping_subPlan x
            , maybe [] (schemaTypeToXML "subPlanDisplay") $ coverage'Grouping_subPlanDisplay x
            , maybe [] (schemaTypeToXML "class") $ coverage'Grouping_class x
            , maybe [] (schemaTypeToXML "classDisplay") $ coverage'Grouping_classDisplay x
            , maybe [] (schemaTypeToXML "subClass") $ coverage'Grouping_subClass x
            , maybe [] (schemaTypeToXML "subClassDisplay") $ coverage'Grouping_subClassDisplay x
            ]
instance Extension Coverage'Grouping BackboneElement where
    supertype (Coverage'Grouping a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension Coverage'Grouping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Coverage'Grouping -> BackboneElement)
              
 
-- | The formal description of a single piece of information 
--   that can be gathered and reported.
elementDataElement :: XMLParser DataElement
elementDataElement = parseSchemaType "DataElement"
elementToXMLDataElement :: DataElement -> [Content ()]
elementToXMLDataElement = schemaTypeToXML "DataElement"
 
data DataElement = DataElement
        { dataElement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , dataElement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , dataElement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , dataElement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , dataElement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , dataElement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , dataElement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataElement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , dataElement_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this data element 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this data element 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the data element. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , dataElement_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this data 
          --   element when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , dataElement_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   data element when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the data element author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , dataElement_status :: PublicationStatus
          -- ^ The status of this data element. Enables tracking the 
          --   life-cycle of the content.
        , dataElement_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this data element is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , dataElement_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the data element was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the data element changes.
        , dataElement_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the data element.
        , dataElement_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the data element. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , dataElement_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the data 
          --   element.
        , dataElement_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , dataElement_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   data element instances.
        , dataElement_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the data element is 
          --   intended to be used.
        , dataElement_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the data element and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the data element.
        , dataElement_stringency :: Maybe DataElementStringency
          -- ^ Identifies how precise the data element is in its 
          --   definition.
        , dataElement_mapping :: [DataElement'Mapping]
          -- ^ Identifies a specification (other than a terminology) that 
          --   the elements which make up the DataElement have some 
          --   correspondence with.
        , dataElement_element :: [ElementDefinition]
          -- ^ Defines the structure, type, allowed values and other 
          --   constraining characteristics of the data element.
        }
        deriving (Eq,Show)
instance SchemaType DataElement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DataElement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "stringency")
            `apply` many (parseSchemaType "mapping")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@DataElement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ dataElement_id x
            , maybe [] (schemaTypeToXML "meta") $ dataElement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ dataElement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ dataElement_language x
            , maybe [] (schemaTypeToXML "text") $ dataElement_text x
            , concatMap (schemaTypeToXML "contained") $ dataElement_contained x
            , concatMap (schemaTypeToXML "extension") $ dataElement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ dataElement_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ dataElement_url x
            , concatMap (schemaTypeToXML "identifier") $ dataElement_identifier x
            , maybe [] (schemaTypeToXML "version") $ dataElement_version x
            , schemaTypeToXML "status" $ dataElement_status x
            , maybe [] (schemaTypeToXML "experimental") $ dataElement_experimental x
            , maybe [] (schemaTypeToXML "date") $ dataElement_date x
            , maybe [] (schemaTypeToXML "publisher") $ dataElement_publisher x
            , maybe [] (schemaTypeToXML "name") $ dataElement_name x
            , maybe [] (schemaTypeToXML "title") $ dataElement_title x
            , concatMap (schemaTypeToXML "contact") $ dataElement_contact x
            , concatMap (schemaTypeToXML "useContext") $ dataElement_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ dataElement_jurisdiction x
            , maybe [] (schemaTypeToXML "copyright") $ dataElement_copyright x
            , maybe [] (schemaTypeToXML "stringency") $ dataElement_stringency x
            , concatMap (schemaTypeToXML "mapping") $ dataElement_mapping x
            , concatMap (schemaTypeToXML "element") $ dataElement_element x
            ]
instance Extension DataElement DomainResource where
    supertype (DataElement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DataElement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DataElement -> DomainResource)
              
 
-- | The formal description of a single piece of information 
--   that can be gathered and reported.
data DataElement'Mapping = DataElement'Mapping
        { dataElement'Mapping_id :: Maybe String'primitive
        , dataElement'Mapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataElement'Mapping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , dataElement'Mapping_identity :: Id
          -- ^ An internal id that is used to identify this mapping set 
          --   when specific mappings are made on a per-element basis.
        , dataElement'Mapping_uri :: Maybe Uri
          -- ^ An absolute URI that identifies the specification that this 
          --   mapping is expressed to.
        , dataElement'Mapping_name :: Maybe Xsd.XsdString
          -- ^ A name for the specification that is being mapped to.
        , dataElement'Mapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments about this mapping, including version notes, 
          --   issues, scope limitations, and other important notes for 
          --   usage.
        }
        deriving (Eq,Show)
instance SchemaType DataElement'Mapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataElement'Mapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@DataElement'Mapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataElement'Mapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataElement'Mapping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ dataElement'Mapping_modifierExtension x
            , schemaTypeToXML "identity" $ dataElement'Mapping_identity x
            , maybe [] (schemaTypeToXML "uri") $ dataElement'Mapping_uri x
            , maybe [] (schemaTypeToXML "name") $ dataElement'Mapping_name x
            , maybe [] (schemaTypeToXML "comment") $ dataElement'Mapping_comment x
            ]
instance Extension DataElement'Mapping BackboneElement where
    supertype (DataElement'Mapping a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension DataElement'Mapping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DataElement'Mapping -> BackboneElement)
              
 
data DataElementStringency'list
    = DataElementStringency'list_Comparable
      -- ^ Comparable
    | DataElementStringency'list_Fully'specified
      -- ^ Fully Specified
    | DataElementStringency'list_Equivalent
      -- ^ Equivalent
    | DataElementStringency'list_Convertable
      -- ^ Convertable
    | DataElementStringency'list_Scaleable
      -- ^ Scaleable
    | DataElementStringency'list_Flexible
      -- ^ Flexible
    deriving (Eq,Show,Enum)
instance SchemaType DataElementStringency'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DataElementStringency'list where
    acceptingParser =  do literal "comparable"; return DataElementStringency'list_Comparable
                      `onFail` do literal "fully-specified"; return DataElementStringency'list_Fully'specified
                      `onFail` do literal "equivalent"; return DataElementStringency'list_Equivalent
                      `onFail` do literal "convertable"; return DataElementStringency'list_Convertable
                      `onFail` do literal "scaleable"; return DataElementStringency'list_Scaleable
                      `onFail` do literal "flexible"; return DataElementStringency'list_Flexible
                      
    simpleTypeText DataElementStringency'list_Comparable = "comparable"
    simpleTypeText DataElementStringency'list_Fully'specified = "fully-specified"
    simpleTypeText DataElementStringency'list_Equivalent = "equivalent"
    simpleTypeText DataElementStringency'list_Convertable = "convertable"
    simpleTypeText DataElementStringency'list_Scaleable = "scaleable"
    simpleTypeText DataElementStringency'list_Flexible = "flexible"
 
data DataElementStringency = DataElementStringency
        { dataElementStringency_id :: Maybe String'primitive
        , dataElementStringency_value :: Maybe DataElementStringency'list
        , dataElementStringency_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DataElementStringency where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DataElementStringency a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DataElementStringency{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataElementStringency_id x
                       , maybe [] (toXMLAttribute "value") $ dataElementStringency_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataElementStringency_extension x
            ]
instance Extension DataElementStringency Element where
    supertype (DataElementStringency a0 a1 e0) =
               Element a0 e0
 
-- | Indicates an actual or potential clinical issue with or 
--   between one or more active or proposed clinical actions for 
--   a patient; e.g. Drug-drug interaction, Ineffective 
--   treatment frequency, Procedure-condition conflict, etc.
elementDetectedIssue :: XMLParser DetectedIssue
elementDetectedIssue = parseSchemaType "DetectedIssue"
elementToXMLDetectedIssue :: DetectedIssue -> [Content ()]
elementToXMLDetectedIssue = schemaTypeToXML "DetectedIssue"
 
data DetectedIssue = DetectedIssue
        { detectedIssue_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , detectedIssue_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , detectedIssue_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , detectedIssue_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , detectedIssue_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , detectedIssue_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , detectedIssue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , detectedIssue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , detectedIssue_identifier :: Maybe Identifier
          -- ^ Business identifier associated with the detected issue 
          --   record.
        , detectedIssue_status :: ObservationStatus
          -- ^ Indicates the status of the detected issue.
        , detectedIssue_category :: Maybe CodeableConcept
          -- ^ Identifies the general type of issue identified.
        , detectedIssue_severity :: Maybe DetectedIssueSeverity
          -- ^ Indicates the degree of importance associated with the 
          --   identified issue based on the potential impact on the 
          --   patient.
        , detectedIssue_patient :: Maybe Reference
          -- ^ Indicates the patient whose record the detected issue is 
          --   associated with.
        , detectedIssue_date :: Maybe DateTime
          -- ^ The date or date-time when the detected issue was initially 
          --   identified.
        , detectedIssue_author :: Maybe Reference
          -- ^ Individual or device responsible for the issue being 
          --   raised. For example, a decision support application or a 
          --   pharmacist conducting a medication review.
        , detectedIssue_implicated :: [Reference]
          -- ^ Indicates the resource representing the current activity or 
          --   proposed activity that is potentially problematic.
        , detectedIssue_detail :: Maybe Xsd.XsdString
          -- ^ A textual explanation of the detected issue.
        , detectedIssue_reference :: Maybe Uri
          -- ^ The literature, knowledge-base or similar reference that 
          --   describes the propensity for the detected issue identified.
        , detectedIssue_mitigation :: [DetectedIssue'Mitigation]
          -- ^ Indicates an action that has been taken or is committed to 
          --   to reduce or eliminate the likelihood of the risk 
          --   identified by the detected issue from manifesting. Can also 
          --   reflect an observation of known mitigating factors that may 
          --   reduce/eliminate the need for any action.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DetectedIssue
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "author")
            `apply` many (parseSchemaType "implicated")
            `apply` optional (parseSchemaType "detail")
            `apply` optional (parseSchemaType "reference")
            `apply` many (parseSchemaType "mitigation")
    schemaTypeToXML s x@DetectedIssue{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ detectedIssue_id x
            , maybe [] (schemaTypeToXML "meta") $ detectedIssue_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ detectedIssue_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ detectedIssue_language x
            , maybe [] (schemaTypeToXML "text") $ detectedIssue_text x
            , concatMap (schemaTypeToXML "contained") $ detectedIssue_contained x
            , concatMap (schemaTypeToXML "extension") $ detectedIssue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ detectedIssue_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ detectedIssue_identifier x
            , schemaTypeToXML "status" $ detectedIssue_status x
            , maybe [] (schemaTypeToXML "category") $ detectedIssue_category x
            , maybe [] (schemaTypeToXML "severity") $ detectedIssue_severity x
            , maybe [] (schemaTypeToXML "patient") $ detectedIssue_patient x
            , maybe [] (schemaTypeToXML "date") $ detectedIssue_date x
            , maybe [] (schemaTypeToXML "author") $ detectedIssue_author x
            , concatMap (schemaTypeToXML "implicated") $ detectedIssue_implicated x
            , maybe [] (schemaTypeToXML "detail") $ detectedIssue_detail x
            , maybe [] (schemaTypeToXML "reference") $ detectedIssue_reference x
            , concatMap (schemaTypeToXML "mitigation") $ detectedIssue_mitigation x
            ]
instance Extension DetectedIssue DomainResource where
    supertype (DetectedIssue e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DetectedIssue Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DetectedIssue -> DomainResource)
              
 
-- | Indicates an actual or potential clinical issue with or 
--   between one or more active or proposed clinical actions for 
--   a patient; e.g. Drug-drug interaction, Ineffective 
--   treatment frequency, Procedure-condition conflict, etc.
data DetectedIssue'Mitigation = DetectedIssue'Mitigation
        { detectedIssue'Mitigation_id :: Maybe String'primitive
        , detectedIssue'Mitigation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , detectedIssue'Mitigation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , detectedIssue'Mitigation_action :: CodeableConcept
          -- ^ Describes the action that was taken or the observation that 
          --   was made that reduces/eliminates the risk associated with 
          --   the identified issue.
        , detectedIssue'Mitigation_date :: Maybe DateTime
          -- ^ Indicates when the mitigating action was documented.
        , detectedIssue'Mitigation_author :: Maybe Reference
          -- ^ Identifies the practitioner who determined the mitigation 
          --   and takes responsibility for the mitigation step occurring.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssue'Mitigation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DetectedIssue'Mitigation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "action"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@DetectedIssue'Mitigation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ detectedIssue'Mitigation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ detectedIssue'Mitigation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ detectedIssue'Mitigation_modifierExtension x
            , schemaTypeToXML "action" $ detectedIssue'Mitigation_action x
            , maybe [] (schemaTypeToXML "date") $ detectedIssue'Mitigation_date x
            , maybe [] (schemaTypeToXML "author") $ detectedIssue'Mitigation_author x
            ]
instance Extension DetectedIssue'Mitigation BackboneElement where
    supertype (DetectedIssue'Mitigation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DetectedIssue'Mitigation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DetectedIssue'Mitigation -> BackboneElement)
              
 
data ObservationStatus'list
    = ObservationStatus'list_Registered
      -- ^ Registered
    | ObservationStatus'list_Preliminary
      -- ^ Preliminary
    | ObservationStatus'list_Final
      -- ^ Final
    | ObservationStatus'list_Amended
      -- ^ Amended
    | ObservationStatus'list_Corrected
      -- ^ Corrected
    | ObservationStatus'list_Cancelled
      -- ^ Cancelled
    | ObservationStatus'list_Entered'in'error
      -- ^ Entered in Error
    | ObservationStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ObservationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ObservationStatus'list where
    acceptingParser =  do literal "registered"; return ObservationStatus'list_Registered
                      `onFail` do literal "preliminary"; return ObservationStatus'list_Preliminary
                      `onFail` do literal "final"; return ObservationStatus'list_Final
                      `onFail` do literal "amended"; return ObservationStatus'list_Amended
                      `onFail` do literal "corrected"; return ObservationStatus'list_Corrected
                      `onFail` do literal "cancelled"; return ObservationStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return ObservationStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return ObservationStatus'list_Unknown
                      
    simpleTypeText ObservationStatus'list_Registered = "registered"
    simpleTypeText ObservationStatus'list_Preliminary = "preliminary"
    simpleTypeText ObservationStatus'list_Final = "final"
    simpleTypeText ObservationStatus'list_Amended = "amended"
    simpleTypeText ObservationStatus'list_Corrected = "corrected"
    simpleTypeText ObservationStatus'list_Cancelled = "cancelled"
    simpleTypeText ObservationStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText ObservationStatus'list_Unknown = "unknown"
 
data ObservationStatus = ObservationStatus
        { observationStatus_id :: Maybe String'primitive
        , observationStatus_value :: Maybe ObservationStatus'list
        , observationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ObservationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ObservationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ObservationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ observationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationStatus_extension x
            ]
instance Extension ObservationStatus Element where
    supertype (ObservationStatus a0 a1 e0) =
               Element a0 e0
 
data DetectedIssueSeverity'list
    = DetectedIssueSeverity'list_High
      -- ^ High
    | DetectedIssueSeverity'list_Moderate
      -- ^ Moderate
    | DetectedIssueSeverity'list_Low
      -- ^ Low
    deriving (Eq,Show,Enum)
instance SchemaType DetectedIssueSeverity'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DetectedIssueSeverity'list where
    acceptingParser =  do literal "high"; return DetectedIssueSeverity'list_High
                      `onFail` do literal "moderate"; return DetectedIssueSeverity'list_Moderate
                      `onFail` do literal "low"; return DetectedIssueSeverity'list_Low
                      
    simpleTypeText DetectedIssueSeverity'list_High = "high"
    simpleTypeText DetectedIssueSeverity'list_Moderate = "moderate"
    simpleTypeText DetectedIssueSeverity'list_Low = "low"
 
data DetectedIssueSeverity = DetectedIssueSeverity
        { detectedIssueSeverity_id :: Maybe String'primitive
        , detectedIssueSeverity_value :: Maybe DetectedIssueSeverity'list
        , detectedIssueSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssueSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DetectedIssueSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DetectedIssueSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ detectedIssueSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ detectedIssueSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ detectedIssueSeverity_extension x
            ]
instance Extension DetectedIssueSeverity Element where
    supertype (DetectedIssueSeverity a0 a1 e0) =
               Element a0 e0
 
-- | This resource identifies an instance or a type of a 
--   manufactured item that is used in the provision of 
--   healthcare without being substantially changed through that 
--   activity. The device may be a medical or non-medical 
--   device. Medical devices include durable (reusable) medical 
--   equipment, implantable devices, as well as disposable 
--   equipment used for diagnostic, treatment, and research for 
--   healthcare and public health. Non-medical devices may 
--   include items such as a machine, cellphone, computer, 
--   application, etc.
elementDevice :: XMLParser Device
elementDevice = parseSchemaType "Device"
elementToXMLDevice :: Device -> [Content ()]
elementToXMLDevice = schemaTypeToXML "Device"
 
data Device = Device
        { device_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , device_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , device_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , device_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , device_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , device_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , device_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , device_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , device_identifier :: [Identifier]
          -- ^ Unique instance identifiers assigned to a device by 
          --   manufacturers other organizations or owners.
        , device_udi :: Maybe Device'Udi
          -- ^ [Unique device identifier (UDI)](device.html#5.11.3.2.2) 
          --   assigned to device label or package.
        , device_status :: Maybe FHIRDeviceStatus
          -- ^ Status of the Device availability.
        , device_type :: Maybe CodeableConcept
          -- ^ Code or identifier to identify a kind of device.
        , device_lotNumber :: Maybe Xsd.XsdString
          -- ^ Lot number assigned by the manufacturer.
        , device_manufacturer :: Maybe Xsd.XsdString
          -- ^ A name of the manufacturer.
        , device_manufactureDate :: Maybe DateTime
          -- ^ The date and time when the device was manufactured.
        , device_expirationDate :: Maybe DateTime
          -- ^ The date and time beyond which this device is no longer 
          --   valid or should not be used (if applicable).
        , device_model :: Maybe Xsd.XsdString
          -- ^ The &quot;model&quot; is an identifier assigned by the 
          --   manufacturer to identify the product by its type. This 
          --   number is shared by the all devices sold as the same type.
        , device_version :: Maybe Xsd.XsdString
          -- ^ The version of the device, if the device has multiple 
          --   releases under the same model, or if the device is software 
          --   or carries firmware.
        , device_patient :: Maybe Reference
          -- ^ Patient information, If the device is affixed to a person.
        , device_owner :: Maybe Reference
          -- ^ An organization that is responsible for the provision and 
          --   ongoing maintenance of the device.
        , device_contact :: [ContactPoint]
          -- ^ Contact details for an organization or a particular human 
          --   that is responsible for the device.
        , device_location :: Maybe Reference
          -- ^ The place where the device can be found.
        , device_url :: Maybe Uri
          -- ^ A network address on which the device may be contacted 
          --   directly.
        , device_note :: [Annotation]
          -- ^ Descriptive information, usage information or implantation 
          --   information that is not captured in an existing element.
        , device_safety :: [CodeableConcept]
          -- ^ Provides additional safety characteristics about a medical 
          --   device. For example devices containing latex.
        }
        deriving (Eq,Show)
instance SchemaType Device where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Device
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "udi")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "manufactureDate")
            `apply` optional (parseSchemaType "expirationDate")
            `apply` optional (parseSchemaType "model")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "owner")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "safety")
    schemaTypeToXML s x@Device{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ device_id x
            , maybe [] (schemaTypeToXML "meta") $ device_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ device_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ device_language x
            , maybe [] (schemaTypeToXML "text") $ device_text x
            , concatMap (schemaTypeToXML "contained") $ device_contained x
            , concatMap (schemaTypeToXML "extension") $ device_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ device_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ device_identifier x
            , maybe [] (schemaTypeToXML "udi") $ device_udi x
            , maybe [] (schemaTypeToXML "status") $ device_status x
            , maybe [] (schemaTypeToXML "type") $ device_type x
            , maybe [] (schemaTypeToXML "lotNumber") $ device_lotNumber x
            , maybe [] (schemaTypeToXML "manufacturer") $ device_manufacturer x
            , maybe [] (schemaTypeToXML "manufactureDate") $ device_manufactureDate x
            , maybe [] (schemaTypeToXML "expirationDate") $ device_expirationDate x
            , maybe [] (schemaTypeToXML "model") $ device_model x
            , maybe [] (schemaTypeToXML "version") $ device_version x
            , maybe [] (schemaTypeToXML "patient") $ device_patient x
            , maybe [] (schemaTypeToXML "owner") $ device_owner x
            , concatMap (schemaTypeToXML "contact") $ device_contact x
            , maybe [] (schemaTypeToXML "location") $ device_location x
            , maybe [] (schemaTypeToXML "url") $ device_url x
            , concatMap (schemaTypeToXML "note") $ device_note x
            , concatMap (schemaTypeToXML "safety") $ device_safety x
            ]
instance Extension Device DomainResource where
    supertype (Device e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Device Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Device -> DomainResource)
              
 
-- | This resource identifies an instance or a type of a 
--   manufactured item that is used in the provision of 
--   healthcare without being substantially changed through that 
--   activity. The device may be a medical or non-medical 
--   device. Medical devices include durable (reusable) medical 
--   equipment, implantable devices, as well as disposable 
--   equipment used for diagnostic, treatment, and research for 
--   healthcare and public health. Non-medical devices may 
--   include items such as a machine, cellphone, computer, 
--   application, etc.
data Device'Udi = Device'Udi
        { device'Udi_id :: Maybe String'primitive
        , device'Udi_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , device'Udi_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , device'Udi_deviceIdentifier :: Maybe Xsd.XsdString
          -- ^ The device identifier (DI) is a mandatory, fixed portion of 
          --   a UDI that identifies the labeler and the specific version 
          --   or model of a device.
        , device'Udi_name :: Maybe Xsd.XsdString
          -- ^ Name of device as used in labeling or catalog.
        , device'Udi_jurisdiction :: Maybe Uri
          -- ^ The identity of the authoritative source for UDI generation 
          --   within a jurisdiction. All UDIs are globally unique within 
          --   a single namespace. with the appropriate repository uri as 
          --   the system. For example, UDIs of devices managed in the 
          --   U.S. by the FDA, the value is 
          --   http://hl7.org/fhir/NamingSystem/fda-udi.
        , device'Udi_carrierHRF :: Maybe Xsd.XsdString
          -- ^ The full UDI carrier as the human readable form (HRF) 
          --   representation of the barcode string as printed on the 
          --   packaging of the device.
        , device'Udi_carrierAIDC :: Maybe Base64Binary
          -- ^ The full UDI carrier of the Automatic Identification and 
          --   Data Capture (AIDC) technology representation of the 
          --   barcode string as printed on the packaging of the device - 
          --   E.g a barcode or RFID. Because of limitations on character 
          --   sets in XML and the need to round-trip JSON data through 
          --   XML, AIDC Formats *SHALL* be base64 encoded.
        , device'Udi_issuer :: Maybe Uri
          -- ^ Organization that is charged with issuing UDIs for devices. 
          --   For example, the US FDA issuers include : 1) GS1: 
          --   http://hl7.org/fhir/NamingSystem/gs1-di, 2) HIBCC: 
          --   http://hl7.org/fhir/NamingSystem/hibcc-dI, 3) ICCBBA for 
          --   blood containers: 
          --   http://hl7.org/fhir/NamingSystem/iccbba-blood-di, 4) ICCBA 
          --   for other devices: 
          --   http://hl7.org/fhir/NamingSystem/iccbba-other-di.
        , device'Udi_entryType :: Maybe UDIEntryType
          -- ^ A coded entry to indicate how the data was entered.
        }
        deriving (Eq,Show)
instance SchemaType Device'Udi where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Device'Udi a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "deviceIdentifier")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "carrierHRF")
            `apply` optional (parseSchemaType "carrierAIDC")
            `apply` optional (parseSchemaType "issuer")
            `apply` optional (parseSchemaType "entryType")
    schemaTypeToXML s x@Device'Udi{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ device'Udi_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ device'Udi_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ device'Udi_modifierExtension x
            , maybe [] (schemaTypeToXML "deviceIdentifier") $ device'Udi_deviceIdentifier x
            , maybe [] (schemaTypeToXML "name") $ device'Udi_name x
            , maybe [] (schemaTypeToXML "jurisdiction") $ device'Udi_jurisdiction x
            , maybe [] (schemaTypeToXML "carrierHRF") $ device'Udi_carrierHRF x
            , maybe [] (schemaTypeToXML "carrierAIDC") $ device'Udi_carrierAIDC x
            , maybe [] (schemaTypeToXML "issuer") $ device'Udi_issuer x
            , maybe [] (schemaTypeToXML "entryType") $ device'Udi_entryType x
            ]
instance Extension Device'Udi BackboneElement where
    supertype (Device'Udi a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension Device'Udi Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Device'Udi -> BackboneElement)
              
 
data FHIRDeviceStatus'list
    = FHIRDeviceStatus'list_Active
      -- ^ Active
    | FHIRDeviceStatus'list_Inactive
      -- ^ Inactive
    | FHIRDeviceStatus'list_Entered'in'error
      -- ^ Entered in Error
    | FHIRDeviceStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType FHIRDeviceStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRDeviceStatus'list where
    acceptingParser =  do literal "active"; return FHIRDeviceStatus'list_Active
                      `onFail` do literal "inactive"; return FHIRDeviceStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return FHIRDeviceStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return FHIRDeviceStatus'list_Unknown
                      
    simpleTypeText FHIRDeviceStatus'list_Active = "active"
    simpleTypeText FHIRDeviceStatus'list_Inactive = "inactive"
    simpleTypeText FHIRDeviceStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText FHIRDeviceStatus'list_Unknown = "unknown"
 
data FHIRDeviceStatus = FHIRDeviceStatus
        { fHIRDeviceStatus_id :: Maybe String'primitive
        , fHIRDeviceStatus_value :: Maybe FHIRDeviceStatus'list
        , fHIRDeviceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRDeviceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRDeviceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRDeviceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRDeviceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRDeviceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRDeviceStatus_extension x
            ]
instance Extension FHIRDeviceStatus Element where
    supertype (FHIRDeviceStatus a0 a1 e0) =
               Element a0 e0
 
data UDIEntryType'list
    = UDIEntryType'list_Barcode
      -- ^ BarCode
    | UDIEntryType'list_Rfid
      -- ^ RFID
    | UDIEntryType'list_Manual
      -- ^ Manual
    | UDIEntryType'list_Card
      -- ^ Card
    | UDIEntryType'list_Self'reported
      -- ^ Self Reported
    | UDIEntryType'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType UDIEntryType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UDIEntryType'list where
    acceptingParser =  do literal "barcode"; return UDIEntryType'list_Barcode
                      `onFail` do literal "rfid"; return UDIEntryType'list_Rfid
                      `onFail` do literal "manual"; return UDIEntryType'list_Manual
                      `onFail` do literal "card"; return UDIEntryType'list_Card
                      `onFail` do literal "self-reported"; return UDIEntryType'list_Self'reported
                      `onFail` do literal "unknown"; return UDIEntryType'list_Unknown
                      
    simpleTypeText UDIEntryType'list_Barcode = "barcode"
    simpleTypeText UDIEntryType'list_Rfid = "rfid"
    simpleTypeText UDIEntryType'list_Manual = "manual"
    simpleTypeText UDIEntryType'list_Card = "card"
    simpleTypeText UDIEntryType'list_Self'reported = "self-reported"
    simpleTypeText UDIEntryType'list_Unknown = "unknown"
 
data UDIEntryType = UDIEntryType
        { uDIEntryType_id :: Maybe String'primitive
        , uDIEntryType_value :: Maybe UDIEntryType'list
        , uDIEntryType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UDIEntryType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UDIEntryType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UDIEntryType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uDIEntryType_id x
                       , maybe [] (toXMLAttribute "value") $ uDIEntryType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uDIEntryType_extension x
            ]
instance Extension UDIEntryType Element where
    supertype (UDIEntryType a0 a1 e0) =
               Element a0 e0
 
-- | The characteristics, operational status and capabilities of 
--   a medical-related component of a medical device.
elementDeviceComponent :: XMLParser DeviceComponent
elementDeviceComponent = parseSchemaType "DeviceComponent"
elementToXMLDeviceComponent :: DeviceComponent -> [Content ()]
elementToXMLDeviceComponent = schemaTypeToXML "DeviceComponent"
 
data DeviceComponent = DeviceComponent
        { deviceComponent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceComponent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceComponent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceComponent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceComponent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceComponent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceComponent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceComponent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceComponent_identifier :: Identifier
          -- ^ The locally assigned unique identification by the software. 
          --   For example: handle ID.
        , deviceComponent_type :: CodeableConcept
          -- ^ The component type as defined in the object-oriented or 
          --   metric nomenclature partition.
        , deviceComponent_lastSystemChange :: Maybe Instant
          -- ^ The timestamp for the most recent system change which 
          --   includes device configuration or setting change.
        , deviceComponent_source :: Maybe Reference
          -- ^ The link to the source Device that contains administrative 
          --   device information such as manufacture, serial number, etc.
        , deviceComponent_parent :: Maybe Reference
          -- ^ The link to the parent resource. For example: Channel is 
          --   linked to its VMD parent.
        , deviceComponent_operationalStatus :: [CodeableConcept]
          -- ^ The current operational status of the device. For example: 
          --   On, Off, Standby, etc.
        , deviceComponent_parameterGroup :: Maybe CodeableConcept
          -- ^ The parameter group supported by the current device 
          --   component that is based on some nomenclature, e.g. 
          --   cardiovascular.
        , deviceComponent_measurementPrinciple :: Maybe MeasmntPrinciple
          -- ^ The physical principle of the measurement. For example: 
          --   thermal, chemical, acoustical, etc.
        , deviceComponent_productionSpecification :: [DeviceComponent'ProductionSpecification]
          -- ^ The production specification such as component revision, 
          --   serial number, etc.
        , deviceComponent_languageCode :: Maybe CodeableConcept
          -- ^ The language code for the human-readable text string 
          --   produced by the device. This language code will follow the 
          --   IETF language tag. Example: en-US.
        }
        deriving (Eq,Show)
instance SchemaType DeviceComponent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceComponent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "lastSystemChange")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "parent")
            `apply` many (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "parameterGroup")
            `apply` optional (parseSchemaType "measurementPrinciple")
            `apply` many (parseSchemaType "productionSpecification")
            `apply` optional (parseSchemaType "languageCode")
    schemaTypeToXML s x@DeviceComponent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceComponent_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceComponent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceComponent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceComponent_language x
            , maybe [] (schemaTypeToXML "text") $ deviceComponent_text x
            , concatMap (schemaTypeToXML "contained") $ deviceComponent_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceComponent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceComponent_modifierExtension x
            , schemaTypeToXML "identifier" $ deviceComponent_identifier x
            , schemaTypeToXML "type" $ deviceComponent_type x
            , maybe [] (schemaTypeToXML "lastSystemChange") $ deviceComponent_lastSystemChange x
            , maybe [] (schemaTypeToXML "source") $ deviceComponent_source x
            , maybe [] (schemaTypeToXML "parent") $ deviceComponent_parent x
            , concatMap (schemaTypeToXML "operationalStatus") $ deviceComponent_operationalStatus x
            , maybe [] (schemaTypeToXML "parameterGroup") $ deviceComponent_parameterGroup x
            , maybe [] (schemaTypeToXML "measurementPrinciple") $ deviceComponent_measurementPrinciple x
            , concatMap (schemaTypeToXML "productionSpecification") $ deviceComponent_productionSpecification x
            , maybe [] (schemaTypeToXML "languageCode") $ deviceComponent_languageCode x
            ]
instance Extension DeviceComponent DomainResource where
    supertype (DeviceComponent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceComponent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceComponent -> DomainResource)
              
 
-- | The characteristics, operational status and capabilities of 
--   a medical-related component of a medical device.
data DeviceComponent'ProductionSpecification = DeviceComponent'ProductionSpecification
        { deviceComponent'ProductionSpecification_id :: Maybe String'primitive
        , deviceComponent'ProductionSpecification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceComponent'ProductionSpecification_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceComponent'ProductionSpecification_specType :: Maybe CodeableConcept
          -- ^ The specification type, such as, serial number, part 
          --   number, hardware revision, software revision, etc.
        , deviceComponent'ProductionSpecification_componentId :: Maybe Identifier
          -- ^ The internal component unique identification. This is a 
          --   provision for manufacture specific standard components 
          --   using a private OID. 11073-10101 has a partition for 
          --   private OID semantic that the manufacturer can make use of.
        , deviceComponent'ProductionSpecification_productionSpec :: Maybe Xsd.XsdString
          -- ^ The printable string defining the component.
        }
        deriving (Eq,Show)
instance SchemaType DeviceComponent'ProductionSpecification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceComponent'ProductionSpecification a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "specType")
            `apply` optional (parseSchemaType "componentId")
            `apply` optional (parseSchemaType "productionSpec")
    schemaTypeToXML s x@DeviceComponent'ProductionSpecification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceComponent'ProductionSpecification_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceComponent'ProductionSpecification_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceComponent'ProductionSpecification_modifierExtension x
            , maybe [] (schemaTypeToXML "specType") $ deviceComponent'ProductionSpecification_specType x
            , maybe [] (schemaTypeToXML "componentId") $ deviceComponent'ProductionSpecification_componentId x
            , maybe [] (schemaTypeToXML "productionSpec") $ deviceComponent'ProductionSpecification_productionSpec x
            ]
instance Extension DeviceComponent'ProductionSpecification BackboneElement where
    supertype (DeviceComponent'ProductionSpecification a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DeviceComponent'ProductionSpecification Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceComponent'ProductionSpecification -> BackboneElement)
              
 
data MeasmntPrinciple'list
    = MeasmntPrinciple'list_Other
      -- ^ MSP Other
    | MeasmntPrinciple'list_Chemical
      -- ^ MSP Chemical
    | MeasmntPrinciple'list_Electrical
      -- ^ MSP Electrical
    | MeasmntPrinciple'list_Impedance
      -- ^ MSP Impedance
    | MeasmntPrinciple'list_Nuclear
      -- ^ MSP Nuclear
    | MeasmntPrinciple'list_Optical
      -- ^ MSP Optical
    | MeasmntPrinciple'list_Thermal
      -- ^ MSP Thermal
    | MeasmntPrinciple'list_Biological
      -- ^ MSP Biological
    | MeasmntPrinciple'list_Mechanical
      -- ^ MSP Mechanical
    | MeasmntPrinciple'list_Acoustical
      -- ^ MSP Acoustical
    | MeasmntPrinciple'list_Manual
      -- ^ MSP Manual
    deriving (Eq,Show,Enum)
instance SchemaType MeasmntPrinciple'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasmntPrinciple'list where
    acceptingParser =  do literal "other"; return MeasmntPrinciple'list_Other
                      `onFail` do literal "chemical"; return MeasmntPrinciple'list_Chemical
                      `onFail` do literal "electrical"; return MeasmntPrinciple'list_Electrical
                      `onFail` do literal "impedance"; return MeasmntPrinciple'list_Impedance
                      `onFail` do literal "nuclear"; return MeasmntPrinciple'list_Nuclear
                      `onFail` do literal "optical"; return MeasmntPrinciple'list_Optical
                      `onFail` do literal "thermal"; return MeasmntPrinciple'list_Thermal
                      `onFail` do literal "biological"; return MeasmntPrinciple'list_Biological
                      `onFail` do literal "mechanical"; return MeasmntPrinciple'list_Mechanical
                      `onFail` do literal "acoustical"; return MeasmntPrinciple'list_Acoustical
                      `onFail` do literal "manual"; return MeasmntPrinciple'list_Manual
                      
    simpleTypeText MeasmntPrinciple'list_Other = "other"
    simpleTypeText MeasmntPrinciple'list_Chemical = "chemical"
    simpleTypeText MeasmntPrinciple'list_Electrical = "electrical"
    simpleTypeText MeasmntPrinciple'list_Impedance = "impedance"
    simpleTypeText MeasmntPrinciple'list_Nuclear = "nuclear"
    simpleTypeText MeasmntPrinciple'list_Optical = "optical"
    simpleTypeText MeasmntPrinciple'list_Thermal = "thermal"
    simpleTypeText MeasmntPrinciple'list_Biological = "biological"
    simpleTypeText MeasmntPrinciple'list_Mechanical = "mechanical"
    simpleTypeText MeasmntPrinciple'list_Acoustical = "acoustical"
    simpleTypeText MeasmntPrinciple'list_Manual = "manual"
 
data MeasmntPrinciple = MeasmntPrinciple
        { measmntPrinciple_id :: Maybe String'primitive
        , measmntPrinciple_value :: Maybe MeasmntPrinciple'list
        , measmntPrinciple_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasmntPrinciple where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasmntPrinciple a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasmntPrinciple{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measmntPrinciple_id x
                       , maybe [] (toXMLAttribute "value") $ measmntPrinciple_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measmntPrinciple_extension x
            ]
instance Extension MeasmntPrinciple Element where
    supertype (MeasmntPrinciple a0 a1 e0) =
               Element a0 e0
 
-- | Describes a measurement, calculation or setting capability 
--   of a medical device.
elementDeviceMetric :: XMLParser DeviceMetric
elementDeviceMetric = parseSchemaType "DeviceMetric"
elementToXMLDeviceMetric :: DeviceMetric -> [Content ()]
elementToXMLDeviceMetric = schemaTypeToXML "DeviceMetric"
 
data DeviceMetric = DeviceMetric
        { deviceMetric_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceMetric_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceMetric_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceMetric_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceMetric_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceMetric_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceMetric_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceMetric_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceMetric_identifier :: Identifier
          -- ^ Describes the unique identification of this metric that has 
          --   been assigned by the device or gateway software. For 
          --   example: handle ID. It should be noted that in order to 
          --   make the identifier unique, the system element of the 
          --   identifier should be set to the unique identifier of the 
          --   device.
        , deviceMetric_type :: CodeableConcept
          -- ^ Describes the type of the metric. For example: Heart Rate, 
          --   PEEP Setting, etc.
        , deviceMetric_unit :: Maybe CodeableConcept
          -- ^ Describes the unit that an observed value determined for 
          --   this metric will have. For example: Percent, Seconds, etc.
        , deviceMetric_source :: Maybe Reference
          -- ^ Describes the link to the Device that this DeviceMetric 
          --   belongs to and that contains administrative device 
          --   information such as manufacturer, serial number, etc.
        , deviceMetric_parent :: Maybe Reference
          -- ^ Describes the link to the DeviceComponent that this 
          --   DeviceMetric belongs to and that provide information about 
          --   the location of this DeviceMetric in the containment 
          --   structure of the parent Device. An example would be a 
          --   DeviceComponent that represents a Channel. This reference 
          --   can be used by a client application to distinguish 
          --   DeviceMetrics that have the same type, but should be 
          --   interpreted based on their containment location.
        , deviceMetric_operationalStatus :: Maybe DeviceMetricOperationalStatus
          -- ^ Indicates current operational state of the device. For 
          --   example: On, Off, Standby, etc.
        , deviceMetric_color :: Maybe DeviceMetricColor
          -- ^ Describes the color representation for the metric. This is 
          --   often used to aid clinicians to track and identify 
          --   parameter types by color. In practice, consider a Patient 
          --   Monitor that has ECG/HR and Pleth for example; the 
          --   parameters are displayed in different characteristic 
          --   colors, such as HR-blue, BP-green, and PR and SpO2- 
          --   magenta.
        , deviceMetric_category :: DeviceMetricCategory
          -- ^ Indicates the category of the observation generation 
          --   process. A DeviceMetric can be for example a setting, 
          --   measurement, or calculation.
        , deviceMetric_measurementPeriod :: Maybe Timing
          -- ^ Describes the measurement repetition time. This is not 
          --   necessarily the same as the update period. The measurement 
          --   repetition time can range from milliseconds up to hours. An 
          --   example for a measurement repetition time in the range of 
          --   milliseconds is the sampling rate of an ECG. An example for 
          --   a measurement repetition time in the range of hours is a 
          --   NIBP that is triggered automatically every hour. The update 
          --   period may be different than the measurement repetition 
          --   time, if the device does not update the published observed 
          --   value with the same frequency as it was measured.
        , deviceMetric_calibration :: [DeviceMetric'Calibration]
          -- ^ Describes the calibrations that have been performed or that 
          --   are required to be performed.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetric where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceMetric
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "parent")
            `apply` optional (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "color")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "measurementPeriod")
            `apply` many (parseSchemaType "calibration")
    schemaTypeToXML s x@DeviceMetric{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceMetric_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceMetric_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceMetric_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceMetric_language x
            , maybe [] (schemaTypeToXML "text") $ deviceMetric_text x
            , concatMap (schemaTypeToXML "contained") $ deviceMetric_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceMetric_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceMetric_modifierExtension x
            , schemaTypeToXML "identifier" $ deviceMetric_identifier x
            , schemaTypeToXML "type" $ deviceMetric_type x
            , maybe [] (schemaTypeToXML "unit") $ deviceMetric_unit x
            , maybe [] (schemaTypeToXML "source") $ deviceMetric_source x
            , maybe [] (schemaTypeToXML "parent") $ deviceMetric_parent x
            , maybe [] (schemaTypeToXML "operationalStatus") $ deviceMetric_operationalStatus x
            , maybe [] (schemaTypeToXML "color") $ deviceMetric_color x
            , schemaTypeToXML "category" $ deviceMetric_category x
            , maybe [] (schemaTypeToXML "measurementPeriod") $ deviceMetric_measurementPeriod x
            , concatMap (schemaTypeToXML "calibration") $ deviceMetric_calibration x
            ]
instance Extension DeviceMetric DomainResource where
    supertype (DeviceMetric e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceMetric Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceMetric -> DomainResource)
              
 
-- | Describes a measurement, calculation or setting capability 
--   of a medical device.
data DeviceMetric'Calibration = DeviceMetric'Calibration
        { deviceMetric'Calibration_id :: Maybe String'primitive
        , deviceMetric'Calibration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceMetric'Calibration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceMetric'Calibration_type :: Maybe DeviceMetricCalibrationType
          -- ^ Describes the type of the calibration method.
        , deviceMetric'Calibration_state :: Maybe DeviceMetricCalibrationState
          -- ^ Describes the state of the calibration.
        , deviceMetric'Calibration_time :: Maybe Instant
          -- ^ Describes the time last calibration has been performed.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetric'Calibration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceMetric'Calibration a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "state")
            `apply` optional (parseSchemaType "time")
    schemaTypeToXML s x@DeviceMetric'Calibration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetric'Calibration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetric'Calibration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceMetric'Calibration_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ deviceMetric'Calibration_type x
            , maybe [] (schemaTypeToXML "state") $ deviceMetric'Calibration_state x
            , maybe [] (schemaTypeToXML "time") $ deviceMetric'Calibration_time x
            ]
instance Extension DeviceMetric'Calibration BackboneElement where
    supertype (DeviceMetric'Calibration a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DeviceMetric'Calibration Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceMetric'Calibration -> BackboneElement)
              
 
data DeviceMetricCalibrationType'list
    = DeviceMetricCalibrationType'list_Unspecified
      -- ^ Unspecified
    | DeviceMetricCalibrationType'list_Offset
      -- ^ Offset
    | DeviceMetricCalibrationType'list_Gain
      -- ^ Gain
    | DeviceMetricCalibrationType'list_Two'point
      -- ^ Two Point
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCalibrationType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCalibrationType'list where
    acceptingParser =  do literal "unspecified"; return DeviceMetricCalibrationType'list_Unspecified
                      `onFail` do literal "offset"; return DeviceMetricCalibrationType'list_Offset
                      `onFail` do literal "gain"; return DeviceMetricCalibrationType'list_Gain
                      `onFail` do literal "two-point"; return DeviceMetricCalibrationType'list_Two'point
                      
    simpleTypeText DeviceMetricCalibrationType'list_Unspecified = "unspecified"
    simpleTypeText DeviceMetricCalibrationType'list_Offset = "offset"
    simpleTypeText DeviceMetricCalibrationType'list_Gain = "gain"
    simpleTypeText DeviceMetricCalibrationType'list_Two'point = "two-point"
 
data DeviceMetricCalibrationType = DeviceMetricCalibrationType
        { deviceMetricCalibrationType_id :: Maybe String'primitive
        , deviceMetricCalibrationType_value :: Maybe DeviceMetricCalibrationType'list
        , deviceMetricCalibrationType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCalibrationType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCalibrationType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCalibrationType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCalibrationType_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCalibrationType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCalibrationType_extension x
            ]
instance Extension DeviceMetricCalibrationType Element where
    supertype (DeviceMetricCalibrationType a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricColor'list
    = DeviceMetricColor'list_Black
      -- ^ Color Black
    | DeviceMetricColor'list_Red
      -- ^ Color Red
    | DeviceMetricColor'list_Green
      -- ^ Color Green
    | DeviceMetricColor'list_Yellow
      -- ^ Color Yellow
    | DeviceMetricColor'list_Blue
      -- ^ Color Blue
    | DeviceMetricColor'list_Magenta
      -- ^ Color Magenta
    | DeviceMetricColor'list_Cyan
      -- ^ Color Cyan
    | DeviceMetricColor'list_White
      -- ^ Color White
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricColor'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricColor'list where
    acceptingParser =  do literal "black"; return DeviceMetricColor'list_Black
                      `onFail` do literal "red"; return DeviceMetricColor'list_Red
                      `onFail` do literal "green"; return DeviceMetricColor'list_Green
                      `onFail` do literal "yellow"; return DeviceMetricColor'list_Yellow
                      `onFail` do literal "blue"; return DeviceMetricColor'list_Blue
                      `onFail` do literal "magenta"; return DeviceMetricColor'list_Magenta
                      `onFail` do literal "cyan"; return DeviceMetricColor'list_Cyan
                      `onFail` do literal "white"; return DeviceMetricColor'list_White
                      
    simpleTypeText DeviceMetricColor'list_Black = "black"
    simpleTypeText DeviceMetricColor'list_Red = "red"
    simpleTypeText DeviceMetricColor'list_Green = "green"
    simpleTypeText DeviceMetricColor'list_Yellow = "yellow"
    simpleTypeText DeviceMetricColor'list_Blue = "blue"
    simpleTypeText DeviceMetricColor'list_Magenta = "magenta"
    simpleTypeText DeviceMetricColor'list_Cyan = "cyan"
    simpleTypeText DeviceMetricColor'list_White = "white"
 
data DeviceMetricColor = DeviceMetricColor
        { deviceMetricColor_id :: Maybe String'primitive
        , deviceMetricColor_value :: Maybe DeviceMetricColor'list
        , deviceMetricColor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricColor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricColor a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricColor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricColor_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricColor_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricColor_extension x
            ]
instance Extension DeviceMetricColor Element where
    supertype (DeviceMetricColor a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricCalibrationState'list
    = DeviceMetricCalibrationState'list_Not'calibrated
      -- ^ Not Calibrated
    | DeviceMetricCalibrationState'list_Calibration'required
      -- ^ Calibration Required
    | DeviceMetricCalibrationState'list_Calibrated
      -- ^ Calibrated
    | DeviceMetricCalibrationState'list_Unspecified
      -- ^ Unspecified
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCalibrationState'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCalibrationState'list where
    acceptingParser =  do literal "not-calibrated"; return DeviceMetricCalibrationState'list_Not'calibrated
                      `onFail` do literal "calibration-required"; return DeviceMetricCalibrationState'list_Calibration'required
                      `onFail` do literal "calibrated"; return DeviceMetricCalibrationState'list_Calibrated
                      `onFail` do literal "unspecified"; return DeviceMetricCalibrationState'list_Unspecified
                      
    simpleTypeText DeviceMetricCalibrationState'list_Not'calibrated = "not-calibrated"
    simpleTypeText DeviceMetricCalibrationState'list_Calibration'required = "calibration-required"
    simpleTypeText DeviceMetricCalibrationState'list_Calibrated = "calibrated"
    simpleTypeText DeviceMetricCalibrationState'list_Unspecified = "unspecified"
 
data DeviceMetricCalibrationState = DeviceMetricCalibrationState
        { deviceMetricCalibrationState_id :: Maybe String'primitive
        , deviceMetricCalibrationState_value :: Maybe DeviceMetricCalibrationState'list
        , deviceMetricCalibrationState_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCalibrationState where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCalibrationState a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCalibrationState{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCalibrationState_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCalibrationState_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCalibrationState_extension x
            ]
instance Extension DeviceMetricCalibrationState Element where
    supertype (DeviceMetricCalibrationState a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricOperationalStatus'list
    = DeviceMetricOperationalStatus'list_On
      -- ^ On
    | DeviceMetricOperationalStatus'list_Off
      -- ^ Off
    | DeviceMetricOperationalStatus'list_Standby
      -- ^ Standby
    | DeviceMetricOperationalStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricOperationalStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricOperationalStatus'list where
    acceptingParser =  do literal "on"; return DeviceMetricOperationalStatus'list_On
                      `onFail` do literal "off"; return DeviceMetricOperationalStatus'list_Off
                      `onFail` do literal "standby"; return DeviceMetricOperationalStatus'list_Standby
                      `onFail` do literal "entered-in-error"; return DeviceMetricOperationalStatus'list_Entered'in'error
                      
    simpleTypeText DeviceMetricOperationalStatus'list_On = "on"
    simpleTypeText DeviceMetricOperationalStatus'list_Off = "off"
    simpleTypeText DeviceMetricOperationalStatus'list_Standby = "standby"
    simpleTypeText DeviceMetricOperationalStatus'list_Entered'in'error = "entered-in-error"
 
data DeviceMetricOperationalStatus = DeviceMetricOperationalStatus
        { deviceMetricOperationalStatus_id :: Maybe String'primitive
        , deviceMetricOperationalStatus_value :: Maybe DeviceMetricOperationalStatus'list
        , deviceMetricOperationalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricOperationalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricOperationalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricOperationalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricOperationalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricOperationalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricOperationalStatus_extension x
            ]
instance Extension DeviceMetricOperationalStatus Element where
    supertype (DeviceMetricOperationalStatus a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricCategory'list
    = DeviceMetricCategory'list_Measurement
      -- ^ Measurement
    | DeviceMetricCategory'list_Setting
      -- ^ Setting
    | DeviceMetricCategory'list_Calculation
      -- ^ Calculation
    | DeviceMetricCategory'list_Unspecified
      -- ^ Unspecified
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCategory'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCategory'list where
    acceptingParser =  do literal "measurement"; return DeviceMetricCategory'list_Measurement
                      `onFail` do literal "setting"; return DeviceMetricCategory'list_Setting
                      `onFail` do literal "calculation"; return DeviceMetricCategory'list_Calculation
                      `onFail` do literal "unspecified"; return DeviceMetricCategory'list_Unspecified
                      
    simpleTypeText DeviceMetricCategory'list_Measurement = "measurement"
    simpleTypeText DeviceMetricCategory'list_Setting = "setting"
    simpleTypeText DeviceMetricCategory'list_Calculation = "calculation"
    simpleTypeText DeviceMetricCategory'list_Unspecified = "unspecified"
 
data DeviceMetricCategory = DeviceMetricCategory
        { deviceMetricCategory_id :: Maybe String'primitive
        , deviceMetricCategory_value :: Maybe DeviceMetricCategory'list
        , deviceMetricCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCategory_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCategory_extension x
            ]
instance Extension DeviceMetricCategory Element where
    supertype (DeviceMetricCategory a0 a1 e0) =
               Element a0 e0
 
-- | Represents a request for a patient to employ a medical 
--   device. The device may be an implantable device, or an 
--   external assistive device, such as a walker.
elementDeviceRequest :: XMLParser DeviceRequest
elementDeviceRequest = parseSchemaType "DeviceRequest"
elementToXMLDeviceRequest :: DeviceRequest -> [Content ()]
elementToXMLDeviceRequest = schemaTypeToXML "DeviceRequest"
 
data DeviceRequest = DeviceRequest
        { deviceRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceRequest_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order by the orderer or by the 
          --   receiver.
        , deviceRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request. For 
          --   example: The proposed act must be performed if the 
          --   indicated conditions occur, e.g.., shortness of breath, 
          --   SpO2 less than x%.
        , deviceRequest_basedOn :: [Reference]
          -- ^ Plan/proposal/order fulfilled by this request.
        , deviceRequest_priorRequest :: [Reference]
          -- ^ The request takes the place of the referenced completed or 
          --   terminated request(s).
        , deviceRequest_groupIdentifier :: Maybe Identifier
          -- ^ Composite request this is part of.
        , deviceRequest_status :: Maybe RequestStatus
          -- ^ The status of the request.
        , deviceRequest_intent :: CodeableConcept
          -- ^ Whether the request is a proposal, plan, an original order 
          --   or a reflex order.
        , deviceRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the {{title}} should be addressed 
          --   with respect to other requests.
        , deviceRequest_choice16 :: OneOf2 Reference CodeableConcept
          -- ^ The details of the device to be used.
          --   
          --   Choice between:
          --   
          --   (1) codeReference
          --   
          --   (2) codeCodeableConcept
        , deviceRequest_subject :: Reference
          -- ^ The patient who will use the device.
        , deviceRequest_context :: Maybe Reference
          -- ^ An encounter that provides additional context in which this 
          --   request is made.
        , deviceRequest_choice19 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The timing schedule for the use of the device. The Schedule 
          --   data type allows many different expressions, for example. 
          --   &quot;Every 8 hours&quot;; &quot;Three times a day&quot;; 
          --   &quot;1/2 an hour before breakfast for 10 days from 23-Dec 
          --   2011:&quot;; &quot;15 Oct 2013, 17 Oct 2013 and 1 Nov 
          --   2013&quot;.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , deviceRequest_authoredOn :: Maybe DateTime
          -- ^ When the request transitioned to being actionable.
        , deviceRequest_requester :: Maybe DeviceRequest'Requester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , deviceRequest_performerType :: Maybe CodeableConcept
          -- ^ Desired type of performer for doing the diagnostic testing.
        , deviceRequest_performer :: Maybe Reference
          -- ^ The desired perfomer for doing the diagnostic testing.
        , deviceRequest_reasonCode :: [CodeableConcept]
          -- ^ Reason or justification for the use of this device.
        , deviceRequest_reasonReference :: [Reference]
          -- ^ Reason or justification for the use of this device.
        , deviceRequest_supportingInfo :: [Reference]
          -- ^ Additional clinical information about the patient that may 
          --   influence the request fulfilment. For example, this may 
          --   includes body where on the subject's the device will be 
          --   used ( i.e. the target site).
        , deviceRequest_note :: [Annotation]
          -- ^ Details about this request that were not represented at all 
          --   or sufficiently in one of the attributes provided in a 
          --   class. These may include for example a comment, an 
          --   instruction, or a note associated with the statement.
        , deviceRequest_relevantHistory :: [Reference]
          -- ^ Key events in the history of the request.
        }
        deriving (Eq,Show)
instance SchemaType DeviceRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "priorRequest")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` oneOf' [ ("Reference", fmap OneOf2 (parseSchemaType "codeReference"))
                           , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "codeCodeableConcept"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "performer")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@DeviceRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceRequest_language x
            , maybe [] (schemaTypeToXML "text") $ deviceRequest_text x
            , concatMap (schemaTypeToXML "contained") $ deviceRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ deviceRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ deviceRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ deviceRequest_basedOn x
            , concatMap (schemaTypeToXML "priorRequest") $ deviceRequest_priorRequest x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ deviceRequest_groupIdentifier x
            , maybe [] (schemaTypeToXML "status") $ deviceRequest_status x
            , schemaTypeToXML "intent" $ deviceRequest_intent x
            , maybe [] (schemaTypeToXML "priority") $ deviceRequest_priority x
            , foldOneOf2  (schemaTypeToXML "codeReference")
                          (schemaTypeToXML "codeCodeableConcept")
                          $ deviceRequest_choice16 x
            , schemaTypeToXML "subject" $ deviceRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ deviceRequest_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ deviceRequest_choice19 x
            , maybe [] (schemaTypeToXML "authoredOn") $ deviceRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ deviceRequest_requester x
            , maybe [] (schemaTypeToXML "performerType") $ deviceRequest_performerType x
            , maybe [] (schemaTypeToXML "performer") $ deviceRequest_performer x
            , concatMap (schemaTypeToXML "reasonCode") $ deviceRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ deviceRequest_reasonReference x
            , concatMap (schemaTypeToXML "supportingInfo") $ deviceRequest_supportingInfo x
            , concatMap (schemaTypeToXML "note") $ deviceRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ deviceRequest_relevantHistory x
            ]
instance Extension DeviceRequest DomainResource where
    supertype (DeviceRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceRequest -> DomainResource)
              
 
-- | Represents a request for a patient to employ a medical 
--   device. The device may be an implantable device, or an 
--   external assistive device, such as a walker.
data DeviceRequest'Requester = DeviceRequest'Requester
        { deviceRequest'Requester_id :: Maybe String'primitive
        , deviceRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceRequest'Requester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , deviceRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType DeviceRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@DeviceRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ deviceRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ deviceRequest'Requester_onBehalfOf x
            ]
instance Extension DeviceRequest'Requester BackboneElement where
    supertype (DeviceRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DeviceRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceRequest'Requester -> BackboneElement)
              
 
-- | A record of a device being used by a patient where the 
--   record is the result of a report from the patient or 
--   another clinician.
elementDeviceUseStatement :: XMLParser DeviceUseStatement
elementDeviceUseStatement = parseSchemaType "DeviceUseStatement"
elementToXMLDeviceUseStatement :: DeviceUseStatement -> [Content ()]
elementToXMLDeviceUseStatement = schemaTypeToXML "DeviceUseStatement"
 
data DeviceUseStatement = DeviceUseStatement
        { deviceUseStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceUseStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceUseStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceUseStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceUseStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceUseStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceUseStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceUseStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceUseStatement_identifier :: [Identifier]
          -- ^ An external identifier for this statement such as an IRI.
        , deviceUseStatement_status :: DeviceUseStatementStatus
          -- ^ A code representing the patient or other source's judgment 
          --   about the state of the device used that this statement is 
          --   about. Generally this will be active or completed.
        , deviceUseStatement_subject :: Reference
          -- ^ The patient who used the device.
        , deviceUseStatement_whenUsed :: Maybe Period
          -- ^ The time period over which the device was used.
        , deviceUseStatement_choice12 :: (Maybe (OneOf3 Timing Period DateTime))
          -- ^ How often the device was used.
          --   
          --   Choice between:
          --   
          --   (1) timingTiming
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDateTime
        , deviceUseStatement_recordedOn :: Maybe DateTime
          -- ^ The time at which the statement was made/recorded.
        , deviceUseStatement_source :: Maybe Reference
          -- ^ Who reported the device was being used by the patient.
        , deviceUseStatement_device :: Reference
          -- ^ The details of the device used.
        , deviceUseStatement_indication :: [CodeableConcept]
          -- ^ Reason or justification for the use of the device.
        , deviceUseStatement_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the device 
          --   was used ( i.e. the target site).
        , deviceUseStatement_note :: [Annotation]
          -- ^ Details about the device statement that were not 
          --   represented at all or sufficiently in one of the attributes 
          --   provided in a class. These may include for example a 
          --   comment, an instruction, or a note associated with the 
          --   statement.
        }
        deriving (Eq,Show)
instance SchemaType DeviceUseStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceUseStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "whenUsed")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf3 (parseSchemaType "timingTiming"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "timingPeriod"))
                                     , ("DateTime", fmap ThreeOf3 (parseSchemaType "timingDateTime"))
                                     ])
            `apply` optional (parseSchemaType "recordedOn")
            `apply` optional (parseSchemaType "source")
            `apply` parseSchemaType "device"
            `apply` many (parseSchemaType "indication")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@DeviceUseStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceUseStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceUseStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceUseStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceUseStatement_language x
            , maybe [] (schemaTypeToXML "text") $ deviceUseStatement_text x
            , concatMap (schemaTypeToXML "contained") $ deviceUseStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceUseStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceUseStatement_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ deviceUseStatement_identifier x
            , schemaTypeToXML "status" $ deviceUseStatement_status x
            , schemaTypeToXML "subject" $ deviceUseStatement_subject x
            , maybe [] (schemaTypeToXML "whenUsed") $ deviceUseStatement_whenUsed x
            , maybe [] (foldOneOf3  (schemaTypeToXML "timingTiming")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDateTime")
                                   ) $ deviceUseStatement_choice12 x
            , maybe [] (schemaTypeToXML "recordedOn") $ deviceUseStatement_recordedOn x
            , maybe [] (schemaTypeToXML "source") $ deviceUseStatement_source x
            , schemaTypeToXML "device" $ deviceUseStatement_device x
            , concatMap (schemaTypeToXML "indication") $ deviceUseStatement_indication x
            , maybe [] (schemaTypeToXML "bodySite") $ deviceUseStatement_bodySite x
            , concatMap (schemaTypeToXML "note") $ deviceUseStatement_note x
            ]
instance Extension DeviceUseStatement DomainResource where
    supertype (DeviceUseStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceUseStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceUseStatement -> DomainResource)
              
 
data DeviceUseStatementStatus'list
    = DeviceUseStatementStatus'list_Active
      -- ^ Active
    | DeviceUseStatementStatus'list_Completed
      -- ^ Completed
    | DeviceUseStatementStatus'list_Entered'in'error
      -- ^ Entered in Error
    | DeviceUseStatementStatus'list_Intended
      -- ^ Intended
    | DeviceUseStatementStatus'list_Stopped
      -- ^ Stopped
    | DeviceUseStatementStatus'list_On'hold
      -- ^ On Hold
    deriving (Eq,Show,Enum)
instance SchemaType DeviceUseStatementStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceUseStatementStatus'list where
    acceptingParser =  do literal "active"; return DeviceUseStatementStatus'list_Active
                      `onFail` do literal "completed"; return DeviceUseStatementStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return DeviceUseStatementStatus'list_Entered'in'error
                      `onFail` do literal "intended"; return DeviceUseStatementStatus'list_Intended
                      `onFail` do literal "stopped"; return DeviceUseStatementStatus'list_Stopped
                      `onFail` do literal "on-hold"; return DeviceUseStatementStatus'list_On'hold
                      
    simpleTypeText DeviceUseStatementStatus'list_Active = "active"
    simpleTypeText DeviceUseStatementStatus'list_Completed = "completed"
    simpleTypeText DeviceUseStatementStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText DeviceUseStatementStatus'list_Intended = "intended"
    simpleTypeText DeviceUseStatementStatus'list_Stopped = "stopped"
    simpleTypeText DeviceUseStatementStatus'list_On'hold = "on-hold"
 
data DeviceUseStatementStatus = DeviceUseStatementStatus
        { deviceUseStatementStatus_id :: Maybe String'primitive
        , deviceUseStatementStatus_value :: Maybe DeviceUseStatementStatus'list
        , deviceUseStatementStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceUseStatementStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceUseStatementStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceUseStatementStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceUseStatementStatus_id x
                       , maybe [] (toXMLAttribute "value") $ deviceUseStatementStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceUseStatementStatus_extension x
            ]
instance Extension DeviceUseStatementStatus Element where
    supertype (DeviceUseStatementStatus a0 a1 e0) =
               Element a0 e0
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
elementDiagnosticReport :: XMLParser DiagnosticReport
elementDiagnosticReport = parseSchemaType "DiagnosticReport"
elementToXMLDiagnosticReport :: DiagnosticReport -> [Content ()]
elementToXMLDiagnosticReport = schemaTypeToXML "DiagnosticReport"
 
data DiagnosticReport = DiagnosticReport
        { diagnosticReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , diagnosticReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , diagnosticReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , diagnosticReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , diagnosticReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , diagnosticReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , diagnosticReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReport_identifier :: [Identifier]
          -- ^ Identifiers assigned to this report by the performer or 
          --   other systems.
        , diagnosticReport_basedOn :: [Reference]
          -- ^ Details concerning a test or procedure requested.
        , diagnosticReport_status :: DiagnosticReportStatus
          -- ^ The status of the diagnostic report as a whole.
        , diagnosticReport_category :: Maybe CodeableConcept
          -- ^ A code that classifies the clinical discipline, department 
          --   or diagnostic service that created the report (e.g. 
          --   cardiology, biochemistry, hematology, MRI). This is used 
          --   for searching, sorting and display purposes.
        , diagnosticReport_code :: CodeableConcept
          -- ^ A code or name that describes this diagnostic report.
        , diagnosticReport_subject :: Maybe Reference
          -- ^ The subject of the report. Usually, but not always, this is 
          --   a patient. However diagnostic services also perform 
          --   analyses on specimens collected from a variety of other 
          --   sources.
        , diagnosticReport_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) which this DiagnosticReport per is 
          --   about.
        , diagnosticReport_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time or time-period the observed values are related to. 
          --   When the subject of the report is a patient, this is 
          --   usually either the time of the procedure or of specimen 
          --   collection(s), but very often the source of the date/time 
          --   is not known, only the date/time itself.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , diagnosticReport_issued :: Maybe Instant
          -- ^ The date and time that this version of the report was 
          --   released from the source diagnostic service.
        , diagnosticReport_performer :: [DiagnosticReport'Performer]
          -- ^ Indicates who or what participated in producing the report.
        , diagnosticReport_specimen :: [Reference]
          -- ^ Details about the specimens on which this diagnostic report 
          --   is based.
        , diagnosticReport_result :: [Reference]
          -- ^ Observations that are part of this diagnostic report. 
          --   Observations can be simple name/value pairs (e.g. 
          --   &quot;atomic&quot; results), or they can be grouping 
          --   observations that include references to other members of 
          --   the group (e.g. &quot;panels&quot;).
        , diagnosticReport_imagingStudy :: [Reference]
          -- ^ One or more links to full details of any imaging performed 
          --   during the diagnostic investigation. Typically, this is 
          --   imaging performed by DICOM enabled modalities, but this is 
          --   not required. A fully enabled PACS viewer can use this 
          --   information to provide views of the source images.
        , diagnosticReport_image :: [DiagnosticReport'Image]
          -- ^ A list of key images associated with this report. The 
          --   images are generally created during the diagnostic process, 
          --   and may be directly of the patient, or of treated specimens 
          --   (i.e. slides of interest).
        , diagnosticReport_conclusion :: Maybe Xsd.XsdString
          -- ^ Concise and clinically contextualized impression / summary 
          --   of the diagnostic report.
        , diagnosticReport_codedDiagnosis :: [CodeableConcept]
          -- ^ Codes for the conclusion.
        , diagnosticReport_presentedForm :: [Attachment]
          -- ^ Rich text representation of the entire result as issued by 
          --   the diagnostic service. Multiple formats are allowed but 
          --   they SHALL be semantically equivalent.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DiagnosticReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "specimen")
            `apply` many (parseSchemaType "result")
            `apply` many (parseSchemaType "imagingStudy")
            `apply` many (parseSchemaType "image")
            `apply` optional (parseSchemaType "conclusion")
            `apply` many (parseSchemaType "codedDiagnosis")
            `apply` many (parseSchemaType "presentedForm")
    schemaTypeToXML s x@DiagnosticReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ diagnosticReport_id x
            , maybe [] (schemaTypeToXML "meta") $ diagnosticReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ diagnosticReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ diagnosticReport_language x
            , maybe [] (schemaTypeToXML "text") $ diagnosticReport_text x
            , concatMap (schemaTypeToXML "contained") $ diagnosticReport_contained x
            , concatMap (schemaTypeToXML "extension") $ diagnosticReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReport_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ diagnosticReport_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ diagnosticReport_basedOn x
            , schemaTypeToXML "status" $ diagnosticReport_status x
            , maybe [] (schemaTypeToXML "category") $ diagnosticReport_category x
            , schemaTypeToXML "code" $ diagnosticReport_code x
            , maybe [] (schemaTypeToXML "subject") $ diagnosticReport_subject x
            , maybe [] (schemaTypeToXML "context") $ diagnosticReport_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ diagnosticReport_choice15 x
            , maybe [] (schemaTypeToXML "issued") $ diagnosticReport_issued x
            , concatMap (schemaTypeToXML "performer") $ diagnosticReport_performer x
            , concatMap (schemaTypeToXML "specimen") $ diagnosticReport_specimen x
            , concatMap (schemaTypeToXML "result") $ diagnosticReport_result x
            , concatMap (schemaTypeToXML "imagingStudy") $ diagnosticReport_imagingStudy x
            , concatMap (schemaTypeToXML "image") $ diagnosticReport_image x
            , maybe [] (schemaTypeToXML "conclusion") $ diagnosticReport_conclusion x
            , concatMap (schemaTypeToXML "codedDiagnosis") $ diagnosticReport_codedDiagnosis x
            , concatMap (schemaTypeToXML "presentedForm") $ diagnosticReport_presentedForm x
            ]
instance Extension DiagnosticReport DomainResource where
    supertype (DiagnosticReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DiagnosticReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DiagnosticReport -> DomainResource)
              
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
data DiagnosticReport'Performer = DiagnosticReport'Performer
        { diagnosticReport'Performer_id :: Maybe String'primitive
        , diagnosticReport'Performer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReport'Performer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReport'Performer_role :: Maybe CodeableConcept
          -- ^ Describes the type of participation (e.g. a responsible 
          --   party, author, or verifier).
        , diagnosticReport'Performer_actor :: Reference
          -- ^ The reference to the practitioner or organization involved 
          --   in producing the report. For example, the diagnostic 
          --   service that is responsible for issuing the report.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReport'Performer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DiagnosticReport'Performer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@DiagnosticReport'Performer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReport'Performer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReport'Performer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReport'Performer_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ diagnosticReport'Performer_role x
            , schemaTypeToXML "actor" $ diagnosticReport'Performer_actor x
            ]
instance Extension DiagnosticReport'Performer BackboneElement where
    supertype (DiagnosticReport'Performer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DiagnosticReport'Performer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DiagnosticReport'Performer -> BackboneElement)
              
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
data DiagnosticReport'Image = DiagnosticReport'Image
        { diagnosticReport'Image_id :: Maybe String'primitive
        , diagnosticReport'Image_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReport'Image_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReport'Image_comment :: Maybe Xsd.XsdString
          -- ^ A comment about the image. Typically, this is used to 
          --   provide an explanation for why the image is included, or to 
          --   draw the viewer's attention to important features.
        , diagnosticReport'Image_link :: Reference
          -- ^ Reference to the image source.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReport'Image where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DiagnosticReport'Image a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "comment")
            `apply` parseSchemaType "link"
    schemaTypeToXML s x@DiagnosticReport'Image{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReport'Image_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReport'Image_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReport'Image_modifierExtension x
            , maybe [] (schemaTypeToXML "comment") $ diagnosticReport'Image_comment x
            , schemaTypeToXML "link" $ diagnosticReport'Image_link x
            ]
instance Extension DiagnosticReport'Image BackboneElement where
    supertype (DiagnosticReport'Image a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DiagnosticReport'Image Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DiagnosticReport'Image -> BackboneElement)
              
 
data DiagnosticReportStatus'list
    = DiagnosticReportStatus'list_Registered
      -- ^ Registered
    | DiagnosticReportStatus'list_Partial
      -- ^ Partial
    | DiagnosticReportStatus'list_Preliminary
      -- ^ Preliminary
    | DiagnosticReportStatus'list_Final
      -- ^ Final
    | DiagnosticReportStatus'list_Amended
      -- ^ Amended
    | DiagnosticReportStatus'list_Corrected
      -- ^ Corrected
    | DiagnosticReportStatus'list_Appended
      -- ^ Appended
    | DiagnosticReportStatus'list_Cancelled
      -- ^ Cancelled
    | DiagnosticReportStatus'list_Entered'in'error
      -- ^ Entered in Error
    | DiagnosticReportStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType DiagnosticReportStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DiagnosticReportStatus'list where
    acceptingParser =  do literal "registered"; return DiagnosticReportStatus'list_Registered
                      `onFail` do literal "partial"; return DiagnosticReportStatus'list_Partial
                      `onFail` do literal "preliminary"; return DiagnosticReportStatus'list_Preliminary
                      `onFail` do literal "final"; return DiagnosticReportStatus'list_Final
                      `onFail` do literal "amended"; return DiagnosticReportStatus'list_Amended
                      `onFail` do literal "corrected"; return DiagnosticReportStatus'list_Corrected
                      `onFail` do literal "appended"; return DiagnosticReportStatus'list_Appended
                      `onFail` do literal "cancelled"; return DiagnosticReportStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return DiagnosticReportStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return DiagnosticReportStatus'list_Unknown
                      
    simpleTypeText DiagnosticReportStatus'list_Registered = "registered"
    simpleTypeText DiagnosticReportStatus'list_Partial = "partial"
    simpleTypeText DiagnosticReportStatus'list_Preliminary = "preliminary"
    simpleTypeText DiagnosticReportStatus'list_Final = "final"
    simpleTypeText DiagnosticReportStatus'list_Amended = "amended"
    simpleTypeText DiagnosticReportStatus'list_Corrected = "corrected"
    simpleTypeText DiagnosticReportStatus'list_Appended = "appended"
    simpleTypeText DiagnosticReportStatus'list_Cancelled = "cancelled"
    simpleTypeText DiagnosticReportStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText DiagnosticReportStatus'list_Unknown = "unknown"
 
data DiagnosticReportStatus = DiagnosticReportStatus
        { diagnosticReportStatus_id :: Maybe String'primitive
        , diagnosticReportStatus_value :: Maybe DiagnosticReportStatus'list
        , diagnosticReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DiagnosticReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DiagnosticReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ diagnosticReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReportStatus_extension x
            ]
instance Extension DiagnosticReportStatus Element where
    supertype (DiagnosticReportStatus a0 a1 e0) =
               Element a0 e0
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
elementDocumentManifest :: XMLParser DocumentManifest
elementDocumentManifest = parseSchemaType "DocumentManifest"
elementToXMLDocumentManifest :: DocumentManifest -> [Content ()]
elementToXMLDocumentManifest = schemaTypeToXML "DocumentManifest"
 
data DocumentManifest = DocumentManifest
        { documentManifest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , documentManifest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , documentManifest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , documentManifest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , documentManifest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , documentManifest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , documentManifest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifest_masterIdentifier :: Maybe Identifier
          -- ^ A single identifier that uniquely identifies this manifest. 
          --   Principally used to refer to the manifest in non-FHIR 
          --   contexts.
        , documentManifest_identifier :: [Identifier]
          -- ^ Other identifiers associated with the document manifest, 
          --   including version independent identifiers.
        , documentManifest_status :: DocumentReferenceStatus
          -- ^ The status of this document manifest.
        , documentManifest_type :: Maybe CodeableConcept
          -- ^ Specifies the kind of this set of documents (e.g. Patient 
          --   Summary, Discharge Summary, Prescription, etc.). The type 
          --   of a set of documents may be the same as one of the 
          --   documents in it - especially if there is only one - but it 
          --   may be wider.
        , documentManifest_subject :: Maybe Reference
          -- ^ Who or what the set of documents is about. The documents 
          --   can be about a person, (patient or healthcare 
          --   practitioner), a device (i.e. machine) or even a group of 
          --   subjects (such as a document about a herd of farm animals, 
          --   or a set of patients that share a common exposure). If the 
          --   documents cross more than one subject, then more than one 
          --   subject is allowed here (unusual use case).
        , documentManifest_created :: Maybe DateTime
          -- ^ When the document manifest was created for submission to 
          --   the server (not necessarily the same thing as the actual 
          --   resource last modified time, since it may be modified, 
          --   replicated, etc.).
        , documentManifest_author :: [Reference]
          -- ^ Identifies who is responsible for creating the manifest, 
          --   and adding documents to it.
        , documentManifest_recipient :: [Reference]
          -- ^ A patient, practitioner, or organization for which this set 
          --   of documents is intended.
        , documentManifest_source :: Maybe Uri
          -- ^ Identifies the source system, application, or software that 
          --   produced the document manifest.
        , documentManifest_description :: Maybe Xsd.XsdString
          -- ^ Human-readable description of the source document. This is 
          --   sometimes known as the &quot;title&quot;.
        , documentManifest_content :: [DocumentManifest'Content]
          -- ^ The list of Documents included in the manifest.
        , documentManifest_related :: [DocumentManifest'Related]
          -- ^ Related identifiers or resources associated with the 
          --   DocumentManifest.
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DocumentManifest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "masterIdentifier")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` many (parseSchemaType "author")
            `apply` many (parseSchemaType "recipient")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "content")
            `apply` many (parseSchemaType "related")
    schemaTypeToXML s x@DocumentManifest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ documentManifest_id x
            , maybe [] (schemaTypeToXML "meta") $ documentManifest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ documentManifest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ documentManifest_language x
            , maybe [] (schemaTypeToXML "text") $ documentManifest_text x
            , concatMap (schemaTypeToXML "contained") $ documentManifest_contained x
            , concatMap (schemaTypeToXML "extension") $ documentManifest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifest_modifierExtension x
            , maybe [] (schemaTypeToXML "masterIdentifier") $ documentManifest_masterIdentifier x
            , concatMap (schemaTypeToXML "identifier") $ documentManifest_identifier x
            , schemaTypeToXML "status" $ documentManifest_status x
            , maybe [] (schemaTypeToXML "type") $ documentManifest_type x
            , maybe [] (schemaTypeToXML "subject") $ documentManifest_subject x
            , maybe [] (schemaTypeToXML "created") $ documentManifest_created x
            , concatMap (schemaTypeToXML "author") $ documentManifest_author x
            , concatMap (schemaTypeToXML "recipient") $ documentManifest_recipient x
            , maybe [] (schemaTypeToXML "source") $ documentManifest_source x
            , maybe [] (schemaTypeToXML "description") $ documentManifest_description x
            , concatMap (schemaTypeToXML "content") $ documentManifest_content x
            , concatMap (schemaTypeToXML "related") $ documentManifest_related x
            ]
instance Extension DocumentManifest DomainResource where
    supertype (DocumentManifest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DocumentManifest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DocumentManifest -> DomainResource)
              
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
data DocumentManifest'Content = DocumentManifest'Content
        { documentManifest'Content_id :: Maybe String'primitive
        , documentManifest'Content_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifest'Content_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifest'Content_choice2 :: OneOf2 Attachment Reference
          -- ^ The list of references to document content, or Attachment 
          --   that consist of the parts of this document manifest. 
          --   Usually, these would be document references, but direct 
          --   references to Media or Attachments are also allowed.
          --   
          --   Choice between:
          --   
          --   (1) pAttachment
          --   
          --   (2) pReference
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifest'Content where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentManifest'Content a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "pAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "pReference"))
                           ]
    schemaTypeToXML s x@DocumentManifest'Content{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentManifest'Content_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentManifest'Content_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifest'Content_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "pAttachment")
                          (schemaTypeToXML "pReference")
                          $ documentManifest'Content_choice2 x
            ]
instance Extension DocumentManifest'Content BackboneElement where
    supertype (DocumentManifest'Content a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension DocumentManifest'Content Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentManifest'Content -> BackboneElement)
              
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
data DocumentManifest'Related = DocumentManifest'Related
        { documentManifest'Related_id :: Maybe String'primitive
        , documentManifest'Related_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifest'Related_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifest'Related_identifier :: Maybe Identifier
          -- ^ Related identifier to this DocumentManifest. For example, 
          --   Order numbers, accession numbers, XDW workflow numbers.
        , documentManifest'Related_ref :: Maybe Reference
          -- ^ Related Resource to this DocumentManifest. For example, 
          --   Order, ProcedureRequest, Procedure, EligibilityRequest, 
          --   etc.
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifest'Related where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentManifest'Related a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "ref")
    schemaTypeToXML s x@DocumentManifest'Related{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentManifest'Related_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentManifest'Related_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifest'Related_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ documentManifest'Related_identifier x
            , maybe [] (schemaTypeToXML "ref") $ documentManifest'Related_ref x
            ]
instance Extension DocumentManifest'Related BackboneElement where
    supertype (DocumentManifest'Related a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentManifest'Related Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentManifest'Related -> BackboneElement)
              
 
-- | A reference to a document.
elementDocumentReference :: XMLParser DocumentReference
elementDocumentReference = parseSchemaType "DocumentReference"
elementToXMLDocumentReference :: DocumentReference -> [Content ()]
elementToXMLDocumentReference = schemaTypeToXML "DocumentReference"
 
data DocumentReference = DocumentReference
        { documentReference_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , documentReference_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , documentReference_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , documentReference_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , documentReference_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , documentReference_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , documentReference_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference_masterIdentifier :: Maybe Identifier
          -- ^ Document identifier as assigned by the source of the 
          --   document. This identifier is specific to this version of 
          --   the document. This unique identifier may be used elsewhere 
          --   to identify this version of the document.
        , documentReference_identifier :: [Identifier]
          -- ^ Other identifiers associated with the document, including 
          --   version independent identifiers.
        , documentReference_status :: DocumentReferenceStatus
          -- ^ The status of this document reference.
        , documentReference_docStatus :: Maybe CompositionStatus
          -- ^ The status of the underlying document.
        , documentReference_type :: CodeableConcept
          -- ^ Specifies the particular kind of document referenced (e.g. 
          --   History and Physical, Discharge Summary, Progress Note). 
          --   This usually equates to the purpose of making the document 
          --   referenced.
        , documentReference_class :: Maybe CodeableConcept
          -- ^ A categorization for the type of document referenced - 
          --   helps for indexing and searching. This may be implied by or 
          --   derived from the code specified in the 
          --   DocumentReference.type.
        , documentReference_subject :: Maybe Reference
          -- ^ Who or what the document is about. The document can be 
          --   about a person, (patient or healthcare practitioner), a 
          --   device (e.g. a machine) or even a group of subjects (such 
          --   as a document about a herd of farm animals, or a set of 
          --   patients that share a common exposure).
        , documentReference_created :: Maybe DateTime
          -- ^ When the document was created.
        , documentReference_indexed :: Instant
          -- ^ When the document reference was created.
        , documentReference_author :: [Reference]
          -- ^ Identifies who is responsible for adding the information to 
          --   the document.
        , documentReference_authenticator :: Maybe Reference
          -- ^ Which person or organization authenticates that this 
          --   document is valid.
        , documentReference_custodian :: Maybe Reference
          -- ^ Identifies the organization or group who is responsible for 
          --   ongoing maintenance of and access to the document.
        , documentReference_relatesTo :: [DocumentReference'RelatesTo]
          -- ^ Relationships that this document has with other document 
          --   references that already exist.
        , documentReference_description :: Maybe Xsd.XsdString
          -- ^ Human-readable description of the source document. This is 
          --   sometimes known as the &quot;title&quot;.
        , documentReference_securityLabel :: [CodeableConcept]
          -- ^ A set of Security-Tag codes specifying the level of 
          --   privacy/security of the Document. Note that 
          --   DocumentReference.meta.security contains the security 
          --   labels of the &quot;reference&quot; to the document, while 
          --   DocumentReference.securityLabel contains a snapshot of the 
          --   security labels on the document the reference refers to.
        , documentReference_content :: [DocumentReference'Content]
          -- ^ The document and format referenced. There may be multiple 
          --   content element repetitions, each with a different format.
        , documentReference_context :: Maybe DocumentReference'Context
          -- ^ The clinical context in which the document was prepared.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DocumentReference
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "masterIdentifier")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "docStatus")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "class")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` parseSchemaType "indexed"
            `apply` many (parseSchemaType "author")
            `apply` optional (parseSchemaType "authenticator")
            `apply` optional (parseSchemaType "custodian")
            `apply` many (parseSchemaType "relatesTo")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many1 (parseSchemaType "content")
            `apply` optional (parseSchemaType "context")
    schemaTypeToXML s x@DocumentReference{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ documentReference_id x
            , maybe [] (schemaTypeToXML "meta") $ documentReference_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ documentReference_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ documentReference_language x
            , maybe [] (schemaTypeToXML "text") $ documentReference_text x
            , concatMap (schemaTypeToXML "contained") $ documentReference_contained x
            , concatMap (schemaTypeToXML "extension") $ documentReference_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference_modifierExtension x
            , maybe [] (schemaTypeToXML "masterIdentifier") $ documentReference_masterIdentifier x
            , concatMap (schemaTypeToXML "identifier") $ documentReference_identifier x
            , schemaTypeToXML "status" $ documentReference_status x
            , maybe [] (schemaTypeToXML "docStatus") $ documentReference_docStatus x
            , schemaTypeToXML "type" $ documentReference_type x
            , maybe [] (schemaTypeToXML "class") $ documentReference_class x
            , maybe [] (schemaTypeToXML "subject") $ documentReference_subject x
            , maybe [] (schemaTypeToXML "created") $ documentReference_created x
            , schemaTypeToXML "indexed" $ documentReference_indexed x
            , concatMap (schemaTypeToXML "author") $ documentReference_author x
            , maybe [] (schemaTypeToXML "authenticator") $ documentReference_authenticator x
            , maybe [] (schemaTypeToXML "custodian") $ documentReference_custodian x
            , concatMap (schemaTypeToXML "relatesTo") $ documentReference_relatesTo x
            , maybe [] (schemaTypeToXML "description") $ documentReference_description x
            , concatMap (schemaTypeToXML "securityLabel") $ documentReference_securityLabel x
            , concatMap (schemaTypeToXML "content") $ documentReference_content x
            , maybe [] (schemaTypeToXML "context") $ documentReference_context x
            ]
instance Extension DocumentReference DomainResource where
    supertype (DocumentReference e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DocumentReference Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DocumentReference -> DomainResource)
              
 
-- | A reference to a document.
data DocumentReference'RelatesTo = DocumentReference'RelatesTo
        { documentReference'RelatesTo_id :: Maybe String'primitive
        , documentReference'RelatesTo_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference'RelatesTo_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference'RelatesTo_code :: DocumentRelationshipType
          -- ^ The type of relationship that this document has with anther 
          --   document.
        , documentReference'RelatesTo_target :: Reference
          -- ^ The target document of this relationship.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference'RelatesTo where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReference'RelatesTo a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "target"
    schemaTypeToXML s x@DocumentReference'RelatesTo{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReference'RelatesTo_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReference'RelatesTo_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference'RelatesTo_modifierExtension x
            , schemaTypeToXML "code" $ documentReference'RelatesTo_code x
            , schemaTypeToXML "target" $ documentReference'RelatesTo_target x
            ]
instance Extension DocumentReference'RelatesTo BackboneElement where
    supertype (DocumentReference'RelatesTo a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReference'RelatesTo Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReference'RelatesTo -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReference'Content = DocumentReference'Content
        { documentReference'Content_id :: Maybe String'primitive
        , documentReference'Content_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference'Content_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference'Content_attachment :: Attachment
          -- ^ The document or URL of the document along with critical 
          --   metadata to prove content has integrity.
        , documentReference'Content_format :: Maybe Coding
          -- ^ An identifier of the document encoding, structure, and 
          --   template that the document conforms to beyond the base 
          --   format indicated in the mimeType.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference'Content where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReference'Content a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "attachment"
            `apply` optional (parseSchemaType "format")
    schemaTypeToXML s x@DocumentReference'Content{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReference'Content_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReference'Content_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference'Content_modifierExtension x
            , schemaTypeToXML "attachment" $ documentReference'Content_attachment x
            , maybe [] (schemaTypeToXML "format") $ documentReference'Content_format x
            ]
instance Extension DocumentReference'Content BackboneElement where
    supertype (DocumentReference'Content a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReference'Content Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReference'Content -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReference'Context = DocumentReference'Context
        { documentReference'Context_id :: Maybe String'primitive
        , documentReference'Context_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference'Context_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference'Context_encounter :: Maybe Reference
          -- ^ Describes the clinical encounter or type of care that the 
          --   document content is associated with.
        , documentReference'Context_event :: [CodeableConcept]
          -- ^ This list of codes represents the main clinical acts, such 
          --   as a colonoscopy or an appendectomy, being documented. In 
          --   some cases, the event is inherent in the typeCode, such as 
          --   a &quot;History and Physical Report&quot; in which the 
          --   procedure being documented is necessarily a &quot;History 
          --   and Physical&quot; act.
        , documentReference'Context_period :: Maybe Period
          -- ^ The time period over which the service that is described by 
          --   the document was provided.
        , documentReference'Context_facilityType :: Maybe CodeableConcept
          -- ^ The kind of facility where the patient was seen.
        , documentReference'Context_practiceSetting :: Maybe CodeableConcept
          -- ^ This property may convey specifics about the practice 
          --   setting where the content was created, often reflecting the 
          --   clinical specialty.
        , documentReference'Context_sourcePatientInfo :: Maybe Reference
          -- ^ The Patient Information as known when the document was 
          --   published. May be a reference to a version specific, or 
          --   contained.
        , documentReference'Context_related :: [DocumentReference'Related]
          -- ^ Related identifiers or resources associated with the 
          --   DocumentReference.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference'Context where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReference'Context a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "encounter")
            `apply` many (parseSchemaType "event")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "facilityType")
            `apply` optional (parseSchemaType "practiceSetting")
            `apply` optional (parseSchemaType "sourcePatientInfo")
            `apply` many (parseSchemaType "related")
    schemaTypeToXML s x@DocumentReference'Context{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReference'Context_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReference'Context_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference'Context_modifierExtension x
            , maybe [] (schemaTypeToXML "encounter") $ documentReference'Context_encounter x
            , concatMap (schemaTypeToXML "event") $ documentReference'Context_event x
            , maybe [] (schemaTypeToXML "period") $ documentReference'Context_period x
            , maybe [] (schemaTypeToXML "facilityType") $ documentReference'Context_facilityType x
            , maybe [] (schemaTypeToXML "practiceSetting") $ documentReference'Context_practiceSetting x
            , maybe [] (schemaTypeToXML "sourcePatientInfo") $ documentReference'Context_sourcePatientInfo x
            , concatMap (schemaTypeToXML "related") $ documentReference'Context_related x
            ]
instance Extension DocumentReference'Context BackboneElement where
    supertype (DocumentReference'Context a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension DocumentReference'Context Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReference'Context -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReference'Related = DocumentReference'Related
        { documentReference'Related_id :: Maybe String'primitive
        , documentReference'Related_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference'Related_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference'Related_identifier :: Maybe Identifier
          -- ^ Related identifier to this DocumentReference. If both id 
          --   and ref are present they shall refer to the same thing.
        , documentReference'Related_ref :: Maybe Reference
          -- ^ Related Resource to this DocumentReference. If both id and 
          --   ref are present they shall refer to the same thing.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference'Related where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReference'Related a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "ref")
    schemaTypeToXML s x@DocumentReference'Related{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReference'Related_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReference'Related_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference'Related_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ documentReference'Related_identifier x
            , maybe [] (schemaTypeToXML "ref") $ documentReference'Related_ref x
            ]
instance Extension DocumentReference'Related BackboneElement where
    supertype (DocumentReference'Related a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReference'Related Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReference'Related -> BackboneElement)
              
 
-- | The EligibilityRequest provides patient and insurance 
--   coverage information to an insurer for them to respond, in 
--   the form of an EligibilityResponse, with information 
--   regarding whether the stated coverage is valid and in-force 
--   and optionally to provide the insurance details of the 
--   policy.
elementEligibilityRequest :: XMLParser EligibilityRequest
elementEligibilityRequest = parseSchemaType "EligibilityRequest"
elementToXMLEligibilityRequest :: EligibilityRequest -> [Content ()]
elementToXMLEligibilityRequest = schemaTypeToXML "EligibilityRequest"
 
data EligibilityRequest = EligibilityRequest
        { eligibilityRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , eligibilityRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , eligibilityRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , eligibilityRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , eligibilityRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , eligibilityRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , eligibilityRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityRequest_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , eligibilityRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , eligibilityRequest_priority :: Maybe CodeableConcept
          -- ^ Immediate (STAT), best effort (NORMAL), deferred (DEFER).
        , eligibilityRequest_patient :: Maybe Reference
          -- ^ Patient Resource.
        , eligibilityRequest_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , eligibilityRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , eligibilityRequest_enterer :: Maybe Reference
          -- ^ Person who created the invoice/claim/pre-determination or 
          --   pre-authorization.
        , eligibilityRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , eligibilityRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , eligibilityRequest_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , eligibilityRequest_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , eligibilityRequest_coverage :: Maybe Reference
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , eligibilityRequest_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , eligibilityRequest_benefitCategory :: Maybe CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , eligibilityRequest_benefitSubCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EligibilityRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "facility")
            `apply` optional (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` optional (parseSchemaType "benefitCategory")
            `apply` optional (parseSchemaType "benefitSubCategory")
    schemaTypeToXML s x@EligibilityRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ eligibilityRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ eligibilityRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ eligibilityRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ eligibilityRequest_language x
            , maybe [] (schemaTypeToXML "text") $ eligibilityRequest_text x
            , concatMap (schemaTypeToXML "contained") $ eligibilityRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ eligibilityRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ eligibilityRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ eligibilityRequest_status x
            , maybe [] (schemaTypeToXML "priority") $ eligibilityRequest_priority x
            , maybe [] (schemaTypeToXML "patient") $ eligibilityRequest_patient x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ eligibilityRequest_choice12 x
            , maybe [] (schemaTypeToXML "created") $ eligibilityRequest_created x
            , maybe [] (schemaTypeToXML "enterer") $ eligibilityRequest_enterer x
            , maybe [] (schemaTypeToXML "provider") $ eligibilityRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ eligibilityRequest_organization x
            , maybe [] (schemaTypeToXML "insurer") $ eligibilityRequest_insurer x
            , maybe [] (schemaTypeToXML "facility") $ eligibilityRequest_facility x
            , maybe [] (schemaTypeToXML "coverage") $ eligibilityRequest_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ eligibilityRequest_businessArrangement x
            , maybe [] (schemaTypeToXML "benefitCategory") $ eligibilityRequest_benefitCategory x
            , maybe [] (schemaTypeToXML "benefitSubCategory") $ eligibilityRequest_benefitSubCategory x
            ]
instance Extension EligibilityRequest DomainResource where
    supertype (EligibilityRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EligibilityRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EligibilityRequest -> DomainResource)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
elementEligibilityResponse :: XMLParser EligibilityResponse
elementEligibilityResponse = parseSchemaType "EligibilityResponse"
elementToXMLEligibilityResponse :: EligibilityResponse -> [Content ()]
elementToXMLEligibilityResponse = schemaTypeToXML "EligibilityResponse"
 
data EligibilityResponse = EligibilityResponse
        { eligibilityResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , eligibilityResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , eligibilityResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , eligibilityResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , eligibilityResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , eligibilityResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , eligibilityResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , eligibilityResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , eligibilityResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , eligibilityResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , eligibilityResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , eligibilityResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , eligibilityResponse_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete.
        , eligibilityResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , eligibilityResponse_insurer :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , eligibilityResponse_inforce :: Maybe Boolean
          -- ^ Flag indicating if the coverage provided is inforce 
          --   currently if no service date(s) specified or for the whole 
          --   duration of the service dates.
        , eligibilityResponse_insurance :: [EligibilityResponse'Insurance]
          -- ^ The insurer may provide both the details for the requested 
          --   coverage as well as details for additional coverages known 
          --   to the insurer.
        , eligibilityResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , eligibilityResponse_error :: [EligibilityResponse'Error]
          -- ^ Mutually exclusive with Services Provided (Item).
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EligibilityResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "inforce")
            `apply` many (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "error")
    schemaTypeToXML s x@EligibilityResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ eligibilityResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ eligibilityResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ eligibilityResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ eligibilityResponse_language x
            , maybe [] (schemaTypeToXML "text") $ eligibilityResponse_text x
            , concatMap (schemaTypeToXML "contained") $ eligibilityResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ eligibilityResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ eligibilityResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ eligibilityResponse_status x
            , maybe [] (schemaTypeToXML "created") $ eligibilityResponse_created x
            , maybe [] (schemaTypeToXML "requestProvider") $ eligibilityResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ eligibilityResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "request") $ eligibilityResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ eligibilityResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ eligibilityResponse_disposition x
            , maybe [] (schemaTypeToXML "insurer") $ eligibilityResponse_insurer x
            , maybe [] (schemaTypeToXML "inforce") $ eligibilityResponse_inforce x
            , concatMap (schemaTypeToXML "insurance") $ eligibilityResponse_insurance x
            , maybe [] (schemaTypeToXML "form") $ eligibilityResponse_form x
            , concatMap (schemaTypeToXML "error") $ eligibilityResponse_error x
            ]
instance Extension EligibilityResponse DomainResource where
    supertype (EligibilityResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EligibilityResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EligibilityResponse -> DomainResource)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponse'Insurance = EligibilityResponse'Insurance
        { eligibilityResponse'Insurance_id :: Maybe String'primitive
        , eligibilityResponse'Insurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse'Insurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse'Insurance_coverage :: Maybe Reference
          -- ^ A suite of updated or additional Coverages from the 
          --   Insurer.
        , eligibilityResponse'Insurance_contract :: Maybe Reference
          -- ^ The contract resource which may provide more detailed 
          --   information.
        , eligibilityResponse'Insurance_benefitBalance :: [EligibilityResponse'BenefitBalance]
          -- ^ Benefits and optionally current balances by Category.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse'Insurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponse'Insurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "contract")
            `apply` many (parseSchemaType "benefitBalance")
    schemaTypeToXML s x@EligibilityResponse'Insurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponse'Insurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponse'Insurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse'Insurance_modifierExtension x
            , maybe [] (schemaTypeToXML "coverage") $ eligibilityResponse'Insurance_coverage x
            , maybe [] (schemaTypeToXML "contract") $ eligibilityResponse'Insurance_contract x
            , concatMap (schemaTypeToXML "benefitBalance") $ eligibilityResponse'Insurance_benefitBalance x
            ]
instance Extension EligibilityResponse'Insurance BackboneElement where
    supertype (EligibilityResponse'Insurance a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponse'Insurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponse'Insurance -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponse'BenefitBalance = EligibilityResponse'BenefitBalance
        { eligibilityResponse'BenefitBalance_id :: Maybe String'primitive
        , eligibilityResponse'BenefitBalance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse'BenefitBalance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse'BenefitBalance_category :: CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , eligibilityResponse'BenefitBalance_subCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        , eligibilityResponse'BenefitBalance_excluded :: Maybe Boolean
          -- ^ True if the indicated class of service is excluded from the 
          --   plan, missing or False indicated the service is included in 
          --   the coverage.
        , eligibilityResponse'BenefitBalance_name :: Maybe Xsd.XsdString
          -- ^ A short name or tag for the benefit, for example MED01, or 
          --   DENT2.
        , eligibilityResponse'BenefitBalance_description :: Maybe Xsd.XsdString
          -- ^ A richer description of the benefit, for example 'DENT2 
          --   covers 100% of basic, 50% of major but exclused Ortho, 
          --   Implants and Costmetic services'.
        , eligibilityResponse'BenefitBalance_network :: Maybe CodeableConcept
          -- ^ Network designation.
        , eligibilityResponse'BenefitBalance_unit :: Maybe CodeableConcept
          -- ^ Unit designation: individual or family.
        , eligibilityResponse'BenefitBalance_term :: Maybe CodeableConcept
          -- ^ The term or period of the values such as 'maximum lifetime 
          --   benefit' or 'maximum annual vistis'.
        , eligibilityResponse'BenefitBalance_financial :: [EligibilityResponse'Financial]
          -- ^ Benefits Used to date.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse'BenefitBalance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponse'BenefitBalance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "subCategory")
            `apply` optional (parseSchemaType "excluded")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "network")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "term")
            `apply` many (parseSchemaType "financial")
    schemaTypeToXML s x@EligibilityResponse'BenefitBalance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponse'BenefitBalance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponse'BenefitBalance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse'BenefitBalance_modifierExtension x
            , schemaTypeToXML "category" $ eligibilityResponse'BenefitBalance_category x
            , maybe [] (schemaTypeToXML "subCategory") $ eligibilityResponse'BenefitBalance_subCategory x
            , maybe [] (schemaTypeToXML "excluded") $ eligibilityResponse'BenefitBalance_excluded x
            , maybe [] (schemaTypeToXML "name") $ eligibilityResponse'BenefitBalance_name x
            , maybe [] (schemaTypeToXML "description") $ eligibilityResponse'BenefitBalance_description x
            , maybe [] (schemaTypeToXML "network") $ eligibilityResponse'BenefitBalance_network x
            , maybe [] (schemaTypeToXML "unit") $ eligibilityResponse'BenefitBalance_unit x
            , maybe [] (schemaTypeToXML "term") $ eligibilityResponse'BenefitBalance_term x
            , concatMap (schemaTypeToXML "financial") $ eligibilityResponse'BenefitBalance_financial x
            ]
instance Extension EligibilityResponse'BenefitBalance BackboneElement where
    supertype (EligibilityResponse'BenefitBalance a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponse'BenefitBalance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponse'BenefitBalance -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponse'Financial = EligibilityResponse'Financial
        { eligibilityResponse'Financial_id :: Maybe String'primitive
        , eligibilityResponse'Financial_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse'Financial_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse'Financial_type :: CodeableConcept
          -- ^ Deductable, visits, benefit amount.
        , eligibilityResponse'Financial_choice3 :: (Maybe (OneOf3 UnsignedInt Xsd.XsdString Money))
          -- ^ Benefits allowed.
          --   
          --   Choice between:
          --   
          --   (1) allowedUnsignedInt
          --   
          --   (2) allowedString
          --   
          --   (3) allowedMoney
        , eligibilityResponse'Financial_choice4 :: (Maybe (OneOf2 UnsignedInt Money))
          -- ^ Benefits used.
          --   
          --   Choice between:
          --   
          --   (1) usedUnsignedInt
          --   
          --   (2) usedMoney
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse'Financial where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponse'Financial a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf3 (parseSchemaType "allowedUnsignedInt"))
                                     , ("Xsd.XsdString", fmap TwoOf3 (parseSchemaType "allowedString"))
                                     , ("Money", fmap ThreeOf3 (parseSchemaType "allowedMoney"))
                                     ])
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf2 (parseSchemaType "usedUnsignedInt"))
                                     , ("Money", fmap TwoOf2 (parseSchemaType "usedMoney"))
                                     ])
    schemaTypeToXML s x@EligibilityResponse'Financial{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponse'Financial_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponse'Financial_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse'Financial_modifierExtension x
            , schemaTypeToXML "type" $ eligibilityResponse'Financial_type x
            , maybe [] (foldOneOf3  (schemaTypeToXML "allowedUnsignedInt")
                                    (schemaTypeToXML "allowedString")
                                    (schemaTypeToXML "allowedMoney")
                                   ) $ eligibilityResponse'Financial_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "usedUnsignedInt")
                                    (schemaTypeToXML "usedMoney")
                                   ) $ eligibilityResponse'Financial_choice4 x
            ]
instance Extension EligibilityResponse'Financial BackboneElement where
    supertype (EligibilityResponse'Financial a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponse'Financial Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponse'Financial -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponse'Error = EligibilityResponse'Error
        { eligibilityResponse'Error_id :: Maybe String'primitive
        , eligibilityResponse'Error_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse'Error_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse'Error_code :: CodeableConcept
          -- ^ An error code,from a specified code system, which details 
          --   why the eligibility check could not be performed.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse'Error where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponse'Error a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
    schemaTypeToXML s x@EligibilityResponse'Error{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponse'Error_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponse'Error_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse'Error_modifierExtension x
            , schemaTypeToXML "code" $ eligibilityResponse'Error_code x
            ]
instance Extension EligibilityResponse'Error BackboneElement where
    supertype (EligibilityResponse'Error a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponse'Error Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponse'Error -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
elementEncounter :: XMLParser Encounter
elementEncounter = parseSchemaType "Encounter"
elementToXMLEncounter :: Encounter -> [Content ()]
elementToXMLEncounter = schemaTypeToXML "Encounter"
 
data Encounter = Encounter
        { encounter_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , encounter_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , encounter_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , encounter_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , encounter_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , encounter_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , encounter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter_identifier :: [Identifier]
          -- ^ Identifier(s) by which this encounter is known.
        , encounter_status :: EncounterStatus
          -- ^ planned | arrived | triaged | in-progress | onleave | 
          --   finished | cancelled +.
        , encounter_statusHistory :: [Encounter'StatusHistory]
          -- ^ The status history permits the encounter resource to 
          --   contain the status history without needing to read through 
          --   the historical versions of the resource, or even have the 
          --   server store them.
        , encounter_class :: Maybe Coding
          -- ^ inpatient | outpatient | ambulatory | emergency +.
        , encounter_classHistory :: [Encounter'ClassHistory]
          -- ^ The class history permits the tracking of the encounters 
          --   transitions without needing to go through the resource 
          --   history. This would be used for a case where an admission 
          --   starts of as an emergency encounter, then transisions into 
          --   an inpatient scenario. Doing this and not restarting a new 
          --   encounter ensures that any lab/diagnostic results can more 
          --   easily follow the patient and not require re-processing and 
          --   not get lost or cancelled during a kindof discharge from 
          --   emergency to inpatient.
        , encounter_type :: [CodeableConcept]
          -- ^ Specific type of encounter (e.g. e-mail consultation, 
          --   surgical day-care, skilled nursing, rehabilitation).
        , encounter_priority :: Maybe CodeableConcept
          -- ^ Indicates the urgency of the encounter.
        , encounter_subject :: Maybe Reference
          -- ^ The patient ro group present at the encounter.
        , encounter_episodeOfCare :: [Reference]
          -- ^ Where a specific encounter should be classified as a part 
          --   of a specific episode(s) of care this field should be used. 
          --   This association can facilitate grouping of related 
          --   encounters together for a specific purpose, such as 
          --   government reporting, issue tracking, association via a 
          --   common problem. The association is recorded on the 
          --   encounter as these are typically created after the episode 
          --   of care, and grouped on entry rather than editing the 
          --   episode of care to append another encounter to it (the 
          --   episode of care could span years).
        , encounter_incomingReferral :: [Reference]
          -- ^ The referral request this encounter satisfies (incoming 
          --   referral).
        , encounter_participant :: [Encounter'Participant]
          -- ^ The list of people responsible for providing the service.
        , encounter_appointment :: Maybe Reference
          -- ^ The appointment that scheduled this encounter.
        , encounter_period :: Maybe Period
          -- ^ The start and end time of the encounter.
        , encounter_length :: Maybe Duration
          -- ^ Quantity of time the encounter lasted. This excludes the 
          --   time during leaves of absence.
        , encounter_reason :: [CodeableConcept]
          -- ^ Reason the encounter takes place, expressed as a code. For 
          --   admissions, this can be used for a coded admission 
          --   diagnosis.
        , encounter_diagnosis :: [Encounter'Diagnosis]
          -- ^ The list of diagnosis relevant to this encounter.
        , encounter_account :: [Reference]
          -- ^ The set of accounts that may be used for billing for this 
          --   Encounter.
        , encounter_hospitalization :: Maybe Encounter'Hospitalization
          -- ^ Details about the admission to a healthcare service.
        , encounter_location :: [Encounter'Location]
          -- ^ List of locations where the patient has been during this 
          --   encounter.
        , encounter_serviceProvider :: Maybe Reference
          -- ^ An organization that is in charge of maintaining the 
          --   information of this Encounter (e.g. who maintains the 
          --   report or the master service catalog item, etc.). This MAY 
          --   be the same as the organization on the Patient record, 
          --   however it could be different. This MAY not be not the 
          --   Service Delivery Location's Organization.
        , encounter_partOf :: Maybe Reference
          -- ^ Another Encounter of which this encounter is a part of 
          --   (administratively or in time).
        }
        deriving (Eq,Show)
instance SchemaType Encounter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Encounter
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "statusHistory")
            `apply` optional (parseSchemaType "class")
            `apply` many (parseSchemaType "classHistory")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "episodeOfCare")
            `apply` many (parseSchemaType "incomingReferral")
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "appointment")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "length")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "account")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "location")
            `apply` optional (parseSchemaType "serviceProvider")
            `apply` optional (parseSchemaType "partOf")
    schemaTypeToXML s x@Encounter{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ encounter_id x
            , maybe [] (schemaTypeToXML "meta") $ encounter_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ encounter_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ encounter_language x
            , maybe [] (schemaTypeToXML "text") $ encounter_text x
            , concatMap (schemaTypeToXML "contained") $ encounter_contained x
            , concatMap (schemaTypeToXML "extension") $ encounter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ encounter_identifier x
            , schemaTypeToXML "status" $ encounter_status x
            , concatMap (schemaTypeToXML "statusHistory") $ encounter_statusHistory x
            , maybe [] (schemaTypeToXML "class") $ encounter_class x
            , concatMap (schemaTypeToXML "classHistory") $ encounter_classHistory x
            , concatMap (schemaTypeToXML "type") $ encounter_type x
            , maybe [] (schemaTypeToXML "priority") $ encounter_priority x
            , maybe [] (schemaTypeToXML "subject") $ encounter_subject x
            , concatMap (schemaTypeToXML "episodeOfCare") $ encounter_episodeOfCare x
            , concatMap (schemaTypeToXML "incomingReferral") $ encounter_incomingReferral x
            , concatMap (schemaTypeToXML "participant") $ encounter_participant x
            , maybe [] (schemaTypeToXML "appointment") $ encounter_appointment x
            , maybe [] (schemaTypeToXML "period") $ encounter_period x
            , maybe [] (schemaTypeToXML "length") $ encounter_length x
            , concatMap (schemaTypeToXML "reason") $ encounter_reason x
            , concatMap (schemaTypeToXML "diagnosis") $ encounter_diagnosis x
            , concatMap (schemaTypeToXML "account") $ encounter_account x
            , maybe [] (schemaTypeToXML "hospitalization") $ encounter_hospitalization x
            , concatMap (schemaTypeToXML "location") $ encounter_location x
            , maybe [] (schemaTypeToXML "serviceProvider") $ encounter_serviceProvider x
            , maybe [] (schemaTypeToXML "partOf") $ encounter_partOf x
            ]
instance Extension Encounter DomainResource where
    supertype (Encounter e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Encounter Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Encounter -> DomainResource)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'StatusHistory = Encounter'StatusHistory
        { encounter'StatusHistory_id :: Maybe String'primitive
        , encounter'StatusHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'StatusHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'StatusHistory_status :: EncounterStatus
          -- ^ planned | arrived | triaged | in-progress | onleave | 
          --   finished | cancelled +.
        , encounter'StatusHistory_period :: Period
          -- ^ The time that the episode was in the specified status.
        }
        deriving (Eq,Show)
instance SchemaType Encounter'StatusHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'StatusHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@Encounter'StatusHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'StatusHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'StatusHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'StatusHistory_modifierExtension x
            , schemaTypeToXML "status" $ encounter'StatusHistory_status x
            , schemaTypeToXML "period" $ encounter'StatusHistory_period x
            ]
instance Extension Encounter'StatusHistory BackboneElement where
    supertype (Encounter'StatusHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Encounter'StatusHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'StatusHistory -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'ClassHistory = Encounter'ClassHistory
        { encounter'ClassHistory_id :: Maybe String'primitive
        , encounter'ClassHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'ClassHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'ClassHistory_class :: Coding
          -- ^ inpatient | outpatient | ambulatory | emergency +.
        , encounter'ClassHistory_period :: Period
          -- ^ The time that the episode was in the specified class.
        }
        deriving (Eq,Show)
instance SchemaType Encounter'ClassHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'ClassHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "class"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@Encounter'ClassHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'ClassHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'ClassHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'ClassHistory_modifierExtension x
            , schemaTypeToXML "class" $ encounter'ClassHistory_class x
            , schemaTypeToXML "period" $ encounter'ClassHistory_period x
            ]
instance Extension Encounter'ClassHistory BackboneElement where
    supertype (Encounter'ClassHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Encounter'ClassHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'ClassHistory -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'Participant = Encounter'Participant
        { encounter'Participant_id :: Maybe String'primitive
        , encounter'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'Participant_type :: [CodeableConcept]
          -- ^ Role of participant in encounter.
        , encounter'Participant_period :: Maybe Period
          -- ^ The period of time that the specified participant 
          --   participated in the encounter. These can overlap or be 
          --   sub-sets of the overall encounter's period.
        , encounter'Participant_individual :: Maybe Reference
          -- ^ Persons involved in the encounter other than the patient.
        }
        deriving (Eq,Show)
instance SchemaType Encounter'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "individual")
    schemaTypeToXML s x@Encounter'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'Participant_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ encounter'Participant_type x
            , maybe [] (schemaTypeToXML "period") $ encounter'Participant_period x
            , maybe [] (schemaTypeToXML "individual") $ encounter'Participant_individual x
            ]
instance Extension Encounter'Participant BackboneElement where
    supertype (Encounter'Participant a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Encounter'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'Participant -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'Diagnosis = Encounter'Diagnosis
        { encounter'Diagnosis_id :: Maybe String'primitive
        , encounter'Diagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'Diagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'Diagnosis_condition :: Reference
          -- ^ Reason the encounter takes place, as specified using 
          --   information from another resource. For admissions, this is 
          --   the admission diagnosis. The indication will typically be a 
          --   Condition (with other resources referenced in the 
          --   evidence.detail), or a Procedure.
        , encounter'Diagnosis_role :: Maybe CodeableConcept
          -- ^ Role that this diagnosis has within the encounter (e.g. 
          --   admission, billing, discharge â€¦).
        , encounter'Diagnosis_rank :: Maybe PositiveInt
          -- ^ Ranking of the diagnosis (for each role type).
        }
        deriving (Eq,Show)
instance SchemaType Encounter'Diagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'Diagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "condition"
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "rank")
    schemaTypeToXML s x@Encounter'Diagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'Diagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'Diagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'Diagnosis_modifierExtension x
            , schemaTypeToXML "condition" $ encounter'Diagnosis_condition x
            , maybe [] (schemaTypeToXML "role") $ encounter'Diagnosis_role x
            , maybe [] (schemaTypeToXML "rank") $ encounter'Diagnosis_rank x
            ]
instance Extension Encounter'Diagnosis BackboneElement where
    supertype (Encounter'Diagnosis a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Encounter'Diagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'Diagnosis -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'Hospitalization = Encounter'Hospitalization
        { encounter'Hospitalization_id :: Maybe String'primitive
        , encounter'Hospitalization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'Hospitalization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'Hospitalization_preAdmissionIdentifier :: Maybe Identifier
          -- ^ Pre-admission identifier.
        , encounter'Hospitalization_origin :: Maybe Reference
          -- ^ The location from which the patient came before admission.
        , encounter'Hospitalization_admitSource :: Maybe CodeableConcept
          -- ^ From where patient was admitted (physician referral, 
          --   transfer).
        , encounter'Hospitalization_reAdmission :: Maybe CodeableConcept
          -- ^ Whether this hospitalization is a readmission and why if 
          --   known.
        , encounter'Hospitalization_dietPreference :: [CodeableConcept]
          -- ^ Diet preferences reported by the patient.
        , encounter'Hospitalization_specialCourtesy :: [CodeableConcept]
          -- ^ Special courtesies (VIP, board member).
        , encounter'Hospitalization_specialArrangement :: [CodeableConcept]
          -- ^ Any special requests that have been made for this 
          --   hospitalization encounter, such as the provision of 
          --   specific equipment or other things.
        , encounter'Hospitalization_destination :: Maybe Reference
          -- ^ Location to which the patient is discharged.
        , encounter'Hospitalization_dischargeDisposition :: Maybe CodeableConcept
          -- ^ Category or kind of location after discharge.
        }
        deriving (Eq,Show)
instance SchemaType Encounter'Hospitalization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'Hospitalization a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "preAdmissionIdentifier")
            `apply` optional (parseSchemaType "origin")
            `apply` optional (parseSchemaType "admitSource")
            `apply` optional (parseSchemaType "reAdmission")
            `apply` many (parseSchemaType "dietPreference")
            `apply` many (parseSchemaType "specialCourtesy")
            `apply` many (parseSchemaType "specialArrangement")
            `apply` optional (parseSchemaType "destination")
            `apply` optional (parseSchemaType "dischargeDisposition")
    schemaTypeToXML s x@Encounter'Hospitalization{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'Hospitalization_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'Hospitalization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'Hospitalization_modifierExtension x
            , maybe [] (schemaTypeToXML "preAdmissionIdentifier") $ encounter'Hospitalization_preAdmissionIdentifier x
            , maybe [] (schemaTypeToXML "origin") $ encounter'Hospitalization_origin x
            , maybe [] (schemaTypeToXML "admitSource") $ encounter'Hospitalization_admitSource x
            , maybe [] (schemaTypeToXML "reAdmission") $ encounter'Hospitalization_reAdmission x
            , concatMap (schemaTypeToXML "dietPreference") $ encounter'Hospitalization_dietPreference x
            , concatMap (schemaTypeToXML "specialCourtesy") $ encounter'Hospitalization_specialCourtesy x
            , concatMap (schemaTypeToXML "specialArrangement") $ encounter'Hospitalization_specialArrangement x
            , maybe [] (schemaTypeToXML "destination") $ encounter'Hospitalization_destination x
            , maybe [] (schemaTypeToXML "dischargeDisposition") $ encounter'Hospitalization_dischargeDisposition x
            ]
instance Extension Encounter'Hospitalization BackboneElement where
    supertype (Encounter'Hospitalization a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension Encounter'Hospitalization Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'Hospitalization -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data Encounter'Location = Encounter'Location
        { encounter'Location_id :: Maybe String'primitive
        , encounter'Location_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter'Location_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter'Location_location :: Reference
          -- ^ The location where the encounter takes place.
        , encounter'Location_status :: Maybe EncounterLocationStatus
          -- ^ The status of the participants' presence at the specified 
          --   location during the period specified. If the participant is 
          --   is no longer at the location, then the period will have an 
          --   end date/time.
        , encounter'Location_period :: Maybe Period
          -- ^ Time period during which the patient was present at the 
          --   location.
        }
        deriving (Eq,Show)
instance SchemaType Encounter'Location where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Encounter'Location a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "location"
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Encounter'Location{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounter'Location_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounter'Location_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter'Location_modifierExtension x
            , schemaTypeToXML "location" $ encounter'Location_location x
            , maybe [] (schemaTypeToXML "status") $ encounter'Location_status x
            , maybe [] (schemaTypeToXML "period") $ encounter'Location_period x
            ]
instance Extension Encounter'Location BackboneElement where
    supertype (Encounter'Location a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Encounter'Location Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Encounter'Location -> BackboneElement)
              
 
data EncounterLocationStatus'list
    = EncounterLocationStatus'list_Planned
      -- ^ Planned
    | EncounterLocationStatus'list_Active
      -- ^ Active
    | EncounterLocationStatus'list_Reserved
      -- ^ Reserved
    | EncounterLocationStatus'list_Completed
      -- ^ Completed
    deriving (Eq,Show,Enum)
instance SchemaType EncounterLocationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EncounterLocationStatus'list where
    acceptingParser =  do literal "planned"; return EncounterLocationStatus'list_Planned
                      `onFail` do literal "active"; return EncounterLocationStatus'list_Active
                      `onFail` do literal "reserved"; return EncounterLocationStatus'list_Reserved
                      `onFail` do literal "completed"; return EncounterLocationStatus'list_Completed
                      
    simpleTypeText EncounterLocationStatus'list_Planned = "planned"
    simpleTypeText EncounterLocationStatus'list_Active = "active"
    simpleTypeText EncounterLocationStatus'list_Reserved = "reserved"
    simpleTypeText EncounterLocationStatus'list_Completed = "completed"
 
data EncounterLocationStatus = EncounterLocationStatus
        { encounterLocationStatus_id :: Maybe String'primitive
        , encounterLocationStatus_value :: Maybe EncounterLocationStatus'list
        , encounterLocationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EncounterLocationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EncounterLocationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EncounterLocationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterLocationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ encounterLocationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterLocationStatus_extension x
            ]
instance Extension EncounterLocationStatus Element where
    supertype (EncounterLocationStatus a0 a1 e0) =
               Element a0 e0
 
data EncounterStatus'list
    = EncounterStatus'list_Planned
      -- ^ Planned
    | EncounterStatus'list_Arrived
      -- ^ Arrived
    | EncounterStatus'list_Triaged
      -- ^ Triaged
    | EncounterStatus'list_In'progress
      -- ^ In Progress
    | EncounterStatus'list_Onleave
      -- ^ On Leave
    | EncounterStatus'list_Finished
      -- ^ Finished
    | EncounterStatus'list_Cancelled
      -- ^ Cancelled
    | EncounterStatus'list_Entered'in'error
      -- ^ Entered in Error
    | EncounterStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType EncounterStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EncounterStatus'list where
    acceptingParser =  do literal "planned"; return EncounterStatus'list_Planned
                      `onFail` do literal "arrived"; return EncounterStatus'list_Arrived
                      `onFail` do literal "triaged"; return EncounterStatus'list_Triaged
                      `onFail` do literal "in-progress"; return EncounterStatus'list_In'progress
                      `onFail` do literal "onleave"; return EncounterStatus'list_Onleave
                      `onFail` do literal "finished"; return EncounterStatus'list_Finished
                      `onFail` do literal "cancelled"; return EncounterStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return EncounterStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return EncounterStatus'list_Unknown
                      
    simpleTypeText EncounterStatus'list_Planned = "planned"
    simpleTypeText EncounterStatus'list_Arrived = "arrived"
    simpleTypeText EncounterStatus'list_Triaged = "triaged"
    simpleTypeText EncounterStatus'list_In'progress = "in-progress"
    simpleTypeText EncounterStatus'list_Onleave = "onleave"
    simpleTypeText EncounterStatus'list_Finished = "finished"
    simpleTypeText EncounterStatus'list_Cancelled = "cancelled"
    simpleTypeText EncounterStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText EncounterStatus'list_Unknown = "unknown"
 
data EncounterStatus = EncounterStatus
        { encounterStatus_id :: Maybe String'primitive
        , encounterStatus_value :: Maybe EncounterStatus'list
        , encounterStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EncounterStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EncounterStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EncounterStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterStatus_id x
                       , maybe [] (toXMLAttribute "value") $ encounterStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterStatus_extension x
            ]
instance Extension EncounterStatus Element where
    supertype (EncounterStatus a0 a1 e0) =
               Element a0 e0
 
-- | The technical details of an endpoint that can be used for 
--   electronic services, such as for web services providing 
--   XDS.b or a REST endpoint for another FHIR server. This may 
--   include any security context information.
elementEndpoint :: XMLParser Endpoint
elementEndpoint = parseSchemaType "Endpoint"
elementToXMLEndpoint :: Endpoint -> [Content ()]
elementToXMLEndpoint = schemaTypeToXML "Endpoint"
 
data Endpoint = Endpoint
        { endpoint_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , endpoint_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , endpoint_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , endpoint_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , endpoint_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , endpoint_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , endpoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , endpoint_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , endpoint_identifier :: [Identifier]
          -- ^ Identifier for the organization that is used to identify 
          --   the endpoint across multiple disparate systems.
        , endpoint_status :: EndpointStatus
          -- ^ active | suspended | error | off | test.
        , endpoint_connectionType :: Coding
          -- ^ A coded value that represents the technical details of the 
          --   usage of this endpoint, such as what WSDLs should be used 
          --   in what way. (e.g. XDS.b/DICOM/cds-hook).
        , endpoint_name :: Maybe Xsd.XsdString
          -- ^ A friendly name that this endpoint can be referred to with.
        , endpoint_managingOrganization :: Maybe Reference
          -- ^ The organization that manages this endpoint (even if 
          --   technically another organisation is hosting this in the 
          --   cloud, it is the organisation associated with the data).
        , endpoint_contact :: [ContactPoint]
          -- ^ Contact details for a human to contact about the 
          --   subscription. The primary use of this for system 
          --   administrator troubleshooting.
        , endpoint_period :: Maybe Period
          -- ^ The interval during which the endpoint is expected to be 
          --   operational.
        , endpoint_payloadType :: [CodeableConcept]
          -- ^ The payload type describes the acceptable content that can 
          --   be communicated on the endpoint.
        , endpoint_payloadMimeType :: [Code]
          -- ^ The mime type to send the payload in - e.g. 
          --   application/fhir+xml, application/fhir+json. If the mime 
          --   type is not specified, then the sender could send any 
          --   content (including no content depending on the 
          --   connectionType).
        , endpoint_address :: Uri
          -- ^ The uri that describes the actual end-point to connect to.
        , endpoint_header :: [Xsd.XsdString]
          -- ^ Additional headers / information to send as part of the 
          --   notification.
        }
        deriving (Eq,Show)
instance SchemaType Endpoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Endpoint
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "connectionType"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "period")
            `apply` many1 (parseSchemaType "payloadType")
            `apply` many (parseSchemaType "payloadMimeType")
            `apply` parseSchemaType "address"
            `apply` many (parseSchemaType "header")
    schemaTypeToXML s x@Endpoint{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ endpoint_id x
            , maybe [] (schemaTypeToXML "meta") $ endpoint_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ endpoint_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ endpoint_language x
            , maybe [] (schemaTypeToXML "text") $ endpoint_text x
            , concatMap (schemaTypeToXML "contained") $ endpoint_contained x
            , concatMap (schemaTypeToXML "extension") $ endpoint_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ endpoint_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ endpoint_identifier x
            , schemaTypeToXML "status" $ endpoint_status x
            , schemaTypeToXML "connectionType" $ endpoint_connectionType x
            , maybe [] (schemaTypeToXML "name") $ endpoint_name x
            , maybe [] (schemaTypeToXML "managingOrganization") $ endpoint_managingOrganization x
            , concatMap (schemaTypeToXML "contact") $ endpoint_contact x
            , maybe [] (schemaTypeToXML "period") $ endpoint_period x
            , concatMap (schemaTypeToXML "payloadType") $ endpoint_payloadType x
            , concatMap (schemaTypeToXML "payloadMimeType") $ endpoint_payloadMimeType x
            , schemaTypeToXML "address" $ endpoint_address x
            , concatMap (schemaTypeToXML "header") $ endpoint_header x
            ]
instance Extension Endpoint DomainResource where
    supertype (Endpoint e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Endpoint Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Endpoint -> DomainResource)
              
 
data EndpointStatus'list
    = EndpointStatus'list_Active
      -- ^ Active
    | EndpointStatus'list_Suspended
      -- ^ Suspended
    | EndpointStatus'list_Error
      -- ^ Error
    | EndpointStatus'list_Off
      -- ^ Off
    | EndpointStatus'list_Entered'in'error
      -- ^ Entered in error
    | EndpointStatus'list_Test
      -- ^ Test
    deriving (Eq,Show,Enum)
instance SchemaType EndpointStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EndpointStatus'list where
    acceptingParser =  do literal "active"; return EndpointStatus'list_Active
                      `onFail` do literal "suspended"; return EndpointStatus'list_Suspended
                      `onFail` do literal "error"; return EndpointStatus'list_Error
                      `onFail` do literal "off"; return EndpointStatus'list_Off
                      `onFail` do literal "entered-in-error"; return EndpointStatus'list_Entered'in'error
                      `onFail` do literal "test"; return EndpointStatus'list_Test
                      
    simpleTypeText EndpointStatus'list_Active = "active"
    simpleTypeText EndpointStatus'list_Suspended = "suspended"
    simpleTypeText EndpointStatus'list_Error = "error"
    simpleTypeText EndpointStatus'list_Off = "off"
    simpleTypeText EndpointStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText EndpointStatus'list_Test = "test"
 
data EndpointStatus = EndpointStatus
        { endpointStatus_id :: Maybe String'primitive
        , endpointStatus_value :: Maybe EndpointStatus'list
        , endpointStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EndpointStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EndpointStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EndpointStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ endpointStatus_id x
                       , maybe [] (toXMLAttribute "value") $ endpointStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ endpointStatus_extension x
            ]
instance Extension EndpointStatus Element where
    supertype (EndpointStatus a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the insurance enrollment details to 
--   the insurer regarding a specified coverage.
elementEnrollmentRequest :: XMLParser EnrollmentRequest
elementEnrollmentRequest = parseSchemaType "EnrollmentRequest"
elementToXMLEnrollmentRequest :: EnrollmentRequest -> [Content ()]
elementToXMLEnrollmentRequest = schemaTypeToXML "EnrollmentRequest"
 
data EnrollmentRequest = EnrollmentRequest
        { enrollmentRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , enrollmentRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , enrollmentRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , enrollmentRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , enrollmentRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , enrollmentRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , enrollmentRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , enrollmentRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , enrollmentRequest_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , enrollmentRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , enrollmentRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , enrollmentRequest_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , enrollmentRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , enrollmentRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , enrollmentRequest_subject :: Maybe Reference
          -- ^ Patient Resource.
        , enrollmentRequest_coverage :: Maybe Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        }
        deriving (Eq,Show)
instance SchemaType EnrollmentRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EnrollmentRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "coverage")
    schemaTypeToXML s x@EnrollmentRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ enrollmentRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ enrollmentRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ enrollmentRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ enrollmentRequest_language x
            , maybe [] (schemaTypeToXML "text") $ enrollmentRequest_text x
            , concatMap (schemaTypeToXML "contained") $ enrollmentRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ enrollmentRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ enrollmentRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ enrollmentRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ enrollmentRequest_status x
            , maybe [] (schemaTypeToXML "created") $ enrollmentRequest_created x
            , maybe [] (schemaTypeToXML "insurer") $ enrollmentRequest_insurer x
            , maybe [] (schemaTypeToXML "provider") $ enrollmentRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ enrollmentRequest_organization x
            , maybe [] (schemaTypeToXML "subject") $ enrollmentRequest_subject x
            , maybe [] (schemaTypeToXML "coverage") $ enrollmentRequest_coverage x
            ]
instance Extension EnrollmentRequest DomainResource where
    supertype (EnrollmentRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EnrollmentRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EnrollmentRequest -> DomainResource)
              
 
-- | This resource provides enrollment and plan details from the 
--   processing of an Enrollment resource.
elementEnrollmentResponse :: XMLParser EnrollmentResponse
elementEnrollmentResponse = parseSchemaType "EnrollmentResponse"
elementToXMLEnrollmentResponse :: EnrollmentResponse -> [Content ()]
elementToXMLEnrollmentResponse = schemaTypeToXML "EnrollmentResponse"
 
data EnrollmentResponse = EnrollmentResponse
        { enrollmentResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , enrollmentResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , enrollmentResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , enrollmentResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , enrollmentResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , enrollmentResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , enrollmentResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , enrollmentResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , enrollmentResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , enrollmentResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , enrollmentResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , enrollmentResponse_outcome :: Maybe CodeableConcept
          -- ^ Processing status: error, complete.
        , enrollmentResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , enrollmentResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , enrollmentResponse_organization :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , enrollmentResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , enrollmentResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        }
        deriving (Eq,Show)
instance SchemaType EnrollmentResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EnrollmentResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
    schemaTypeToXML s x@EnrollmentResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ enrollmentResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ enrollmentResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ enrollmentResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ enrollmentResponse_language x
            , maybe [] (schemaTypeToXML "text") $ enrollmentResponse_text x
            , concatMap (schemaTypeToXML "contained") $ enrollmentResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ enrollmentResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ enrollmentResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ enrollmentResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ enrollmentResponse_status x
            , maybe [] (schemaTypeToXML "request") $ enrollmentResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ enrollmentResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ enrollmentResponse_disposition x
            , maybe [] (schemaTypeToXML "created") $ enrollmentResponse_created x
            , maybe [] (schemaTypeToXML "organization") $ enrollmentResponse_organization x
            , maybe [] (schemaTypeToXML "requestProvider") $ enrollmentResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ enrollmentResponse_requestOrganization x
            ]
instance Extension EnrollmentResponse DomainResource where
    supertype (EnrollmentResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EnrollmentResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EnrollmentResponse -> DomainResource)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
elementEpisodeOfCare :: XMLParser EpisodeOfCare
elementEpisodeOfCare = parseSchemaType "EpisodeOfCare"
elementToXMLEpisodeOfCare :: EpisodeOfCare -> [Content ()]
elementToXMLEpisodeOfCare = schemaTypeToXML "EpisodeOfCare"
 
data EpisodeOfCare = EpisodeOfCare
        { episodeOfCare_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , episodeOfCare_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , episodeOfCare_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , episodeOfCare_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , episodeOfCare_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , episodeOfCare_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , episodeOfCare_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCare_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCare_identifier :: [Identifier]
          -- ^ The EpisodeOfCare may be known by different identifiers for 
          --   different contexts of use, such as when an external agency 
          --   is tracking the Episode for funding purposes.
        , episodeOfCare_status :: EpisodeOfCareStatus
          -- ^ planned | waitlist | active | onhold | finished | 
          --   cancelled.
        , episodeOfCare_statusHistory :: [EpisodeOfCare'StatusHistory]
          -- ^ The history of statuses that the EpisodeOfCare has been 
          --   through (without requiring processing the history of the 
          --   resource).
        , episodeOfCare_type :: [CodeableConcept]
          -- ^ A classification of the type of episode of care; e.g. 
          --   specialist referral, disease management, type of funded 
          --   care.
        , episodeOfCare_diagnosis :: [EpisodeOfCare'Diagnosis]
          -- ^ The list of diagnosis relevant to this episode of care.
        , episodeOfCare_patient :: Reference
          -- ^ The patient who is the focus of this episode of care.
        , episodeOfCare_managingOrganization :: Maybe Reference
          -- ^ The organization that has assumed the specific 
          --   responsibilities for the specified duration.
        , episodeOfCare_period :: Maybe Period
          -- ^ The interval during which the managing organization assumes 
          --   the defined responsibility.
        , episodeOfCare_referralRequest :: [Reference]
          -- ^ Referral Request(s) that are fulfilled by this 
          --   EpisodeOfCare, incoming referrals.
        , episodeOfCare_careManager :: Maybe Reference
          -- ^ The practitioner that is the care manager/care co-ordinator 
          --   for this patient.
        , episodeOfCare_team :: [Reference]
          -- ^ The list of practitioners that may be facilitating this 
          --   episode of care for specific purposes.
        , episodeOfCare_account :: [Reference]
          -- ^ The set of accounts that may be used for billing for this 
          --   EpisodeOfCare.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCare where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EpisodeOfCare
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "statusHistory")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "diagnosis")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "referralRequest")
            `apply` optional (parseSchemaType "careManager")
            `apply` many (parseSchemaType "team")
            `apply` many (parseSchemaType "account")
    schemaTypeToXML s x@EpisodeOfCare{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ episodeOfCare_id x
            , maybe [] (schemaTypeToXML "meta") $ episodeOfCare_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ episodeOfCare_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ episodeOfCare_language x
            , maybe [] (schemaTypeToXML "text") $ episodeOfCare_text x
            , concatMap (schemaTypeToXML "contained") $ episodeOfCare_contained x
            , concatMap (schemaTypeToXML "extension") $ episodeOfCare_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCare_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ episodeOfCare_identifier x
            , schemaTypeToXML "status" $ episodeOfCare_status x
            , concatMap (schemaTypeToXML "statusHistory") $ episodeOfCare_statusHistory x
            , concatMap (schemaTypeToXML "type") $ episodeOfCare_type x
            , concatMap (schemaTypeToXML "diagnosis") $ episodeOfCare_diagnosis x
            , schemaTypeToXML "patient" $ episodeOfCare_patient x
            , maybe [] (schemaTypeToXML "managingOrganization") $ episodeOfCare_managingOrganization x
            , maybe [] (schemaTypeToXML "period") $ episodeOfCare_period x
            , concatMap (schemaTypeToXML "referralRequest") $ episodeOfCare_referralRequest x
            , maybe [] (schemaTypeToXML "careManager") $ episodeOfCare_careManager x
            , concatMap (schemaTypeToXML "team") $ episodeOfCare_team x
            , concatMap (schemaTypeToXML "account") $ episodeOfCare_account x
            ]
instance Extension EpisodeOfCare DomainResource where
    supertype (EpisodeOfCare e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EpisodeOfCare Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EpisodeOfCare -> DomainResource)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
data EpisodeOfCare'StatusHistory = EpisodeOfCare'StatusHistory
        { episodeOfCare'StatusHistory_id :: Maybe String'primitive
        , episodeOfCare'StatusHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCare'StatusHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCare'StatusHistory_status :: EpisodeOfCareStatus
          -- ^ planned | waitlist | active | onhold | finished | 
          --   cancelled.
        , episodeOfCare'StatusHistory_period :: Period
          -- ^ The period during this EpisodeOfCare that the specific 
          --   status applied.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCare'StatusHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EpisodeOfCare'StatusHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@EpisodeOfCare'StatusHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCare'StatusHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCare'StatusHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCare'StatusHistory_modifierExtension x
            , schemaTypeToXML "status" $ episodeOfCare'StatusHistory_status x
            , schemaTypeToXML "period" $ episodeOfCare'StatusHistory_period x
            ]
instance Extension EpisodeOfCare'StatusHistory BackboneElement where
    supertype (EpisodeOfCare'StatusHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension EpisodeOfCare'StatusHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EpisodeOfCare'StatusHistory -> BackboneElement)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
data EpisodeOfCare'Diagnosis = EpisodeOfCare'Diagnosis
        { episodeOfCare'Diagnosis_id :: Maybe String'primitive
        , episodeOfCare'Diagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCare'Diagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCare'Diagnosis_condition :: Reference
          -- ^ A list of conditions/problems/diagnoses that this episode 
          --   of care is intended to be providing care for.
        , episodeOfCare'Diagnosis_role :: Maybe CodeableConcept
          -- ^ Role that this diagnosis has within the episode of care 
          --   (e.g. admission, billing, discharge â€¦).
        , episodeOfCare'Diagnosis_rank :: Maybe PositiveInt
          -- ^ Ranking of the diagnosis (for each role type).
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCare'Diagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EpisodeOfCare'Diagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "condition"
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "rank")
    schemaTypeToXML s x@EpisodeOfCare'Diagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCare'Diagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCare'Diagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCare'Diagnosis_modifierExtension x
            , schemaTypeToXML "condition" $ episodeOfCare'Diagnosis_condition x
            , maybe [] (schemaTypeToXML "role") $ episodeOfCare'Diagnosis_role x
            , maybe [] (schemaTypeToXML "rank") $ episodeOfCare'Diagnosis_rank x
            ]
instance Extension EpisodeOfCare'Diagnosis BackboneElement where
    supertype (EpisodeOfCare'Diagnosis a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EpisodeOfCare'Diagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EpisodeOfCare'Diagnosis -> BackboneElement)
              
 
data EpisodeOfCareStatus'list
    = EpisodeOfCareStatus'list_Planned
      -- ^ Planned
    | EpisodeOfCareStatus'list_Waitlist
      -- ^ Waitlist
    | EpisodeOfCareStatus'list_Active
      -- ^ Active
    | EpisodeOfCareStatus'list_Onhold
      -- ^ On Hold
    | EpisodeOfCareStatus'list_Finished
      -- ^ Finished
    | EpisodeOfCareStatus'list_Cancelled
      -- ^ Cancelled
    | EpisodeOfCareStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType EpisodeOfCareStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EpisodeOfCareStatus'list where
    acceptingParser =  do literal "planned"; return EpisodeOfCareStatus'list_Planned
                      `onFail` do literal "waitlist"; return EpisodeOfCareStatus'list_Waitlist
                      `onFail` do literal "active"; return EpisodeOfCareStatus'list_Active
                      `onFail` do literal "onhold"; return EpisodeOfCareStatus'list_Onhold
                      `onFail` do literal "finished"; return EpisodeOfCareStatus'list_Finished
                      `onFail` do literal "cancelled"; return EpisodeOfCareStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return EpisodeOfCareStatus'list_Entered'in'error
                      
    simpleTypeText EpisodeOfCareStatus'list_Planned = "planned"
    simpleTypeText EpisodeOfCareStatus'list_Waitlist = "waitlist"
    simpleTypeText EpisodeOfCareStatus'list_Active = "active"
    simpleTypeText EpisodeOfCareStatus'list_Onhold = "onhold"
    simpleTypeText EpisodeOfCareStatus'list_Finished = "finished"
    simpleTypeText EpisodeOfCareStatus'list_Cancelled = "cancelled"
    simpleTypeText EpisodeOfCareStatus'list_Entered'in'error = "entered-in-error"
 
data EpisodeOfCareStatus = EpisodeOfCareStatus
        { episodeOfCareStatus_id :: Maybe String'primitive
        , episodeOfCareStatus_value :: Maybe EpisodeOfCareStatus'list
        , episodeOfCareStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCareStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EpisodeOfCareStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EpisodeOfCareStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCareStatus_id x
                       , maybe [] (toXMLAttribute "value") $ episodeOfCareStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCareStatus_extension x
            ]
instance Extension EpisodeOfCareStatus Element where
    supertype (EpisodeOfCareStatus a0 a1 e0) =
               Element a0 e0
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
elementExpansionProfile :: XMLParser ExpansionProfile
elementExpansionProfile = parseSchemaType "ExpansionProfile"
elementToXMLExpansionProfile :: ExpansionProfile -> [Content ()]
elementToXMLExpansionProfile = schemaTypeToXML "ExpansionProfile"
 
data ExpansionProfile = ExpansionProfile
        { expansionProfile_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , expansionProfile_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , expansionProfile_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , expansionProfile_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , expansionProfile_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , expansionProfile_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , expansionProfile_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this expansion 
          --   profile when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   expansion profile is (or will be) published. The URL SHOULD 
          --   include the major version of the expansion profile. For 
          --   more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , expansionProfile_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this expansion 
          --   profile when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , expansionProfile_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   expansion profile when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the expansion profile author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , expansionProfile_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the expansion profile. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , expansionProfile_status :: PublicationStatus
          -- ^ The status of this expansion profile. Enables tracking the 
          --   life-cycle of the content.
        , expansionProfile_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this expansion profile is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , expansionProfile_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the expansion profile 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the expansion profile changes.
        , expansionProfile_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the expansion profile.
        , expansionProfile_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , expansionProfile_description :: Maybe Markdown
          -- ^ A free text natural language description of the expansion 
          --   profile from a consumer's perspective.
        , expansionProfile_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   expansion profile instances.
        , expansionProfile_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the expansion profile 
          --   is intended to be used.
        , expansionProfile_fixedVersion :: [ExpansionProfile'FixedVersion]
          -- ^ Fix use of a particular code system to a particular 
          --   version.
        , expansionProfile_excludedSystem :: Maybe ExpansionProfile'ExcludedSystem
          -- ^ Code system, or a particular version of a code system to be 
          --   excluded from value set expansions.
        , expansionProfile_includeDesignations :: Maybe Boolean
          -- ^ Controls whether concept designations are to be included or 
          --   excluded in value set expansions.
        , expansionProfile_designation :: Maybe ExpansionProfile'Designation
          -- ^ A set of criteria that provide the constraints imposed on 
          --   the value set expansion by including or excluding 
          --   designations.
        , expansionProfile_includeDefinition :: Maybe Boolean
          -- ^ Controls whether the value set definition is included or 
          --   excluded in value set expansions.
        , expansionProfile_activeOnly :: Maybe Boolean
          -- ^ Controls whether inactive concepts are included or excluded 
          --   in value set expansions.
        , expansionProfile_excludeNested :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion nests codes 
          --   or not (i.e. ValueSet.expansion.contains.contains).
        , expansionProfile_excludeNotForUI :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion includes 
          --   codes which cannot be displayed in user interfaces.
        , expansionProfile_excludePostCoordinated :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion includes 
          --   post coordinated codes.
        , expansionProfile_displayLanguage :: Maybe Code
          -- ^ Specifies the language to be used for description in the 
          --   expansions i.e. the language to be used for 
          --   ValueSet.expansion.contains.display.
        , expansionProfile_limitedExpansion :: Maybe Boolean
          -- ^ If the value set being expanded is incomplete (because it 
          --   is too big to expand), return a limited expansion (a 
          --   subset) with an indicator that expansion is incomplete, 
          --   using the extension 
          --   [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html).
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ExpansionProfile
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "fixedVersion")
            `apply` optional (parseSchemaType "excludedSystem")
            `apply` optional (parseSchemaType "includeDesignations")
            `apply` optional (parseSchemaType "designation")
            `apply` optional (parseSchemaType "includeDefinition")
            `apply` optional (parseSchemaType "activeOnly")
            `apply` optional (parseSchemaType "excludeNested")
            `apply` optional (parseSchemaType "excludeNotForUI")
            `apply` optional (parseSchemaType "excludePostCoordinated")
            `apply` optional (parseSchemaType "displayLanguage")
            `apply` optional (parseSchemaType "limitedExpansion")
    schemaTypeToXML s x@ExpansionProfile{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ expansionProfile_id x
            , maybe [] (schemaTypeToXML "meta") $ expansionProfile_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ expansionProfile_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ expansionProfile_language x
            , maybe [] (schemaTypeToXML "text") $ expansionProfile_text x
            , concatMap (schemaTypeToXML "contained") $ expansionProfile_contained x
            , concatMap (schemaTypeToXML "extension") $ expansionProfile_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ expansionProfile_url x
            , maybe [] (schemaTypeToXML "identifier") $ expansionProfile_identifier x
            , maybe [] (schemaTypeToXML "version") $ expansionProfile_version x
            , maybe [] (schemaTypeToXML "name") $ expansionProfile_name x
            , schemaTypeToXML "status" $ expansionProfile_status x
            , maybe [] (schemaTypeToXML "experimental") $ expansionProfile_experimental x
            , maybe [] (schemaTypeToXML "date") $ expansionProfile_date x
            , maybe [] (schemaTypeToXML "publisher") $ expansionProfile_publisher x
            , concatMap (schemaTypeToXML "contact") $ expansionProfile_contact x
            , maybe [] (schemaTypeToXML "description") $ expansionProfile_description x
            , concatMap (schemaTypeToXML "useContext") $ expansionProfile_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ expansionProfile_jurisdiction x
            , concatMap (schemaTypeToXML "fixedVersion") $ expansionProfile_fixedVersion x
            , maybe [] (schemaTypeToXML "excludedSystem") $ expansionProfile_excludedSystem x
            , maybe [] (schemaTypeToXML "includeDesignations") $ expansionProfile_includeDesignations x
            , maybe [] (schemaTypeToXML "designation") $ expansionProfile_designation x
            , maybe [] (schemaTypeToXML "includeDefinition") $ expansionProfile_includeDefinition x
            , maybe [] (schemaTypeToXML "activeOnly") $ expansionProfile_activeOnly x
            , maybe [] (schemaTypeToXML "excludeNested") $ expansionProfile_excludeNested x
            , maybe [] (schemaTypeToXML "excludeNotForUI") $ expansionProfile_excludeNotForUI x
            , maybe [] (schemaTypeToXML "excludePostCoordinated") $ expansionProfile_excludePostCoordinated x
            , maybe [] (schemaTypeToXML "displayLanguage") $ expansionProfile_displayLanguage x
            , maybe [] (schemaTypeToXML "limitedExpansion") $ expansionProfile_limitedExpansion x
            ]
instance Extension ExpansionProfile DomainResource where
    supertype (ExpansionProfile e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ExpansionProfile Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ExpansionProfile -> DomainResource)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'FixedVersion = ExpansionProfile'FixedVersion
        { expansionProfile'FixedVersion_id :: Maybe String'primitive
        , expansionProfile'FixedVersion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'FixedVersion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'FixedVersion_system :: Uri
          -- ^ The specific system for which to fix the version.
        , expansionProfile'FixedVersion_version :: Xsd.XsdString
          -- ^ The version of the code system from which codes in the 
          --   expansion should be included.
        , expansionProfile'FixedVersion_mode :: SystemVersionProcessingMode
          -- ^ How to manage the intersection between a fixed version in a 
          --   value set, and this fixed version of the system in the 
          --   expansion profile.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'FixedVersion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'FixedVersion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "system"
            `apply` parseSchemaType "version"
            `apply` parseSchemaType "mode"
    schemaTypeToXML s x@ExpansionProfile'FixedVersion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'FixedVersion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'FixedVersion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'FixedVersion_modifierExtension x
            , schemaTypeToXML "system" $ expansionProfile'FixedVersion_system x
            , schemaTypeToXML "version" $ expansionProfile'FixedVersion_version x
            , schemaTypeToXML "mode" $ expansionProfile'FixedVersion_mode x
            ]
instance Extension ExpansionProfile'FixedVersion BackboneElement where
    supertype (ExpansionProfile'FixedVersion a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'FixedVersion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'FixedVersion -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'ExcludedSystem = ExpansionProfile'ExcludedSystem
        { expansionProfile'ExcludedSystem_id :: Maybe String'primitive
        , expansionProfile'ExcludedSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'ExcludedSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'ExcludedSystem_system :: Uri
          -- ^ An absolute URI which is the code system to be excluded.
        , expansionProfile'ExcludedSystem_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system from which codes in the 
          --   expansion should be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'ExcludedSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'ExcludedSystem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "system"
            `apply` optional (parseSchemaType "version")
    schemaTypeToXML s x@ExpansionProfile'ExcludedSystem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'ExcludedSystem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'ExcludedSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'ExcludedSystem_modifierExtension x
            , schemaTypeToXML "system" $ expansionProfile'ExcludedSystem_system x
            , maybe [] (schemaTypeToXML "version") $ expansionProfile'ExcludedSystem_version x
            ]
instance Extension ExpansionProfile'ExcludedSystem BackboneElement where
    supertype (ExpansionProfile'ExcludedSystem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'ExcludedSystem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'ExcludedSystem -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'Designation = ExpansionProfile'Designation
        { expansionProfile'Designation_id :: Maybe String'primitive
        , expansionProfile'Designation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'Designation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'Designation_include :: Maybe ExpansionProfile'Include
          -- ^ Designations to be included.
        , expansionProfile'Designation_exclude :: Maybe ExpansionProfile'Exclude
          -- ^ Designations to be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'Designation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'Designation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "include")
            `apply` optional (parseSchemaType "exclude")
    schemaTypeToXML s x@ExpansionProfile'Designation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'Designation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'Designation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'Designation_modifierExtension x
            , maybe [] (schemaTypeToXML "include") $ expansionProfile'Designation_include x
            , maybe [] (schemaTypeToXML "exclude") $ expansionProfile'Designation_exclude x
            ]
instance Extension ExpansionProfile'Designation BackboneElement where
    supertype (ExpansionProfile'Designation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'Designation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'Designation -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'Include = ExpansionProfile'Include
        { expansionProfile'Include_id :: Maybe String'primitive
        , expansionProfile'Include_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'Include_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'Include_designation :: [ExpansionProfile'Designation1]
          -- ^ A data group for each designation to be included.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'Include where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'Include a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ExpansionProfile'Include{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'Include_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'Include_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'Include_modifierExtension x
            , concatMap (schemaTypeToXML "designation") $ expansionProfile'Include_designation x
            ]
instance Extension ExpansionProfile'Include BackboneElement where
    supertype (ExpansionProfile'Include a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'Include Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'Include -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'Designation1 = ExpansionProfile'Designation1
        { expansionProfile'Designation1_id :: Maybe String'primitive
        , expansionProfile'Designation1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'Designation1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'Designation1_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , expansionProfile'Designation1_use :: Maybe Coding
          -- ^ Which kinds of designation to include in the expansion.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'Designation1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'Designation1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
    schemaTypeToXML s x@ExpansionProfile'Designation1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'Designation1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'Designation1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'Designation1_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ expansionProfile'Designation1_language x
            , maybe [] (schemaTypeToXML "use") $ expansionProfile'Designation1_use x
            ]
instance Extension ExpansionProfile'Designation1 BackboneElement where
    supertype (ExpansionProfile'Designation1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'Designation1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'Designation1 -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'Exclude = ExpansionProfile'Exclude
        { expansionProfile'Exclude_id :: Maybe String'primitive
        , expansionProfile'Exclude_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'Exclude_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'Exclude_designation :: [ExpansionProfile'Designation2]
          -- ^ A data group for each designation to be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'Exclude where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'Exclude a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ExpansionProfile'Exclude{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'Exclude_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'Exclude_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'Exclude_modifierExtension x
            , concatMap (schemaTypeToXML "designation") $ expansionProfile'Exclude_designation x
            ]
instance Extension ExpansionProfile'Exclude BackboneElement where
    supertype (ExpansionProfile'Exclude a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'Exclude Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'Exclude -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfile'Designation2 = ExpansionProfile'Designation2
        { expansionProfile'Designation2_id :: Maybe String'primitive
        , expansionProfile'Designation2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile'Designation2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile'Designation2_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , expansionProfile'Designation2_use :: Maybe Coding
          -- ^ Which kinds of designation to exclude from the expansion.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile'Designation2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfile'Designation2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
    schemaTypeToXML s x@ExpansionProfile'Designation2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfile'Designation2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfile'Designation2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile'Designation2_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ expansionProfile'Designation2_language x
            , maybe [] (schemaTypeToXML "use") $ expansionProfile'Designation2_use x
            ]
instance Extension ExpansionProfile'Designation2 BackboneElement where
    supertype (ExpansionProfile'Designation2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfile'Designation2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfile'Designation2 -> BackboneElement)
              
 
data SystemVersionProcessingMode'list
    = SystemVersionProcessingMode'list_Default
      -- ^ Default Version
    | SystemVersionProcessingMode'list_Check
      -- ^ Check ValueSet Version
    | SystemVersionProcessingMode'list_Override
      -- ^ Override ValueSet Version
    deriving (Eq,Show,Enum)
instance SchemaType SystemVersionProcessingMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SystemVersionProcessingMode'list where
    acceptingParser =  do literal "default"; return SystemVersionProcessingMode'list_Default
                      `onFail` do literal "check"; return SystemVersionProcessingMode'list_Check
                      `onFail` do literal "override"; return SystemVersionProcessingMode'list_Override
                      
    simpleTypeText SystemVersionProcessingMode'list_Default = "default"
    simpleTypeText SystemVersionProcessingMode'list_Check = "check"
    simpleTypeText SystemVersionProcessingMode'list_Override = "override"
 
data SystemVersionProcessingMode = SystemVersionProcessingMode
        { systemVersionProcessingMode_id :: Maybe String'primitive
        , systemVersionProcessingMode_value :: Maybe SystemVersionProcessingMode'list
        , systemVersionProcessingMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SystemVersionProcessingMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SystemVersionProcessingMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SystemVersionProcessingMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ systemVersionProcessingMode_id x
                       , maybe [] (toXMLAttribute "value") $ systemVersionProcessingMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ systemVersionProcessingMode_extension x
            ]
instance Extension SystemVersionProcessingMode Element where
    supertype (SystemVersionProcessingMode a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
elementExplanationOfBenefit :: XMLParser ExplanationOfBenefit
elementExplanationOfBenefit = parseSchemaType "ExplanationOfBenefit"
elementToXMLExplanationOfBenefit :: ExplanationOfBenefit -> [Content ()]
elementToXMLExplanationOfBenefit = schemaTypeToXML "ExplanationOfBenefit"
 
data ExplanationOfBenefit = ExplanationOfBenefit
        { explanationOfBenefit_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , explanationOfBenefit_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , explanationOfBenefit_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , explanationOfBenefit_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , explanationOfBenefit_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , explanationOfBenefit_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , explanationOfBenefit_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit_identifier :: [Identifier]
          -- ^ The EOB Business Identifier.
        , explanationOfBenefit_status :: Maybe ExplanationOfBenefitStatus
          -- ^ The status of the resource instance.
        , explanationOfBenefit_type :: Maybe CodeableConcept
          -- ^ The category of claim, eg, oral, pharmacy, vision, 
          --   insitutional, professional.
        , explanationOfBenefit_subType :: [CodeableConcept]
          -- ^ A finer grained suite of claim subtype codes which may 
          --   convey Inpatient vs Outpatient and/or a specialty service. 
          --   In the US the BillType.
        , explanationOfBenefit_patient :: Maybe Reference
          -- ^ Patient Resource.
        , explanationOfBenefit_billablePeriod :: Maybe Period
          -- ^ The billable period for which charges are being submitted.
        , explanationOfBenefit_created :: Maybe DateTime
          -- ^ The date when the EOB was created.
        , explanationOfBenefit_enterer :: Maybe Reference
          -- ^ The person who created the explanation of benefit.
        , explanationOfBenefit_insurer :: Maybe Reference
          -- ^ The insurer which is responsible for the explanation of 
          --   benefit.
        , explanationOfBenefit_provider :: Maybe Reference
          -- ^ The provider which is responsible for the claim.
        , explanationOfBenefit_organization :: Maybe Reference
          -- ^ The provider which is responsible for the claim.
        , explanationOfBenefit_referral :: Maybe Reference
          -- ^ The referral resource which lists the date, practitioner, 
          --   reason and other supporting information.
        , explanationOfBenefit_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , explanationOfBenefit_claim :: Maybe Reference
          -- ^ The business identifier for the instance: invoice number, 
          --   claim number, pre-determination or pre-authorization 
          --   number.
        , explanationOfBenefit_claimResponse :: Maybe Reference
          -- ^ The business identifier for the instance: invoice number, 
          --   claim number, pre-determination or pre-authorization 
          --   number.
        , explanationOfBenefit_outcome :: Maybe CodeableConcept
          -- ^ Processing outcome errror, partial or complete processing.
        , explanationOfBenefit_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , explanationOfBenefit_related :: [ExplanationOfBenefit'Related]
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , explanationOfBenefit_prescription :: Maybe Reference
          -- ^ Prescription to support the dispensing of Pharmacy or 
          --   Vision products.
        , explanationOfBenefit_originalPrescription :: Maybe Reference
          -- ^ Original prescription which has been superceded by this 
          --   prescription to support the dispensing of pharmacy 
          --   services, medications or products. For example, a physician 
          --   may prescribe a medication which the pharmacy determines is 
          --   contraindicated, or for which the patient has an 
          --   intolerance, and therefor issues a new precription for an 
          --   alternate medication which has the same theraputic intent. 
          --   The prescription from the pharmacy becomes the 
          --   'prescription' and that from the physician becomes the 
          --   'original prescription'.
        , explanationOfBenefit_payee :: Maybe ExplanationOfBenefit'Payee
          -- ^ The party to be reimbursed for the services.
        , explanationOfBenefit_information :: [ExplanationOfBenefit'Information]
          -- ^ Additional information codes regarding exceptions, special 
          --   considerations, the condition, situation, prior or 
          --   concurrent issues. Often there are mutiple jurisdiction 
          --   specific valuesets which are required.
        , explanationOfBenefit_careTeam :: [ExplanationOfBenefit'CareTeam]
          -- ^ The members of the team who provided the overall service as 
          --   well as their role and whether responsible and 
          --   qualifications.
        , explanationOfBenefit_diagnosis :: [ExplanationOfBenefit'Diagnosis]
          -- ^ Ordered list of patient diagnosis for which care is sought.
        , explanationOfBenefit_procedure :: [ExplanationOfBenefit'Procedure]
          -- ^ Ordered list of patient procedures performed to support the 
          --   adjudication.
        , explanationOfBenefit_precedence :: Maybe PositiveInt
          -- ^ Precedence (primary, secondary, etc.).
        , explanationOfBenefit_insurance :: Maybe ExplanationOfBenefit'Insurance
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , explanationOfBenefit_accident :: Maybe ExplanationOfBenefit'Accident
          -- ^ An accident which resulted in the need for healthcare 
          --   services.
        , explanationOfBenefit_employmentImpacted :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   precluded from working due to the treatable condition(s).
        , explanationOfBenefit_hospitalization :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   confined to a treatment center.
        , explanationOfBenefit_item :: [ExplanationOfBenefit'Item]
          -- ^ First tier of goods and services.
        , explanationOfBenefit_addItem :: [ExplanationOfBenefit'AddItem]
          -- ^ The first tier service adjudications for payor added 
          --   services.
        , explanationOfBenefit_totalCost :: Maybe Money
          -- ^ The total cost of the services reported.
        , explanationOfBenefit_unallocDeductable :: Maybe Money
          -- ^ The amount of deductable applied which was not allocated to 
          --   any particular service line.
        , explanationOfBenefit_totalBenefit :: Maybe Money
          -- ^ Total amount of benefit payable (Equal to sum of the 
          --   Benefit amounts from all detail lines and additions less 
          --   the Unallocated Deductable).
        , explanationOfBenefit_payment :: Maybe ExplanationOfBenefit'Payment
          -- ^ Payment details for the claim if the claim has been paid.
        , explanationOfBenefit_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , explanationOfBenefit_processNote :: [ExplanationOfBenefit'ProcessNote]
          -- ^ Note text.
        , explanationOfBenefit_benefitBalance :: [ExplanationOfBenefit'BenefitBalance]
          -- ^ Balance by Benefit Category.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ExplanationOfBenefit
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "billablePeriod")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "referral")
            `apply` optional (parseSchemaType "facility")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "claimResponse")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` many (parseSchemaType "related")
            `apply` optional (parseSchemaType "prescription")
            `apply` optional (parseSchemaType "originalPrescription")
            `apply` optional (parseSchemaType "payee")
            `apply` many (parseSchemaType "information")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "procedure")
            `apply` optional (parseSchemaType "precedence")
            `apply` optional (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "accident")
            `apply` optional (parseSchemaType "employmentImpacted")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "addItem")
            `apply` optional (parseSchemaType "totalCost")
            `apply` optional (parseSchemaType "unallocDeductable")
            `apply` optional (parseSchemaType "totalBenefit")
            `apply` optional (parseSchemaType "payment")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "benefitBalance")
    schemaTypeToXML s x@ExplanationOfBenefit{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ explanationOfBenefit_id x
            , maybe [] (schemaTypeToXML "meta") $ explanationOfBenefit_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ explanationOfBenefit_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ explanationOfBenefit_language x
            , maybe [] (schemaTypeToXML "text") $ explanationOfBenefit_text x
            , concatMap (schemaTypeToXML "contained") $ explanationOfBenefit_contained x
            , concatMap (schemaTypeToXML "extension") $ explanationOfBenefit_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ explanationOfBenefit_identifier x
            , maybe [] (schemaTypeToXML "status") $ explanationOfBenefit_status x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit_type x
            , concatMap (schemaTypeToXML "subType") $ explanationOfBenefit_subType x
            , maybe [] (schemaTypeToXML "patient") $ explanationOfBenefit_patient x
            , maybe [] (schemaTypeToXML "billablePeriod") $ explanationOfBenefit_billablePeriod x
            , maybe [] (schemaTypeToXML "created") $ explanationOfBenefit_created x
            , maybe [] (schemaTypeToXML "enterer") $ explanationOfBenefit_enterer x
            , maybe [] (schemaTypeToXML "insurer") $ explanationOfBenefit_insurer x
            , maybe [] (schemaTypeToXML "provider") $ explanationOfBenefit_provider x
            , maybe [] (schemaTypeToXML "organization") $ explanationOfBenefit_organization x
            , maybe [] (schemaTypeToXML "referral") $ explanationOfBenefit_referral x
            , maybe [] (schemaTypeToXML "facility") $ explanationOfBenefit_facility x
            , maybe [] (schemaTypeToXML "claim") $ explanationOfBenefit_claim x
            , maybe [] (schemaTypeToXML "claimResponse") $ explanationOfBenefit_claimResponse x
            , maybe [] (schemaTypeToXML "outcome") $ explanationOfBenefit_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ explanationOfBenefit_disposition x
            , concatMap (schemaTypeToXML "related") $ explanationOfBenefit_related x
            , maybe [] (schemaTypeToXML "prescription") $ explanationOfBenefit_prescription x
            , maybe [] (schemaTypeToXML "originalPrescription") $ explanationOfBenefit_originalPrescription x
            , maybe [] (schemaTypeToXML "payee") $ explanationOfBenefit_payee x
            , concatMap (schemaTypeToXML "information") $ explanationOfBenefit_information x
            , concatMap (schemaTypeToXML "careTeam") $ explanationOfBenefit_careTeam x
            , concatMap (schemaTypeToXML "diagnosis") $ explanationOfBenefit_diagnosis x
            , concatMap (schemaTypeToXML "procedure") $ explanationOfBenefit_procedure x
            , maybe [] (schemaTypeToXML "precedence") $ explanationOfBenefit_precedence x
            , maybe [] (schemaTypeToXML "insurance") $ explanationOfBenefit_insurance x
            , maybe [] (schemaTypeToXML "accident") $ explanationOfBenefit_accident x
            , maybe [] (schemaTypeToXML "employmentImpacted") $ explanationOfBenefit_employmentImpacted x
            , maybe [] (schemaTypeToXML "hospitalization") $ explanationOfBenefit_hospitalization x
            , concatMap (schemaTypeToXML "item") $ explanationOfBenefit_item x
            , concatMap (schemaTypeToXML "addItem") $ explanationOfBenefit_addItem x
            , maybe [] (schemaTypeToXML "totalCost") $ explanationOfBenefit_totalCost x
            , maybe [] (schemaTypeToXML "unallocDeductable") $ explanationOfBenefit_unallocDeductable x
            , maybe [] (schemaTypeToXML "totalBenefit") $ explanationOfBenefit_totalBenefit x
            , maybe [] (schemaTypeToXML "payment") $ explanationOfBenefit_payment x
            , maybe [] (schemaTypeToXML "form") $ explanationOfBenefit_form x
            , concatMap (schemaTypeToXML "processNote") $ explanationOfBenefit_processNote x
            , concatMap (schemaTypeToXML "benefitBalance") $ explanationOfBenefit_benefitBalance x
            ]
instance Extension ExplanationOfBenefit DomainResource where
    supertype (ExplanationOfBenefit e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41 e42 e43 e44 e45 e46) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ExplanationOfBenefit Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ExplanationOfBenefit -> DomainResource)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Related = ExplanationOfBenefit'Related
        { explanationOfBenefit'Related_id :: Maybe String'primitive
        , explanationOfBenefit'Related_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Related_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Related_claim :: Maybe Reference
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , explanationOfBenefit'Related_relationship :: Maybe CodeableConcept
          -- ^ For example prior or umbrella.
        , explanationOfBenefit'Related_reference :: Maybe Identifier
          -- ^ An alternate organizational reference to the case or file 
          --   to which this particular claim pertains - eg 
          --   Property/Casualy insurer claim # or Workers Compensation 
          --   case # .
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Related where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Related a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "reference")
    schemaTypeToXML s x@ExplanationOfBenefit'Related{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Related_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Related_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Related_modifierExtension x
            , maybe [] (schemaTypeToXML "claim") $ explanationOfBenefit'Related_claim x
            , maybe [] (schemaTypeToXML "relationship") $ explanationOfBenefit'Related_relationship x
            , maybe [] (schemaTypeToXML "reference") $ explanationOfBenefit'Related_reference x
            ]
instance Extension ExplanationOfBenefit'Related BackboneElement where
    supertype (ExplanationOfBenefit'Related a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Related Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Related -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Payee = ExplanationOfBenefit'Payee
        { explanationOfBenefit'Payee_id :: Maybe String'primitive
        , explanationOfBenefit'Payee_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Payee_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Payee_type :: Maybe CodeableConcept
          -- ^ Type of Party to be reimbursed: Subscriber, provider, 
          --   other.
        , explanationOfBenefit'Payee_resourceType :: Maybe CodeableConcept
          -- ^ organization | patient | practitioner | relatedperson.
        , explanationOfBenefit'Payee_party :: Maybe Reference
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Payee where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Payee a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "resourceType")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@ExplanationOfBenefit'Payee{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Payee_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Payee_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Payee_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit'Payee_type x
            , maybe [] (schemaTypeToXML "resourceType") $ explanationOfBenefit'Payee_resourceType x
            , maybe [] (schemaTypeToXML "party") $ explanationOfBenefit'Payee_party x
            ]
instance Extension ExplanationOfBenefit'Payee BackboneElement where
    supertype (ExplanationOfBenefit'Payee a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Payee Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Payee -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Information = ExplanationOfBenefit'Information
        { explanationOfBenefit'Information_id :: Maybe String'primitive
        , explanationOfBenefit'Information_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Information_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Information_sequence :: PositiveInt
          -- ^ Sequence of the information element which serves to provide 
          --   a link.
        , explanationOfBenefit'Information_category :: CodeableConcept
          -- ^ The general class of the information supplied: information; 
          --   exception; accident, employment; onset, etc.
        , explanationOfBenefit'Information_code :: Maybe CodeableConcept
          -- ^ System and code pertaining to the specific information 
          --   regarding special conditions relating to the setting, 
          --   treatment or patient for which care is sought which may 
          --   influence the adjudication.
        , explanationOfBenefit'Information_choice5 :: (Maybe (OneOf2 Date Period))
          -- ^ The date when or period to which this information refers.
          --   
          --   Choice between:
          --   
          --   (1) timingDate
          --   
          --   (2) timingPeriod
        , explanationOfBenefit'Information_choice6 :: (Maybe (OneOf4 Xsd.XsdString Quantity Attachment Reference))
          -- ^ Additional data or information such as resources, 
          --   documents, images etc. including references to the data or 
          --   the actual inclusion of the data.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueAttachment
          --   
          --   (4) valueReference
        , explanationOfBenefit'Information_reason :: Maybe Coding
          -- ^ For example, provides the reason for: the additional stay, 
          --   or missing tooth or any other situation where a reason code 
          --   is required in addition to the content.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Information where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Information a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "timingDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timingPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf4 (parseSchemaType "valueString"))
                                     , ("Quantity", fmap TwoOf4 (parseSchemaType "valueQuantity"))
                                     , ("Attachment", fmap ThreeOf4 (parseSchemaType "valueAttachment"))
                                     , ("Reference", fmap FourOf4 (parseSchemaType "valueReference"))
                                     ])
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@ExplanationOfBenefit'Information{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Information_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Information_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Information_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'Information_sequence x
            , schemaTypeToXML "category" $ explanationOfBenefit'Information_category x
            , maybe [] (schemaTypeToXML "code") $ explanationOfBenefit'Information_code x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timingDate")
                                    (schemaTypeToXML "timingPeriod")
                                   ) $ explanationOfBenefit'Information_choice5 x
            , maybe [] (foldOneOf4  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueQuantity")
                                    (schemaTypeToXML "valueAttachment")
                                    (schemaTypeToXML "valueReference")
                                   ) $ explanationOfBenefit'Information_choice6 x
            , maybe [] (schemaTypeToXML "reason") $ explanationOfBenefit'Information_reason x
            ]
instance Extension ExplanationOfBenefit'Information BackboneElement where
    supertype (ExplanationOfBenefit'Information a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Information Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Information -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'CareTeam = ExplanationOfBenefit'CareTeam
        { explanationOfBenefit'CareTeam_id :: Maybe String'primitive
        , explanationOfBenefit'CareTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'CareTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'CareTeam_sequence :: PositiveInt
          -- ^ Sequence of careteam which serves to order and provide a 
          --   link.
        , explanationOfBenefit'CareTeam_provider :: Reference
          -- ^ The members of the team who provided the overall service.
        , explanationOfBenefit'CareTeam_responsible :: Maybe Boolean
          -- ^ The practitioner who is billing and responsible for the 
          --   claimed services rendered to the patient.
        , explanationOfBenefit'CareTeam_role :: Maybe CodeableConcept
          -- ^ The lead, assisting or supervising practitioner and their 
          --   discipline if a multidisiplinary team.
        , explanationOfBenefit'CareTeam_qualification :: Maybe CodeableConcept
          -- ^ The qualification which is applicable for this service.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'CareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'CareTeam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "provider"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "qualification")
    schemaTypeToXML s x@ExplanationOfBenefit'CareTeam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'CareTeam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'CareTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'CareTeam_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'CareTeam_sequence x
            , schemaTypeToXML "provider" $ explanationOfBenefit'CareTeam_provider x
            , maybe [] (schemaTypeToXML "responsible") $ explanationOfBenefit'CareTeam_responsible x
            , maybe [] (schemaTypeToXML "role") $ explanationOfBenefit'CareTeam_role x
            , maybe [] (schemaTypeToXML "qualification") $ explanationOfBenefit'CareTeam_qualification x
            ]
instance Extension ExplanationOfBenefit'CareTeam BackboneElement where
    supertype (ExplanationOfBenefit'CareTeam a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'CareTeam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'CareTeam -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Diagnosis = ExplanationOfBenefit'Diagnosis
        { explanationOfBenefit'Diagnosis_id :: Maybe String'primitive
        , explanationOfBenefit'Diagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Diagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Diagnosis_sequence :: PositiveInt
          -- ^ Sequence of diagnosis which serves to provide a link.
        , explanationOfBenefit'Diagnosis_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ The diagnosis.
          --   
          --   Choice between:
          --   
          --   (1) diagnosisCodeableConcept
          --   
          --   (2) diagnosisReference
        , explanationOfBenefit'Diagnosis_type :: [CodeableConcept]
          -- ^ The type of the Diagnosis, for example: admitting, primary, 
          --   secondary, discharge.
        , explanationOfBenefit'Diagnosis_packageCode :: Maybe CodeableConcept
          -- ^ The package billing code, for example DRG, based on the 
          --   assigned grouping code system.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Diagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Diagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "diagnosisCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "diagnosisReference"))
                           ]
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "packageCode")
    schemaTypeToXML s x@ExplanationOfBenefit'Diagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Diagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Diagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Diagnosis_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'Diagnosis_sequence x
            , foldOneOf2  (schemaTypeToXML "diagnosisCodeableConcept")
                          (schemaTypeToXML "diagnosisReference")
                          $ explanationOfBenefit'Diagnosis_choice3 x
            , concatMap (schemaTypeToXML "type") $ explanationOfBenefit'Diagnosis_type x
            , maybe [] (schemaTypeToXML "packageCode") $ explanationOfBenefit'Diagnosis_packageCode x
            ]
instance Extension ExplanationOfBenefit'Diagnosis BackboneElement where
    supertype (ExplanationOfBenefit'Diagnosis a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Diagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Diagnosis -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Procedure = ExplanationOfBenefit'Procedure
        { explanationOfBenefit'Procedure_id :: Maybe String'primitive
        , explanationOfBenefit'Procedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Procedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Procedure_sequence :: PositiveInt
          -- ^ Sequence of procedures which serves to order and provide a 
          --   link.
        , explanationOfBenefit'Procedure_date :: Maybe DateTime
          -- ^ Date and optionally time the procedure was performed .
        , explanationOfBenefit'Procedure_choice4 :: OneOf2 CodeableConcept Reference
          -- ^ The procedure code.
          --   
          --   Choice between:
          --   
          --   (1) procedureCodeableConcept
          --   
          --   (2) procedureReference
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Procedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Procedure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "date")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "procedureCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "procedureReference"))
                           ]
    schemaTypeToXML s x@ExplanationOfBenefit'Procedure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Procedure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Procedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Procedure_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'Procedure_sequence x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefit'Procedure_date x
            , foldOneOf2  (schemaTypeToXML "procedureCodeableConcept")
                          (schemaTypeToXML "procedureReference")
                          $ explanationOfBenefit'Procedure_choice4 x
            ]
instance Extension ExplanationOfBenefit'Procedure BackboneElement where
    supertype (ExplanationOfBenefit'Procedure a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Procedure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Procedure -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Insurance = ExplanationOfBenefit'Insurance
        { explanationOfBenefit'Insurance_id :: Maybe String'primitive
        , explanationOfBenefit'Insurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Insurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Insurance_coverage :: Maybe Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , explanationOfBenefit'Insurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Insurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Insurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "coverage")
            `apply` many (parseSchemaType "preAuthRef")
    schemaTypeToXML s x@ExplanationOfBenefit'Insurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Insurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Insurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Insurance_modifierExtension x
            , maybe [] (schemaTypeToXML "coverage") $ explanationOfBenefit'Insurance_coverage x
            , concatMap (schemaTypeToXML "preAuthRef") $ explanationOfBenefit'Insurance_preAuthRef x
            ]
instance Extension ExplanationOfBenefit'Insurance BackboneElement where
    supertype (ExplanationOfBenefit'Insurance a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Insurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Insurance -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Accident = ExplanationOfBenefit'Accident
        { explanationOfBenefit'Accident_id :: Maybe String'primitive
        , explanationOfBenefit'Accident_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Accident_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Accident_date :: Maybe Date
          -- ^ Date of an accident which these services are addressing.
        , explanationOfBenefit'Accident_type :: Maybe CodeableConcept
          -- ^ Type of accident: work, auto, etc.
        , explanationOfBenefit'Accident_choice4 :: (Maybe (OneOf2 Address Reference))
          -- ^ Where the accident occurred.
          --   
          --   Choice between:
          --   
          --   (1) locationAddress
          --   
          --   (2) locationReference
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Accident where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Accident a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Address", fmap OneOf2 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "locationReference"))
                                     ])
    schemaTypeToXML s x@ExplanationOfBenefit'Accident{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Accident_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Accident_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Accident_modifierExtension x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefit'Accident_date x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit'Accident_type x
            , maybe [] (foldOneOf2  (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ explanationOfBenefit'Accident_choice4 x
            ]
instance Extension ExplanationOfBenefit'Accident BackboneElement where
    supertype (ExplanationOfBenefit'Accident a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Accident Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Accident -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Item = ExplanationOfBenefit'Item
        { explanationOfBenefit'Item_id :: Maybe String'primitive
        , explanationOfBenefit'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Item_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefit'Item_careTeamLinkId :: [PositiveInt]
          -- ^ Careteam applicable for this service or product line.
        , explanationOfBenefit'Item_diagnosisLinkId :: [PositiveInt]
          -- ^ Diagnosis applicable for this service or product line.
        , explanationOfBenefit'Item_procedureLinkId :: [PositiveInt]
          -- ^ Procedures applicable for this service or product line.
        , explanationOfBenefit'Item_informationLinkId :: [PositiveInt]
          -- ^ Exceptions, special conditions and supporting information 
          --   pplicable for this service or product line.
        , explanationOfBenefit'Item_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefit'Item_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefit'Item_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefit'Item_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefit'Item_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefit'Item_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , explanationOfBenefit'Item_choice13 :: (Maybe (OneOf3 CodeableConcept Address Reference))
          -- ^ Where the service was provided.
          --   
          --   Choice between:
          --   
          --   (1) locationCodeableConcept
          --   
          --   (2) locationAddress
          --   
          --   (3) locationReference
        , explanationOfBenefit'Item_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefit'Item_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , explanationOfBenefit'Item_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefit'Item_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefit'Item_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefit'Item_bodySite :: Maybe CodeableConcept
          -- ^ Physical service site on the patient (limb, tooth, etc).
        , explanationOfBenefit'Item_subSite :: [CodeableConcept]
          -- ^ A region or surface of the site, eg. limb region or tooth 
          --   surface(s).
        , explanationOfBenefit'Item_encounter :: [Reference]
          -- ^ A billed item may include goods or services provided in 
          --   multiple encounters.
        , explanationOfBenefit'Item_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefit'Item_adjudication :: [ExplanationOfBenefit'Adjudication]
          -- ^ The adjudications results.
        , explanationOfBenefit'Item_detail :: [ExplanationOfBenefit'Detail]
          -- ^ Second tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` many (parseSchemaType "careTeamLinkId")
            `apply` many (parseSchemaType "diagnosisLinkId")
            `apply` many (parseSchemaType "procedureLinkId")
            `apply` many (parseSchemaType "informationLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf3 (parseSchemaType "locationCodeableConcept"))
                                     , ("Address", fmap TwoOf3 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "locationReference"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "subSite")
            `apply` many (parseSchemaType "encounter")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ExplanationOfBenefit'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Item_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'Item_sequence x
            , concatMap (schemaTypeToXML "careTeamLinkId") $ explanationOfBenefit'Item_careTeamLinkId x
            , concatMap (schemaTypeToXML "diagnosisLinkId") $ explanationOfBenefit'Item_diagnosisLinkId x
            , concatMap (schemaTypeToXML "procedureLinkId") $ explanationOfBenefit'Item_procedureLinkId x
            , concatMap (schemaTypeToXML "informationLinkId") $ explanationOfBenefit'Item_informationLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefit'Item_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefit'Item_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefit'Item_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefit'Item_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefit'Item_programCode x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ explanationOfBenefit'Item_choice12 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "locationCodeableConcept")
                                    (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ explanationOfBenefit'Item_choice13 x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefit'Item_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefit'Item_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefit'Item_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefit'Item_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefit'Item_udi x
            , maybe [] (schemaTypeToXML "bodySite") $ explanationOfBenefit'Item_bodySite x
            , concatMap (schemaTypeToXML "subSite") $ explanationOfBenefit'Item_subSite x
            , concatMap (schemaTypeToXML "encounter") $ explanationOfBenefit'Item_encounter x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefit'Item_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefit'Item_adjudication x
            , concatMap (schemaTypeToXML "detail") $ explanationOfBenefit'Item_detail x
            ]
instance Extension ExplanationOfBenefit'Item BackboneElement where
    supertype (ExplanationOfBenefit'Item a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Item -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Adjudication = ExplanationOfBenefit'Adjudication
        { explanationOfBenefit'Adjudication_id :: Maybe String'primitive
        , explanationOfBenefit'Adjudication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Adjudication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Adjudication_category :: CodeableConcept
          -- ^ Code indicating: Co-Pay, deductable, elegible, benefit, 
          --   tax, etc.
        , explanationOfBenefit'Adjudication_reason :: Maybe CodeableConcept
          -- ^ Adjudication reason such as limit reached.
        , explanationOfBenefit'Adjudication_amount :: Maybe Money
          -- ^ Monitory amount associated with the code.
        , explanationOfBenefit'Adjudication_value :: Maybe Decimal
          -- ^ A non-monetary value for example a percentage. Mutually 
          --   exclusive to the amount element above.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Adjudication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Adjudication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@ExplanationOfBenefit'Adjudication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Adjudication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Adjudication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Adjudication_modifierExtension x
            , schemaTypeToXML "category" $ explanationOfBenefit'Adjudication_category x
            , maybe [] (schemaTypeToXML "reason") $ explanationOfBenefit'Adjudication_reason x
            , maybe [] (schemaTypeToXML "amount") $ explanationOfBenefit'Adjudication_amount x
            , maybe [] (schemaTypeToXML "value") $ explanationOfBenefit'Adjudication_value x
            ]
instance Extension ExplanationOfBenefit'Adjudication BackboneElement where
    supertype (ExplanationOfBenefit'Adjudication a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Adjudication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Adjudication -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Detail = ExplanationOfBenefit'Detail
        { explanationOfBenefit'Detail_id :: Maybe String'primitive
        , explanationOfBenefit'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Detail_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefit'Detail_type :: CodeableConcept
          -- ^ The type of product or service.
        , explanationOfBenefit'Detail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefit'Detail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefit'Detail_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefit'Detail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefit'Detail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefit'Detail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefit'Detail_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , explanationOfBenefit'Detail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefit'Detail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefit'Detail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefit'Detail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefit'Detail_adjudication :: [ExplanationOfBenefit'Adjudication]
          -- ^ The adjudications results.
        , explanationOfBenefit'Detail_subDetail :: [ExplanationOfBenefit'SubDetail]
          -- ^ Third tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@ExplanationOfBenefit'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Detail_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'Detail_sequence x
            , schemaTypeToXML "type" $ explanationOfBenefit'Detail_type x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefit'Detail_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefit'Detail_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefit'Detail_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefit'Detail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefit'Detail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefit'Detail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefit'Detail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefit'Detail_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefit'Detail_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefit'Detail_udi x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefit'Detail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefit'Detail_adjudication x
            , concatMap (schemaTypeToXML "subDetail") $ explanationOfBenefit'Detail_subDetail x
            ]
instance Extension ExplanationOfBenefit'Detail BackboneElement where
    supertype (ExplanationOfBenefit'Detail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Detail -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'SubDetail = ExplanationOfBenefit'SubDetail
        { explanationOfBenefit'SubDetail_id :: Maybe String'primitive
        , explanationOfBenefit'SubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'SubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'SubDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefit'SubDetail_type :: CodeableConcept
          -- ^ The type of product or service.
        , explanationOfBenefit'SubDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefit'SubDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefit'SubDetail_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , explanationOfBenefit'SubDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefit'SubDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefit'SubDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefit'SubDetail_unitPrice :: Maybe Money
          -- ^ The fee for an addittional service or product or charge.
        , explanationOfBenefit'SubDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefit'SubDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefit'SubDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefit'SubDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefit'SubDetail_adjudication :: [ExplanationOfBenefit'Adjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'SubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'SubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ExplanationOfBenefit'SubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'SubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'SubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'SubDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefit'SubDetail_sequence x
            , schemaTypeToXML "type" $ explanationOfBenefit'SubDetail_type x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefit'SubDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefit'SubDetail_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefit'SubDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefit'SubDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefit'SubDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefit'SubDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefit'SubDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefit'SubDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefit'SubDetail_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefit'SubDetail_udi x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefit'SubDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefit'SubDetail_adjudication x
            ]
instance Extension ExplanationOfBenefit'SubDetail BackboneElement where
    supertype (ExplanationOfBenefit'SubDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'SubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'SubDetail -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'AddItem = ExplanationOfBenefit'AddItem
        { explanationOfBenefit'AddItem_id :: Maybe String'primitive
        , explanationOfBenefit'AddItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'AddItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'AddItem_sequenceLinkId :: [PositiveInt]
          -- ^ List of input service items which this service line is 
          --   intended to replace.
        , explanationOfBenefit'AddItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefit'AddItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefit'AddItem_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefit'AddItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefit'AddItem_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product.
        , explanationOfBenefit'AddItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefit'AddItem_adjudication :: [ExplanationOfBenefit'Adjudication]
          -- ^ The adjudications results.
        , explanationOfBenefit'AddItem_detail :: [ExplanationOfBenefit'Detail1]
          -- ^ The second tier service adjudications for payor added 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'AddItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'AddItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ExplanationOfBenefit'AddItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'AddItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'AddItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'AddItem_modifierExtension x
            , concatMap (schemaTypeToXML "sequenceLinkId") $ explanationOfBenefit'AddItem_sequenceLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefit'AddItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefit'AddItem_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefit'AddItem_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefit'AddItem_modifier x
            , maybe [] (schemaTypeToXML "fee") $ explanationOfBenefit'AddItem_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefit'AddItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefit'AddItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ explanationOfBenefit'AddItem_detail x
            ]
instance Extension ExplanationOfBenefit'AddItem BackboneElement where
    supertype (ExplanationOfBenefit'AddItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'AddItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'AddItem -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Detail1 = ExplanationOfBenefit'Detail1
        { explanationOfBenefit'Detail1_id :: Maybe String'primitive
        , explanationOfBenefit'Detail1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Detail1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Detail1_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefit'Detail1_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefit'Detail1_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , explanationOfBenefit'Detail1_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefit'Detail1_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product.
        , explanationOfBenefit'Detail1_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefit'Detail1_adjudication :: [ExplanationOfBenefit'Adjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Detail1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Detail1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ExplanationOfBenefit'Detail1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Detail1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Detail1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Detail1_modifierExtension x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefit'Detail1_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefit'Detail1_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefit'Detail1_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefit'Detail1_modifier x
            , maybe [] (schemaTypeToXML "fee") $ explanationOfBenefit'Detail1_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefit'Detail1_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefit'Detail1_adjudication x
            ]
instance Extension ExplanationOfBenefit'Detail1 BackboneElement where
    supertype (ExplanationOfBenefit'Detail1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Detail1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Detail1 -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Payment = ExplanationOfBenefit'Payment
        { explanationOfBenefit'Payment_id :: Maybe String'primitive
        , explanationOfBenefit'Payment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Payment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Payment_type :: Maybe CodeableConcept
          -- ^ Whether this represents partial or complete payment of the 
          --   claim.
        , explanationOfBenefit'Payment_adjustment :: Maybe Money
          -- ^ Adjustment to the payment of this transaction which is not 
          --   related to adjudication of this transaction.
        , explanationOfBenefit'Payment_adjustmentReason :: Maybe CodeableConcept
          -- ^ Reason for the payment adjustment.
        , explanationOfBenefit'Payment_date :: Maybe Date
          -- ^ Estimated payment date.
        , explanationOfBenefit'Payment_amount :: Maybe Money
          -- ^ Payable less any payment adjustment.
        , explanationOfBenefit'Payment_identifier :: Maybe Identifier
          -- ^ Payment identifer.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Payment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Payment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "adjustment")
            `apply` optional (parseSchemaType "adjustmentReason")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "identifier")
    schemaTypeToXML s x@ExplanationOfBenefit'Payment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Payment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Payment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Payment_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit'Payment_type x
            , maybe [] (schemaTypeToXML "adjustment") $ explanationOfBenefit'Payment_adjustment x
            , maybe [] (schemaTypeToXML "adjustmentReason") $ explanationOfBenefit'Payment_adjustmentReason x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefit'Payment_date x
            , maybe [] (schemaTypeToXML "amount") $ explanationOfBenefit'Payment_amount x
            , maybe [] (schemaTypeToXML "identifier") $ explanationOfBenefit'Payment_identifier x
            ]
instance Extension ExplanationOfBenefit'Payment BackboneElement where
    supertype (ExplanationOfBenefit'Payment a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Payment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Payment -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'ProcessNote = ExplanationOfBenefit'ProcessNote
        { explanationOfBenefit'ProcessNote_id :: Maybe String'primitive
        , explanationOfBenefit'ProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'ProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'ProcessNote_number :: Maybe PositiveInt
          -- ^ An integer associated with each note which may be referred 
          --   to from each service line item.
        , explanationOfBenefit'ProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , explanationOfBenefit'ProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        , explanationOfBenefit'ProcessNote_language :: Maybe CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'ProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'ProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "number")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@ExplanationOfBenefit'ProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'ProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'ProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'ProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "number") $ explanationOfBenefit'ProcessNote_number x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit'ProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ explanationOfBenefit'ProcessNote_text x
            , maybe [] (schemaTypeToXML "language") $ explanationOfBenefit'ProcessNote_language x
            ]
instance Extension ExplanationOfBenefit'ProcessNote BackboneElement where
    supertype (ExplanationOfBenefit'ProcessNote a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'ProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'ProcessNote -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'BenefitBalance = ExplanationOfBenefit'BenefitBalance
        { explanationOfBenefit'BenefitBalance_id :: Maybe String'primitive
        , explanationOfBenefit'BenefitBalance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'BenefitBalance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'BenefitBalance_category :: CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , explanationOfBenefit'BenefitBalance_subCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        , explanationOfBenefit'BenefitBalance_excluded :: Maybe Boolean
          -- ^ True if the indicated class of service is excluded from the 
          --   plan, missing or False indicated the service is included in 
          --   the coverage.
        , explanationOfBenefit'BenefitBalance_name :: Maybe Xsd.XsdString
          -- ^ A short name or tag for the benefit, for example MED01, or 
          --   DENT2.
        , explanationOfBenefit'BenefitBalance_description :: Maybe Xsd.XsdString
          -- ^ A richer description of the benefit, for example 'DENT2 
          --   covers 100% of basic, 50% of major but exclused Ortho, 
          --   Implants and Costmetic services'.
        , explanationOfBenefit'BenefitBalance_network :: Maybe CodeableConcept
          -- ^ Network designation.
        , explanationOfBenefit'BenefitBalance_unit :: Maybe CodeableConcept
          -- ^ Unit designation: individual or family.
        , explanationOfBenefit'BenefitBalance_term :: Maybe CodeableConcept
          -- ^ The term or period of the values such as 'maximum lifetime 
          --   benefit' or 'maximum annual vistis'.
        , explanationOfBenefit'BenefitBalance_financial :: [ExplanationOfBenefit'Financial]
          -- ^ Benefits Used to date.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'BenefitBalance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'BenefitBalance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "subCategory")
            `apply` optional (parseSchemaType "excluded")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "network")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "term")
            `apply` many (parseSchemaType "financial")
    schemaTypeToXML s x@ExplanationOfBenefit'BenefitBalance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'BenefitBalance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'BenefitBalance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'BenefitBalance_modifierExtension x
            , schemaTypeToXML "category" $ explanationOfBenefit'BenefitBalance_category x
            , maybe [] (schemaTypeToXML "subCategory") $ explanationOfBenefit'BenefitBalance_subCategory x
            , maybe [] (schemaTypeToXML "excluded") $ explanationOfBenefit'BenefitBalance_excluded x
            , maybe [] (schemaTypeToXML "name") $ explanationOfBenefit'BenefitBalance_name x
            , maybe [] (schemaTypeToXML "description") $ explanationOfBenefit'BenefitBalance_description x
            , maybe [] (schemaTypeToXML "network") $ explanationOfBenefit'BenefitBalance_network x
            , maybe [] (schemaTypeToXML "unit") $ explanationOfBenefit'BenefitBalance_unit x
            , maybe [] (schemaTypeToXML "term") $ explanationOfBenefit'BenefitBalance_term x
            , concatMap (schemaTypeToXML "financial") $ explanationOfBenefit'BenefitBalance_financial x
            ]
instance Extension ExplanationOfBenefit'BenefitBalance BackboneElement where
    supertype (ExplanationOfBenefit'BenefitBalance a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'BenefitBalance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'BenefitBalance -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefit'Financial = ExplanationOfBenefit'Financial
        { explanationOfBenefit'Financial_id :: Maybe String'primitive
        , explanationOfBenefit'Financial_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit'Financial_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit'Financial_type :: CodeableConcept
          -- ^ Deductable, visits, benefit amount.
        , explanationOfBenefit'Financial_choice3 :: (Maybe (OneOf3 UnsignedInt Xsd.XsdString Money))
          -- ^ Benefits allowed.
          --   
          --   Choice between:
          --   
          --   (1) allowedUnsignedInt
          --   
          --   (2) allowedString
          --   
          --   (3) allowedMoney
        , explanationOfBenefit'Financial_choice4 :: (Maybe (OneOf2 UnsignedInt Money))
          -- ^ Benefits used.
          --   
          --   Choice between:
          --   
          --   (1) usedUnsignedInt
          --   
          --   (2) usedMoney
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit'Financial where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefit'Financial a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf3 (parseSchemaType "allowedUnsignedInt"))
                                     , ("Xsd.XsdString", fmap TwoOf3 (parseSchemaType "allowedString"))
                                     , ("Money", fmap ThreeOf3 (parseSchemaType "allowedMoney"))
                                     ])
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf2 (parseSchemaType "usedUnsignedInt"))
                                     , ("Money", fmap TwoOf2 (parseSchemaType "usedMoney"))
                                     ])
    schemaTypeToXML s x@ExplanationOfBenefit'Financial{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefit'Financial_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefit'Financial_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit'Financial_modifierExtension x
            , schemaTypeToXML "type" $ explanationOfBenefit'Financial_type x
            , maybe [] (foldOneOf3  (schemaTypeToXML "allowedUnsignedInt")
                                    (schemaTypeToXML "allowedString")
                                    (schemaTypeToXML "allowedMoney")
                                   ) $ explanationOfBenefit'Financial_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "usedUnsignedInt")
                                    (schemaTypeToXML "usedMoney")
                                   ) $ explanationOfBenefit'Financial_choice4 x
            ]
instance Extension ExplanationOfBenefit'Financial BackboneElement where
    supertype (ExplanationOfBenefit'Financial a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefit'Financial Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefit'Financial -> BackboneElement)
              
 
data ExplanationOfBenefitStatus'list
    = ExplanationOfBenefitStatus'list_Active
      -- ^ Active
    | ExplanationOfBenefitStatus'list_Cancelled
      -- ^ Cancelled
    | ExplanationOfBenefitStatus'list_Draft
      -- ^ Draft
    | ExplanationOfBenefitStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType ExplanationOfBenefitStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ExplanationOfBenefitStatus'list where
    acceptingParser =  do literal "active"; return ExplanationOfBenefitStatus'list_Active
                      `onFail` do literal "cancelled"; return ExplanationOfBenefitStatus'list_Cancelled
                      `onFail` do literal "draft"; return ExplanationOfBenefitStatus'list_Draft
                      `onFail` do literal "entered-in-error"; return ExplanationOfBenefitStatus'list_Entered'in'error
                      
    simpleTypeText ExplanationOfBenefitStatus'list_Active = "active"
    simpleTypeText ExplanationOfBenefitStatus'list_Cancelled = "cancelled"
    simpleTypeText ExplanationOfBenefitStatus'list_Draft = "draft"
    simpleTypeText ExplanationOfBenefitStatus'list_Entered'in'error = "entered-in-error"
 
data ExplanationOfBenefitStatus = ExplanationOfBenefitStatus
        { explanationOfBenefitStatus_id :: Maybe String'primitive
        , explanationOfBenefitStatus_value :: Maybe ExplanationOfBenefitStatus'list
        , explanationOfBenefitStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ExplanationOfBenefitStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ExplanationOfBenefitStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitStatus_id x
                       , maybe [] (toXMLAttribute "value") $ explanationOfBenefitStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitStatus_extension x
            ]
instance Extension ExplanationOfBenefitStatus Element where
    supertype (ExplanationOfBenefitStatus a0 a1 e0) =
               Element a0 e0
 
-- | Significant health events and conditions for a person 
--   related to the patient relevant in the context of care for 
--   the patient.
elementFamilyMemberHistory :: XMLParser FamilyMemberHistory
elementFamilyMemberHistory = parseSchemaType "FamilyMemberHistory"
elementToXMLFamilyMemberHistory :: FamilyMemberHistory -> [Content ()]
elementToXMLFamilyMemberHistory = schemaTypeToXML "FamilyMemberHistory"
 
data FamilyMemberHistory = FamilyMemberHistory
        { familyMemberHistory_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , familyMemberHistory_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , familyMemberHistory_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , familyMemberHistory_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , familyMemberHistory_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , familyMemberHistory_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , familyMemberHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , familyMemberHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , familyMemberHistory_identifier :: [Identifier]
          -- ^ This records identifiers associated with this family member 
          --   history record that are defined by business processes and/ 
          --   or used to refer to it when a direct URL reference to the 
          --   resource itself is not appropriate (e.g. in CDA documents, 
          --   or in written / printed documentation).
        , familyMemberHistory_definition :: [Reference]
          -- ^ A protocol or questionnaire that was adhered to in whole or 
          --   in part by this event.
        , familyMemberHistory_status :: FamilyHistoryStatus
          -- ^ A code specifying the status of the record of the family 
          --   history of a specific family member.
        , familyMemberHistory_notDone :: Maybe Boolean
          -- ^ If true, indicates the taking of an individual family 
          --   member's history did not occur. The notDone element should 
          --   not be used to document negated conditions, such as a 
          --   family member that did not have a condition.
        , familyMemberHistory_notDoneReason :: Maybe CodeableConcept
          -- ^ Describes why the family member's history is absent.
        , familyMemberHistory_patient :: Reference
          -- ^ The person who this history concerns.
        , familyMemberHistory_date :: Maybe DateTime
          -- ^ The date (and possibly time) when the family member history 
          --   was taken.
        , familyMemberHistory_name :: Maybe Xsd.XsdString
          -- ^ This will either be a name or a description; e.g. 
          --   &quot;Aunt Susan&quot;, &quot;my cousin with the red 
          --   hair&quot;.
        , familyMemberHistory_relationship :: CodeableConcept
          -- ^ The type of relationship this person has to the patient 
          --   (father, mother, brother etc.).
        , familyMemberHistory_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the relative is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , familyMemberHistory_choice18 :: (Maybe (OneOf3 Period Date Xsd.XsdString))
          -- ^ The actual or approximate date of birth of the relative.
          --   
          --   Choice between:
          --   
          --   (1) bornPeriod
          --   
          --   (2) bornDate
          --   
          --   (3) bornString
        , familyMemberHistory_choice19 :: (Maybe (OneOf3 Age Range Xsd.XsdString))
          -- ^ The age of the relative at the time the family member 
          --   history is recorded.
          --   
          --   Choice between:
          --   
          --   (1) ageAge
          --   
          --   (2) ageRange
          --   
          --   (3) ageString
        , familyMemberHistory_estimatedAge :: Maybe Boolean
          -- ^ If true, indicates that the age value specified is an 
          --   estimated value.
        , familyMemberHistory_choice21 :: (Maybe (OneOf5 Boolean Age Range Date Xsd.XsdString))
          -- ^ Deceased flag or the actual or approximate age of the 
          --   relative at the time of death for the family member history 
          --   record.
          --   
          --   Choice between:
          --   
          --   (1) deceasedBoolean
          --   
          --   (2) deceasedAge
          --   
          --   (3) deceasedRange
          --   
          --   (4) deceasedDate
          --   
          --   (5) deceasedString
        , familyMemberHistory_reasonCode :: [CodeableConcept]
          -- ^ Describes why the family member history occurred in coded 
          --   or textual form.
        , familyMemberHistory_reasonReference :: [Reference]
          -- ^ Indicates a Condition, Observation, AllergyIntolerance, or 
          --   QuestionnaireResponse that justifies this family member 
          --   history event.
        , familyMemberHistory_note :: [Annotation]
          -- ^ This property allows a non condition-specific note to the 
          --   made about the related person. Ideally, the note would be 
          --   in the condition property, but this is not always possible.
        , familyMemberHistory_condition :: [FamilyMemberHistory'Condition]
          -- ^ The significant Conditions (or condition) that the family 
          --   member had. This is a repeating section to allow a system 
          --   to represent more than one condition per resource, though 
          --   there is nothing stopping multiple resources - one per 
          --   condition.
        }
        deriving (Eq,Show)
instance SchemaType FamilyMemberHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return FamilyMemberHistory
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "relationship"
            `apply` optional (parseSchemaType "gender")
            `apply` optional (oneOf' [ ("Period", fmap OneOf3 (parseSchemaType "bornPeriod"))
                                     , ("Date", fmap TwoOf3 (parseSchemaType "bornDate"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "bornString"))
                                     ])
            `apply` optional (oneOf' [ ("Age", fmap OneOf3 (parseSchemaType "ageAge"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "ageRange"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "ageString"))
                                     ])
            `apply` optional (parseSchemaType "estimatedAge")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf5 (parseSchemaType "deceasedBoolean"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "deceasedAge"))
                                     , ("Range", fmap ThreeOf5 (parseSchemaType "deceasedRange"))
                                     , ("Date", fmap FourOf5 (parseSchemaType "deceasedDate"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "deceasedString"))
                                     ])
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "condition")
    schemaTypeToXML s x@FamilyMemberHistory{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ familyMemberHistory_id x
            , maybe [] (schemaTypeToXML "meta") $ familyMemberHistory_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ familyMemberHistory_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ familyMemberHistory_language x
            , maybe [] (schemaTypeToXML "text") $ familyMemberHistory_text x
            , concatMap (schemaTypeToXML "contained") $ familyMemberHistory_contained x
            , concatMap (schemaTypeToXML "extension") $ familyMemberHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ familyMemberHistory_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ familyMemberHistory_identifier x
            , concatMap (schemaTypeToXML "definition") $ familyMemberHistory_definition x
            , schemaTypeToXML "status" $ familyMemberHistory_status x
            , maybe [] (schemaTypeToXML "notDone") $ familyMemberHistory_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ familyMemberHistory_notDoneReason x
            , schemaTypeToXML "patient" $ familyMemberHistory_patient x
            , maybe [] (schemaTypeToXML "date") $ familyMemberHistory_date x
            , maybe [] (schemaTypeToXML "name") $ familyMemberHistory_name x
            , schemaTypeToXML "relationship" $ familyMemberHistory_relationship x
            , maybe [] (schemaTypeToXML "gender") $ familyMemberHistory_gender x
            , maybe [] (foldOneOf3  (schemaTypeToXML "bornPeriod")
                                    (schemaTypeToXML "bornDate")
                                    (schemaTypeToXML "bornString")
                                   ) $ familyMemberHistory_choice18 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "ageAge")
                                    (schemaTypeToXML "ageRange")
                                    (schemaTypeToXML "ageString")
                                   ) $ familyMemberHistory_choice19 x
            , maybe [] (schemaTypeToXML "estimatedAge") $ familyMemberHistory_estimatedAge x
            , maybe [] (foldOneOf5  (schemaTypeToXML "deceasedBoolean")
                                    (schemaTypeToXML "deceasedAge")
                                    (schemaTypeToXML "deceasedRange")
                                    (schemaTypeToXML "deceasedDate")
                                    (schemaTypeToXML "deceasedString")
                                   ) $ familyMemberHistory_choice21 x
            , concatMap (schemaTypeToXML "reasonCode") $ familyMemberHistory_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ familyMemberHistory_reasonReference x
            , concatMap (schemaTypeToXML "note") $ familyMemberHistory_note x
            , concatMap (schemaTypeToXML "condition") $ familyMemberHistory_condition x
            ]
instance Extension FamilyMemberHistory DomainResource where
    supertype (FamilyMemberHistory e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension FamilyMemberHistory Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: FamilyMemberHistory -> DomainResource)
              
 
-- | Significant health events and conditions for a person 
--   related to the patient relevant in the context of care for 
--   the patient.
data FamilyMemberHistory'Condition = FamilyMemberHistory'Condition
        { familyMemberHistory'Condition_id :: Maybe String'primitive
        , familyMemberHistory'Condition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , familyMemberHistory'Condition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , familyMemberHistory'Condition_code :: CodeableConcept
          -- ^ The actual condition specified. Could be a coded condition 
          --   (like MI or Diabetes) or a less specific string like 
          --   'cancer' depending on how much is known about the condition 
          --   and the capabilities of the creating system.
        , familyMemberHistory'Condition_outcome :: Maybe CodeableConcept
          -- ^ Indicates what happened as a result of this condition. If 
          --   the condition resulted in death, deceased date is captured 
          --   on the relation.
        , familyMemberHistory'Condition_choice4 :: (Maybe (OneOf4 Age Range Period Xsd.XsdString))
          -- ^ Either the age of onset, range of approximate age or 
          --   descriptive string can be recorded. For conditions with 
          --   multiple occurrences, this describes the first known 
          --   occurrence.
          --   
          --   Choice between:
          --   
          --   (1) onsetAge
          --   
          --   (2) onsetRange
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetString
        , familyMemberHistory'Condition_note :: [Annotation]
          -- ^ An area where general notes can be placed about this 
          --   specific condition.
        }
        deriving (Eq,Show)
instance SchemaType FamilyMemberHistory'Condition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (FamilyMemberHistory'Condition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (oneOf' [ ("Age", fmap OneOf4 (parseSchemaType "onsetAge"))
                                     , ("Range", fmap TwoOf4 (parseSchemaType "onsetRange"))
                                     , ("Period", fmap ThreeOf4 (parseSchemaType "onsetPeriod"))
                                     , ("Xsd.XsdString", fmap FourOf4 (parseSchemaType "onsetString"))
                                     ])
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@FamilyMemberHistory'Condition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ familyMemberHistory'Condition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ familyMemberHistory'Condition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ familyMemberHistory'Condition_modifierExtension x
            , schemaTypeToXML "code" $ familyMemberHistory'Condition_code x
            , maybe [] (schemaTypeToXML "outcome") $ familyMemberHistory'Condition_outcome x
            , maybe [] (foldOneOf4  (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetString")
                                   ) $ familyMemberHistory'Condition_choice4 x
            , concatMap (schemaTypeToXML "note") $ familyMemberHistory'Condition_note x
            ]
instance Extension FamilyMemberHistory'Condition BackboneElement where
    supertype (FamilyMemberHistory'Condition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension FamilyMemberHistory'Condition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: FamilyMemberHistory'Condition -> BackboneElement)
              
 
data FamilyHistoryStatus'list
    = FamilyHistoryStatus'list_Partial
      -- ^ Partial
    | FamilyHistoryStatus'list_Completed
      -- ^ Completed
    | FamilyHistoryStatus'list_Entered'in'error
      -- ^ Entered in error
    | FamilyHistoryStatus'list_Health'unknown
      -- ^ Health unknown
    deriving (Eq,Show,Enum)
instance SchemaType FamilyHistoryStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FamilyHistoryStatus'list where
    acceptingParser =  do literal "partial"; return FamilyHistoryStatus'list_Partial
                      `onFail` do literal "completed"; return FamilyHistoryStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return FamilyHistoryStatus'list_Entered'in'error
                      `onFail` do literal "health-unknown"; return FamilyHistoryStatus'list_Health'unknown
                      
    simpleTypeText FamilyHistoryStatus'list_Partial = "partial"
    simpleTypeText FamilyHistoryStatus'list_Completed = "completed"
    simpleTypeText FamilyHistoryStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText FamilyHistoryStatus'list_Health'unknown = "health-unknown"
 
data FamilyHistoryStatus = FamilyHistoryStatus
        { familyHistoryStatus_id :: Maybe String'primitive
        , familyHistoryStatus_value :: Maybe FamilyHistoryStatus'list
        , familyHistoryStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FamilyHistoryStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FamilyHistoryStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FamilyHistoryStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ familyHistoryStatus_id x
                       , maybe [] (toXMLAttribute "value") $ familyHistoryStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ familyHistoryStatus_extension x
            ]
instance Extension FamilyHistoryStatus Element where
    supertype (FamilyHistoryStatus a0 a1 e0) =
               Element a0 e0
 
-- | Prospective warnings of potential issues when providing 
--   care to the patient.
elementFlag :: XMLParser Flag
elementFlag = parseSchemaType "Flag"
elementToXMLFlag :: Flag -> [Content ()]
elementToXMLFlag = schemaTypeToXML "Flag"
 
data Flag = Flag
        { flag_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , flag_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , flag_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , flag_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , flag_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , flag_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , flag_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , flag_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , flag_identifier :: [Identifier]
          -- ^ Identifier assigned to the flag for external use (outside 
          --   the FHIR environment).
        , flag_status :: FlagStatus
          -- ^ Supports basic workflow.
        , flag_category :: Maybe CodeableConcept
          -- ^ Allows an flag to be divided into different categories like 
          --   clinical, administrative etc. Intended to be used as a 
          --   means of filtering which flags are displayed to particular 
          --   user or in a given context.
        , flag_code :: CodeableConcept
          -- ^ The coded value or textual component of the flag to display 
          --   to the user.
        , flag_subject :: Reference
          -- ^ The patient, location, group , organization , or 
          --   practitioner, etc. this is about record this flag is 
          --   associated with.
        , flag_period :: Maybe Period
          -- ^ The period of time from the activation of the flag to 
          --   inactivation of the flag. If the flag is active, the end of 
          --   the period should be unspecified.
        , flag_encounter :: Maybe Reference
          -- ^ This alert is only relevant during the encounter.
        , flag_author :: Maybe Reference
          -- ^ The person, organization or device that created the flag.
        }
        deriving (Eq,Show)
instance SchemaType Flag where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Flag
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@Flag{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ flag_id x
            , maybe [] (schemaTypeToXML "meta") $ flag_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ flag_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ flag_language x
            , maybe [] (schemaTypeToXML "text") $ flag_text x
            , concatMap (schemaTypeToXML "contained") $ flag_contained x
            , concatMap (schemaTypeToXML "extension") $ flag_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ flag_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ flag_identifier x
            , schemaTypeToXML "status" $ flag_status x
            , maybe [] (schemaTypeToXML "category") $ flag_category x
            , schemaTypeToXML "code" $ flag_code x
            , schemaTypeToXML "subject" $ flag_subject x
            , maybe [] (schemaTypeToXML "period") $ flag_period x
            , maybe [] (schemaTypeToXML "encounter") $ flag_encounter x
            , maybe [] (schemaTypeToXML "author") $ flag_author x
            ]
instance Extension Flag DomainResource where
    supertype (Flag e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Flag Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Flag -> DomainResource)
              
 
data FlagStatus'list
    = FlagStatus'list_Active
      -- ^ Active
    | FlagStatus'list_Inactive
      -- ^ Inactive
    | FlagStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FlagStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FlagStatus'list where
    acceptingParser =  do literal "active"; return FlagStatus'list_Active
                      `onFail` do literal "inactive"; return FlagStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return FlagStatus'list_Entered'in'error
                      
    simpleTypeText FlagStatus'list_Active = "active"
    simpleTypeText FlagStatus'list_Inactive = "inactive"
    simpleTypeText FlagStatus'list_Entered'in'error = "entered-in-error"
 
data FlagStatus = FlagStatus
        { flagStatus_id :: Maybe String'primitive
        , flagStatus_value :: Maybe FlagStatus'list
        , flagStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FlagStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FlagStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FlagStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ flagStatus_id x
                       , maybe [] (toXMLAttribute "value") $ flagStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ flagStatus_extension x
            ]
instance Extension FlagStatus Element where
    supertype (FlagStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the intended objective(s) for a patient, group or 
--   organization care, for example, weight loss, restoring an 
--   activity of daily living, obtaining herd immunity via 
--   immunization, meeting a process improvement objective, etc.
elementGoal :: XMLParser Goal
elementGoal = parseSchemaType "Goal"
elementToXMLGoal :: Goal -> [Content ()]
elementToXMLGoal = schemaTypeToXML "Goal"
 
data Goal = Goal
        { goal_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , goal_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , goal_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , goal_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , goal_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , goal_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , goal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , goal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , goal_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care plan 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , goal_status :: GoalStatus
          -- ^ Indicates whether the goal has been reached and is still 
          --   considered relevant.
        , goal_category :: [CodeableConcept]
          -- ^ Indicates a category the goal falls within.
        , goal_priority :: Maybe CodeableConcept
          -- ^ Identifies the mutually agreed level of importance 
          --   associated with reaching/sustaining the goal.
        , goal_description :: CodeableConcept
          -- ^ Human-readable and/or coded description of a specific 
          --   desired objective of care, such as &quot;control blood 
          --   pressure&quot; or &quot;negotiate an obstacle course&quot; 
          --   or &quot;dance with child at wedding&quot;.
        , goal_subject :: Maybe Reference
          -- ^ Identifies the patient, group or organization for whom the 
          --   goal is being established.
        , goal_choice14 :: (Maybe (OneOf2 Date CodeableConcept))
          -- ^ The date or event after which the goal should begin being 
          --   pursued.
          --   
          --   Choice between:
          --   
          --   (1) startDate
          --   
          --   (2) startCodeableConcept
        , goal_target :: Maybe Goal'Target
          -- ^ Indicates what should be done by when.
        , goal_statusDate :: Maybe Date
          -- ^ Identifies when the current status. I.e. When initially 
          --   created, when achieved, when cancelled, etc.
        , goal_statusReason :: Maybe Xsd.XsdString
          -- ^ Captures the reason for the current status.
        , goal_expressedBy :: Maybe Reference
          -- ^ Indicates whose goal this is - patient goal, practitioner 
          --   goal, etc.
        , goal_addresses :: [Reference]
          -- ^ The identified conditions and other health record elements 
          --   that are intended to be addressed by the goal.
        , goal_note :: [Annotation]
          -- ^ Any comments related to the goal.
        , goal_outcomeCode :: [CodeableConcept]
          -- ^ Identifies the change (or lack of change) at the point when 
          --   the status of the goal is assessed.
        , goal_outcomeReference :: [Reference]
          -- ^ Details of what's changed (or not changed).
        }
        deriving (Eq,Show)
instance SchemaType Goal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Goal
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "startDate"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "startCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "statusDate")
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "expressedBy")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "outcomeCode")
            `apply` many (parseSchemaType "outcomeReference")
    schemaTypeToXML s x@Goal{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ goal_id x
            , maybe [] (schemaTypeToXML "meta") $ goal_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ goal_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ goal_language x
            , maybe [] (schemaTypeToXML "text") $ goal_text x
            , concatMap (schemaTypeToXML "contained") $ goal_contained x
            , concatMap (schemaTypeToXML "extension") $ goal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ goal_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ goal_identifier x
            , schemaTypeToXML "status" $ goal_status x
            , concatMap (schemaTypeToXML "category") $ goal_category x
            , maybe [] (schemaTypeToXML "priority") $ goal_priority x
            , schemaTypeToXML "description" $ goal_description x
            , maybe [] (schemaTypeToXML "subject") $ goal_subject x
            , maybe [] (foldOneOf2  (schemaTypeToXML "startDate")
                                    (schemaTypeToXML "startCodeableConcept")
                                   ) $ goal_choice14 x
            , maybe [] (schemaTypeToXML "target") $ goal_target x
            , maybe [] (schemaTypeToXML "statusDate") $ goal_statusDate x
            , maybe [] (schemaTypeToXML "statusReason") $ goal_statusReason x
            , maybe [] (schemaTypeToXML "expressedBy") $ goal_expressedBy x
            , concatMap (schemaTypeToXML "addresses") $ goal_addresses x
            , concatMap (schemaTypeToXML "note") $ goal_note x
            , concatMap (schemaTypeToXML "outcomeCode") $ goal_outcomeCode x
            , concatMap (schemaTypeToXML "outcomeReference") $ goal_outcomeReference x
            ]
instance Extension Goal DomainResource where
    supertype (Goal e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Goal Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Goal -> DomainResource)
              
 
-- | Describes the intended objective(s) for a patient, group or 
--   organization care, for example, weight loss, restoring an 
--   activity of daily living, obtaining herd immunity via 
--   immunization, meeting a process improvement objective, etc.
data Goal'Target = Goal'Target
        { goal'Target_id :: Maybe String'primitive
        , goal'Target_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , goal'Target_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , goal'Target_measure :: Maybe CodeableConcept
          -- ^ The parameter whose value is being tracked, e.g. body 
          --   weight, blood pressure, or hemoglobin A1c level.
        , goal'Target_choice3 :: (Maybe (OneOf3 Quantity Range CodeableConcept))
          -- ^ The target value of the focus to be achieved to signify the 
          --   fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the 
          --   high or low or both values of the range can be specified. 
          --   When a low value is missing, it indicates that the goal is 
          --   achieved at any focus value at or below the high value. 
          --   Similarly, if the high value is missing, it indicates that 
          --   the goal is achieved at any focus value at or above the low 
          --   value.
          --   
          --   Choice between:
          --   
          --   (1) detailQuantity
          --   
          --   (2) detailRange
          --   
          --   (3) detailCodeableConcept
        , goal'Target_choice4 :: (Maybe (OneOf2 Date Duration))
          -- ^ Indicates either the date or the duration after start by 
          --   which the goal should be met.
          --   
          --   Choice between:
          --   
          --   (1) dueDate
          --   
          --   (2) dueDuration
        }
        deriving (Eq,Show)
instance SchemaType Goal'Target where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Goal'Target a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "measure")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf3 (parseSchemaType "detailQuantity"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "detailRange"))
                                     , ("CodeableConcept", fmap ThreeOf3 (parseSchemaType "detailCodeableConcept"))
                                     ])
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "dueDate"))
                                     , ("Duration", fmap TwoOf2 (parseSchemaType "dueDuration"))
                                     ])
    schemaTypeToXML s x@Goal'Target{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ goal'Target_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ goal'Target_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ goal'Target_modifierExtension x
            , maybe [] (schemaTypeToXML "measure") $ goal'Target_measure x
            , maybe [] (foldOneOf3  (schemaTypeToXML "detailQuantity")
                                    (schemaTypeToXML "detailRange")
                                    (schemaTypeToXML "detailCodeableConcept")
                                   ) $ goal'Target_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "dueDate")
                                    (schemaTypeToXML "dueDuration")
                                   ) $ goal'Target_choice4 x
            ]
instance Extension Goal'Target BackboneElement where
    supertype (Goal'Target a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Goal'Target Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Goal'Target -> BackboneElement)
              
 
data GoalStatus'list
    = GoalStatus'list_Proposed
      -- ^ Proposed
    | GoalStatus'list_Accepted
      -- ^ Accepted
    | GoalStatus'list_Planned
      -- ^ Planned
    | GoalStatus'list_In'progress
      -- ^ In Progress
    | GoalStatus'list_On'target
      -- ^ On Target
    | GoalStatus'list_Ahead'of'target
      -- ^ Ahead of Target
    | GoalStatus'list_Behind'target
      -- ^ Behind Target
    | GoalStatus'list_Sustaining
      -- ^ Sustaining
    | GoalStatus'list_Achieved
      -- ^ Achieved
    | GoalStatus'list_On'hold
      -- ^ On Hold
    | GoalStatus'list_Cancelled
      -- ^ Cancelled
    | GoalStatus'list_Entered'in'error
      -- ^ Entered In Error
    | GoalStatus'list_Rejected
      -- ^ Rejected
    deriving (Eq,Show,Enum)
instance SchemaType GoalStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GoalStatus'list where
    acceptingParser =  do literal "proposed"; return GoalStatus'list_Proposed
                      `onFail` do literal "accepted"; return GoalStatus'list_Accepted
                      `onFail` do literal "planned"; return GoalStatus'list_Planned
                      `onFail` do literal "in-progress"; return GoalStatus'list_In'progress
                      `onFail` do literal "on-target"; return GoalStatus'list_On'target
                      `onFail` do literal "ahead-of-target"; return GoalStatus'list_Ahead'of'target
                      `onFail` do literal "behind-target"; return GoalStatus'list_Behind'target
                      `onFail` do literal "sustaining"; return GoalStatus'list_Sustaining
                      `onFail` do literal "achieved"; return GoalStatus'list_Achieved
                      `onFail` do literal "on-hold"; return GoalStatus'list_On'hold
                      `onFail` do literal "cancelled"; return GoalStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return GoalStatus'list_Entered'in'error
                      `onFail` do literal "rejected"; return GoalStatus'list_Rejected
                      
    simpleTypeText GoalStatus'list_Proposed = "proposed"
    simpleTypeText GoalStatus'list_Accepted = "accepted"
    simpleTypeText GoalStatus'list_Planned = "planned"
    simpleTypeText GoalStatus'list_In'progress = "in-progress"
    simpleTypeText GoalStatus'list_On'target = "on-target"
    simpleTypeText GoalStatus'list_Ahead'of'target = "ahead-of-target"
    simpleTypeText GoalStatus'list_Behind'target = "behind-target"
    simpleTypeText GoalStatus'list_Sustaining = "sustaining"
    simpleTypeText GoalStatus'list_Achieved = "achieved"
    simpleTypeText GoalStatus'list_On'hold = "on-hold"
    simpleTypeText GoalStatus'list_Cancelled = "cancelled"
    simpleTypeText GoalStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText GoalStatus'list_Rejected = "rejected"
 
data GoalStatus = GoalStatus
        { goalStatus_id :: Maybe String'primitive
        , goalStatus_value :: Maybe GoalStatus'list
        , goalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GoalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GoalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GoalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ goalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ goalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ goalStatus_extension x
            ]
instance Extension GoalStatus Element where
    supertype (GoalStatus a0 a1 e0) =
               Element a0 e0
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
elementGraphDefinition :: XMLParser GraphDefinition
elementGraphDefinition = parseSchemaType "GraphDefinition"
elementToXMLGraphDefinition :: GraphDefinition -> [Content ()]
elementToXMLGraphDefinition = schemaTypeToXML "GraphDefinition"
 
data GraphDefinition = GraphDefinition
        { graphDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , graphDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , graphDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , graphDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , graphDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , graphDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , graphDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this graph 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   graph definition is (or will be) published. The URL SHOULD 
          --   include the major version of the graph definition. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , graphDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   graph definition when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the graph definition author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , graphDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the graph definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , graphDefinition_status :: PublicationStatus
          -- ^ The status of this graph definition. Enables tracking the 
          --   life-cycle of the content.
        , graphDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this graph definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , graphDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the graph definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the graph definition changes.
        , graphDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the graph definition.
        , graphDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , graphDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the graph 
          --   definition from a consumer's perspective.
        , graphDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   graph definition instances.
        , graphDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the graph definition 
          --   is intended to be used.
        , graphDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this graph definition is needed and why 
          --   it has been designed as it has.
        , graphDefinition_start :: ResourceType
          -- ^ The type of FHIR resource at which instances of this graph 
          --   start.
        , graphDefinition_profile :: Maybe Uri
          -- ^ The profile that describes the use of the base resource.
        , graphDefinition_link :: [GraphDefinition'Link]
          -- ^ Links this graph makes rules about.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return GraphDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` parseSchemaType "start"
            `apply` optional (parseSchemaType "profile")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@GraphDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ graphDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ graphDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ graphDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ graphDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ graphDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ graphDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ graphDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ graphDefinition_url x
            , maybe [] (schemaTypeToXML "version") $ graphDefinition_version x
            , schemaTypeToXML "name" $ graphDefinition_name x
            , schemaTypeToXML "status" $ graphDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ graphDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ graphDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ graphDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ graphDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ graphDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ graphDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ graphDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ graphDefinition_purpose x
            , schemaTypeToXML "start" $ graphDefinition_start x
            , maybe [] (schemaTypeToXML "profile") $ graphDefinition_profile x
            , concatMap (schemaTypeToXML "link") $ graphDefinition_link x
            ]
instance Extension GraphDefinition DomainResource where
    supertype (GraphDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension GraphDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: GraphDefinition -> DomainResource)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinition'Link = GraphDefinition'Link
        { graphDefinition'Link_id :: Maybe String'primitive
        , graphDefinition'Link_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinition'Link_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinition'Link_path :: Xsd.XsdString
          -- ^ Path in the resource that contains the link.
        , graphDefinition'Link_sliceName :: Maybe Xsd.XsdString
          -- ^ Which slice (if profiled).
        , graphDefinition'Link_min :: Maybe Integer
          -- ^ Minimum occurrences for this link.
        , graphDefinition'Link_max :: Maybe Xsd.XsdString
          -- ^ Maximum occurrences for this link.
        , graphDefinition'Link_description :: Maybe Xsd.XsdString
          -- ^ Information about why this link is of interest in this 
          --   graph definition.
        , graphDefinition'Link_target :: [GraphDefinition'Target]
          -- ^ Potential target for the link.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinition'Link where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinition'Link a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "path"
            `apply` optional (parseSchemaType "sliceName")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "target")
    schemaTypeToXML s x@GraphDefinition'Link{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinition'Link_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinition'Link_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinition'Link_modifierExtension x
            , schemaTypeToXML "path" $ graphDefinition'Link_path x
            , maybe [] (schemaTypeToXML "sliceName") $ graphDefinition'Link_sliceName x
            , maybe [] (schemaTypeToXML "min") $ graphDefinition'Link_min x
            , maybe [] (schemaTypeToXML "max") $ graphDefinition'Link_max x
            , maybe [] (schemaTypeToXML "description") $ graphDefinition'Link_description x
            , concatMap (schemaTypeToXML "target") $ graphDefinition'Link_target x
            ]
instance Extension GraphDefinition'Link BackboneElement where
    supertype (GraphDefinition'Link a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinition'Link Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinition'Link -> BackboneElement)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinition'Target = GraphDefinition'Target
        { graphDefinition'Target_id :: Maybe String'primitive
        , graphDefinition'Target_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinition'Target_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinition'Target_type :: ResourceType
          -- ^ Type of resource this link refers to.
        , graphDefinition'Target_profile :: Maybe Uri
          -- ^ Profile for the target resource.
        , graphDefinition'Target_compartment :: [GraphDefinition'Compartment]
          -- ^ Compartment Consistency Rules.
        , graphDefinition'Target_link :: [GraphDefinition'Link]
          -- ^ Additional links from target resource.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinition'Target where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinition'Target a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
            `apply` many (parseSchemaType "compartment")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@GraphDefinition'Target{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinition'Target_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinition'Target_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinition'Target_modifierExtension x
            , schemaTypeToXML "type" $ graphDefinition'Target_type x
            , maybe [] (schemaTypeToXML "profile") $ graphDefinition'Target_profile x
            , concatMap (schemaTypeToXML "compartment") $ graphDefinition'Target_compartment x
            , concatMap (schemaTypeToXML "link") $ graphDefinition'Target_link x
            ]
instance Extension GraphDefinition'Target BackboneElement where
    supertype (GraphDefinition'Target a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinition'Target Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinition'Target -> BackboneElement)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinition'Compartment = GraphDefinition'Compartment
        { graphDefinition'Compartment_id :: Maybe String'primitive
        , graphDefinition'Compartment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinition'Compartment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinition'Compartment_code :: CompartmentType
          -- ^ Identifies the compartment.
        , graphDefinition'Compartment_rule :: GraphCompartmentRule
          -- ^ identical | matching | different | no-rule | custom.
        , graphDefinition'Compartment_expression :: Maybe Xsd.XsdString
          -- ^ Custom rule, as a FHIRPath expression.
        , graphDefinition'Compartment_description :: Maybe Xsd.XsdString
          -- ^ Documentation for FHIRPath expression.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinition'Compartment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinition'Compartment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "rule"
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@GraphDefinition'Compartment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinition'Compartment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinition'Compartment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinition'Compartment_modifierExtension x
            , schemaTypeToXML "code" $ graphDefinition'Compartment_code x
            , schemaTypeToXML "rule" $ graphDefinition'Compartment_rule x
            , maybe [] (schemaTypeToXML "expression") $ graphDefinition'Compartment_expression x
            , maybe [] (schemaTypeToXML "description") $ graphDefinition'Compartment_description x
            ]
instance Extension GraphDefinition'Compartment BackboneElement where
    supertype (GraphDefinition'Compartment a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinition'Compartment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinition'Compartment -> BackboneElement)
              
 
data GraphCompartmentRule'list
    = GraphCompartmentRule'list_Identical
      -- ^ Identical
    | GraphCompartmentRule'list_Matching
      -- ^ Matching
    | GraphCompartmentRule'list_Different
      -- ^ Different
    | GraphCompartmentRule'list_Custom
      -- ^ Custom
    deriving (Eq,Show,Enum)
instance SchemaType GraphCompartmentRule'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GraphCompartmentRule'list where
    acceptingParser =  do literal "identical"; return GraphCompartmentRule'list_Identical
                      `onFail` do literal "matching"; return GraphCompartmentRule'list_Matching
                      `onFail` do literal "different"; return GraphCompartmentRule'list_Different
                      `onFail` do literal "custom"; return GraphCompartmentRule'list_Custom
                      
    simpleTypeText GraphCompartmentRule'list_Identical = "identical"
    simpleTypeText GraphCompartmentRule'list_Matching = "matching"
    simpleTypeText GraphCompartmentRule'list_Different = "different"
    simpleTypeText GraphCompartmentRule'list_Custom = "custom"
 
data GraphCompartmentRule = GraphCompartmentRule
        { graphCompartmentRule_id :: Maybe String'primitive
        , graphCompartmentRule_value :: Maybe GraphCompartmentRule'list
        , graphCompartmentRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GraphCompartmentRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GraphCompartmentRule a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GraphCompartmentRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphCompartmentRule_id x
                       , maybe [] (toXMLAttribute "value") $ graphCompartmentRule_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphCompartmentRule_extension x
            ]
instance Extension GraphCompartmentRule Element where
    supertype (GraphCompartmentRule a0 a1 e0) =
               Element a0 e0
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
elementGroup :: XMLParser Group
elementGroup = parseSchemaType "Group"
elementToXMLGroup :: Group -> [Content ()]
elementToXMLGroup = schemaTypeToXML "Group"
 
data Group = Group
        { group_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , group_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , group_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , group_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , group_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , group_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , group_identifier :: [Identifier]
          -- ^ A unique business identifier for this group.
        , group_active :: Maybe Boolean
          -- ^ Indicates whether the record for the group is available for 
          --   use or is merely being retained for historical purposes.
        , group_type :: GroupType
          -- ^ Identifies the broad classification of the kind of 
          --   resources the group includes.
        , group_actual :: Boolean
          -- ^ If true, indicates that the resource refers to a specific 
          --   group of real individuals. If false, the group defines a 
          --   set of intended individuals.
        , group_code :: Maybe CodeableConcept
          -- ^ Provides a specific type of resource the group includes; 
          --   e.g. &quot;cow&quot;, &quot;syringe&quot;, etc.
        , group_name :: Maybe Xsd.XsdString
          -- ^ A label assigned to the group for human identification and 
          --   communication.
        , group_quantity :: Maybe UnsignedInt
          -- ^ A count of the number of resource instances that are part 
          --   of the group.
        , group_characteristic :: [Group'Characteristic]
          -- ^ Identifies the traits shared by members of the group.
        , group_member :: [Group'Member]
          -- ^ Identifies the resource instances that are members of the 
          --   group.
        }
        deriving (Eq,Show)
instance SchemaType Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Group
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "actual"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "characteristic")
            `apply` many (parseSchemaType "member")
    schemaTypeToXML s x@Group{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ group_id x
            , maybe [] (schemaTypeToXML "meta") $ group_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ group_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ group_language x
            , maybe [] (schemaTypeToXML "text") $ group_text x
            , concatMap (schemaTypeToXML "contained") $ group_contained x
            , concatMap (schemaTypeToXML "extension") $ group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ group_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ group_identifier x
            , maybe [] (schemaTypeToXML "active") $ group_active x
            , schemaTypeToXML "type" $ group_type x
            , schemaTypeToXML "actual" $ group_actual x
            , maybe [] (schemaTypeToXML "code") $ group_code x
            , maybe [] (schemaTypeToXML "name") $ group_name x
            , maybe [] (schemaTypeToXML "quantity") $ group_quantity x
            , concatMap (schemaTypeToXML "characteristic") $ group_characteristic x
            , concatMap (schemaTypeToXML "member") $ group_member x
            ]
instance Extension Group DomainResource where
    supertype (Group e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Group Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Group -> DomainResource)
              
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
data Group'Characteristic = Group'Characteristic
        { group'Characteristic_id :: Maybe String'primitive
        , group'Characteristic_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , group'Characteristic_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , group'Characteristic_code :: CodeableConcept
          -- ^ A code that identifies the kind of trait being asserted.
        , group'Characteristic_choice3 :: OneOf4 CodeableConcept Boolean Quantity Range
          -- ^ The value of the trait that holds (or does not hold - see 
          --   'exclude') for members of the group.
          --   
          --   Choice between:
          --   
          --   (1) valueCodeableConcept
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueQuantity
          --   
          --   (4) valueRange
        , group'Characteristic_exclude :: Boolean
          -- ^ If true, indicates the characteristic is one that is NOT 
          --   held by members of the group.
        , group'Characteristic_period :: Maybe Period
          -- ^ The period over which the characteristic is tested; e.g. 
          --   the patient had an operation during the month of June.
        }
        deriving (Eq,Show)
instance SchemaType Group'Characteristic where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Group'Characteristic a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf4 (parseSchemaType "valueCodeableConcept"))
                           , ("Boolean", fmap TwoOf4 (parseSchemaType "valueBoolean"))
                           , ("Quantity", fmap ThreeOf4 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap FourOf4 (parseSchemaType "valueRange"))
                           ]
            `apply` parseSchemaType "exclude"
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Group'Characteristic{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ group'Characteristic_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ group'Characteristic_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ group'Characteristic_modifierExtension x
            , schemaTypeToXML "code" $ group'Characteristic_code x
            , foldOneOf4  (schemaTypeToXML "valueCodeableConcept")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueQuantity")
                          (schemaTypeToXML "valueRange")
                          $ group'Characteristic_choice3 x
            , schemaTypeToXML "exclude" $ group'Characteristic_exclude x
            , maybe [] (schemaTypeToXML "period") $ group'Characteristic_period x
            ]
instance Extension Group'Characteristic BackboneElement where
    supertype (Group'Characteristic a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Group'Characteristic Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Group'Characteristic -> BackboneElement)
              
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
data Group'Member = Group'Member
        { group'Member_id :: Maybe String'primitive
        , group'Member_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , group'Member_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , group'Member_entity :: Reference
          -- ^ A reference to the entity that is a member of the group. 
          --   Must be consistent with Group.type.
        , group'Member_period :: Maybe Period
          -- ^ The period that the member was in the group, if known.
        , group'Member_inactive :: Maybe Boolean
          -- ^ A flag to indicate that the member is no longer in the 
          --   group, but previously may have been a member.
        }
        deriving (Eq,Show)
instance SchemaType Group'Member where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Group'Member a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "entity"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "inactive")
    schemaTypeToXML s x@Group'Member{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ group'Member_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ group'Member_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ group'Member_modifierExtension x
            , schemaTypeToXML "entity" $ group'Member_entity x
            , maybe [] (schemaTypeToXML "period") $ group'Member_period x
            , maybe [] (schemaTypeToXML "inactive") $ group'Member_inactive x
            ]
instance Extension Group'Member BackboneElement where
    supertype (Group'Member a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Group'Member Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Group'Member -> BackboneElement)
              
 
data GroupType'list
    = GroupType'list_Person
      -- ^ Person
    | GroupType'list_Animal
      -- ^ Animal
    | GroupType'list_Practitioner
      -- ^ Practitioner
    | GroupType'list_Device
      -- ^ Device
    | GroupType'list_Medication
      -- ^ Medication
    | GroupType'list_Substance
      -- ^ Substance
    deriving (Eq,Show,Enum)
instance SchemaType GroupType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GroupType'list where
    acceptingParser =  do literal "person"; return GroupType'list_Person
                      `onFail` do literal "animal"; return GroupType'list_Animal
                      `onFail` do literal "practitioner"; return GroupType'list_Practitioner
                      `onFail` do literal "device"; return GroupType'list_Device
                      `onFail` do literal "medication"; return GroupType'list_Medication
                      `onFail` do literal "substance"; return GroupType'list_Substance
                      
    simpleTypeText GroupType'list_Person = "person"
    simpleTypeText GroupType'list_Animal = "animal"
    simpleTypeText GroupType'list_Practitioner = "practitioner"
    simpleTypeText GroupType'list_Device = "device"
    simpleTypeText GroupType'list_Medication = "medication"
    simpleTypeText GroupType'list_Substance = "substance"
 
data GroupType = GroupType
        { groupType_id :: Maybe String'primitive
        , groupType_value :: Maybe GroupType'list
        , groupType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GroupType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GroupType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GroupType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ groupType_id x
                       , maybe [] (toXMLAttribute "value") $ groupType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ groupType_extension x
            ]
instance Extension GroupType Element where
    supertype (GroupType a0 a1 e0) =
               Element a0 e0
 
-- | A guidance response is the formal response to a guidance 
--   request, including any output parameters returned by the 
--   evaluation, as well as the description of any proposed 
--   actions to be taken.
elementGuidanceResponse :: XMLParser GuidanceResponse
elementGuidanceResponse = parseSchemaType "GuidanceResponse"
elementToXMLGuidanceResponse :: GuidanceResponse -> [Content ()]
elementToXMLGuidanceResponse = schemaTypeToXML "GuidanceResponse"
 
data GuidanceResponse = GuidanceResponse
        { guidanceResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , guidanceResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , guidanceResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , guidanceResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , guidanceResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , guidanceResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , guidanceResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , guidanceResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , guidanceResponse_requestId :: Maybe Id
          -- ^ The id of the request associated with this response. If an 
          --   id was given as part of the request, it will be reproduced 
          --   here to enable the requester to more easily identify the 
          --   response in a multi-request scenario.
        , guidanceResponse_identifier :: Maybe Identifier
          -- ^ Allows a service to provide a unique, business identifier 
          --   for the response.
        , guidanceResponse_module :: Reference
          -- ^ A reference to the knowledge module that was invoked.
        , guidanceResponse_status :: GuidanceResponseStatus
          -- ^ The status of the response. If the evaluation is completed 
          --   successfully, the status will indicate success. However, in 
          --   order to complete the evaluation, the engine may require 
          --   more information. In this case, the status will be 
          --   data-required, and the response will contain a description 
          --   of the additional required information. If the evaluation 
          --   completed successfully, but the engine determines that a 
          --   potentially more accurate response could be provided if 
          --   more data was available, the status will be data-requested, 
          --   and the response will contain a description of the 
          --   additional requested information.
        , guidanceResponse_subject :: Maybe Reference
          -- ^ The patient for which the request was processed.
        , guidanceResponse_context :: Maybe Reference
          -- ^ Allows the context of the guidance response to be provided 
          --   if available. In a service context, this would likely be 
          --   unavailable.
        , guidanceResponse_occurrenceDateTime :: Maybe DateTime
          -- ^ Indicates when the guidance response was processed.
        , guidanceResponse_performer :: Maybe Reference
          -- ^ Provides a reference to the device that performed the 
          --   guidance.
        , guidanceResponse_choice16 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason the request was initiated. This is 
          --   typically provided as a parameter to the evaluation and 
          --   echoed by the service, although for some use cases, such as 
          --   subscription- or event-based scenarios, it may provide an 
          --   indication of the cause for the response.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , guidanceResponse_note :: [Annotation]
          -- ^ Provides a mechanism to communicate additional information 
          --   about the response.
        , guidanceResponse_evaluationMessage :: [Reference]
          -- ^ Messages resulting from the evaluation of the artifact or 
          --   artifacts. As part of evaluating the request, the engine 
          --   may produce informational or warning messages. These 
          --   messages will be provided by this element.
        , guidanceResponse_outputParameters :: Maybe Reference
          -- ^ The output parameters of the evaluation, if any. Many 
          --   modules will result in the return of specific resources 
          --   such as procedure or communication requests that are 
          --   returned as part of the operation result. However, modules 
          --   may define specific outputs that would be returned as the 
          --   result of the evaluation, and these would be returned in 
          --   this element.
        , guidanceResponse_result :: Maybe Reference
          -- ^ The actions, if any, produced by the evaluation of the 
          --   artifact.
        , guidanceResponse_dataRequirement :: [DataRequirement]
          -- ^ If the evaluation could not be completed due to lack of 
          --   information, or additional information would potentially 
          --   result in a more accurate response, this element will a 
          --   description of the data required in order to proceed with 
          --   the evaluation. A subsequent request to the service should 
          --   include this data.
        }
        deriving (Eq,Show)
instance SchemaType GuidanceResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return GuidanceResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "requestId")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "module"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "occurrenceDateTime")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "evaluationMessage")
            `apply` optional (parseSchemaType "outputParameters")
            `apply` optional (parseSchemaType "result")
            `apply` many (parseSchemaType "dataRequirement")
    schemaTypeToXML s x@GuidanceResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ guidanceResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ guidanceResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ guidanceResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ guidanceResponse_language x
            , maybe [] (schemaTypeToXML "text") $ guidanceResponse_text x
            , concatMap (schemaTypeToXML "contained") $ guidanceResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ guidanceResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ guidanceResponse_modifierExtension x
            , maybe [] (schemaTypeToXML "requestId") $ guidanceResponse_requestId x
            , maybe [] (schemaTypeToXML "identifier") $ guidanceResponse_identifier x
            , schemaTypeToXML "module" $ guidanceResponse_module x
            , schemaTypeToXML "status" $ guidanceResponse_status x
            , maybe [] (schemaTypeToXML "subject") $ guidanceResponse_subject x
            , maybe [] (schemaTypeToXML "context") $ guidanceResponse_context x
            , maybe [] (schemaTypeToXML "occurrenceDateTime") $ guidanceResponse_occurrenceDateTime x
            , maybe [] (schemaTypeToXML "performer") $ guidanceResponse_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ guidanceResponse_choice16 x
            , concatMap (schemaTypeToXML "note") $ guidanceResponse_note x
            , concatMap (schemaTypeToXML "evaluationMessage") $ guidanceResponse_evaluationMessage x
            , maybe [] (schemaTypeToXML "outputParameters") $ guidanceResponse_outputParameters x
            , maybe [] (schemaTypeToXML "result") $ guidanceResponse_result x
            , concatMap (schemaTypeToXML "dataRequirement") $ guidanceResponse_dataRequirement x
            ]
instance Extension GuidanceResponse DomainResource where
    supertype (GuidanceResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension GuidanceResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: GuidanceResponse -> DomainResource)
              
 
data GuidanceResponseStatus'list
    = GuidanceResponseStatus'list_Success
      -- ^ Success
    | GuidanceResponseStatus'list_Data'requested
      -- ^ Data Requested
    | GuidanceResponseStatus'list_Data'required
      -- ^ Data Required
    | GuidanceResponseStatus'list_In'progress
      -- ^ In Progress
    | GuidanceResponseStatus'list_Failure
      -- ^ Failure
    | GuidanceResponseStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType GuidanceResponseStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuidanceResponseStatus'list where
    acceptingParser =  do literal "success"; return GuidanceResponseStatus'list_Success
                      `onFail` do literal "data-requested"; return GuidanceResponseStatus'list_Data'requested
                      `onFail` do literal "data-required"; return GuidanceResponseStatus'list_Data'required
                      `onFail` do literal "in-progress"; return GuidanceResponseStatus'list_In'progress
                      `onFail` do literal "failure"; return GuidanceResponseStatus'list_Failure
                      `onFail` do literal "entered-in-error"; return GuidanceResponseStatus'list_Entered'in'error
                      
    simpleTypeText GuidanceResponseStatus'list_Success = "success"
    simpleTypeText GuidanceResponseStatus'list_Data'requested = "data-requested"
    simpleTypeText GuidanceResponseStatus'list_Data'required = "data-required"
    simpleTypeText GuidanceResponseStatus'list_In'progress = "in-progress"
    simpleTypeText GuidanceResponseStatus'list_Failure = "failure"
    simpleTypeText GuidanceResponseStatus'list_Entered'in'error = "entered-in-error"
 
data GuidanceResponseStatus = GuidanceResponseStatus
        { guidanceResponseStatus_id :: Maybe String'primitive
        , guidanceResponseStatus_value :: Maybe GuidanceResponseStatus'list
        , guidanceResponseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuidanceResponseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuidanceResponseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuidanceResponseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guidanceResponseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ guidanceResponseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guidanceResponseStatus_extension x
            ]
instance Extension GuidanceResponseStatus Element where
    supertype (GuidanceResponseStatus a0 a1 e0) =
               Element a0 e0
 
-- | The details of a healthcare service available at a 
--   location.
elementHealthcareService :: XMLParser HealthcareService
elementHealthcareService = parseSchemaType "HealthcareService"
elementToXMLHealthcareService :: HealthcareService -> [Content ()]
elementToXMLHealthcareService = schemaTypeToXML "HealthcareService"
 
data HealthcareService = HealthcareService
        { healthcareService_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , healthcareService_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , healthcareService_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , healthcareService_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , healthcareService_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , healthcareService_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , healthcareService_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareService_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareService_identifier :: [Identifier]
          -- ^ External identifiers for this item.
        , healthcareService_active :: Maybe Boolean
          -- ^ Whether this healthcareservice record is in active use.
        , healthcareService_providedBy :: Maybe Reference
          -- ^ The organization that provides this healthcare service.
        , healthcareService_category :: Maybe CodeableConcept
          -- ^ Identifies the broad category of service being performed or 
          --   delivered.
        , healthcareService_type :: [CodeableConcept]
          -- ^ The specific type of service that may be delivered or 
          --   performed.
        , healthcareService_specialty :: [CodeableConcept]
          -- ^ Collection of specialties handled by the service site. This 
          --   is more of a medical term.
        , healthcareService_location :: [Reference]
          -- ^ The location(s) where this healthcare service may be 
          --   provided.
        , healthcareService_name :: Maybe Xsd.XsdString
          -- ^ Further description of the service as it would be presented 
          --   to a consumer while searching.
        , healthcareService_comment :: Maybe Xsd.XsdString
          -- ^ Any additional description of the service and/or any 
          --   specific issues not covered by the other attributes, which 
          --   can be displayed as further detail under the serviceName.
        , healthcareService_extraDetails :: Maybe Xsd.XsdString
          -- ^ Extra details about the service that can't be placed in the 
          --   other fields.
        , healthcareService_photo :: Maybe Attachment
          -- ^ If there is a photo/symbol associated with this 
          --   HealthcareService, it may be included here to facilitate 
          --   quick identification of the service in a list.
        , healthcareService_telecom :: [ContactPoint]
          -- ^ List of contacts related to this specific healthcare 
          --   service.
        , healthcareService_coverageArea :: [Reference]
          -- ^ The location(s) that this service is available to (not 
          --   where the service is provided).
        , healthcareService_serviceProvisionCode :: [CodeableConcept]
          -- ^ The code(s) that detail the conditions under which the 
          --   healthcare service is available/offered.
        , healthcareService_eligibility :: Maybe CodeableConcept
          -- ^ Does this service have specific eligibility requirements 
          --   that need to be met in order to use the service?
        , healthcareService_eligibilityNote :: Maybe Xsd.XsdString
          -- ^ Describes the eligibility conditions for the service.
        , healthcareService_programName :: [Xsd.XsdString]
          -- ^ Program Names that can be used to categorize the service.
        , healthcareService_characteristic :: [CodeableConcept]
          -- ^ Collection of characteristics (attributes).
        , healthcareService_referralMethod :: [CodeableConcept]
          -- ^ Ways that the service accepts referrals, if this is not 
          --   provided then it is implied that no referral is required.
        , healthcareService_appointmentRequired :: Maybe Boolean
          -- ^ Indicates whether or not a prospective consumer will 
          --   require an appointment for a particular service at a site 
          --   to be provided by the Organization. Indicates if an 
          --   appointment is required for access to this service.
        , healthcareService_availableTime :: [HealthcareService'AvailableTime]
          -- ^ A collection of times that the Service Site is available.
        , healthcareService_notAvailable :: [HealthcareService'NotAvailable]
          -- ^ The HealthcareService is not available during this period 
          --   of time due to the provided reason.
        , healthcareService_availabilityExceptions :: Maybe Xsd.XsdString
          -- ^ A description of site availability exceptions, e.g. public 
          --   holiday availability. Succinctly describing all possible 
          --   exceptions to normal site availability as details in the 
          --   available Times and not available Times.
        , healthcareService_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the specific healthcare services defined at this 
          --   resource.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareService where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return HealthcareService
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "providedBy")
            `apply` optional (parseSchemaType "category")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "specialty")
            `apply` many (parseSchemaType "location")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "extraDetails")
            `apply` optional (parseSchemaType "photo")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "coverageArea")
            `apply` many (parseSchemaType "serviceProvisionCode")
            `apply` optional (parseSchemaType "eligibility")
            `apply` optional (parseSchemaType "eligibilityNote")
            `apply` many (parseSchemaType "programName")
            `apply` many (parseSchemaType "characteristic")
            `apply` many (parseSchemaType "referralMethod")
            `apply` optional (parseSchemaType "appointmentRequired")
            `apply` many (parseSchemaType "availableTime")
            `apply` many (parseSchemaType "notAvailable")
            `apply` optional (parseSchemaType "availabilityExceptions")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@HealthcareService{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ healthcareService_id x
            , maybe [] (schemaTypeToXML "meta") $ healthcareService_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ healthcareService_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ healthcareService_language x
            , maybe [] (schemaTypeToXML "text") $ healthcareService_text x
            , concatMap (schemaTypeToXML "contained") $ healthcareService_contained x
            , concatMap (schemaTypeToXML "extension") $ healthcareService_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareService_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ healthcareService_identifier x
            , maybe [] (schemaTypeToXML "active") $ healthcareService_active x
            , maybe [] (schemaTypeToXML "providedBy") $ healthcareService_providedBy x
            , maybe [] (schemaTypeToXML "category") $ healthcareService_category x
            , concatMap (schemaTypeToXML "type") $ healthcareService_type x
            , concatMap (schemaTypeToXML "specialty") $ healthcareService_specialty x
            , concatMap (schemaTypeToXML "location") $ healthcareService_location x
            , maybe [] (schemaTypeToXML "name") $ healthcareService_name x
            , maybe [] (schemaTypeToXML "comment") $ healthcareService_comment x
            , maybe [] (schemaTypeToXML "extraDetails") $ healthcareService_extraDetails x
            , maybe [] (schemaTypeToXML "photo") $ healthcareService_photo x
            , concatMap (schemaTypeToXML "telecom") $ healthcareService_telecom x
            , concatMap (schemaTypeToXML "coverageArea") $ healthcareService_coverageArea x
            , concatMap (schemaTypeToXML "serviceProvisionCode") $ healthcareService_serviceProvisionCode x
            , maybe [] (schemaTypeToXML "eligibility") $ healthcareService_eligibility x
            , maybe [] (schemaTypeToXML "eligibilityNote") $ healthcareService_eligibilityNote x
            , concatMap (schemaTypeToXML "programName") $ healthcareService_programName x
            , concatMap (schemaTypeToXML "characteristic") $ healthcareService_characteristic x
            , concatMap (schemaTypeToXML "referralMethod") $ healthcareService_referralMethod x
            , maybe [] (schemaTypeToXML "appointmentRequired") $ healthcareService_appointmentRequired x
            , concatMap (schemaTypeToXML "availableTime") $ healthcareService_availableTime x
            , concatMap (schemaTypeToXML "notAvailable") $ healthcareService_notAvailable x
            , maybe [] (schemaTypeToXML "availabilityExceptions") $ healthcareService_availabilityExceptions x
            , concatMap (schemaTypeToXML "endpoint") $ healthcareService_endpoint x
            ]
instance Extension HealthcareService DomainResource where
    supertype (HealthcareService e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension HealthcareService Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: HealthcareService -> DomainResource)
              
 
-- | The details of a healthcare service available at a 
--   location.
data HealthcareService'AvailableTime = HealthcareService'AvailableTime
        { healthcareService'AvailableTime_id :: Maybe String'primitive
        , healthcareService'AvailableTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareService'AvailableTime_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareService'AvailableTime_daysOfWeek :: [DaysOfWeek]
          -- ^ Indicates which days of the week are available between the 
          --   start and end Times.
        , healthcareService'AvailableTime_allDay :: Maybe Boolean
          -- ^ Is this always available? (hence times are irrelevant) e.g. 
          --   24 hour service.
        , healthcareService'AvailableTime_availableStartTime :: Maybe Time
          -- ^ The opening time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        , healthcareService'AvailableTime_availableEndTime :: Maybe Time
          -- ^ The closing time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareService'AvailableTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HealthcareService'AvailableTime a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "daysOfWeek")
            `apply` optional (parseSchemaType "allDay")
            `apply` optional (parseSchemaType "availableStartTime")
            `apply` optional (parseSchemaType "availableEndTime")
    schemaTypeToXML s x@HealthcareService'AvailableTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ healthcareService'AvailableTime_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ healthcareService'AvailableTime_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareService'AvailableTime_modifierExtension x
            , concatMap (schemaTypeToXML "daysOfWeek") $ healthcareService'AvailableTime_daysOfWeek x
            , maybe [] (schemaTypeToXML "allDay") $ healthcareService'AvailableTime_allDay x
            , maybe [] (schemaTypeToXML "availableStartTime") $ healthcareService'AvailableTime_availableStartTime x
            , maybe [] (schemaTypeToXML "availableEndTime") $ healthcareService'AvailableTime_availableEndTime x
            ]
instance Extension HealthcareService'AvailableTime BackboneElement where
    supertype (HealthcareService'AvailableTime a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension HealthcareService'AvailableTime Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: HealthcareService'AvailableTime -> BackboneElement)
              
 
-- | The details of a healthcare service available at a 
--   location.
data HealthcareService'NotAvailable = HealthcareService'NotAvailable
        { healthcareService'NotAvailable_id :: Maybe String'primitive
        , healthcareService'NotAvailable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareService'NotAvailable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareService'NotAvailable_description :: Xsd.XsdString
          -- ^ The reason that can be presented to the user as to why this 
          --   time is not available.
        , healthcareService'NotAvailable_during :: Maybe Period
          -- ^ Service is not available (seasonally or for a public 
          --   holiday) from this date.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareService'NotAvailable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HealthcareService'NotAvailable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "during")
    schemaTypeToXML s x@HealthcareService'NotAvailable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ healthcareService'NotAvailable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ healthcareService'NotAvailable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareService'NotAvailable_modifierExtension x
            , schemaTypeToXML "description" $ healthcareService'NotAvailable_description x
            , maybe [] (schemaTypeToXML "during") $ healthcareService'NotAvailable_during x
            ]
instance Extension HealthcareService'NotAvailable BackboneElement where
    supertype (HealthcareService'NotAvailable a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension HealthcareService'NotAvailable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: HealthcareService'NotAvailable -> BackboneElement)
              
 
data DaysOfWeek'list
    = DaysOfWeek'list_Mon
      -- ^ Monday
    | DaysOfWeek'list_Tue
      -- ^ Tuesday
    | DaysOfWeek'list_Wed
      -- ^ Wednesday
    | DaysOfWeek'list_Thu
      -- ^ Thursday
    | DaysOfWeek'list_Fri
      -- ^ Friday
    | DaysOfWeek'list_Sat
      -- ^ Saturday
    | DaysOfWeek'list_Sun
      -- ^ Sunday
    deriving (Eq,Show,Enum)
instance SchemaType DaysOfWeek'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DaysOfWeek'list where
    acceptingParser =  do literal "mon"; return DaysOfWeek'list_Mon
                      `onFail` do literal "tue"; return DaysOfWeek'list_Tue
                      `onFail` do literal "wed"; return DaysOfWeek'list_Wed
                      `onFail` do literal "thu"; return DaysOfWeek'list_Thu
                      `onFail` do literal "fri"; return DaysOfWeek'list_Fri
                      `onFail` do literal "sat"; return DaysOfWeek'list_Sat
                      `onFail` do literal "sun"; return DaysOfWeek'list_Sun
                      
    simpleTypeText DaysOfWeek'list_Mon = "mon"
    simpleTypeText DaysOfWeek'list_Tue = "tue"
    simpleTypeText DaysOfWeek'list_Wed = "wed"
    simpleTypeText DaysOfWeek'list_Thu = "thu"
    simpleTypeText DaysOfWeek'list_Fri = "fri"
    simpleTypeText DaysOfWeek'list_Sat = "sat"
    simpleTypeText DaysOfWeek'list_Sun = "sun"
 
data DaysOfWeek = DaysOfWeek
        { daysOfWeek_id :: Maybe String'primitive
        , daysOfWeek_value :: Maybe DaysOfWeek'list
        , daysOfWeek_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DaysOfWeek where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DaysOfWeek a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DaysOfWeek{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ daysOfWeek_id x
                       , maybe [] (toXMLAttribute "value") $ daysOfWeek_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ daysOfWeek_extension x
            ]
instance Extension DaysOfWeek Element where
    supertype (DaysOfWeek a0 a1 e0) =
               Element a0 e0
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
elementImagingManifest :: XMLParser ImagingManifest
elementImagingManifest = parseSchemaType "ImagingManifest"
elementToXMLImagingManifest :: ImagingManifest -> [Content ()]
elementToXMLImagingManifest = schemaTypeToXML "ImagingManifest"
 
data ImagingManifest = ImagingManifest
        { imagingManifest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , imagingManifest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , imagingManifest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , imagingManifest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , imagingManifest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , imagingManifest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , imagingManifest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifest_identifier :: Maybe Identifier
          -- ^ Unique identifier of the DICOM Key Object Selection (KOS) 
          --   that this resource represents.
        , imagingManifest_patient :: Reference
          -- ^ A patient resource reference which is the patient subject 
          --   of all DICOM SOP Instances in this ImagingManifest.
        , imagingManifest_authoringTime :: Maybe DateTime
          -- ^ Date and time when the selection of the referenced 
          --   instances were made. It is (typically) different from the 
          --   creation date of the selection resource, and from dates 
          --   associated with the referenced instances (e.g. capture time 
          --   of the referenced image).
        , imagingManifest_author :: Maybe Reference
          -- ^ Author of ImagingManifest. It can be a human author or a 
          --   device which made the decision of the SOP instances 
          --   selected. For example, a radiologist selected a set of 
          --   imaging SOP instances to attach in a diagnostic report, and 
          --   a CAD application may author a selection to describe SOP 
          --   instances it used to generate a detection conclusion.
        , imagingManifest_description :: Maybe Xsd.XsdString
          -- ^ Free text narrative description of the ImagingManifest. The 
          --   value may be derived from the DICOM Standard Part 16, 
          --   CID-7010 descriptions (e.g. Best in Set, Complete Study 
          --   Content). Note that those values cover the wide range of 
          --   uses of the DICOM Key Object Selection object, several of 
          --   which are not supported by ImagingManifest. Specifically, 
          --   there is no expected behavior associated with descriptions 
          --   that suggest referenced images be removed or not used.
        , imagingManifest_study :: [ImagingManifest'Study]
          -- ^ Study identity and locating information of the DICOM SOP 
          --   instances in the selection.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImagingManifest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "authoringTime")
            `apply` optional (parseSchemaType "author")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "study")
    schemaTypeToXML s x@ImagingManifest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ imagingManifest_id x
            , maybe [] (schemaTypeToXML "meta") $ imagingManifest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ imagingManifest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ imagingManifest_language x
            , maybe [] (schemaTypeToXML "text") $ imagingManifest_text x
            , concatMap (schemaTypeToXML "contained") $ imagingManifest_contained x
            , concatMap (schemaTypeToXML "extension") $ imagingManifest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifest_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ imagingManifest_identifier x
            , schemaTypeToXML "patient" $ imagingManifest_patient x
            , maybe [] (schemaTypeToXML "authoringTime") $ imagingManifest_authoringTime x
            , maybe [] (schemaTypeToXML "author") $ imagingManifest_author x
            , maybe [] (schemaTypeToXML "description") $ imagingManifest_description x
            , concatMap (schemaTypeToXML "study") $ imagingManifest_study x
            ]
instance Extension ImagingManifest DomainResource where
    supertype (ImagingManifest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImagingManifest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImagingManifest -> DomainResource)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifest'Study = ImagingManifest'Study
        { imagingManifest'Study_id :: Maybe String'primitive
        , imagingManifest'Study_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifest'Study_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifest'Study_uid :: Oid
          -- ^ Study instance UID of the SOP instances in the selection.
        , imagingManifest'Study_imagingStudy :: Maybe Reference
          -- ^ Reference to the Imaging Study in FHIR form.
        , imagingManifest'Study_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for the study. See implementation notes for 
          --   information about using DICOM endpoints. A study-level 
          --   endpoint applies to each series in the study, unless 
          --   overridden by a series-level endpoint with the same 
          --   Endpoint.type.
        , imagingManifest'Study_series :: [ImagingManifest'Series]
          -- ^ Series identity and locating information of the DICOM SOP 
          --   instances in the selection.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifest'Study where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifest'Study a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "imagingStudy")
            `apply` many (parseSchemaType "endpoint")
            `apply` many1 (parseSchemaType "series")
    schemaTypeToXML s x@ImagingManifest'Study{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifest'Study_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifest'Study_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifest'Study_modifierExtension x
            , schemaTypeToXML "uid" $ imagingManifest'Study_uid x
            , maybe [] (schemaTypeToXML "imagingStudy") $ imagingManifest'Study_imagingStudy x
            , concatMap (schemaTypeToXML "endpoint") $ imagingManifest'Study_endpoint x
            , concatMap (schemaTypeToXML "series") $ imagingManifest'Study_series x
            ]
instance Extension ImagingManifest'Study BackboneElement where
    supertype (ImagingManifest'Study a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifest'Study Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifest'Study -> BackboneElement)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifest'Series = ImagingManifest'Series
        { imagingManifest'Series_id :: Maybe String'primitive
        , imagingManifest'Series_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifest'Series_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifest'Series_uid :: Oid
          -- ^ Series instance UID of the SOP instances in the selection.
        , imagingManifest'Series_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for this series. See implementation notes for 
          --   information about using DICOM endpoints. A series-level 
          --   endpoint, if present, has precedence over a study-level 
          --   endpoint with the same Endpoint.type.
        , imagingManifest'Series_instance :: [ImagingManifest'Instance]
          -- ^ Identity and locating information of the selected DICOM SOP 
          --   instances.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifest'Series where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifest'Series a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` many (parseSchemaType "endpoint")
            `apply` many1 (parseSchemaType "instance")
    schemaTypeToXML s x@ImagingManifest'Series{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifest'Series_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifest'Series_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifest'Series_modifierExtension x
            , schemaTypeToXML "uid" $ imagingManifest'Series_uid x
            , concatMap (schemaTypeToXML "endpoint") $ imagingManifest'Series_endpoint x
            , concatMap (schemaTypeToXML "instance") $ imagingManifest'Series_instance x
            ]
instance Extension ImagingManifest'Series BackboneElement where
    supertype (ImagingManifest'Series a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifest'Series Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifest'Series -> BackboneElement)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifest'Instance = ImagingManifest'Instance
        { imagingManifest'Instance_id :: Maybe String'primitive
        , imagingManifest'Instance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifest'Instance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifest'Instance_sopClass :: Oid
          -- ^ SOP class UID of the selected instance.
        , imagingManifest'Instance_uid :: Oid
          -- ^ SOP Instance UID of the selected instance.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifest'Instance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifest'Instance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sopClass"
            `apply` parseSchemaType "uid"
    schemaTypeToXML s x@ImagingManifest'Instance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifest'Instance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifest'Instance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifest'Instance_modifierExtension x
            , schemaTypeToXML "sopClass" $ imagingManifest'Instance_sopClass x
            , schemaTypeToXML "uid" $ imagingManifest'Instance_uid x
            ]
instance Extension ImagingManifest'Instance BackboneElement where
    supertype (ImagingManifest'Instance a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifest'Instance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifest'Instance -> BackboneElement)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
elementImagingStudy :: XMLParser ImagingStudy
elementImagingStudy = parseSchemaType "ImagingStudy"
elementToXMLImagingStudy :: ImagingStudy -> [Content ()]
elementToXMLImagingStudy = schemaTypeToXML "ImagingStudy"
 
data ImagingStudy = ImagingStudy
        { imagingStudy_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , imagingStudy_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , imagingStudy_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , imagingStudy_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , imagingStudy_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , imagingStudy_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , imagingStudy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudy_uid :: Oid
          -- ^ Formal identifier for the study.
        , imagingStudy_accession :: Maybe Identifier
          -- ^ Accession Number is an identifier related to some aspect of 
          --   imaging workflow and data management. Usage may vary across 
          --   different institutions. See for instance [IHE Radiology 
          --   Technical Framework Volume 1 Appendix 
          --   A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf).
        , imagingStudy_identifier :: [Identifier]
          -- ^ Other identifiers for the study.
        , imagingStudy_availability :: Maybe InstanceAvailability
          -- ^ Availability of study (online, offline, or nearline).
        , imagingStudy_modalityList :: [Coding]
          -- ^ A list of all the Series.ImageModality values that are 
          --   actual acquisition modalities, i.e. those in the DICOM 
          --   Context Group 29 (value set OID 1.2.840.10008.6.1.19).
        , imagingStudy_patient :: Reference
          -- ^ The patient imaged in the study.
        , imagingStudy_context :: Maybe Reference
          -- ^ The encounter or episode at which the request is initiated.
        , imagingStudy_started :: Maybe DateTime
          -- ^ Date and time the study started.
        , imagingStudy_basedOn :: [Reference]
          -- ^ A list of the diagnostic requests that resulted in this 
          --   imaging study being performed.
        , imagingStudy_referrer :: Maybe Reference
          -- ^ The requesting/referring physician.
        , imagingStudy_interpreter :: [Reference]
          -- ^ Who read the study and interpreted the images or other 
          --   content.
        , imagingStudy_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for the study. See implementation notes for 
          --   information about using DICOM endpoints. A study-level 
          --   endpoint applies to each series in the study, unless 
          --   overridden by a series-level endpoint with the same 
          --   Endpoint.type.
        , imagingStudy_numberOfSeries :: Maybe UnsignedInt
          -- ^ Number of Series in the Study. This value given may be 
          --   larger than the number of series elements this Resource 
          --   contains due to resource availability, security, or other 
          --   factors. This element should be present if any series 
          --   elements are present.
        , imagingStudy_numberOfInstances :: Maybe UnsignedInt
          -- ^ Number of SOP Instances in Study. This value given may be 
          --   larger than the number of instance elements this resource 
          --   contains due to resource availability, security, or other 
          --   factors. This element should be present if any instance 
          --   elements are present.
        , imagingStudy_procedureReference :: [Reference]
          -- ^ A reference to the performed Procedure.
        , imagingStudy_procedureCode :: [CodeableConcept]
          -- ^ The code for the performed procedure type.
        , imagingStudy_reason :: Maybe CodeableConcept
          -- ^ Description of clinical condition indicating why the 
          --   ImagingStudy was requested.
        , imagingStudy_description :: Maybe Xsd.XsdString
          -- ^ Institution-generated description or classification of the 
          --   Study performed.
        , imagingStudy_series :: [ImagingStudy'Series]
          -- ^ Each study has one or more series of images or other 
          --   content.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImagingStudy
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "accession")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "availability")
            `apply` many (parseSchemaType "modalityList")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "started")
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "referrer")
            `apply` many (parseSchemaType "interpreter")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "numberOfSeries")
            `apply` optional (parseSchemaType "numberOfInstances")
            `apply` many (parseSchemaType "procedureReference")
            `apply` many (parseSchemaType "procedureCode")
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "series")
    schemaTypeToXML s x@ImagingStudy{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ imagingStudy_id x
            , maybe [] (schemaTypeToXML "meta") $ imagingStudy_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ imagingStudy_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ imagingStudy_language x
            , maybe [] (schemaTypeToXML "text") $ imagingStudy_text x
            , concatMap (schemaTypeToXML "contained") $ imagingStudy_contained x
            , concatMap (schemaTypeToXML "extension") $ imagingStudy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudy_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudy_uid x
            , maybe [] (schemaTypeToXML "accession") $ imagingStudy_accession x
            , concatMap (schemaTypeToXML "identifier") $ imagingStudy_identifier x
            , maybe [] (schemaTypeToXML "availability") $ imagingStudy_availability x
            , concatMap (schemaTypeToXML "modalityList") $ imagingStudy_modalityList x
            , schemaTypeToXML "patient" $ imagingStudy_patient x
            , maybe [] (schemaTypeToXML "context") $ imagingStudy_context x
            , maybe [] (schemaTypeToXML "started") $ imagingStudy_started x
            , concatMap (schemaTypeToXML "basedOn") $ imagingStudy_basedOn x
            , maybe [] (schemaTypeToXML "referrer") $ imagingStudy_referrer x
            , concatMap (schemaTypeToXML "interpreter") $ imagingStudy_interpreter x
            , concatMap (schemaTypeToXML "endpoint") $ imagingStudy_endpoint x
            , maybe [] (schemaTypeToXML "numberOfSeries") $ imagingStudy_numberOfSeries x
            , maybe [] (schemaTypeToXML "numberOfInstances") $ imagingStudy_numberOfInstances x
            , concatMap (schemaTypeToXML "procedureReference") $ imagingStudy_procedureReference x
            , concatMap (schemaTypeToXML "procedureCode") $ imagingStudy_procedureCode x
            , maybe [] (schemaTypeToXML "reason") $ imagingStudy_reason x
            , maybe [] (schemaTypeToXML "description") $ imagingStudy_description x
            , concatMap (schemaTypeToXML "series") $ imagingStudy_series x
            ]
instance Extension ImagingStudy DomainResource where
    supertype (ImagingStudy e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImagingStudy Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImagingStudy -> DomainResource)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
data ImagingStudy'Series = ImagingStudy'Series
        { imagingStudy'Series_id :: Maybe String'primitive
        , imagingStudy'Series_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudy'Series_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudy'Series_uid :: Oid
          -- ^ Formal identifier for this series.
        , imagingStudy'Series_number :: Maybe UnsignedInt
          -- ^ The numeric identifier of this series in the study.
        , imagingStudy'Series_modality :: Coding
          -- ^ The modality of this series sequence.
        , imagingStudy'Series_description :: Maybe Xsd.XsdString
          -- ^ A description of the series.
        , imagingStudy'Series_numberOfInstances :: Maybe UnsignedInt
          -- ^ Number of SOP Instances in the Study. The value given may 
          --   be larger than the number of instance elements this 
          --   resource contains due to resource availability, security, 
          --   or other factors. This element should be present if any 
          --   instance elements are present.
        , imagingStudy'Series_availability :: Maybe InstanceAvailability
          -- ^ Availability of series (online, offline or nearline).
        , imagingStudy'Series_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for this series. See implementation notes for 
          --   information about using DICOM endpoints. A series-level 
          --   endpoint, if present, has precedence over a study-level 
          --   endpoint with the same Endpoint.type.
        , imagingStudy'Series_bodySite :: Maybe Coding
          -- ^ The anatomic structures examined. See DICOM Part 16 Annex L 
          --   (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) 
          --   for DICOM to SNOMED-CT mappings. The bodySite may indicate 
          --   the laterality of body part imaged; if so, it shall be 
          --   consistent with any content of 
          --   ImagingStudy.series.laterality.
        , imagingStudy'Series_laterality :: Maybe Coding
          -- ^ The laterality of the (possibly paired) anatomic structures 
          --   examined. E.g., the left knee, both lungs, or unpaired 
          --   abdomen. If present, shall be consistent with any 
          --   laterality information indicated in 
          --   ImagingStudy.series.bodySite.
        , imagingStudy'Series_started :: Maybe DateTime
          -- ^ The date and time the series was started.
        , imagingStudy'Series_performer :: [Reference]
          -- ^ The physician or operator (often the radiology technician) 
          --   who performed the series. The performer is recorded at the 
          --   series level, since each series in a study may be performed 
          --   by a different practitioner, at different times, and using 
          --   different devices. A series may be performed by multiple 
          --   practitioners.
        , imagingStudy'Series_instance :: [ImagingStudy'Instance]
          -- ^ A single SOP instance within the series, e.g. an image, or 
          --   presentation state.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudy'Series where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingStudy'Series a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "number")
            `apply` parseSchemaType "modality"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "numberOfInstances")
            `apply` optional (parseSchemaType "availability")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "laterality")
            `apply` optional (parseSchemaType "started")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "instance")
    schemaTypeToXML s x@ImagingStudy'Series{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingStudy'Series_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingStudy'Series_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudy'Series_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudy'Series_uid x
            , maybe [] (schemaTypeToXML "number") $ imagingStudy'Series_number x
            , schemaTypeToXML "modality" $ imagingStudy'Series_modality x
            , maybe [] (schemaTypeToXML "description") $ imagingStudy'Series_description x
            , maybe [] (schemaTypeToXML "numberOfInstances") $ imagingStudy'Series_numberOfInstances x
            , maybe [] (schemaTypeToXML "availability") $ imagingStudy'Series_availability x
            , concatMap (schemaTypeToXML "endpoint") $ imagingStudy'Series_endpoint x
            , maybe [] (schemaTypeToXML "bodySite") $ imagingStudy'Series_bodySite x
            , maybe [] (schemaTypeToXML "laterality") $ imagingStudy'Series_laterality x
            , maybe [] (schemaTypeToXML "started") $ imagingStudy'Series_started x
            , concatMap (schemaTypeToXML "performer") $ imagingStudy'Series_performer x
            , concatMap (schemaTypeToXML "instance") $ imagingStudy'Series_instance x
            ]
instance Extension ImagingStudy'Series BackboneElement where
    supertype (ImagingStudy'Series a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension ImagingStudy'Series Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingStudy'Series -> BackboneElement)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
data ImagingStudy'Instance = ImagingStudy'Instance
        { imagingStudy'Instance_id :: Maybe String'primitive
        , imagingStudy'Instance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudy'Instance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudy'Instance_uid :: Oid
          -- ^ Formal identifier for this image or other content.
        , imagingStudy'Instance_number :: Maybe UnsignedInt
          -- ^ The number of instance in the series.
        , imagingStudy'Instance_sopClass :: Oid
          -- ^ DICOM instance type.
        , imagingStudy'Instance_title :: Maybe Xsd.XsdString
          -- ^ The description of the instance.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudy'Instance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingStudy'Instance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "number")
            `apply` parseSchemaType "sopClass"
            `apply` optional (parseSchemaType "title")
    schemaTypeToXML s x@ImagingStudy'Instance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingStudy'Instance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingStudy'Instance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudy'Instance_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudy'Instance_uid x
            , maybe [] (schemaTypeToXML "number") $ imagingStudy'Instance_number x
            , schemaTypeToXML "sopClass" $ imagingStudy'Instance_sopClass x
            , maybe [] (schemaTypeToXML "title") $ imagingStudy'Instance_title x
            ]
instance Extension ImagingStudy'Instance BackboneElement where
    supertype (ImagingStudy'Instance a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImagingStudy'Instance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingStudy'Instance -> BackboneElement)
              
 
data InstanceAvailability'list
    = InstanceAvailability'list_ONLINE
      -- ^ Online
    | InstanceAvailability'list_OFFLINE
      -- ^ Offline
    | InstanceAvailability'list_NEARLINE
      -- ^ Nearline
    | InstanceAvailability'list_UNAVAILABLE
      -- ^ Unavailable
    deriving (Eq,Show,Enum)
instance SchemaType InstanceAvailability'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType InstanceAvailability'list where
    acceptingParser =  do literal "ONLINE"; return InstanceAvailability'list_ONLINE
                      `onFail` do literal "OFFLINE"; return InstanceAvailability'list_OFFLINE
                      `onFail` do literal "NEARLINE"; return InstanceAvailability'list_NEARLINE
                      `onFail` do literal "UNAVAILABLE"; return InstanceAvailability'list_UNAVAILABLE
                      
    simpleTypeText InstanceAvailability'list_ONLINE = "ONLINE"
    simpleTypeText InstanceAvailability'list_OFFLINE = "OFFLINE"
    simpleTypeText InstanceAvailability'list_NEARLINE = "NEARLINE"
    simpleTypeText InstanceAvailability'list_UNAVAILABLE = "UNAVAILABLE"
 
data InstanceAvailability = InstanceAvailability
        { instanceAvailability_id :: Maybe String'primitive
        , instanceAvailability_value :: Maybe InstanceAvailability'list
        , instanceAvailability_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType InstanceAvailability where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (InstanceAvailability a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@InstanceAvailability{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ instanceAvailability_id x
                       , maybe [] (toXMLAttribute "value") $ instanceAvailability_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ instanceAvailability_extension x
            ]
instance Extension InstanceAvailability Element where
    supertype (InstanceAvailability a0 a1 e0) =
               Element a0 e0
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
elementImmunization :: XMLParser Immunization
elementImmunization = parseSchemaType "Immunization"
elementToXMLImmunization :: Immunization -> [Content ()]
elementToXMLImmunization = schemaTypeToXML "Immunization"
 
data Immunization = Immunization
        { immunization_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , immunization_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , immunization_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , immunization_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , immunization_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , immunization_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , immunization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this immunization record.
        , immunization_status :: ImmunizationStatusCodes
          -- ^ Indicates the current status of the vaccination event.
        , immunization_notGiven :: Boolean
          -- ^ Indicates if the vaccination was or was not given.
        , immunization_vaccineCode :: CodeableConcept
          -- ^ Vaccine that was administered or was to be administered.
        , immunization_patient :: Reference
          -- ^ The patient who either received or did not receive the 
          --   immunization.
        , immunization_encounter :: Maybe Reference
          -- ^ The visit or admission or other contact between patient and 
          --   health care provider the immunization was performed as part 
          --   of.
        , immunization_date :: Maybe DateTime
          -- ^ Date vaccine administered or was to be administered.
        , immunization_primarySource :: Boolean
          -- ^ An indication that the content of the record is based on 
          --   information from the person who administered the vaccine. 
          --   This reflects the context under which the data was 
          --   originally recorded.
        , immunization_reportOrigin :: Maybe CodeableConcept
          -- ^ The source of the data when the report of the immunization 
          --   event is not based on information from the person who 
          --   administered the vaccine.
        , immunization_location :: Maybe Reference
          -- ^ The service delivery location where the vaccine 
          --   administration occurred.
        , immunization_manufacturer :: Maybe Reference
          -- ^ Name of vaccine manufacturer.
        , immunization_lotNumber :: Maybe Xsd.XsdString
          -- ^ Lot number of the vaccine product.
        , immunization_expirationDate :: Maybe Date
          -- ^ Date vaccine batch expires.
        , immunization_site :: Maybe CodeableConcept
          -- ^ Body site where vaccine was administered.
        , immunization_route :: Maybe CodeableConcept
          -- ^ The path by which the vaccine product is taken into the 
          --   body.
        , immunization_doseQuantity :: Maybe Quantity
          -- ^ The quantity of vaccine product that was administered.
        , immunization_practitioner :: [Immunization'Practitioner]
          -- ^ Indicates who or what performed the event.
        , immunization_note :: [Annotation]
          -- ^ Extra information about the immunization that is not 
          --   conveyed by the other attributes.
        , immunization_explanation :: Maybe Immunization'Explanation
          -- ^ Reasons why a vaccine was or was not administered.
        , immunization_reaction :: [Immunization'Reaction]
          -- ^ Categorical data indicating that an adverse event is 
          --   associated in time to an immunization.
        , immunization_vaccinationProtocol :: [Immunization'VaccinationProtocol]
          -- ^ Contains information about the protocol(s) under which the 
          --   vaccine was administered.
        }
        deriving (Eq,Show)
instance SchemaType Immunization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Immunization
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "notGiven"
            `apply` parseSchemaType "vaccineCode"
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "date")
            `apply` parseSchemaType "primarySource"
            `apply` optional (parseSchemaType "reportOrigin")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "expirationDate")
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "doseQuantity")
            `apply` many (parseSchemaType "practitioner")
            `apply` many (parseSchemaType "note")
            `apply` optional (parseSchemaType "explanation")
            `apply` many (parseSchemaType "reaction")
            `apply` many (parseSchemaType "vaccinationProtocol")
    schemaTypeToXML s x@Immunization{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ immunization_id x
            , maybe [] (schemaTypeToXML "meta") $ immunization_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ immunization_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ immunization_language x
            , maybe [] (schemaTypeToXML "text") $ immunization_text x
            , concatMap (schemaTypeToXML "contained") $ immunization_contained x
            , concatMap (schemaTypeToXML "extension") $ immunization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ immunization_identifier x
            , schemaTypeToXML "status" $ immunization_status x
            , schemaTypeToXML "notGiven" $ immunization_notGiven x
            , schemaTypeToXML "vaccineCode" $ immunization_vaccineCode x
            , schemaTypeToXML "patient" $ immunization_patient x
            , maybe [] (schemaTypeToXML "encounter") $ immunization_encounter x
            , maybe [] (schemaTypeToXML "date") $ immunization_date x
            , schemaTypeToXML "primarySource" $ immunization_primarySource x
            , maybe [] (schemaTypeToXML "reportOrigin") $ immunization_reportOrigin x
            , maybe [] (schemaTypeToXML "location") $ immunization_location x
            , maybe [] (schemaTypeToXML "manufacturer") $ immunization_manufacturer x
            , maybe [] (schemaTypeToXML "lotNumber") $ immunization_lotNumber x
            , maybe [] (schemaTypeToXML "expirationDate") $ immunization_expirationDate x
            , maybe [] (schemaTypeToXML "site") $ immunization_site x
            , maybe [] (schemaTypeToXML "route") $ immunization_route x
            , maybe [] (schemaTypeToXML "doseQuantity") $ immunization_doseQuantity x
            , concatMap (schemaTypeToXML "practitioner") $ immunization_practitioner x
            , concatMap (schemaTypeToXML "note") $ immunization_note x
            , maybe [] (schemaTypeToXML "explanation") $ immunization_explanation x
            , concatMap (schemaTypeToXML "reaction") $ immunization_reaction x
            , concatMap (schemaTypeToXML "vaccinationProtocol") $ immunization_vaccinationProtocol x
            ]
instance Extension Immunization DomainResource where
    supertype (Immunization e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Immunization Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Immunization -> DomainResource)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data Immunization'Practitioner = Immunization'Practitioner
        { immunization'Practitioner_id :: Maybe String'primitive
        , immunization'Practitioner_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization'Practitioner_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization'Practitioner_role :: Maybe CodeableConcept
          -- ^ Describes the type of performance (e.g. ordering provider, 
          --   administering provider, etc.).
        , immunization'Practitioner_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action.
        }
        deriving (Eq,Show)
instance SchemaType Immunization'Practitioner where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Immunization'Practitioner a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@Immunization'Practitioner{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunization'Practitioner_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunization'Practitioner_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization'Practitioner_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ immunization'Practitioner_role x
            , schemaTypeToXML "actor" $ immunization'Practitioner_actor x
            ]
instance Extension Immunization'Practitioner BackboneElement where
    supertype (Immunization'Practitioner a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Immunization'Practitioner Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Immunization'Practitioner -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data Immunization'Explanation = Immunization'Explanation
        { immunization'Explanation_id :: Maybe String'primitive
        , immunization'Explanation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization'Explanation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization'Explanation_reason :: [CodeableConcept]
          -- ^ Reasons why a vaccine was administered.
        , immunization'Explanation_reasonNotGiven :: [CodeableConcept]
          -- ^ Reason why a vaccine was not administered.
        }
        deriving (Eq,Show)
instance SchemaType Immunization'Explanation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Immunization'Explanation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "reasonNotGiven")
    schemaTypeToXML s x@Immunization'Explanation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunization'Explanation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunization'Explanation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization'Explanation_modifierExtension x
            , concatMap (schemaTypeToXML "reason") $ immunization'Explanation_reason x
            , concatMap (schemaTypeToXML "reasonNotGiven") $ immunization'Explanation_reasonNotGiven x
            ]
instance Extension Immunization'Explanation BackboneElement where
    supertype (Immunization'Explanation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Immunization'Explanation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Immunization'Explanation -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data Immunization'Reaction = Immunization'Reaction
        { immunization'Reaction_id :: Maybe String'primitive
        , immunization'Reaction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization'Reaction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization'Reaction_date :: Maybe DateTime
          -- ^ Date of reaction to the immunization.
        , immunization'Reaction_detail :: Maybe Reference
          -- ^ Details of the reaction.
        , immunization'Reaction_reported :: Maybe Boolean
          -- ^ Self-reported indicator.
        }
        deriving (Eq,Show)
instance SchemaType Immunization'Reaction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Immunization'Reaction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "detail")
            `apply` optional (parseSchemaType "reported")
    schemaTypeToXML s x@Immunization'Reaction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunization'Reaction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunization'Reaction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization'Reaction_modifierExtension x
            , maybe [] (schemaTypeToXML "date") $ immunization'Reaction_date x
            , maybe [] (schemaTypeToXML "detail") $ immunization'Reaction_detail x
            , maybe [] (schemaTypeToXML "reported") $ immunization'Reaction_reported x
            ]
instance Extension Immunization'Reaction BackboneElement where
    supertype (Immunization'Reaction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Immunization'Reaction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Immunization'Reaction -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data Immunization'VaccinationProtocol = Immunization'VaccinationProtocol
        { immunization'VaccinationProtocol_id :: Maybe String'primitive
        , immunization'VaccinationProtocol_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization'VaccinationProtocol_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization'VaccinationProtocol_doseSequence :: Maybe PositiveInt
          -- ^ Nominal position in a series.
        , immunization'VaccinationProtocol_description :: Maybe Xsd.XsdString
          -- ^ Contains the description about the protocol under which the 
          --   vaccine was administered.
        , immunization'VaccinationProtocol_authority :: Maybe Reference
          -- ^ Indicates the authority who published the protocol. E.g. 
          --   ACIP.
        , immunization'VaccinationProtocol_series :: Maybe Xsd.XsdString
          -- ^ One possible path to achieve presumed immunity against a 
          --   disease - within the context of an authority.
        , immunization'VaccinationProtocol_seriesDoses :: Maybe PositiveInt
          -- ^ The recommended number of doses to achieve immunity.
        , immunization'VaccinationProtocol_targetDisease :: [CodeableConcept]
          -- ^ The targeted disease.
        , immunization'VaccinationProtocol_doseStatus :: CodeableConcept
          -- ^ Indicates if the immunization event should 
          --   &quot;count&quot; against the protocol.
        , immunization'VaccinationProtocol_doseStatusReason :: Maybe CodeableConcept
          -- ^ Provides an explanation as to why an immunization event 
          --   should or should not count against the protocol.
        }
        deriving (Eq,Show)
instance SchemaType Immunization'VaccinationProtocol where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Immunization'VaccinationProtocol a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "doseSequence")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "series")
            `apply` optional (parseSchemaType "seriesDoses")
            `apply` many1 (parseSchemaType "targetDisease")
            `apply` parseSchemaType "doseStatus"
            `apply` optional (parseSchemaType "doseStatusReason")
    schemaTypeToXML s x@Immunization'VaccinationProtocol{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunization'VaccinationProtocol_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunization'VaccinationProtocol_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization'VaccinationProtocol_modifierExtension x
            , maybe [] (schemaTypeToXML "doseSequence") $ immunization'VaccinationProtocol_doseSequence x
            , maybe [] (schemaTypeToXML "description") $ immunization'VaccinationProtocol_description x
            , maybe [] (schemaTypeToXML "authority") $ immunization'VaccinationProtocol_authority x
            , maybe [] (schemaTypeToXML "series") $ immunization'VaccinationProtocol_series x
            , maybe [] (schemaTypeToXML "seriesDoses") $ immunization'VaccinationProtocol_seriesDoses x
            , concatMap (schemaTypeToXML "targetDisease") $ immunization'VaccinationProtocol_targetDisease x
            , schemaTypeToXML "doseStatus" $ immunization'VaccinationProtocol_doseStatus x
            , maybe [] (schemaTypeToXML "doseStatusReason") $ immunization'VaccinationProtocol_doseStatusReason x
            ]
instance Extension Immunization'VaccinationProtocol BackboneElement where
    supertype (Immunization'VaccinationProtocol a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension Immunization'VaccinationProtocol Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Immunization'VaccinationProtocol -> BackboneElement)
              
 
data ImmunizationStatusCodes'list
    = ImmunizationStatusCodes'list_Completed
      -- ^ Completed
    | ImmunizationStatusCodes'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ImmunizationStatusCodes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ImmunizationStatusCodes'list where
    acceptingParser =  do literal "completed"; return ImmunizationStatusCodes'list_Completed
                      `onFail` do literal "entered-in-error"; return ImmunizationStatusCodes'list_Entered'in'error
                      
    simpleTypeText ImmunizationStatusCodes'list_Completed = "completed"
    simpleTypeText ImmunizationStatusCodes'list_Entered'in'error = "entered-in-error"
 
data ImmunizationStatusCodes = ImmunizationStatusCodes
        { immunizationStatusCodes_id :: Maybe String'primitive
        , immunizationStatusCodes_value :: Maybe ImmunizationStatusCodes'list
        , immunizationStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ImmunizationStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ImmunizationStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ immunizationStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationStatusCodes_extension x
            ]
instance Extension ImmunizationStatusCodes Element where
    supertype (ImmunizationStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
elementImmunizationRecommendation :: XMLParser ImmunizationRecommendation
elementImmunizationRecommendation = parseSchemaType "ImmunizationRecommendation"
elementToXMLImmunizationRecommendation :: ImmunizationRecommendation -> [Content ()]
elementToXMLImmunizationRecommendation = schemaTypeToXML "ImmunizationRecommendation"
 
data ImmunizationRecommendation = ImmunizationRecommendation
        { immunizationRecommendation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , immunizationRecommendation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , immunizationRecommendation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , immunizationRecommendation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , immunizationRecommendation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , immunizationRecommendation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , immunizationRecommendation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendation_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this particular 
          --   recommendation record.
        , immunizationRecommendation_patient :: Reference
          -- ^ The patient the recommendations are for.
        , immunizationRecommendation_recommendation :: [ImmunizationRecommendation'Recommendation]
          -- ^ Vaccine administration recommendations.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImmunizationRecommendation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "patient"
            `apply` many1 (parseSchemaType "recommendation")
    schemaTypeToXML s x@ImmunizationRecommendation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ immunizationRecommendation_id x
            , maybe [] (schemaTypeToXML "meta") $ immunizationRecommendation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ immunizationRecommendation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ immunizationRecommendation_language x
            , maybe [] (schemaTypeToXML "text") $ immunizationRecommendation_text x
            , concatMap (schemaTypeToXML "contained") $ immunizationRecommendation_contained x
            , concatMap (schemaTypeToXML "extension") $ immunizationRecommendation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ immunizationRecommendation_identifier x
            , schemaTypeToXML "patient" $ immunizationRecommendation_patient x
            , concatMap (schemaTypeToXML "recommendation") $ immunizationRecommendation_recommendation x
            ]
instance Extension ImmunizationRecommendation DomainResource where
    supertype (ImmunizationRecommendation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImmunizationRecommendation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImmunizationRecommendation -> DomainResource)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendation'Recommendation = ImmunizationRecommendation'Recommendation
        { immunizationRecommendation'Recommendation_id :: Maybe String'primitive
        , immunizationRecommendation'Recommendation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendation'Recommendation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendation'Recommendation_date :: DateTime
          -- ^ The date the immunization recommendation was created.
        , immunizationRecommendation'Recommendation_vaccineCode :: Maybe CodeableConcept
          -- ^ Vaccine that pertains to the recommendation.
        , immunizationRecommendation'Recommendation_targetDisease :: Maybe CodeableConcept
          -- ^ The targeted disease for the recommendation.
        , immunizationRecommendation'Recommendation_doseNumber :: Maybe PositiveInt
          -- ^ The next recommended dose number (e.g. dose 2 is the next 
          --   recommended dose).
        , immunizationRecommendation'Recommendation_forecastStatus :: CodeableConcept
          -- ^ Vaccine administration status.
        , immunizationRecommendation'Recommendation_dateCriterion :: [ImmunizationRecommendation'DateCriterion]
          -- ^ Vaccine date recommendations. For example, earliest date to 
          --   administer, latest date to administer, etc.
        , immunizationRecommendation'Recommendation_protocol :: Maybe ImmunizationRecommendation'Protocol
          -- ^ Contains information about the protocol under which the 
          --   vaccine was administered.
        , immunizationRecommendation'Recommendation_supportingImmunization :: [Reference]
          -- ^ Immunization event history that supports the status and 
          --   recommendation.
        , immunizationRecommendation'Recommendation_supportingPatientInformation :: [Reference]
          -- ^ Patient Information that supports the status and 
          --   recommendation. This includes patient observations, adverse 
          --   reactions and allergy/intolerance information.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendation'Recommendation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendation'Recommendation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "vaccineCode")
            `apply` optional (parseSchemaType "targetDisease")
            `apply` optional (parseSchemaType "doseNumber")
            `apply` parseSchemaType "forecastStatus"
            `apply` many (parseSchemaType "dateCriterion")
            `apply` optional (parseSchemaType "protocol")
            `apply` many (parseSchemaType "supportingImmunization")
            `apply` many (parseSchemaType "supportingPatientInformation")
    schemaTypeToXML s x@ImmunizationRecommendation'Recommendation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendation'Recommendation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendation'Recommendation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendation'Recommendation_modifierExtension x
            , schemaTypeToXML "date" $ immunizationRecommendation'Recommendation_date x
            , maybe [] (schemaTypeToXML "vaccineCode") $ immunizationRecommendation'Recommendation_vaccineCode x
            , maybe [] (schemaTypeToXML "targetDisease") $ immunizationRecommendation'Recommendation_targetDisease x
            , maybe [] (schemaTypeToXML "doseNumber") $ immunizationRecommendation'Recommendation_doseNumber x
            , schemaTypeToXML "forecastStatus" $ immunizationRecommendation'Recommendation_forecastStatus x
            , concatMap (schemaTypeToXML "dateCriterion") $ immunizationRecommendation'Recommendation_dateCriterion x
            , maybe [] (schemaTypeToXML "protocol") $ immunizationRecommendation'Recommendation_protocol x
            , concatMap (schemaTypeToXML "supportingImmunization") $ immunizationRecommendation'Recommendation_supportingImmunization x
            , concatMap (schemaTypeToXML "supportingPatientInformation") $ immunizationRecommendation'Recommendation_supportingPatientInformation x
            ]
instance Extension ImmunizationRecommendation'Recommendation BackboneElement where
    supertype (ImmunizationRecommendation'Recommendation a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendation'Recommendation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendation'Recommendation -> BackboneElement)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendation'DateCriterion = ImmunizationRecommendation'DateCriterion
        { immunizationRecommendation'DateCriterion_id :: Maybe String'primitive
        , immunizationRecommendation'DateCriterion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendation'DateCriterion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendation'DateCriterion_code :: CodeableConcept
          -- ^ Date classification of recommendation. For example, 
          --   earliest date to give, latest date to give, etc.
        , immunizationRecommendation'DateCriterion_value :: DateTime
          -- ^ The date whose meaning is specified by dateCriterion.code.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendation'DateCriterion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendation'DateCriterion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ImmunizationRecommendation'DateCriterion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendation'DateCriterion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendation'DateCriterion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendation'DateCriterion_modifierExtension x
            , schemaTypeToXML "code" $ immunizationRecommendation'DateCriterion_code x
            , schemaTypeToXML "value" $ immunizationRecommendation'DateCriterion_value x
            ]
instance Extension ImmunizationRecommendation'DateCriterion BackboneElement where
    supertype (ImmunizationRecommendation'DateCriterion a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendation'DateCriterion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendation'DateCriterion -> BackboneElement)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendation'Protocol = ImmunizationRecommendation'Protocol
        { immunizationRecommendation'Protocol_id :: Maybe String'primitive
        , immunizationRecommendation'Protocol_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendation'Protocol_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendation'Protocol_doseSequence :: Maybe PositiveInt
          -- ^ Indicates the nominal position in a series of the next 
          --   dose. This is the recommended dose number as per a 
          --   specified protocol.
        , immunizationRecommendation'Protocol_description :: Maybe Xsd.XsdString
          -- ^ Contains the description about the protocol under which the 
          --   vaccine was administered.
        , immunizationRecommendation'Protocol_authority :: Maybe Reference
          -- ^ Indicates the authority who published the protocol. For 
          --   example, ACIP.
        , immunizationRecommendation'Protocol_series :: Maybe Xsd.XsdString
          -- ^ One possible path to achieve presumed immunity against a 
          --   disease - within the context of an authority.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendation'Protocol where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendation'Protocol a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "doseSequence")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "series")
    schemaTypeToXML s x@ImmunizationRecommendation'Protocol{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendation'Protocol_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendation'Protocol_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendation'Protocol_modifierExtension x
            , maybe [] (schemaTypeToXML "doseSequence") $ immunizationRecommendation'Protocol_doseSequence x
            , maybe [] (schemaTypeToXML "description") $ immunizationRecommendation'Protocol_description x
            , maybe [] (schemaTypeToXML "authority") $ immunizationRecommendation'Protocol_authority x
            , maybe [] (schemaTypeToXML "series") $ immunizationRecommendation'Protocol_series x
            ]
instance Extension ImmunizationRecommendation'Protocol BackboneElement where
    supertype (ImmunizationRecommendation'Protocol a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendation'Protocol Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendation'Protocol -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
elementImplementationGuide :: XMLParser ImplementationGuide
elementImplementationGuide = parseSchemaType "ImplementationGuide"
elementToXMLImplementationGuide :: ImplementationGuide -> [Content ()]
elementToXMLImplementationGuide = schemaTypeToXML "ImplementationGuide"
 
data ImplementationGuide = ImplementationGuide
        { implementationGuide_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , implementationGuide_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , implementationGuide_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , implementationGuide_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , implementationGuide_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , implementationGuide_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , implementationGuide_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide_url :: Uri
          -- ^ An absolute URI that is used to identify this 
          --   implementation guide when it is referenced in a 
          --   specification, model, design or an instance. This SHALL be 
          --   a URL, SHOULD be globally unique, and SHOULD be an address 
          --   at which this implementation guide is (or will be) 
          --   published. The URL SHOULD include the major version of the 
          --   implementation guide. For more information see [Technical 
          --   and Business Versions](resource.html#versions).
        , implementationGuide_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   implementation guide when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the implementation guide author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , implementationGuide_name :: Xsd.XsdString
          -- ^ A natural language name identifying the implementation 
          --   guide. This name should be usable as an identifier for the 
          --   module by machine processing applications such as code 
          --   generation.
        , implementationGuide_status :: PublicationStatus
          -- ^ The status of this implementation guide. Enables tracking 
          --   the life-cycle of the content.
        , implementationGuide_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this implementation guide 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , implementationGuide_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the implementation 
          --   guide was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the implementation guide changes.
        , implementationGuide_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the implementation guide.
        , implementationGuide_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , implementationGuide_description :: Maybe Markdown
          -- ^ A free text natural language description of the 
          --   implementation guide from a consumer's perspective.
        , implementationGuide_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   implementation guide instances.
        , implementationGuide_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the implementation 
          --   guide is intended to be used.
        , implementationGuide_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the implementation guide 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   implementation guide.
        , implementationGuide_fhirVersion :: Maybe Id
          -- ^ The version of the FHIR specification on which this 
          --   ImplementationGuide is based - this is the formal version 
          --   of the specification, without the revision number, e.g. 
          --   [publication].[major].[minor], which is 3.0.1 for this 
          --   version.
        , implementationGuide_dependency :: [ImplementationGuide'Dependency]
          -- ^ Another implementation guide that this implementation 
          --   depends on. Typically, an implementation guide uses value 
          --   sets, profiles etc.defined in other implementation guides.
        , implementationGuide_package :: [ImplementationGuide'Package]
          -- ^ A logical group of resources. Logical groups can be used 
          --   when building pages.
        , implementationGuide_global :: [ImplementationGuide'Global]
          -- ^ A set of profiles that all resources covered by this 
          --   implementation guide must conform to.
        , implementationGuide_binary :: [Uri]
          -- ^ A binary file that is included in the implementation guide 
          --   when it is published.
        , implementationGuide_page :: Maybe ImplementationGuide'Page
          -- ^ A page / section in the implementation guide. The root page 
          --   is the implementation guide home page.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImplementationGuide
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "fhirVersion")
            `apply` many (parseSchemaType "dependency")
            `apply` many (parseSchemaType "package")
            `apply` many (parseSchemaType "global")
            `apply` many (parseSchemaType "binary")
            `apply` optional (parseSchemaType "page")
    schemaTypeToXML s x@ImplementationGuide{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ implementationGuide_id x
            , maybe [] (schemaTypeToXML "meta") $ implementationGuide_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ implementationGuide_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ implementationGuide_language x
            , maybe [] (schemaTypeToXML "text") $ implementationGuide_text x
            , concatMap (schemaTypeToXML "contained") $ implementationGuide_contained x
            , concatMap (schemaTypeToXML "extension") $ implementationGuide_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide_modifierExtension x
            , schemaTypeToXML "url" $ implementationGuide_url x
            , maybe [] (schemaTypeToXML "version") $ implementationGuide_version x
            , schemaTypeToXML "name" $ implementationGuide_name x
            , schemaTypeToXML "status" $ implementationGuide_status x
            , maybe [] (schemaTypeToXML "experimental") $ implementationGuide_experimental x
            , maybe [] (schemaTypeToXML "date") $ implementationGuide_date x
            , maybe [] (schemaTypeToXML "publisher") $ implementationGuide_publisher x
            , concatMap (schemaTypeToXML "contact") $ implementationGuide_contact x
            , maybe [] (schemaTypeToXML "description") $ implementationGuide_description x
            , concatMap (schemaTypeToXML "useContext") $ implementationGuide_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ implementationGuide_jurisdiction x
            , maybe [] (schemaTypeToXML "copyright") $ implementationGuide_copyright x
            , maybe [] (schemaTypeToXML "fhirVersion") $ implementationGuide_fhirVersion x
            , concatMap (schemaTypeToXML "dependency") $ implementationGuide_dependency x
            , concatMap (schemaTypeToXML "package") $ implementationGuide_package x
            , concatMap (schemaTypeToXML "global") $ implementationGuide_global x
            , concatMap (schemaTypeToXML "binary") $ implementationGuide_binary x
            , maybe [] (schemaTypeToXML "page") $ implementationGuide_page x
            ]
instance Extension ImplementationGuide DomainResource where
    supertype (ImplementationGuide e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImplementationGuide Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImplementationGuide -> DomainResource)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuide'Dependency = ImplementationGuide'Dependency
        { implementationGuide'Dependency_id :: Maybe String'primitive
        , implementationGuide'Dependency_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide'Dependency_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide'Dependency_type :: GuideDependencyType
          -- ^ How the dependency is represented when the guide is 
          --   published.
        , implementationGuide'Dependency_uri :: Uri
          -- ^ Where the dependency is located.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide'Dependency where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuide'Dependency a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "uri"
    schemaTypeToXML s x@ImplementationGuide'Dependency{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuide'Dependency_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuide'Dependency_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide'Dependency_modifierExtension x
            , schemaTypeToXML "type" $ implementationGuide'Dependency_type x
            , schemaTypeToXML "uri" $ implementationGuide'Dependency_uri x
            ]
instance Extension ImplementationGuide'Dependency BackboneElement where
    supertype (ImplementationGuide'Dependency a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuide'Dependency Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuide'Dependency -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuide'Package = ImplementationGuide'Package
        { implementationGuide'Package_id :: Maybe String'primitive
        , implementationGuide'Package_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide'Package_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide'Package_name :: Xsd.XsdString
          -- ^ The name for the group, as used in page.package.
        , implementationGuide'Package_description :: Maybe Xsd.XsdString
          -- ^ Human readable text describing the package.
        , implementationGuide'Package_resource :: [ImplementationGuide'Resource]
          -- ^ A resource that is part of the implementation guide. 
          --   Conformance resources (value set, structure definition, 
          --   capability statements etc.) are obvious candidates for 
          --   inclusion, but any kind of resource can be included as an 
          --   example resource.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide'Package where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuide'Package a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "resource")
    schemaTypeToXML s x@ImplementationGuide'Package{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuide'Package_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuide'Package_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide'Package_modifierExtension x
            , schemaTypeToXML "name" $ implementationGuide'Package_name x
            , maybe [] (schemaTypeToXML "description") $ implementationGuide'Package_description x
            , concatMap (schemaTypeToXML "resource") $ implementationGuide'Package_resource x
            ]
instance Extension ImplementationGuide'Package BackboneElement where
    supertype (ImplementationGuide'Package a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuide'Package Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuide'Package -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuide'Resource = ImplementationGuide'Resource
        { implementationGuide'Resource_id :: Maybe String'primitive
        , implementationGuide'Resource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide'Resource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide'Resource_example :: Boolean
          -- ^ Whether a resource is included in the guide as part of the 
          --   rules defined by the guide, or just as an example of a 
          --   resource that conforms to the rules and/or help 
          --   implementers understand the intent of the guide.
        , implementationGuide'Resource_name :: Maybe Xsd.XsdString
          -- ^ A human assigned name for the resource. All resources 
          --   SHOULD have a name, but the name may be extracted from the 
          --   resource (e.g. ValueSet.name).
        , implementationGuide'Resource_description :: Maybe Xsd.XsdString
          -- ^ A description of the reason that a resource has been 
          --   included in the implementation guide.
        , implementationGuide'Resource_acronym :: Maybe Xsd.XsdString
          -- ^ A short code that may be used to identify the resource 
          --   throughout the implementation guide.
        , implementationGuide'Resource_choice6 :: OneOf2 Uri Reference
          -- ^ Where this resource is found.
          --   
          --   Choice between:
          --   
          --   (1) sourceUri
          --   
          --   (2) sourceReference
        , implementationGuide'Resource_exampleFor :: Maybe Reference
          -- ^ Another resource that this resource is an example for. This 
          --   is mostly used for resources that are included as examples 
          --   of StructureDefinitions.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide'Resource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuide'Resource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "example"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "acronym")
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "sourceUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "sourceReference"))
                           ]
            `apply` optional (parseSchemaType "exampleFor")
    schemaTypeToXML s x@ImplementationGuide'Resource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuide'Resource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuide'Resource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide'Resource_modifierExtension x
            , schemaTypeToXML "example" $ implementationGuide'Resource_example x
            , maybe [] (schemaTypeToXML "name") $ implementationGuide'Resource_name x
            , maybe [] (schemaTypeToXML "description") $ implementationGuide'Resource_description x
            , maybe [] (schemaTypeToXML "acronym") $ implementationGuide'Resource_acronym x
            , foldOneOf2  (schemaTypeToXML "sourceUri")
                          (schemaTypeToXML "sourceReference")
                          $ implementationGuide'Resource_choice6 x
            , maybe [] (schemaTypeToXML "exampleFor") $ implementationGuide'Resource_exampleFor x
            ]
instance Extension ImplementationGuide'Resource BackboneElement where
    supertype (ImplementationGuide'Resource a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuide'Resource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuide'Resource -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuide'Global = ImplementationGuide'Global
        { implementationGuide'Global_id :: Maybe String'primitive
        , implementationGuide'Global_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide'Global_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide'Global_type :: ResourceType
          -- ^ The type of resource that all instances must conform to.
        , implementationGuide'Global_profile :: Reference
          -- ^ A reference to the profile that all instances must conform 
          --   to.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide'Global where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuide'Global a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@ImplementationGuide'Global{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuide'Global_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuide'Global_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide'Global_modifierExtension x
            , schemaTypeToXML "type" $ implementationGuide'Global_type x
            , schemaTypeToXML "profile" $ implementationGuide'Global_profile x
            ]
instance Extension ImplementationGuide'Global BackboneElement where
    supertype (ImplementationGuide'Global a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuide'Global Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuide'Global -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuide'Page = ImplementationGuide'Page
        { implementationGuide'Page_id :: Maybe String'primitive
        , implementationGuide'Page_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide'Page_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide'Page_source :: Uri
          -- ^ The source address for the page.
        , implementationGuide'Page_title :: Xsd.XsdString
          -- ^ A short title used to represent this page in navigational 
          --   structures such as table of contents, bread crumbs, etc.
        , implementationGuide'Page_kind :: GuidePageKind
          -- ^ The kind of page that this is. Some pages are autogenerated 
          --   (list, example), and other kinds are of interest so that 
          --   tools can navigate the user to the page of interest.
        , implementationGuide'Page_type :: [ResourceType]
          -- ^ For constructed pages, what kind of resources to include in 
          --   the list.
        , implementationGuide'Page_package :: [Xsd.XsdString]
          -- ^ For constructed pages, a list of packages to include in the 
          --   page (or else empty for everything).
        , implementationGuide'Page_format :: Maybe Code
          -- ^ The format of the page.
        , implementationGuide'Page_page :: [ImplementationGuide'Page]
          -- ^ Nested Pages/Sections under this page.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide'Page where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuide'Page a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "source"
            `apply` parseSchemaType "title"
            `apply` parseSchemaType "kind"
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "package")
            `apply` optional (parseSchemaType "format")
            `apply` many (parseSchemaType "page")
    schemaTypeToXML s x@ImplementationGuide'Page{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuide'Page_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuide'Page_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide'Page_modifierExtension x
            , schemaTypeToXML "source" $ implementationGuide'Page_source x
            , schemaTypeToXML "title" $ implementationGuide'Page_title x
            , schemaTypeToXML "kind" $ implementationGuide'Page_kind x
            , concatMap (schemaTypeToXML "type") $ implementationGuide'Page_type x
            , concatMap (schemaTypeToXML "package") $ implementationGuide'Page_package x
            , maybe [] (schemaTypeToXML "format") $ implementationGuide'Page_format x
            , concatMap (schemaTypeToXML "page") $ implementationGuide'Page_page x
            ]
instance Extension ImplementationGuide'Page BackboneElement where
    supertype (ImplementationGuide'Page a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuide'Page Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuide'Page -> BackboneElement)
              
 
data GuideDependencyType'list
    = GuideDependencyType'list_Reference
      -- ^ Reference
    | GuideDependencyType'list_Inclusion
      -- ^ Inclusion
    deriving (Eq,Show,Enum)
instance SchemaType GuideDependencyType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuideDependencyType'list where
    acceptingParser =  do literal "reference"; return GuideDependencyType'list_Reference
                      `onFail` do literal "inclusion"; return GuideDependencyType'list_Inclusion
                      
    simpleTypeText GuideDependencyType'list_Reference = "reference"
    simpleTypeText GuideDependencyType'list_Inclusion = "inclusion"
 
data GuideDependencyType = GuideDependencyType
        { guideDependencyType_id :: Maybe String'primitive
        , guideDependencyType_value :: Maybe GuideDependencyType'list
        , guideDependencyType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuideDependencyType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuideDependencyType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuideDependencyType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guideDependencyType_id x
                       , maybe [] (toXMLAttribute "value") $ guideDependencyType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guideDependencyType_extension x
            ]
instance Extension GuideDependencyType Element where
    supertype (GuideDependencyType a0 a1 e0) =
               Element a0 e0
 
data GuidePageKind'list
    = GuidePageKind'list_Page
      -- ^ Page
    | GuidePageKind'list_Example
      -- ^ Example
    | GuidePageKind'list_List
      -- ^ List
    | GuidePageKind'list_Include
      -- ^ Include
    | GuidePageKind'list_Directory
      -- ^ Directory
    | GuidePageKind'list_Dictionary
      -- ^ Dictionary
    | GuidePageKind'list_Toc
      -- ^ Table Of Contents
    | GuidePageKind'list_Resource
      -- ^ Resource
    deriving (Eq,Show,Enum)
instance SchemaType GuidePageKind'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuidePageKind'list where
    acceptingParser =  do literal "page"; return GuidePageKind'list_Page
                      `onFail` do literal "example"; return GuidePageKind'list_Example
                      `onFail` do literal "list"; return GuidePageKind'list_List
                      `onFail` do literal "include"; return GuidePageKind'list_Include
                      `onFail` do literal "directory"; return GuidePageKind'list_Directory
                      `onFail` do literal "dictionary"; return GuidePageKind'list_Dictionary
                      `onFail` do literal "toc"; return GuidePageKind'list_Toc
                      `onFail` do literal "resource"; return GuidePageKind'list_Resource
                      
    simpleTypeText GuidePageKind'list_Page = "page"
    simpleTypeText GuidePageKind'list_Example = "example"
    simpleTypeText GuidePageKind'list_List = "list"
    simpleTypeText GuidePageKind'list_Include = "include"
    simpleTypeText GuidePageKind'list_Directory = "directory"
    simpleTypeText GuidePageKind'list_Dictionary = "dictionary"
    simpleTypeText GuidePageKind'list_Toc = "toc"
    simpleTypeText GuidePageKind'list_Resource = "resource"
 
data GuidePageKind = GuidePageKind
        { guidePageKind_id :: Maybe String'primitive
        , guidePageKind_value :: Maybe GuidePageKind'list
        , guidePageKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuidePageKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuidePageKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuidePageKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guidePageKind_id x
                       , maybe [] (toXMLAttribute "value") $ guidePageKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guidePageKind_extension x
            ]
instance Extension GuidePageKind Element where
    supertype (GuidePageKind a0 a1 e0) =
               Element a0 e0
 
-- | The Library resource is a general-purpose container for 
--   knowledge asset definitions. It can be used to describe and 
--   expose existing knowledge assets such as logic libraries 
--   and information model descriptions, as well as to describe 
--   a collection of knowledge assets.
elementLibrary :: XMLParser Library
elementLibrary = parseSchemaType "Library"
elementToXMLLibrary :: Library -> [Content ()]
elementToXMLLibrary = schemaTypeToXML "Library"
 
data Library = Library
        { library_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , library_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , library_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , library_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , library_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , library_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , library_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , library_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , library_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this library when 
          --   it is referenced in a specification, model, design or an 
          --   instance. This SHALL be a URL, SHOULD be globally unique, 
          --   and SHOULD be an address at which this library is (or will 
          --   be) published. The URL SHOULD include the major version of 
          --   the library. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , library_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this library 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance. e.g. CMS or 
          --   NQF identifiers for a measure artifact. Note that at least 
          --   one identifier is required for non-experimental active 
          --   artifacts.
        , library_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   library when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the library author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , library_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the library. This name 
          --   should be usable as an identifier for the module by machine 
          --   processing applications such as code generation.
        , library_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the library.
        , library_status :: PublicationStatus
          -- ^ The status of this library. Enables tracking the life-cycle 
          --   of the content.
        , library_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this library is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , library_type :: CodeableConcept
          -- ^ Identifies the type of library such as a Logic Library, 
          --   Model Definition, Asset Collection, or Module Definition.
        , library_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the library was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the library changes.
        , library_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the library.
        , library_description :: Maybe Markdown
          -- ^ A free text natural language description of the library 
          --   from a consumer's perspective.
        , library_purpose :: Maybe Markdown
          -- ^ Explaination of why this library is needed and why it has 
          --   been designed as it has.
        , library_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the library is used from a 
          --   clinical perspective.
        , library_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , library_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , library_effectivePeriod :: Maybe Period
          -- ^ The period during which the library content was or is 
          --   planned to be in active use.
        , library_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   library instances.
        , library_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the library is 
          --   intended to be used.
        , library_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the library. 
          --   Topics provide a high-level categorization of the library 
          --   that can be useful for filtering and searching.
        , library_contributor :: [Contributor]
          -- ^ A contributor to the content of the library, including 
          --   authors, editors, reviewers, and endorsers.
        , library_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , library_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the library and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the library.
        , library_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , library_parameter :: [ParameterDefinition]
          -- ^ The parameter element defines parameters used by the 
          --   library.
        , library_dataRequirement :: [DataRequirement]
          -- ^ Describes a set of data that must be provided in order to 
          --   be able to successfully perform the computations defined by 
          --   the library.
        , library_content :: [Attachment]
          -- ^ The content of the library as an Attachment. The content 
          --   may be a reference to a url, or may be directly embedded as 
          --   a base-64 string. Either way, the contentType of the 
          --   attachment determines how to interpret the content.
        }
        deriving (Eq,Show)
instance SchemaType Library where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Library
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "dataRequirement")
            `apply` many (parseSchemaType "content")
    schemaTypeToXML s x@Library{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ library_id x
            , maybe [] (schemaTypeToXML "meta") $ library_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ library_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ library_language x
            , maybe [] (schemaTypeToXML "text") $ library_text x
            , concatMap (schemaTypeToXML "contained") $ library_contained x
            , concatMap (schemaTypeToXML "extension") $ library_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ library_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ library_url x
            , concatMap (schemaTypeToXML "identifier") $ library_identifier x
            , maybe [] (schemaTypeToXML "version") $ library_version x
            , maybe [] (schemaTypeToXML "name") $ library_name x
            , maybe [] (schemaTypeToXML "title") $ library_title x
            , schemaTypeToXML "status" $ library_status x
            , maybe [] (schemaTypeToXML "experimental") $ library_experimental x
            , schemaTypeToXML "type" $ library_type x
            , maybe [] (schemaTypeToXML "date") $ library_date x
            , maybe [] (schemaTypeToXML "publisher") $ library_publisher x
            , maybe [] (schemaTypeToXML "description") $ library_description x
            , maybe [] (schemaTypeToXML "purpose") $ library_purpose x
            , maybe [] (schemaTypeToXML "usage") $ library_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ library_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ library_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ library_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ library_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ library_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ library_topic x
            , concatMap (schemaTypeToXML "contributor") $ library_contributor x
            , concatMap (schemaTypeToXML "contact") $ library_contact x
            , maybe [] (schemaTypeToXML "copyright") $ library_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ library_relatedArtifact x
            , concatMap (schemaTypeToXML "parameter") $ library_parameter x
            , concatMap (schemaTypeToXML "dataRequirement") $ library_dataRequirement x
            , concatMap (schemaTypeToXML "content") $ library_content x
            ]
instance Extension Library DomainResource where
    supertype (Library e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Library Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Library -> DomainResource)
              
 
-- | Identifies two or more records (resource instances) that 
--   are referring to the same real-world 
--   &quot;occurrence&quot;.
elementLinkage :: XMLParser Linkage
elementLinkage = parseSchemaType "Linkage"
elementToXMLLinkage :: Linkage -> [Content ()]
elementToXMLLinkage = schemaTypeToXML "Linkage"
 
data Linkage = Linkage
        { linkage_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , linkage_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , linkage_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , linkage_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , linkage_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , linkage_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , linkage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , linkage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , linkage_active :: Maybe Boolean
          -- ^ Indicates whether the asserted set of linkages are 
          --   considered to be &quot;in effect&quot;.
        , linkage_author :: Maybe Reference
          -- ^ Identifies the user or organization responsible for 
          --   asserting the linkages and who establishes the context for 
          --   evaluating the nature of each linkage.
        , linkage_item :: [Linkage'Item]
          -- ^ Identifies one of the records that is considered to refer 
          --   to the same real-world occurrence as well as how the items 
          --   hould be evaluated within the collection of linked items.
        }
        deriving (Eq,Show)
instance SchemaType Linkage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Linkage
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "author")
            `apply` many1 (parseSchemaType "item")
    schemaTypeToXML s x@Linkage{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ linkage_id x
            , maybe [] (schemaTypeToXML "meta") $ linkage_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ linkage_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ linkage_language x
            , maybe [] (schemaTypeToXML "text") $ linkage_text x
            , concatMap (schemaTypeToXML "contained") $ linkage_contained x
            , concatMap (schemaTypeToXML "extension") $ linkage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ linkage_modifierExtension x
            , maybe [] (schemaTypeToXML "active") $ linkage_active x
            , maybe [] (schemaTypeToXML "author") $ linkage_author x
            , concatMap (schemaTypeToXML "item") $ linkage_item x
            ]
instance Extension Linkage DomainResource where
    supertype (Linkage e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Linkage Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Linkage -> DomainResource)
              
 
-- | Identifies two or more records (resource instances) that 
--   are referring to the same real-world 
--   &quot;occurrence&quot;.
data Linkage'Item = Linkage'Item
        { linkage'Item_id :: Maybe String'primitive
        , linkage'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , linkage'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , linkage'Item_type :: LinkageType
          -- ^ Distinguishes which item is &quot;source of truth&quot; (if 
          --   any) and which items are no longer considered to be current 
          --   representations.
        , linkage'Item_resource :: Reference
          -- ^ The resource instance being linked as part of the group.
        }
        deriving (Eq,Show)
instance SchemaType Linkage'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Linkage'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "resource"
    schemaTypeToXML s x@Linkage'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkage'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkage'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ linkage'Item_modifierExtension x
            , schemaTypeToXML "type" $ linkage'Item_type x
            , schemaTypeToXML "resource" $ linkage'Item_resource x
            ]
instance Extension Linkage'Item BackboneElement where
    supertype (Linkage'Item a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Linkage'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Linkage'Item -> BackboneElement)
              
 
data LinkageType'list
    = LinkageType'list_Source
      -- ^ Source of truth
    | LinkageType'list_Alternate
      -- ^ Alternate record
    | LinkageType'list_Historical
      -- ^ Historical/obsolete record
    deriving (Eq,Show,Enum)
instance SchemaType LinkageType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LinkageType'list where
    acceptingParser =  do literal "source"; return LinkageType'list_Source
                      `onFail` do literal "alternate"; return LinkageType'list_Alternate
                      `onFail` do literal "historical"; return LinkageType'list_Historical
                      
    simpleTypeText LinkageType'list_Source = "source"
    simpleTypeText LinkageType'list_Alternate = "alternate"
    simpleTypeText LinkageType'list_Historical = "historical"
 
data LinkageType = LinkageType
        { linkageType_id :: Maybe String'primitive
        , linkageType_value :: Maybe LinkageType'list
        , linkageType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LinkageType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LinkageType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LinkageType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkageType_id x
                       , maybe [] (toXMLAttribute "value") $ linkageType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkageType_extension x
            ]
instance Extension LinkageType Element where
    supertype (LinkageType a0 a1 e0) =
               Element a0 e0
 
-- | A set of information summarized from a list of other 
--   resources.
elementList :: XMLParser List
elementList = parseSchemaType "List"
elementToXMLList :: List -> [Content ()]
elementToXMLList = schemaTypeToXML "List"
 
data List = List
        { list_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , list_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , list_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , list_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , list_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , list_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , list_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , list_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , list_identifier :: [Identifier]
          -- ^ Identifier for the List assigned for business purposes 
          --   outside the context of FHIR.
        , list_status :: ListStatus
          -- ^ Indicates the current state of this list.
        , list_mode :: ListMode
          -- ^ How this list was prepared - whether it is a working list 
          --   that is suitable for being maintained on an ongoing basis, 
          --   or if it represents a snapshot of a list of items from 
          --   another source, or whether it is a prepared list where 
          --   items may be marked as added, modified or deleted.
        , list_title :: Maybe Xsd.XsdString
          -- ^ A label for the list assigned by the author.
        , list_code :: Maybe CodeableConcept
          -- ^ This code defines the purpose of the list - why it was 
          --   created.
        , list_subject :: Maybe Reference
          -- ^ The common subject (or patient) of the resources that are 
          --   in the list, if there is one.
        , list_encounter :: Maybe Reference
          -- ^ The encounter that is the context in which this list was 
          --   created.
        , list_date :: Maybe DateTime
          -- ^ The date that the list was prepared.
        , list_source :: Maybe Reference
          -- ^ The entity responsible for deciding what the contents of 
          --   the list were. Where the list was created by a human, this 
          --   is the same as the author of the list.
        , list_orderedBy :: Maybe CodeableConcept
          -- ^ What order applies to the items in the list.
        , list_note :: [Annotation]
          -- ^ Comments that apply to the overall list.
        , list_entry :: [List'Entry]
          -- ^ Entries in this list.
        , list_emptyReason :: Maybe CodeableConcept
          -- ^ If the list is empty, why the list is empty.
        }
        deriving (Eq,Show)
instance SchemaType List where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return List
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "orderedBy")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "emptyReason")
    schemaTypeToXML s x@List{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ list_id x
            , maybe [] (schemaTypeToXML "meta") $ list_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ list_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ list_language x
            , maybe [] (schemaTypeToXML "text") $ list_text x
            , concatMap (schemaTypeToXML "contained") $ list_contained x
            , concatMap (schemaTypeToXML "extension") $ list_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ list_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ list_identifier x
            , schemaTypeToXML "status" $ list_status x
            , schemaTypeToXML "mode" $ list_mode x
            , maybe [] (schemaTypeToXML "title") $ list_title x
            , maybe [] (schemaTypeToXML "code") $ list_code x
            , maybe [] (schemaTypeToXML "subject") $ list_subject x
            , maybe [] (schemaTypeToXML "encounter") $ list_encounter x
            , maybe [] (schemaTypeToXML "date") $ list_date x
            , maybe [] (schemaTypeToXML "source") $ list_source x
            , maybe [] (schemaTypeToXML "orderedBy") $ list_orderedBy x
            , concatMap (schemaTypeToXML "note") $ list_note x
            , concatMap (schemaTypeToXML "entry") $ list_entry x
            , maybe [] (schemaTypeToXML "emptyReason") $ list_emptyReason x
            ]
instance Extension List DomainResource where
    supertype (List e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension List Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: List -> DomainResource)
              
 
-- | A set of information summarized from a list of other 
--   resources.
data List'Entry = List'Entry
        { list'Entry_id :: Maybe String'primitive
        , list'Entry_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , list'Entry_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , list'Entry_flag :: Maybe CodeableConcept
          -- ^ The flag allows the system constructing the list to 
          --   indicate the role and significance of the item in the list.
        , list'Entry_deleted :: Maybe Boolean
          -- ^ True if this item is marked as deleted in the list.
        , list'Entry_date :: Maybe DateTime
          -- ^ When this item was added to the list.
        , list'Entry_item :: Reference
          -- ^ A reference to the actual resource from which data was 
          --   derived.
        }
        deriving (Eq,Show)
instance SchemaType List'Entry where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (List'Entry a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "flag")
            `apply` optional (parseSchemaType "deleted")
            `apply` optional (parseSchemaType "date")
            `apply` parseSchemaType "item"
    schemaTypeToXML s x@List'Entry{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ list'Entry_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ list'Entry_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ list'Entry_modifierExtension x
            , maybe [] (schemaTypeToXML "flag") $ list'Entry_flag x
            , maybe [] (schemaTypeToXML "deleted") $ list'Entry_deleted x
            , maybe [] (schemaTypeToXML "date") $ list'Entry_date x
            , schemaTypeToXML "item" $ list'Entry_item x
            ]
instance Extension List'Entry BackboneElement where
    supertype (List'Entry a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension List'Entry Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: List'Entry -> BackboneElement)
              
 
data ListStatus'list
    = ListStatus'list_Current
      -- ^ Current
    | ListStatus'list_Retired
      -- ^ Retired
    | ListStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType ListStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ListStatus'list where
    acceptingParser =  do literal "current"; return ListStatus'list_Current
                      `onFail` do literal "retired"; return ListStatus'list_Retired
                      `onFail` do literal "entered-in-error"; return ListStatus'list_Entered'in'error
                      
    simpleTypeText ListStatus'list_Current = "current"
    simpleTypeText ListStatus'list_Retired = "retired"
    simpleTypeText ListStatus'list_Entered'in'error = "entered-in-error"
 
data ListStatus = ListStatus
        { listStatus_id :: Maybe String'primitive
        , listStatus_value :: Maybe ListStatus'list
        , listStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ListStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ListStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ListStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ listStatus_id x
                       , maybe [] (toXMLAttribute "value") $ listStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ listStatus_extension x
            ]
instance Extension ListStatus Element where
    supertype (ListStatus a0 a1 e0) =
               Element a0 e0
 
-- | Details and position information for a physical place where 
--   services are provided and resources and participants may be 
--   stored, found, contained or accommodated.
elementLocation :: XMLParser Location
elementLocation = parseSchemaType "Location"
elementToXMLLocation :: Location -> [Content ()]
elementToXMLLocation = schemaTypeToXML "Location"
 
data Location = Location
        { location_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , location_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , location_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , location_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , location_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , location_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , location_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , location_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , location_identifier :: [Identifier]
          -- ^ Unique code or number identifying the location to its 
          --   users.
        , location_status :: Maybe LocationStatus
          -- ^ The status property covers the general availability of the 
          --   resource, not the current value which may be covered by the 
          --   operationStatus, or by a schedule/slots if they are 
          --   configured for the location.
        , location_operationalStatus :: Maybe Coding
          -- ^ The Operational status covers operation values most 
          --   relevant to beds (but can also apply to 
          --   rooms/units/chair/etc such as an isolation unit/dialisys 
          --   chair). This typically covers concepts such as 
          --   contamination, housekeeping and other activities like 
          --   maintenance.
        , location_name :: Maybe Xsd.XsdString
          -- ^ Name of the location as used by humans. Does not need to be 
          --   unique.
        , location_alias :: [Xsd.XsdString]
          -- ^ A list of alternate names that the location is known as, or 
          --   was known as in the past.
        , location_description :: Maybe Xsd.XsdString
          -- ^ Description of the Location, which helps in finding or 
          --   referencing the place.
        , location_mode :: Maybe LocationMode
          -- ^ Indicates whether a resource instance represents a specific 
          --   location or a class of locations.
        , location_type :: Maybe CodeableConcept
          -- ^ Indicates the type of function performed at the location.
        , location_telecom :: [ContactPoint]
          -- ^ The contact details of communication devices available at 
          --   the location. This can include phone numbers, fax numbers, 
          --   mobile numbers, email addresses and web sites.
        , location_address :: Maybe Address
          -- ^ Physical location.
        , location_physicalType :: Maybe CodeableConcept
          -- ^ Physical form of the location, e.g. building, room, 
          --   vehicle, road.
        , location_position :: Maybe Location'Position
          -- ^ The absolute geographic location of the Location, expressed 
          --   using the WGS84 datum (This is the same co-ordinate system 
          --   used in KML).
        , location_managingOrganization :: Maybe Reference
          -- ^ The organization responsible for the provisioning and 
          --   upkeep of the location.
        , location_partOf :: Maybe Reference
          -- ^ Another Location which this Location is physically part of.
        , location_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the location.
        }
        deriving (Eq,Show)
instance SchemaType Location where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Location
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "alias")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "physicalType")
            `apply` optional (parseSchemaType "position")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "partOf")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@Location{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ location_id x
            , maybe [] (schemaTypeToXML "meta") $ location_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ location_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ location_language x
            , maybe [] (schemaTypeToXML "text") $ location_text x
            , concatMap (schemaTypeToXML "contained") $ location_contained x
            , concatMap (schemaTypeToXML "extension") $ location_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ location_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ location_identifier x
            , maybe [] (schemaTypeToXML "status") $ location_status x
            , maybe [] (schemaTypeToXML "operationalStatus") $ location_operationalStatus x
            , maybe [] (schemaTypeToXML "name") $ location_name x
            , concatMap (schemaTypeToXML "alias") $ location_alias x
            , maybe [] (schemaTypeToXML "description") $ location_description x
            , maybe [] (schemaTypeToXML "mode") $ location_mode x
            , maybe [] (schemaTypeToXML "type") $ location_type x
            , concatMap (schemaTypeToXML "telecom") $ location_telecom x
            , maybe [] (schemaTypeToXML "address") $ location_address x
            , maybe [] (schemaTypeToXML "physicalType") $ location_physicalType x
            , maybe [] (schemaTypeToXML "position") $ location_position x
            , maybe [] (schemaTypeToXML "managingOrganization") $ location_managingOrganization x
            , maybe [] (schemaTypeToXML "partOf") $ location_partOf x
            , concatMap (schemaTypeToXML "endpoint") $ location_endpoint x
            ]
instance Extension Location DomainResource where
    supertype (Location e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Location Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Location -> DomainResource)
              
 
-- | Details and position information for a physical place where 
--   services are provided and resources and participants may be 
--   stored, found, contained or accommodated.
data Location'Position = Location'Position
        { location'Position_id :: Maybe String'primitive
        , location'Position_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , location'Position_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , location'Position_longitude :: Decimal
          -- ^ Longitude. The value domain and the interpretation are the 
          --   same as for the text of the longitude element in KML (see 
          --   notes below).
        , location'Position_latitude :: Decimal
          -- ^ Latitude. The value domain and the interpretation are the 
          --   same as for the text of the latitude element in KML (see 
          --   notes below).
        , location'Position_altitude :: Maybe Decimal
          -- ^ Altitude. The value domain and the interpretation are the 
          --   same as for the text of the altitude element in KML (see 
          --   notes below).
        }
        deriving (Eq,Show)
instance SchemaType Location'Position where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Location'Position a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "longitude"
            `apply` parseSchemaType "latitude"
            `apply` optional (parseSchemaType "altitude")
    schemaTypeToXML s x@Location'Position{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ location'Position_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ location'Position_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ location'Position_modifierExtension x
            , schemaTypeToXML "longitude" $ location'Position_longitude x
            , schemaTypeToXML "latitude" $ location'Position_latitude x
            , maybe [] (schemaTypeToXML "altitude") $ location'Position_altitude x
            ]
instance Extension Location'Position BackboneElement where
    supertype (Location'Position a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Location'Position Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Location'Position -> BackboneElement)
              
 
data LocationMode'list
    = LocationMode'list_Instance
      -- ^ Instance
    | LocationMode'list_Kind
      -- ^ Kind
    deriving (Eq,Show,Enum)
instance SchemaType LocationMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LocationMode'list where
    acceptingParser =  do literal "instance"; return LocationMode'list_Instance
                      `onFail` do literal "kind"; return LocationMode'list_Kind
                      
    simpleTypeText LocationMode'list_Instance = "instance"
    simpleTypeText LocationMode'list_Kind = "kind"
 
data LocationMode = LocationMode
        { locationMode_id :: Maybe String'primitive
        , locationMode_value :: Maybe LocationMode'list
        , locationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LocationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LocationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LocationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ locationMode_id x
                       , maybe [] (toXMLAttribute "value") $ locationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ locationMode_extension x
            ]
instance Extension LocationMode Element where
    supertype (LocationMode a0 a1 e0) =
               Element a0 e0
 
data LocationStatus'list
    = LocationStatus'list_Active
      -- ^ Active
    | LocationStatus'list_Suspended
      -- ^ Suspended
    | LocationStatus'list_Inactive
      -- ^ Inactive
    deriving (Eq,Show,Enum)
instance SchemaType LocationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LocationStatus'list where
    acceptingParser =  do literal "active"; return LocationStatus'list_Active
                      `onFail` do literal "suspended"; return LocationStatus'list_Suspended
                      `onFail` do literal "inactive"; return LocationStatus'list_Inactive
                      
    simpleTypeText LocationStatus'list_Active = "active"
    simpleTypeText LocationStatus'list_Suspended = "suspended"
    simpleTypeText LocationStatus'list_Inactive = "inactive"
 
data LocationStatus = LocationStatus
        { locationStatus_id :: Maybe String'primitive
        , locationStatus_value :: Maybe LocationStatus'list
        , locationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LocationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LocationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LocationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ locationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ locationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ locationStatus_extension x
            ]
instance Extension LocationStatus Element where
    supertype (LocationStatus a0 a1 e0) =
               Element a0 e0
 
-- | The Measure resource provides the definition of a quality 
--   measure.
elementMeasure :: XMLParser Measure
elementMeasure = parseSchemaType "Measure"
elementToXMLMeasure :: Measure -> [Content ()]
elementToXMLMeasure = schemaTypeToXML "Measure"
 
data Measure = Measure
        { measure_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , measure_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , measure_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , measure_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , measure_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , measure_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , measure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this measure when 
          --   it is referenced in a specification, model, design or an 
          --   instance. This SHALL be a URL, SHOULD be globally unique, 
          --   and SHOULD be an address at which this measure is (or will 
          --   be) published. The URL SHOULD include the major version of 
          --   the measure. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , measure_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this measure 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , measure_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   measure when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the measure author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , measure_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the measure. This name 
          --   should be usable as an identifier for the module by machine 
          --   processing applications such as code generation.
        , measure_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the measure.
        , measure_status :: PublicationStatus
          -- ^ The status of this measure. Enables tracking the life-cycle 
          --   of the content.
        , measure_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this measure is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , measure_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the measure was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the measure changes.
        , measure_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the measure.
        , measure_description :: Maybe Markdown
          -- ^ A free text natural language description of the measure 
          --   from a consumer's perspective.
        , measure_purpose :: Maybe Markdown
          -- ^ Explaination of why this measure is needed and why it has 
          --   been designed as it has.
        , measure_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the measure is used from a 
          --   clinical perspective.
        , measure_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , measure_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , measure_effectivePeriod :: Maybe Period
          -- ^ The period during which the measure content was or is 
          --   planned to be in active use.
        , measure_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   measure instances.
        , measure_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the measure is 
          --   intended to be used.
        , measure_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the measure. 
          --   Topics provide a high-level categorization of the type of 
          --   the measure that can be useful for filtering and searching.
        , measure_contributor :: [Contributor]
          -- ^ A contributor to the content of the measure, including 
          --   authors, editors, reviewers, and endorsers.
        , measure_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , measure_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the measure and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the measure.
        , measure_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , measure_library :: [Reference]
          -- ^ A reference to a Library resource containing the formal 
          --   logic used by the measure.
        , measure_disclaimer :: Maybe Markdown
          -- ^ Notices and disclaimers regarding the use of the measure, 
          --   or related to intellectual property (such as code systems) 
          --   referenced by the measure.
        , measure_scoring :: Maybe CodeableConcept
          -- ^ Indicates how the calculation is performed for the measure, 
          --   including proportion, ratio, continuous variable, and 
          --   cohort. The value set is extensible, allowing additional 
          --   measure scoring types to be represented.
        , measure_compositeScoring :: Maybe CodeableConcept
          -- ^ If this is a composite measure, the scoring method used to 
          --   combine the component measures to determine the composite 
          --   score.
        , measure_type :: [CodeableConcept]
          -- ^ Indicates whether the measure is used to examine a process, 
          --   an outcome over time, a patient-reported outcome, or a 
          --   structure measure such as utilization.
        , measure_riskAdjustment :: Maybe Xsd.XsdString
          -- ^ A description of the risk adjustment factors that may 
          --   impact the resulting score for the measure and how they may 
          --   be accounted for when computing and reporting measure 
          --   results.
        , measure_rateAggregation :: Maybe Xsd.XsdString
          -- ^ Describes how to combine the information calculated, based 
          --   on logic in each of several populations, into one 
          --   summarized result.
        , measure_rationale :: Maybe Markdown
          -- ^ Provides a succint statement of the need for the measure. 
          --   Usually includes statements pertaining to importance 
          --   criterion: impact, gap in care, and evidence.
        , measure_clinicalRecommendationStatement :: Maybe Markdown
          -- ^ Provides a summary of relevant clinical guidelines or other 
          --   clinical recommendations supporting the measure.
        , measure_improvementNotation :: Maybe Xsd.XsdString
          -- ^ Information on whether an increase or decrease in score is 
          --   the preferred result (e.g., a higher score indicates better 
          --   quality OR a lower score indicates better quality OR 
          --   quality is whthin a range).
        , measure_definition :: [Markdown]
          -- ^ Provides a description of an individual term used within 
          --   the measure.
        , measure_guidance :: Maybe Markdown
          -- ^ Additional guidance for the measure including how it can be 
          --   used in a clinical context, and the intent of the measure.
        , measure_set :: Maybe Xsd.XsdString
          -- ^ The measure set, e.g. Preventive Care and Screening.
        , measure_group :: [Measure'Group]
          -- ^ A group of population criteria for the measure.
        , measure_supplementalData :: [Measure'SupplementalData]
          -- ^ The supplemental data criteria for the measure report, 
          --   specified as either the name of a valid CQL expression 
          --   within a referenced library, or a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType Measure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Measure
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` optional (parseSchemaType "disclaimer")
            `apply` optional (parseSchemaType "scoring")
            `apply` optional (parseSchemaType "compositeScoring")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "riskAdjustment")
            `apply` optional (parseSchemaType "rateAggregation")
            `apply` optional (parseSchemaType "rationale")
            `apply` optional (parseSchemaType "clinicalRecommendationStatement")
            `apply` optional (parseSchemaType "improvementNotation")
            `apply` many (parseSchemaType "definition")
            `apply` optional (parseSchemaType "guidance")
            `apply` optional (parseSchemaType "set")
            `apply` many (parseSchemaType "group")
            `apply` many (parseSchemaType "supplementalData")
    schemaTypeToXML s x@Measure{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ measure_id x
            , maybe [] (schemaTypeToXML "meta") $ measure_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ measure_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ measure_language x
            , maybe [] (schemaTypeToXML "text") $ measure_text x
            , concatMap (schemaTypeToXML "contained") $ measure_contained x
            , concatMap (schemaTypeToXML "extension") $ measure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ measure_url x
            , concatMap (schemaTypeToXML "identifier") $ measure_identifier x
            , maybe [] (schemaTypeToXML "version") $ measure_version x
            , maybe [] (schemaTypeToXML "name") $ measure_name x
            , maybe [] (schemaTypeToXML "title") $ measure_title x
            , schemaTypeToXML "status" $ measure_status x
            , maybe [] (schemaTypeToXML "experimental") $ measure_experimental x
            , maybe [] (schemaTypeToXML "date") $ measure_date x
            , maybe [] (schemaTypeToXML "publisher") $ measure_publisher x
            , maybe [] (schemaTypeToXML "description") $ measure_description x
            , maybe [] (schemaTypeToXML "purpose") $ measure_purpose x
            , maybe [] (schemaTypeToXML "usage") $ measure_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ measure_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ measure_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ measure_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ measure_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ measure_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ measure_topic x
            , concatMap (schemaTypeToXML "contributor") $ measure_contributor x
            , concatMap (schemaTypeToXML "contact") $ measure_contact x
            , maybe [] (schemaTypeToXML "copyright") $ measure_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ measure_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ measure_library x
            , maybe [] (schemaTypeToXML "disclaimer") $ measure_disclaimer x
            , maybe [] (schemaTypeToXML "scoring") $ measure_scoring x
            , maybe [] (schemaTypeToXML "compositeScoring") $ measure_compositeScoring x
            , concatMap (schemaTypeToXML "type") $ measure_type x
            , maybe [] (schemaTypeToXML "riskAdjustment") $ measure_riskAdjustment x
            , maybe [] (schemaTypeToXML "rateAggregation") $ measure_rateAggregation x
            , maybe [] (schemaTypeToXML "rationale") $ measure_rationale x
            , maybe [] (schemaTypeToXML "clinicalRecommendationStatement") $ measure_clinicalRecommendationStatement x
            , maybe [] (schemaTypeToXML "improvementNotation") $ measure_improvementNotation x
            , concatMap (schemaTypeToXML "definition") $ measure_definition x
            , maybe [] (schemaTypeToXML "guidance") $ measure_guidance x
            , maybe [] (schemaTypeToXML "set") $ measure_set x
            , concatMap (schemaTypeToXML "group") $ measure_group x
            , concatMap (schemaTypeToXML "supplementalData") $ measure_supplementalData x
            ]
instance Extension Measure DomainResource where
    supertype (Measure e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41 e42 e43 e44) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Measure Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Measure -> DomainResource)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data Measure'Group = Measure'Group
        { measure'Group_id :: Maybe String'primitive
        , measure'Group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure'Group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure'Group_identifier :: Identifier
          -- ^ A unique identifier for the group. This identifier will 
          --   used to report data for the group in the measure report.
        , measure'Group_name :: Maybe Xsd.XsdString
          -- ^ Optional name or short description of this group.
        , measure'Group_description :: Maybe Xsd.XsdString
          -- ^ The human readable description of this population group.
        , measure'Group_population :: [Measure'Population]
          -- ^ A population criteria for the measure.
        , measure'Group_stratifier :: [Measure'Stratifier]
          -- ^ The stratifier criteria for the measure report, specified 
          --   as either the name of a valid CQL expression defined within 
          --   a referenced library, or a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType Measure'Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Measure'Group a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "population")
            `apply` many (parseSchemaType "stratifier")
    schemaTypeToXML s x@Measure'Group{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measure'Group_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measure'Group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure'Group_modifierExtension x
            , schemaTypeToXML "identifier" $ measure'Group_identifier x
            , maybe [] (schemaTypeToXML "name") $ measure'Group_name x
            , maybe [] (schemaTypeToXML "description") $ measure'Group_description x
            , concatMap (schemaTypeToXML "population") $ measure'Group_population x
            , concatMap (schemaTypeToXML "stratifier") $ measure'Group_stratifier x
            ]
instance Extension Measure'Group BackboneElement where
    supertype (Measure'Group a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Measure'Group Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Measure'Group -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data Measure'Population = Measure'Population
        { measure'Population_id :: Maybe String'primitive
        , measure'Population_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure'Population_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure'Population_identifier :: Maybe Identifier
          -- ^ A unique identifier for the population criteria. This 
          --   identifier is used to report data against this criteria 
          --   within the measure report.
        , measure'Population_code :: Maybe CodeableConcept
          -- ^ The type of population criteria.
        , measure'Population_name :: Maybe Xsd.XsdString
          -- ^ Optional name or short description of this population.
        , measure'Population_description :: Maybe Xsd.XsdString
          -- ^ The human readable description of this population criteria.
        , measure'Population_criteria :: Xsd.XsdString
          -- ^ The name of a valid referenced CQL expression (may be 
          --   namespaced) that defines this population criteria.
        }
        deriving (Eq,Show)
instance SchemaType Measure'Population where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Measure'Population a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "criteria"
    schemaTypeToXML s x@Measure'Population{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measure'Population_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measure'Population_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure'Population_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measure'Population_identifier x
            , maybe [] (schemaTypeToXML "code") $ measure'Population_code x
            , maybe [] (schemaTypeToXML "name") $ measure'Population_name x
            , maybe [] (schemaTypeToXML "description") $ measure'Population_description x
            , schemaTypeToXML "criteria" $ measure'Population_criteria x
            ]
instance Extension Measure'Population BackboneElement where
    supertype (Measure'Population a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Measure'Population Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Measure'Population -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data Measure'Stratifier = Measure'Stratifier
        { measure'Stratifier_id :: Maybe String'primitive
        , measure'Stratifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure'Stratifier_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure'Stratifier_identifier :: Maybe Identifier
          -- ^ The identifier for the stratifier used to coordinate the 
          --   reported data back to this stratifier.
        , measure'Stratifier_criteria :: Maybe Xsd.XsdString
          -- ^ The criteria for the stratifier. This must be the name of 
          --   an expression defined within a referenced library.
        , measure'Stratifier_path :: Maybe Xsd.XsdString
          -- ^ The path to an element that defines the stratifier, 
          --   specified as a valid FHIR resource path.
        }
        deriving (Eq,Show)
instance SchemaType Measure'Stratifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Measure'Stratifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "criteria")
            `apply` optional (parseSchemaType "path")
    schemaTypeToXML s x@Measure'Stratifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measure'Stratifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measure'Stratifier_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure'Stratifier_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measure'Stratifier_identifier x
            , maybe [] (schemaTypeToXML "criteria") $ measure'Stratifier_criteria x
            , maybe [] (schemaTypeToXML "path") $ measure'Stratifier_path x
            ]
instance Extension Measure'Stratifier BackboneElement where
    supertype (Measure'Stratifier a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Measure'Stratifier Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Measure'Stratifier -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data Measure'SupplementalData = Measure'SupplementalData
        { measure'SupplementalData_id :: Maybe String'primitive
        , measure'SupplementalData_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure'SupplementalData_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure'SupplementalData_identifier :: Maybe Identifier
          -- ^ An identifier for the supplemental data.
        , measure'SupplementalData_usage :: [CodeableConcept]
          -- ^ An indicator of the intended usage for the supplemental 
          --   data element. Supplemental data indicates the data is 
          --   additional information requested to augment the measure 
          --   information. Risk adjustment factor indicates the data is 
          --   additional information used to calculate risk adjustment 
          --   factors when applying a risk model to the measure 
          --   calculation.
        , measure'SupplementalData_criteria :: Maybe Xsd.XsdString
          -- ^ The criteria for the supplemental data. This must be the 
          --   name of a valid expression defined within a referenced 
          --   library, and defines the data to be returned for this 
          --   element.
        , measure'SupplementalData_path :: Maybe Xsd.XsdString
          -- ^ The supplemental data to be supplied as part of the measure 
          --   response, specified as a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType Measure'SupplementalData where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Measure'SupplementalData a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "usage")
            `apply` optional (parseSchemaType "criteria")
            `apply` optional (parseSchemaType "path")
    schemaTypeToXML s x@Measure'SupplementalData{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measure'SupplementalData_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measure'SupplementalData_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure'SupplementalData_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measure'SupplementalData_identifier x
            , concatMap (schemaTypeToXML "usage") $ measure'SupplementalData_usage x
            , maybe [] (schemaTypeToXML "criteria") $ measure'SupplementalData_criteria x
            , maybe [] (schemaTypeToXML "path") $ measure'SupplementalData_path x
            ]
instance Extension Measure'SupplementalData BackboneElement where
    supertype (Measure'SupplementalData a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Measure'SupplementalData Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Measure'SupplementalData -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
elementMeasureReport :: XMLParser MeasureReport
elementMeasureReport = parseSchemaType "MeasureReport"
elementToXMLMeasureReport :: MeasureReport -> [Content ()]
elementToXMLMeasureReport = schemaTypeToXML "MeasureReport"
 
data MeasureReport = MeasureReport
        { measureReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , measureReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , measureReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , measureReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , measureReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , measureReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , measureReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this report 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , measureReport_status :: MeasureReportStatus
          -- ^ The report status. No data will be available until the 
          --   report status is complete.
        , measureReport_type :: MeasureReportType
          -- ^ The type of measure report. This may be an individual 
          --   report, which provides a single patient's score for the 
          --   measure; a patient listing, which returns the list of 
          --   patients that meet the various criteria in the measure; or 
          --   a summary report, which returns a population count for each 
          --   of the criteria in the measure.
        , measureReport_measure :: Reference
          -- ^ A reference to the Measure that was evaluated to produce 
          --   this report.
        , measureReport_patient :: Maybe Reference
          -- ^ Optional Patient if the report was requested for a single 
          --   patient.
        , measureReport_date :: Maybe DateTime
          -- ^ The date this measure report was generated.
        , measureReport_reportingOrganization :: Maybe Reference
          -- ^ Reporting Organization.
        , measureReport_period :: Period
          -- ^ The reporting period for which the report was calculated.
        , measureReport_group :: [MeasureReport'Group]
          -- ^ The results of the calculation, one for each population 
          --   group in the measure.
        , measureReport_evaluatedResources :: Maybe Reference
          -- ^ A reference to a Bundle containing the Resources that were 
          --   used in the evaluation of this report.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MeasureReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "measure"
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "reportingOrganization")
            `apply` parseSchemaType "period"
            `apply` many (parseSchemaType "group")
            `apply` optional (parseSchemaType "evaluatedResources")
    schemaTypeToXML s x@MeasureReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ measureReport_id x
            , maybe [] (schemaTypeToXML "meta") $ measureReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ measureReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ measureReport_language x
            , maybe [] (schemaTypeToXML "text") $ measureReport_text x
            , concatMap (schemaTypeToXML "contained") $ measureReport_contained x
            , concatMap (schemaTypeToXML "extension") $ measureReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReport_identifier x
            , schemaTypeToXML "status" $ measureReport_status x
            , schemaTypeToXML "type" $ measureReport_type x
            , schemaTypeToXML "measure" $ measureReport_measure x
            , maybe [] (schemaTypeToXML "patient") $ measureReport_patient x
            , maybe [] (schemaTypeToXML "date") $ measureReport_date x
            , maybe [] (schemaTypeToXML "reportingOrganization") $ measureReport_reportingOrganization x
            , schemaTypeToXML "period" $ measureReport_period x
            , concatMap (schemaTypeToXML "group") $ measureReport_group x
            , maybe [] (schemaTypeToXML "evaluatedResources") $ measureReport_evaluatedResources x
            ]
instance Extension MeasureReport DomainResource where
    supertype (MeasureReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MeasureReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MeasureReport -> DomainResource)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReport'Group = MeasureReport'Group
        { measureReport'Group_id :: Maybe String'primitive
        , measureReport'Group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport'Group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport'Group_identifier :: Identifier
          -- ^ The identifier of the population group as defined in the 
          --   measure definition.
        , measureReport'Group_population :: [MeasureReport'Population]
          -- ^ The populations that make up the population group, one for 
          --   each type of population appropriate for the measure.
        , measureReport'Group_measureScore :: Maybe Decimal
          -- ^ The measure score for this population group, calculated as 
          --   appropriate for the measure type and scoring method, and 
          --   based on the contents of the populations defined in the 
          --   group.
        , measureReport'Group_stratifier :: [MeasureReport'Stratifier]
          -- ^ When a measure includes multiple stratifiers, there will be 
          --   a stratifier group for each stratifier defined by the 
          --   measure.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport'Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReport'Group a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` many (parseSchemaType "population")
            `apply` optional (parseSchemaType "measureScore")
            `apply` many (parseSchemaType "stratifier")
    schemaTypeToXML s x@MeasureReport'Group{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReport'Group_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReport'Group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport'Group_modifierExtension x
            , schemaTypeToXML "identifier" $ measureReport'Group_identifier x
            , concatMap (schemaTypeToXML "population") $ measureReport'Group_population x
            , maybe [] (schemaTypeToXML "measureScore") $ measureReport'Group_measureScore x
            , concatMap (schemaTypeToXML "stratifier") $ measureReport'Group_stratifier x
            ]
instance Extension MeasureReport'Group BackboneElement where
    supertype (MeasureReport'Group a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReport'Group Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReport'Group -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReport'Population = MeasureReport'Population
        { measureReport'Population_id :: Maybe String'primitive
        , measureReport'Population_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport'Population_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport'Population_identifier :: Maybe Identifier
          -- ^ The identifier of the population being reported, as defined 
          --   by the population element of the measure.
        , measureReport'Population_code :: Maybe CodeableConcept
          -- ^ The type of the population.
        , measureReport'Population_count :: Maybe Integer
          -- ^ The number of members of the population.
        , measureReport'Population_patients :: Maybe Reference
          -- ^ This element refers to a List of patient level 
          --   MeasureReport resources, one for each patient in this 
          --   population.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport'Population where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReport'Population a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "patients")
    schemaTypeToXML s x@MeasureReport'Population{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReport'Population_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReport'Population_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport'Population_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReport'Population_identifier x
            , maybe [] (schemaTypeToXML "code") $ measureReport'Population_code x
            , maybe [] (schemaTypeToXML "count") $ measureReport'Population_count x
            , maybe [] (schemaTypeToXML "patients") $ measureReport'Population_patients x
            ]
instance Extension MeasureReport'Population BackboneElement where
    supertype (MeasureReport'Population a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReport'Population Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReport'Population -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReport'Stratifier = MeasureReport'Stratifier
        { measureReport'Stratifier_id :: Maybe String'primitive
        , measureReport'Stratifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport'Stratifier_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport'Stratifier_identifier :: Maybe Identifier
          -- ^ The identifier of this stratifier, as defined in the 
          --   measure definition.
        , measureReport'Stratifier_stratum :: [MeasureReport'Stratum]
          -- ^ This element contains the results for a single stratum 
          --   within the stratifier. For example, when stratifying on 
          --   administrative gender, there will be four strata, one for 
          --   each possible gender value.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport'Stratifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReport'Stratifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "stratum")
    schemaTypeToXML s x@MeasureReport'Stratifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReport'Stratifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReport'Stratifier_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport'Stratifier_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReport'Stratifier_identifier x
            , concatMap (schemaTypeToXML "stratum") $ measureReport'Stratifier_stratum x
            ]
instance Extension MeasureReport'Stratifier BackboneElement where
    supertype (MeasureReport'Stratifier a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MeasureReport'Stratifier Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReport'Stratifier -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReport'Stratum = MeasureReport'Stratum
        { measureReport'Stratum_id :: Maybe String'primitive
        , measureReport'Stratum_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport'Stratum_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport'Stratum_value :: Xsd.XsdString
          -- ^ The value for this stratum, expressed as a string. When 
          --   defining stratifiers on complex values, the value must be 
          --   rendered such that the value for each stratum within the 
          --   stratifier is unique.
        , measureReport'Stratum_population :: [MeasureReport'Population1]
          -- ^ The populations that make up the stratum, one for each type 
          --   of population appropriate to the measure.
        , measureReport'Stratum_measureScore :: Maybe Decimal
          -- ^ The measure score for this stratum, calculated as 
          --   appropriate for the measure type and scoring method, and 
          --   based on only the members of this stratum.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport'Stratum where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReport'Stratum a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "value"
            `apply` many (parseSchemaType "population")
            `apply` optional (parseSchemaType "measureScore")
    schemaTypeToXML s x@MeasureReport'Stratum{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReport'Stratum_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReport'Stratum_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport'Stratum_modifierExtension x
            , schemaTypeToXML "value" $ measureReport'Stratum_value x
            , concatMap (schemaTypeToXML "population") $ measureReport'Stratum_population x
            , maybe [] (schemaTypeToXML "measureScore") $ measureReport'Stratum_measureScore x
            ]
instance Extension MeasureReport'Stratum BackboneElement where
    supertype (MeasureReport'Stratum a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MeasureReport'Stratum Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReport'Stratum -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReport'Population1 = MeasureReport'Population1
        { measureReport'Population1_id :: Maybe String'primitive
        , measureReport'Population1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport'Population1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport'Population1_identifier :: Maybe Identifier
          -- ^ The identifier of the population being reported, as defined 
          --   by the population element of the measure.
        , measureReport'Population1_code :: Maybe CodeableConcept
          -- ^ The type of the population.
        , measureReport'Population1_count :: Maybe Integer
          -- ^ The number of members of the population in this stratum.
        , measureReport'Population1_patients :: Maybe Reference
          -- ^ This element refers to a List of patient level 
          --   MeasureReport resources, one for each patient in this 
          --   population in this stratum.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport'Population1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReport'Population1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "patients")
    schemaTypeToXML s x@MeasureReport'Population1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReport'Population1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReport'Population1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport'Population1_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReport'Population1_identifier x
            , maybe [] (schemaTypeToXML "code") $ measureReport'Population1_code x
            , maybe [] (schemaTypeToXML "count") $ measureReport'Population1_count x
            , maybe [] (schemaTypeToXML "patients") $ measureReport'Population1_patients x
            ]
instance Extension MeasureReport'Population1 BackboneElement where
    supertype (MeasureReport'Population1 a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReport'Population1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReport'Population1 -> BackboneElement)
              
 
data MeasureReportStatus'list
    = MeasureReportStatus'list_Complete
      -- ^ Complete
    | MeasureReportStatus'list_Pending
      -- ^ Pending
    | MeasureReportStatus'list_Error
      -- ^ Error
    deriving (Eq,Show,Enum)
instance SchemaType MeasureReportStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasureReportStatus'list where
    acceptingParser =  do literal "complete"; return MeasureReportStatus'list_Complete
                      `onFail` do literal "pending"; return MeasureReportStatus'list_Pending
                      `onFail` do literal "error"; return MeasureReportStatus'list_Error
                      
    simpleTypeText MeasureReportStatus'list_Complete = "complete"
    simpleTypeText MeasureReportStatus'list_Pending = "pending"
    simpleTypeText MeasureReportStatus'list_Error = "error"
 
data MeasureReportStatus = MeasureReportStatus
        { measureReportStatus_id :: Maybe String'primitive
        , measureReportStatus_value :: Maybe MeasureReportStatus'list
        , measureReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasureReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasureReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ measureReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportStatus_extension x
            ]
instance Extension MeasureReportStatus Element where
    supertype (MeasureReportStatus a0 a1 e0) =
               Element a0 e0
 
data MeasureReportType'list
    = MeasureReportType'list_Individual
      -- ^ Individual
    | MeasureReportType'list_Patient'list
      -- ^ Patient List
    | MeasureReportType'list_Summary
      -- ^ Summary
    deriving (Eq,Show,Enum)
instance SchemaType MeasureReportType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasureReportType'list where
    acceptingParser =  do literal "individual"; return MeasureReportType'list_Individual
                      `onFail` do literal "patient-list"; return MeasureReportType'list_Patient'list
                      `onFail` do literal "summary"; return MeasureReportType'list_Summary
                      
    simpleTypeText MeasureReportType'list_Individual = "individual"
    simpleTypeText MeasureReportType'list_Patient'list = "patient-list"
    simpleTypeText MeasureReportType'list_Summary = "summary"
 
data MeasureReportType = MeasureReportType
        { measureReportType_id :: Maybe String'primitive
        , measureReportType_value :: Maybe MeasureReportType'list
        , measureReportType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasureReportType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasureReportType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportType_id x
                       , maybe [] (toXMLAttribute "value") $ measureReportType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportType_extension x
            ]
instance Extension MeasureReportType Element where
    supertype (MeasureReportType a0 a1 e0) =
               Element a0 e0
 
-- | A photo, video, or audio recording acquired or used in 
--   healthcare. The actual content may be inline or provided by 
--   direct reference.
elementMedia :: XMLParser Media
elementMedia = parseSchemaType "Media"
elementToXMLMedia :: Media -> [Content ()]
elementToXMLMedia = schemaTypeToXML "Media"
 
data Media = Media
        { media_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , media_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , media_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , media_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , media_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , media_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , media_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , media_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , media_identifier :: [Identifier]
          -- ^ Identifiers associated with the image - these may include 
          --   identifiers for the image itself, identifiers for the 
          --   context of its collection (e.g. series ids) and context ids 
          --   such as accession numbers or other workflow identifiers.
        , media_basedOn :: [Reference]
          -- ^ A procedure that is fulfilled in whole or in part by the 
          --   creation of this media.
        , media_type :: DigitalMediaType
          -- ^ Whether the media is a photo (still image), an audio 
          --   recording, or a video recording.
        , media_subtype :: Maybe CodeableConcept
          -- ^ Details of the type of the media - usually, how it was 
          --   acquired (what type of device). If images sourced from a 
          --   DICOM system, are wrapped in a Media resource, then this is 
          --   the modality.
        , media_view :: Maybe CodeableConcept
          -- ^ The name of the imaging view e.g. Lateral or 
          --   Antero-posterior (AP).
        , media_subject :: Maybe Reference
          -- ^ Who/What this Media is a record of.
        , media_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this media.
        , media_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date and time(s) at which the media was collected.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , media_operator :: Maybe Reference
          -- ^ The person who administered the collection of the image.
        , media_reasonCode :: [CodeableConcept]
          -- ^ Describes why the event occurred in coded or textual form.
        , media_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the media 
          --   was collected (i.e. the target site).
        , media_device :: Maybe Reference
          -- ^ The device used to collect the media.
        , media_height :: Maybe PositiveInt
          -- ^ Height of the image in pixels (photo/video).
        , media_width :: Maybe PositiveInt
          -- ^ Width of the image in pixels (photo/video).
        , media_frames :: Maybe PositiveInt
          -- ^ The number of frames in a photo. This is used with a 
          --   multi-page fax, or an imaging acquisition context that 
          --   takes multiple slices in a single image, or an animated 
          --   gif. If there is more than one frame, this SHALL have a 
          --   value in order to alert interface software that a 
          --   multi-frame capable rendering widget is required.
        , media_duration :: Maybe UnsignedInt
          -- ^ The duration of the recording in seconds - for audio and 
          --   video.
        , media_content :: Attachment
          -- ^ The actual content of the media - inline or by direct 
          --   reference to the media source file.
        , media_note :: [Annotation]
          -- ^ Comments made about the media by the performer, subject or 
          --   other participants.
        }
        deriving (Eq,Show)
instance SchemaType Media where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Media
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "subtype")
            `apply` optional (parseSchemaType "view")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "operator")
            `apply` many (parseSchemaType "reasonCode")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "device")
            `apply` optional (parseSchemaType "height")
            `apply` optional (parseSchemaType "width")
            `apply` optional (parseSchemaType "frames")
            `apply` optional (parseSchemaType "duration")
            `apply` parseSchemaType "content"
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Media{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ media_id x
            , maybe [] (schemaTypeToXML "meta") $ media_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ media_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ media_language x
            , maybe [] (schemaTypeToXML "text") $ media_text x
            , concatMap (schemaTypeToXML "contained") $ media_contained x
            , concatMap (schemaTypeToXML "extension") $ media_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ media_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ media_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ media_basedOn x
            , schemaTypeToXML "type" $ media_type x
            , maybe [] (schemaTypeToXML "subtype") $ media_subtype x
            , maybe [] (schemaTypeToXML "view") $ media_view x
            , maybe [] (schemaTypeToXML "subject") $ media_subject x
            , maybe [] (schemaTypeToXML "context") $ media_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ media_choice15 x
            , maybe [] (schemaTypeToXML "operator") $ media_operator x
            , concatMap (schemaTypeToXML "reasonCode") $ media_reasonCode x
            , maybe [] (schemaTypeToXML "bodySite") $ media_bodySite x
            , maybe [] (schemaTypeToXML "device") $ media_device x
            , maybe [] (schemaTypeToXML "height") $ media_height x
            , maybe [] (schemaTypeToXML "width") $ media_width x
            , maybe [] (schemaTypeToXML "frames") $ media_frames x
            , maybe [] (schemaTypeToXML "duration") $ media_duration x
            , schemaTypeToXML "content" $ media_content x
            , concatMap (schemaTypeToXML "note") $ media_note x
            ]
instance Extension Media DomainResource where
    supertype (Media e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Media Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Media -> DomainResource)
              
 
data DigitalMediaType'list
    = DigitalMediaType'list_Photo
      -- ^ Photo
    | DigitalMediaType'list_Video
      -- ^ Video
    | DigitalMediaType'list_Audio
      -- ^ Audio
    deriving (Eq,Show,Enum)
instance SchemaType DigitalMediaType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DigitalMediaType'list where
    acceptingParser =  do literal "photo"; return DigitalMediaType'list_Photo
                      `onFail` do literal "video"; return DigitalMediaType'list_Video
                      `onFail` do literal "audio"; return DigitalMediaType'list_Audio
                      
    simpleTypeText DigitalMediaType'list_Photo = "photo"
    simpleTypeText DigitalMediaType'list_Video = "video"
    simpleTypeText DigitalMediaType'list_Audio = "audio"
 
data DigitalMediaType = DigitalMediaType
        { digitalMediaType_id :: Maybe String'primitive
        , digitalMediaType_value :: Maybe DigitalMediaType'list
        , digitalMediaType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DigitalMediaType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DigitalMediaType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DigitalMediaType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ digitalMediaType_id x
                       , maybe [] (toXMLAttribute "value") $ digitalMediaType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ digitalMediaType_extension x
            ]
instance Extension DigitalMediaType Element where
    supertype (DigitalMediaType a0 a1 e0) =
               Element a0 e0
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
elementMedication :: XMLParser Medication
elementMedication = parseSchemaType "Medication"
elementToXMLMedication :: Medication -> [Content ()]
elementToXMLMedication = schemaTypeToXML "Medication"
 
data Medication = Medication
        { medication_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medication_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medication_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medication_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medication_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medication_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication_code :: Maybe CodeableConcept
          -- ^ A code (or set of codes) that specify this medication, or a 
          --   textual description if no code is available. Usage note: 
          --   This could be a standard medication code such as a code 
          --   from RxNorm, SNOMED CT, IDMP etc. It could also be a 
          --   national or local formulary code, optionally with 
          --   translations to other code systems.
        , medication_status :: Maybe MedicationStatus
          -- ^ A code to indicate if the medication is in active use.
        , medication_isBrand :: Maybe Boolean
          -- ^ Set to true if the item is attributable to a specific 
          --   manufacturer.
        , medication_isOverTheCounter :: Maybe Boolean
          -- ^ Set to true if the medication can be obtained without an 
          --   order from a prescriber.
        , medication_manufacturer :: Maybe Reference
          -- ^ Describes the details of the manufacturer of the medication 
          --   product. This is not intended to represent the distributor 
          --   of a medication product.
        , medication_form :: Maybe CodeableConcept
          -- ^ Describes the form of the item. Powder; tablets; capsule.
        , medication_ingredient :: [Medication'Ingredient]
          -- ^ Identifies a particular constituent of interest in the 
          --   product.
        , medication_package :: Maybe Medication'Package
          -- ^ Information that only applies to packages (not products).
        , medication_image :: [Attachment]
          -- ^ Photo(s) or graphic representation(s) of the medication.
        }
        deriving (Eq,Show)
instance SchemaType Medication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Medication
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "isBrand")
            `apply` optional (parseSchemaType "isOverTheCounter")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "ingredient")
            `apply` optional (parseSchemaType "package")
            `apply` many (parseSchemaType "image")
    schemaTypeToXML s x@Medication{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medication_id x
            , maybe [] (schemaTypeToXML "meta") $ medication_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medication_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medication_language x
            , maybe [] (schemaTypeToXML "text") $ medication_text x
            , concatMap (schemaTypeToXML "contained") $ medication_contained x
            , concatMap (schemaTypeToXML "extension") $ medication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ medication_code x
            , maybe [] (schemaTypeToXML "status") $ medication_status x
            , maybe [] (schemaTypeToXML "isBrand") $ medication_isBrand x
            , maybe [] (schemaTypeToXML "isOverTheCounter") $ medication_isOverTheCounter x
            , maybe [] (schemaTypeToXML "manufacturer") $ medication_manufacturer x
            , maybe [] (schemaTypeToXML "form") $ medication_form x
            , concatMap (schemaTypeToXML "ingredient") $ medication_ingredient x
            , maybe [] (schemaTypeToXML "package") $ medication_package x
            , concatMap (schemaTypeToXML "image") $ medication_image x
            ]
instance Extension Medication DomainResource where
    supertype (Medication e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Medication Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Medication -> DomainResource)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data Medication'Ingredient = Medication'Ingredient
        { medication'Ingredient_id :: Maybe String'primitive
        , medication'Ingredient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication'Ingredient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication'Ingredient_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ The actual ingredient - either a substance (simple 
          --   ingredient) or another medication.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , medication'Ingredient_isActive :: Maybe Boolean
          -- ^ Indication of whether this ingredient affects the 
          --   therapeutic action of the drug.
        , medication'Ingredient_amount :: Maybe Ratio
          -- ^ Specifies how many (or how much) of the items there are in 
          --   this Medication. For example, 250 mg per tablet. This is 
          --   expressed as a ratio where the numerator is 250mg and the 
          --   denominator is 1 tablet.
        }
        deriving (Eq,Show)
instance SchemaType Medication'Ingredient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Medication'Ingredient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "isActive")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@Medication'Ingredient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medication'Ingredient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medication'Ingredient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication'Ingredient_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ medication'Ingredient_choice2 x
            , maybe [] (schemaTypeToXML "isActive") $ medication'Ingredient_isActive x
            , maybe [] (schemaTypeToXML "amount") $ medication'Ingredient_amount x
            ]
instance Extension Medication'Ingredient BackboneElement where
    supertype (Medication'Ingredient a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Medication'Ingredient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Medication'Ingredient -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data Medication'Package = Medication'Package
        { medication'Package_id :: Maybe String'primitive
        , medication'Package_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication'Package_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication'Package_container :: Maybe CodeableConcept
          -- ^ The kind of container that this package comes as.
        , medication'Package_content :: [Medication'Content]
          -- ^ A set of components that go to make up the described item.
        , medication'Package_batch :: [Medication'Batch]
          -- ^ Information about a group of medication produced or 
          --   packaged from one production run.
        }
        deriving (Eq,Show)
instance SchemaType Medication'Package where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Medication'Package a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "container")
            `apply` many (parseSchemaType "content")
            `apply` many (parseSchemaType "batch")
    schemaTypeToXML s x@Medication'Package{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medication'Package_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medication'Package_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication'Package_modifierExtension x
            , maybe [] (schemaTypeToXML "container") $ medication'Package_container x
            , concatMap (schemaTypeToXML "content") $ medication'Package_content x
            , concatMap (schemaTypeToXML "batch") $ medication'Package_batch x
            ]
instance Extension Medication'Package BackboneElement where
    supertype (Medication'Package a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Medication'Package Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Medication'Package -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data Medication'Content = Medication'Content
        { medication'Content_id :: Maybe String'primitive
        , medication'Content_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication'Content_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication'Content_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies one of the items in the package.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , medication'Content_amount :: Maybe Quantity
          -- ^ The amount of the product that is in the package.
        }
        deriving (Eq,Show)
instance SchemaType Medication'Content where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Medication'Content a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@Medication'Content{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medication'Content_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medication'Content_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication'Content_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ medication'Content_choice2 x
            , maybe [] (schemaTypeToXML "amount") $ medication'Content_amount x
            ]
instance Extension Medication'Content BackboneElement where
    supertype (Medication'Content a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Medication'Content Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Medication'Content -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data Medication'Batch = Medication'Batch
        { medication'Batch_id :: Maybe String'primitive
        , medication'Batch_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication'Batch_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication'Batch_lotNumber :: Maybe Xsd.XsdString
          -- ^ The assigned lot number of a batch of the specified 
          --   product.
        , medication'Batch_expirationDate :: Maybe DateTime
          -- ^ When this specific batch of product will expire.
        }
        deriving (Eq,Show)
instance SchemaType Medication'Batch where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Medication'Batch a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "expirationDate")
    schemaTypeToXML s x@Medication'Batch{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medication'Batch_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medication'Batch_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication'Batch_modifierExtension x
            , maybe [] (schemaTypeToXML "lotNumber") $ medication'Batch_lotNumber x
            , maybe [] (schemaTypeToXML "expirationDate") $ medication'Batch_expirationDate x
            ]
instance Extension Medication'Batch BackboneElement where
    supertype (Medication'Batch a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Medication'Batch Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Medication'Batch -> BackboneElement)
              
 
data MedicationStatus'list
    = MedicationStatus'list_Active
      -- ^ Active
    | MedicationStatus'list_Inactive
      -- ^ Inactive
    | MedicationStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatus'list where
    acceptingParser =  do literal "active"; return MedicationStatus'list_Active
                      `onFail` do literal "inactive"; return MedicationStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return MedicationStatus'list_Entered'in'error
                      
    simpleTypeText MedicationStatus'list_Active = "active"
    simpleTypeText MedicationStatus'list_Inactive = "inactive"
    simpleTypeText MedicationStatus'list_Entered'in'error = "entered-in-error"
 
data MedicationStatus = MedicationStatus
        { medicationStatus_id :: Maybe String'primitive
        , medicationStatus_value :: Maybe MedicationStatus'list
        , medicationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatus_extension x
            ]
instance Extension MedicationStatus Element where
    supertype (MedicationStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
elementMedicationAdministration :: XMLParser MedicationAdministration
elementMedicationAdministration = parseSchemaType "MedicationAdministration"
elementToXMLMedicationAdministration :: MedicationAdministration -> [Content ()]
elementToXMLMedicationAdministration = schemaTypeToXML "MedicationAdministration"
 
data MedicationAdministration = MedicationAdministration
        { medicationAdministration_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationAdministration_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationAdministration_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationAdministration_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationAdministration_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationAdministration_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationAdministration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministration_identifier :: [Identifier]
          -- ^ External identifier - FHIR will generate its own internal 
          --   identifiers (probably URLs) which do not need to be 
          --   explicitly managed by the resource. The identifier here is 
          --   one that would be used by another non-FHIR system - for 
          --   example an automated medication pump would provide a record 
          --   each time it operated; an administration while the patient 
          --   was off the ward might be made with a different system and 
          --   entered after the event. Particularly important if these 
          --   records have to be updated.
        , medicationAdministration_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that 
          --   was adhered to in whole or in part by this event.
        , medicationAdministration_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , medicationAdministration_status :: MedicationAdministrationStatus
          -- ^ Will generally be set to show that the administration has 
          --   been completed. For some long running administrations such 
          --   as infusions it is possible for an administration to be 
          --   started but not completed or it may be paused while some 
          --   other process is under way.
        , medicationAdministration_category :: Maybe CodeableConcept
          -- ^ Indicates the type of medication administration and where 
          --   the medication is expected to be consumed or administered.
        , medicationAdministration_choice13 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication that was administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationAdministration_subject :: Reference
          -- ^ The person or animal or group receiving the medication.
        , medicationAdministration_context :: Maybe Reference
          -- ^ The visit, admission or other contact between patient and 
          --   health care provider the medication administration was 
          --   performed as part of.
        , medicationAdministration_supportingInformation :: [Reference]
          -- ^ Additional information (for example, patient height and 
          --   weight) that supports the administration of the medication.
        , medicationAdministration_choice17 :: OneOf2 DateTime Period
          -- ^ A specific date/time or interval of time during which the 
          --   administration took place (or did not take place, when the 
          --   'notGiven' attribute is true). For many administrations, 
          --   such as swallowing a tablet the use of dateTime is more 
          --   appropriate.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , medicationAdministration_performer :: [MedicationAdministration'Performer]
          -- ^ The individual who was responsible for giving the 
          --   medication to the patient.
        , medicationAdministration_notGiven :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the 
          --   medication was NOT administered.
        , medicationAdministration_reasonNotGiven :: [CodeableConcept]
          -- ^ A code indicating why the administration was not performed.
        , medicationAdministration_reasonCode :: [CodeableConcept]
          -- ^ A code indicating why the medication was given.
        , medicationAdministration_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   was administered.
        , medicationAdministration_prescription :: Maybe Reference
          -- ^ The original request, instruction or authority to perform 
          --   the administration.
        , medicationAdministration_device :: [Reference]
          -- ^ The device used in administering the medication to the 
          --   patient. For example, a particular infusion pump.
        , medicationAdministration_note :: [Annotation]
          -- ^ Extra information about the medication administration that 
          --   is not conveyed by the other attributes.
        , medicationAdministration_dosage :: Maybe MedicationAdministration'Dosage
          -- ^ Describes the medication dosage information details e.g. 
          --   dose, rate, site, route, etc.
        , medicationAdministration_eventHistory :: [Reference]
          -- ^ A summary of the events of interest that have occurred, 
          --   such as when the administration was verified.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationAdministration
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                           , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                           ]
            `apply` many (parseSchemaType "performer")
            `apply` optional (parseSchemaType "notGiven")
            `apply` many (parseSchemaType "reasonNotGiven")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` optional (parseSchemaType "prescription")
            `apply` many (parseSchemaType "device")
            `apply` many (parseSchemaType "note")
            `apply` optional (parseSchemaType "dosage")
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationAdministration{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationAdministration_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationAdministration_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationAdministration_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationAdministration_language x
            , maybe [] (schemaTypeToXML "text") $ medicationAdministration_text x
            , concatMap (schemaTypeToXML "contained") $ medicationAdministration_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationAdministration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministration_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationAdministration_identifier x
            , concatMap (schemaTypeToXML "definition") $ medicationAdministration_definition x
            , concatMap (schemaTypeToXML "partOf") $ medicationAdministration_partOf x
            , schemaTypeToXML "status" $ medicationAdministration_status x
            , maybe [] (schemaTypeToXML "category") $ medicationAdministration_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationAdministration_choice13 x
            , schemaTypeToXML "subject" $ medicationAdministration_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationAdministration_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationAdministration_supportingInformation x
            , foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                          (schemaTypeToXML "effectivePeriod")
                          $ medicationAdministration_choice17 x
            , concatMap (schemaTypeToXML "performer") $ medicationAdministration_performer x
            , maybe [] (schemaTypeToXML "notGiven") $ medicationAdministration_notGiven x
            , concatMap (schemaTypeToXML "reasonNotGiven") $ medicationAdministration_reasonNotGiven x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationAdministration_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationAdministration_reasonReference x
            , maybe [] (schemaTypeToXML "prescription") $ medicationAdministration_prescription x
            , concatMap (schemaTypeToXML "device") $ medicationAdministration_device x
            , concatMap (schemaTypeToXML "note") $ medicationAdministration_note x
            , maybe [] (schemaTypeToXML "dosage") $ medicationAdministration_dosage x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationAdministration_eventHistory x
            ]
instance Extension MedicationAdministration DomainResource where
    supertype (MedicationAdministration e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationAdministration Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationAdministration -> DomainResource)
              
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
data MedicationAdministration'Performer = MedicationAdministration'Performer
        { medicationAdministration'Performer_id :: Maybe String'primitive
        , medicationAdministration'Performer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministration'Performer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministration'Performer_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action.
        , medicationAdministration'Performer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministration'Performer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationAdministration'Performer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationAdministration'Performer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministration'Performer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministration'Performer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministration'Performer_modifierExtension x
            , schemaTypeToXML "actor" $ medicationAdministration'Performer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationAdministration'Performer_onBehalfOf x
            ]
instance Extension MedicationAdministration'Performer BackboneElement where
    supertype (MedicationAdministration'Performer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationAdministration'Performer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationAdministration'Performer -> BackboneElement)
              
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
data MedicationAdministration'Dosage = MedicationAdministration'Dosage
        { medicationAdministration'Dosage_id :: Maybe String'primitive
        , medicationAdministration'Dosage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministration'Dosage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministration'Dosage_text :: Maybe Xsd.XsdString
          -- ^ Free text dosage can be used for cases where the dosage 
          --   administered is too complex to code. When coded dosage is 
          --   present, the free text dosage may still be present for 
          --   display to humans.The dosage instructions should reflect 
          --   the dosage of the medication that was administered.
        , medicationAdministration'Dosage_site :: Maybe CodeableConcept
          -- ^ A coded specification of the anatomic site where the 
          --   medication first entered the body. For example, &quot;left 
          --   arm&quot;.
        , medicationAdministration'Dosage_route :: Maybe CodeableConcept
          -- ^ A code specifying the route or physiological path of 
          --   administration of a therapeutic agent into or onto the 
          --   patient. For example, topical, intravenous, etc.
        , medicationAdministration'Dosage_method :: Maybe CodeableConcept
          -- ^ A coded value indicating the method by which the medication 
          --   is intended to be or was introduced into or on the body. 
          --   This attribute will most often NOT be populated. It is most 
          --   commonly used for injections. For example, Slow Push, Deep 
          --   IV.
        , medicationAdministration'Dosage_dose :: Maybe Quantity
          -- ^ The amount of the medication given at one administration 
          --   event. Use this value when the administration is 
          --   essentially an instantaneous event such as a swallowing a 
          --   tablet or giving an injection.
        , medicationAdministration'Dosage_choice7 :: (Maybe (OneOf2 Ratio Quantity))
          -- ^ Identifies the speed with which the medication was or will 
          --   be introduced into the patient. Typically the rate for an 
          --   infusion e.g. 100 ml per 1 hour or 100 ml/hr. May also be 
          --   expressed as a rate per unit of time e.g. 500 ml per 2 
          --   hours. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 
          --   liter/8 hours.
          --   
          --   Choice between:
          --   
          --   (1) rateRatio
          --   
          --   (2) rateQuantity
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministration'Dosage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationAdministration'Dosage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "dose")
            `apply` optional (oneOf' [ ("Ratio", fmap OneOf2 (parseSchemaType "rateRatio"))
                                     , ("Quantity", fmap TwoOf2 (parseSchemaType "rateQuantity"))
                                     ])
    schemaTypeToXML s x@MedicationAdministration'Dosage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministration'Dosage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministration'Dosage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministration'Dosage_modifierExtension x
            , maybe [] (schemaTypeToXML "text") $ medicationAdministration'Dosage_text x
            , maybe [] (schemaTypeToXML "site") $ medicationAdministration'Dosage_site x
            , maybe [] (schemaTypeToXML "route") $ medicationAdministration'Dosage_route x
            , maybe [] (schemaTypeToXML "method") $ medicationAdministration'Dosage_method x
            , maybe [] (schemaTypeToXML "dose") $ medicationAdministration'Dosage_dose x
            , maybe [] (foldOneOf2  (schemaTypeToXML "rateRatio")
                                    (schemaTypeToXML "rateQuantity")
                                   ) $ medicationAdministration'Dosage_choice7 x
            ]
instance Extension MedicationAdministration'Dosage BackboneElement where
    supertype (MedicationAdministration'Dosage a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension MedicationAdministration'Dosage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationAdministration'Dosage -> BackboneElement)
              
 
data MedicationAdministrationStatus'list
    = MedicationAdministrationStatus'list_In'progress
      -- ^ In Progress
    | MedicationAdministrationStatus'list_On'hold
      -- ^ On Hold
    | MedicationAdministrationStatus'list_Completed
      -- ^ Completed
    | MedicationAdministrationStatus'list_Entered'in'error
      -- ^ Entered in Error
    | MedicationAdministrationStatus'list_Stopped
      -- ^ Stopped
    | MedicationAdministrationStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType MedicationAdministrationStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationAdministrationStatus'list where
    acceptingParser =  do literal "in-progress"; return MedicationAdministrationStatus'list_In'progress
                      `onFail` do literal "on-hold"; return MedicationAdministrationStatus'list_On'hold
                      `onFail` do literal "completed"; return MedicationAdministrationStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationAdministrationStatus'list_Entered'in'error
                      `onFail` do literal "stopped"; return MedicationAdministrationStatus'list_Stopped
                      `onFail` do literal "unknown"; return MedicationAdministrationStatus'list_Unknown
                      
    simpleTypeText MedicationAdministrationStatus'list_In'progress = "in-progress"
    simpleTypeText MedicationAdministrationStatus'list_On'hold = "on-hold"
    simpleTypeText MedicationAdministrationStatus'list_Completed = "completed"
    simpleTypeText MedicationAdministrationStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText MedicationAdministrationStatus'list_Stopped = "stopped"
    simpleTypeText MedicationAdministrationStatus'list_Unknown = "unknown"
 
data MedicationAdministrationStatus = MedicationAdministrationStatus
        { medicationAdministrationStatus_id :: Maybe String'primitive
        , medicationAdministrationStatus_value :: Maybe MedicationAdministrationStatus'list
        , medicationAdministrationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministrationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationAdministrationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationAdministrationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministrationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationAdministrationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministrationStatus_extension x
            ]
instance Extension MedicationAdministrationStatus Element where
    supertype (MedicationAdministrationStatus a0 a1 e0) =
               Element a0 e0
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
elementMedicationDispense :: XMLParser MedicationDispense
elementMedicationDispense = parseSchemaType "MedicationDispense"
elementToXMLMedicationDispense :: MedicationDispense -> [Content ()]
elementToXMLMedicationDispense = schemaTypeToXML "MedicationDispense"
 
data MedicationDispense = MedicationDispense
        { medicationDispense_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationDispense_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationDispense_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationDispense_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationDispense_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationDispense_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationDispense_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispense_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispense_identifier :: [Identifier]
          -- ^ Identifier assigned by the dispensing facility - this is an 
          --   identifier assigned outside FHIR.
        , medicationDispense_partOf :: [Reference]
          -- ^ The procedure that the dispense is done because of.
        , medicationDispense_status :: Maybe MedicationDispenseStatus
          -- ^ A code specifying the state of the set of dispense events.
        , medicationDispense_category :: Maybe CodeableConcept
          -- ^ Indicates type of medication dispense and where the 
          --   medication is expected to be consumed or administered.
        , medicationDispense_choice12 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationDispense_subject :: Maybe Reference
          -- ^ A link to a resource representing the person or the group 
          --   to whom the medication will be given.
        , medicationDispense_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this event.
        , medicationDispense_supportingInformation :: [Reference]
          -- ^ Additional information that supports the medication being 
          --   dispensed.
        , medicationDispense_performer :: [MedicationDispense'Performer]
          -- ^ Indicates who or what performed the event. It should be 
          --   assumed that the performer is the dispenser of the 
          --   medication.
        , medicationDispense_authorizingPrescription :: [Reference]
          -- ^ Indicates the medication order that is being dispensed 
          --   against.
        , medicationDispense_type :: Maybe CodeableConcept
          -- ^ Indicates the type of dispensing event that is performed. 
          --   For example, Trial Fill, Completion of Trial, Partial Fill, 
          --   Emergency Fill, Samples, etc.
        , medicationDispense_quantity :: Maybe Quantity
          -- ^ The amount of medication that has been dispensed. Includes 
          --   unit of measure.
        , medicationDispense_daysSupply :: Maybe Quantity
          -- ^ The amount of medication expressed as a timing amount.
        , medicationDispense_whenPrepared :: Maybe DateTime
          -- ^ The time when the dispensed product was packaged and 
          --   reviewed.
        , medicationDispense_whenHandedOver :: Maybe DateTime
          -- ^ The time the dispensed product was provided to the patient 
          --   or their representative.
        , medicationDispense_destination :: Maybe Reference
          -- ^ Identification of the facility/location where the 
          --   medication was shipped to, as part of the dispense event.
        , medicationDispense_receiver :: [Reference]
          -- ^ Identifies the person who picked up the medication. This 
          --   will usually be a patient or their caregiver, but some 
          --   cases exist where it can be a healthcare professional.
        , medicationDispense_note :: [Annotation]
          -- ^ Extra information about the dispense that could not be 
          --   conveyed in the other attributes.
        , medicationDispense_dosageInstruction :: [Dosage]
          -- ^ Indicates how the medication is to be used by the patient.
        , medicationDispense_substitution :: Maybe MedicationDispense'Substitution
          -- ^ Indicates whether or not substitution was made as part of 
          --   the dispense. In some cases substitution will be expected 
          --   but does not happen, in other cases substitution is not 
          --   expected but does happen. This block explains what 
          --   substitution did or did not happen and why. If nothing is 
          --   specified, substitution was not done.
        , medicationDispense_detectedIssue :: [Reference]
          -- ^ Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions for 
          --   a patient; e.g. Drug-drug interaction, duplicate therapy, 
          --   dosage alert etc.
        , medicationDispense_notDone :: Maybe Boolean
          -- ^ True if the dispense was not performed for some reason.
        , medicationDispense_choice30 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason why a dispense was not performed.
          --   
          --   Choice between:
          --   
          --   (1) notDoneReasonCodeableConcept
          --   
          --   (2) notDoneReasonReference
        , medicationDispense_eventHistory :: [Reference]
          -- ^ A summary of the events of interest that have occurred, 
          --   such as when the dispense was verified.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispense where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationDispense
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "authorizingPrescription")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "daysSupply")
            `apply` optional (parseSchemaType "whenPrepared")
            `apply` optional (parseSchemaType "whenHandedOver")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "receiver")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosageInstruction")
            `apply` optional (parseSchemaType "substitution")
            `apply` many (parseSchemaType "detectedIssue")
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "notDoneReasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "notDoneReasonReference"))
                                     ])
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationDispense{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationDispense_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationDispense_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationDispense_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationDispense_language x
            , maybe [] (schemaTypeToXML "text") $ medicationDispense_text x
            , concatMap (schemaTypeToXML "contained") $ medicationDispense_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationDispense_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispense_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationDispense_identifier x
            , concatMap (schemaTypeToXML "partOf") $ medicationDispense_partOf x
            , maybe [] (schemaTypeToXML "status") $ medicationDispense_status x
            , maybe [] (schemaTypeToXML "category") $ medicationDispense_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationDispense_choice12 x
            , maybe [] (schemaTypeToXML "subject") $ medicationDispense_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationDispense_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationDispense_supportingInformation x
            , concatMap (schemaTypeToXML "performer") $ medicationDispense_performer x
            , concatMap (schemaTypeToXML "authorizingPrescription") $ medicationDispense_authorizingPrescription x
            , maybe [] (schemaTypeToXML "type") $ medicationDispense_type x
            , maybe [] (schemaTypeToXML "quantity") $ medicationDispense_quantity x
            , maybe [] (schemaTypeToXML "daysSupply") $ medicationDispense_daysSupply x
            , maybe [] (schemaTypeToXML "whenPrepared") $ medicationDispense_whenPrepared x
            , maybe [] (schemaTypeToXML "whenHandedOver") $ medicationDispense_whenHandedOver x
            , maybe [] (schemaTypeToXML "destination") $ medicationDispense_destination x
            , concatMap (schemaTypeToXML "receiver") $ medicationDispense_receiver x
            , concatMap (schemaTypeToXML "note") $ medicationDispense_note x
            , concatMap (schemaTypeToXML "dosageInstruction") $ medicationDispense_dosageInstruction x
            , maybe [] (schemaTypeToXML "substitution") $ medicationDispense_substitution x
            , concatMap (schemaTypeToXML "detectedIssue") $ medicationDispense_detectedIssue x
            , maybe [] (schemaTypeToXML "notDone") $ medicationDispense_notDone x
            , maybe [] (foldOneOf2  (schemaTypeToXML "notDoneReasonCodeableConcept")
                                    (schemaTypeToXML "notDoneReasonReference")
                                   ) $ medicationDispense_choice30 x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationDispense_eventHistory x
            ]
instance Extension MedicationDispense DomainResource where
    supertype (MedicationDispense e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationDispense Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationDispense -> DomainResource)
              
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
data MedicationDispense'Performer = MedicationDispense'Performer
        { medicationDispense'Performer_id :: Maybe String'primitive
        , medicationDispense'Performer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispense'Performer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispense'Performer_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action. It 
          --   should be assumed that the actor is the dispenser of the 
          --   medication.
        , medicationDispense'Performer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispense'Performer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationDispense'Performer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationDispense'Performer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispense'Performer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispense'Performer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispense'Performer_modifierExtension x
            , schemaTypeToXML "actor" $ medicationDispense'Performer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationDispense'Performer_onBehalfOf x
            ]
instance Extension MedicationDispense'Performer BackboneElement where
    supertype (MedicationDispense'Performer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationDispense'Performer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationDispense'Performer -> BackboneElement)
              
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
data MedicationDispense'Substitution = MedicationDispense'Substitution
        { medicationDispense'Substitution_id :: Maybe String'primitive
        , medicationDispense'Substitution_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispense'Substitution_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispense'Substitution_wasSubstituted :: Boolean
          -- ^ True if the dispenser dispensed a different drug or product 
          --   from what was prescribed.
        , medicationDispense'Substitution_type :: Maybe CodeableConcept
          -- ^ A code signifying whether a different drug was dispensed 
          --   from what was prescribed.
        , medicationDispense'Substitution_reason :: [CodeableConcept]
          -- ^ Indicates the reason for the substitution of (or lack of 
          --   substitution) from what was prescribed.
        , medicationDispense'Substitution_responsibleParty :: [Reference]
          -- ^ The person or organization that has primary responsibility 
          --   for the substitution.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispense'Substitution where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationDispense'Substitution a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "wasSubstituted"
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "responsibleParty")
    schemaTypeToXML s x@MedicationDispense'Substitution{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispense'Substitution_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispense'Substitution_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispense'Substitution_modifierExtension x
            , schemaTypeToXML "wasSubstituted" $ medicationDispense'Substitution_wasSubstituted x
            , maybe [] (schemaTypeToXML "type") $ medicationDispense'Substitution_type x
            , concatMap (schemaTypeToXML "reason") $ medicationDispense'Substitution_reason x
            , concatMap (schemaTypeToXML "responsibleParty") $ medicationDispense'Substitution_responsibleParty x
            ]
instance Extension MedicationDispense'Substitution BackboneElement where
    supertype (MedicationDispense'Substitution a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MedicationDispense'Substitution Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationDispense'Substitution -> BackboneElement)
              
 
data MedicationDispenseStatus'list
    = MedicationDispenseStatus'list_Preparation
      -- ^ Preparation
    | MedicationDispenseStatus'list_In'progress
      -- ^ In Progress
    | MedicationDispenseStatus'list_On'hold
      -- ^ On Hold
    | MedicationDispenseStatus'list_Completed
      -- ^ Completed
    | MedicationDispenseStatus'list_Entered'in'error
      -- ^ Entered in-Error
    | MedicationDispenseStatus'list_Stopped
      -- ^ Stopped
    deriving (Eq,Show,Enum)
instance SchemaType MedicationDispenseStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationDispenseStatus'list where
    acceptingParser =  do literal "preparation"; return MedicationDispenseStatus'list_Preparation
                      `onFail` do literal "in-progress"; return MedicationDispenseStatus'list_In'progress
                      `onFail` do literal "on-hold"; return MedicationDispenseStatus'list_On'hold
                      `onFail` do literal "completed"; return MedicationDispenseStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationDispenseStatus'list_Entered'in'error
                      `onFail` do literal "stopped"; return MedicationDispenseStatus'list_Stopped
                      
    simpleTypeText MedicationDispenseStatus'list_Preparation = "preparation"
    simpleTypeText MedicationDispenseStatus'list_In'progress = "in-progress"
    simpleTypeText MedicationDispenseStatus'list_On'hold = "on-hold"
    simpleTypeText MedicationDispenseStatus'list_Completed = "completed"
    simpleTypeText MedicationDispenseStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText MedicationDispenseStatus'list_Stopped = "stopped"
 
data MedicationDispenseStatus = MedicationDispenseStatus
        { medicationDispenseStatus_id :: Maybe String'primitive
        , medicationDispenseStatus_value :: Maybe MedicationDispenseStatus'list
        , medicationDispenseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispenseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationDispenseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationDispenseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispenseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationDispenseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispenseStatus_extension x
            ]
instance Extension MedicationDispenseStatus Element where
    supertype (MedicationDispenseStatus a0 a1 e0) =
               Element a0 e0
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
elementMedicationRequest :: XMLParser MedicationRequest
elementMedicationRequest = parseSchemaType "MedicationRequest"
elementToXMLMedicationRequest :: MedicationRequest -> [Content ()]
elementToXMLMedicationRequest = schemaTypeToXML "MedicationRequest"
 
data MedicationRequest = MedicationRequest
        { medicationRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequest_identifier :: [Identifier]
          -- ^ This records identifiers associated with this medication 
          --   request that are defined by business processes and/or used 
          --   to refer to it when a direct URL reference to the resource 
          --   itself is not appropriate. For example a re-imbursement 
          --   system might issue its own id for each prescription that is 
          --   created. This is particularly important where FHIR only 
          --   provides part of an entire workflow process where records 
          --   must be tracked through an entire system.
        , medicationRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request.
        , medicationRequest_basedOn :: [Reference]
          -- ^ A plan or request that is fulfilled in whole or in part by 
          --   this medication request.
        , medicationRequest_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition or 
          --   prescription.
        , medicationRequest_status :: Maybe MedicationRequestStatus
          -- ^ A code specifying the current state of the order. Generally 
          --   this will be active or completed state.
        , medicationRequest_intent :: MedicationRequestIntent
          -- ^ Whether the request is a proposal, plan, or an original 
          --   order.
        , medicationRequest_category :: Maybe CodeableConcept
          -- ^ Indicates the type of medication order and where the 
          --   medication is expected to be consumed or administered.
        , medicationRequest_priority :: Maybe MedicationRequestPriority
          -- ^ Indicates how quickly the Medication Request should be 
          --   addressed with respect to other requests.
        , medicationRequest_choice16 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being requested. This is a link 
          --   to a resource that represents the medication which may be 
          --   the details of the medication or simply an attribute 
          --   carrying a code that identifies the medication from a known 
          --   list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationRequest_subject :: Reference
          -- ^ A link to a resource representing the person or set of 
          --   individuals to whom the medication will be given.
        , medicationRequest_context :: Maybe Reference
          -- ^ A link to an encounter, or episode of care, that identifies 
          --   the particular occurrence or set occurrences of contact 
          --   between patient and health care provider.
        , medicationRequest_supportingInformation :: [Reference]
          -- ^ Include additional information (for example, patient height 
          --   and weight) that supports the ordering of the medication.
        , medicationRequest_authoredOn :: Maybe DateTime
          -- ^ The date (and perhaps time) when the prescription was 
          --   initially written or authored on.
        , medicationRequest_requester :: Maybe MedicationRequest'Requester
          -- ^ The individual, organization or device that initiated the 
          --   request and has responsibility for its activation.
        , medicationRequest_recorder :: Maybe Reference
          -- ^ The person who entered the order on behalf of another 
          --   individual for example in the case of a verbal or a 
          --   telephone order.
        , medicationRequest_reasonCode :: [CodeableConcept]
          -- ^ The reason or the indication for ordering the medication.
        , medicationRequest_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   was ordered.
        , medicationRequest_note :: [Annotation]
          -- ^ Extra information about the prescription that could not be 
          --   conveyed by the other attributes.
        , medicationRequest_dosageInstruction :: [Dosage]
          -- ^ Indicates how the medication is to be used by the patient.
        , medicationRequest_dispenseRequest :: Maybe MedicationRequest'DispenseRequest
          -- ^ Indicates the specific details for the dispense or 
          --   medication supply part of a medication request (also known 
          --   as a Medication Prescription or Medication Order). Note 
          --   that this information is not always sent with the order. 
          --   There may be in some settings (e.g. hospitals) 
          --   institutional or system support for completing the dispense 
          --   details in the pharmacy department.
        , medicationRequest_substitution :: Maybe MedicationRequest'Substitution
          -- ^ Indicates whether or not substitution can or should be part 
          --   of the dispense. In some cases substitution must happen, in 
          --   other cases substitution must not happen. This block 
          --   explains the prescriber's intent. If nothing is specified 
          --   substitution may be done.
        , medicationRequest_priorPrescription :: Maybe Reference
          -- ^ A link to a resource representing an earlier order related 
          --   order or prescription.
        , medicationRequest_detectedIssue :: [Reference]
          -- ^ Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions for 
          --   a patient; e.g. Drug-drug interaction, duplicate therapy, 
          --   dosage alert etc.
        , medicationRequest_eventHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this 
          --   resource or fulfilling request or event resources that 
          --   identify key state transitions or updates that are likely 
          --   to be relevant to a user looking at the current version of 
          --   the resource.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "recorder")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosageInstruction")
            `apply` optional (parseSchemaType "dispenseRequest")
            `apply` optional (parseSchemaType "substitution")
            `apply` optional (parseSchemaType "priorPrescription")
            `apply` many (parseSchemaType "detectedIssue")
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationRequest_language x
            , maybe [] (schemaTypeToXML "text") $ medicationRequest_text x
            , concatMap (schemaTypeToXML "contained") $ medicationRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ medicationRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ medicationRequest_basedOn x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ medicationRequest_groupIdentifier x
            , maybe [] (schemaTypeToXML "status") $ medicationRequest_status x
            , schemaTypeToXML "intent" $ medicationRequest_intent x
            , maybe [] (schemaTypeToXML "category") $ medicationRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ medicationRequest_priority x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationRequest_choice16 x
            , schemaTypeToXML "subject" $ medicationRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationRequest_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationRequest_supportingInformation x
            , maybe [] (schemaTypeToXML "authoredOn") $ medicationRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ medicationRequest_requester x
            , maybe [] (schemaTypeToXML "recorder") $ medicationRequest_recorder x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationRequest_reasonReference x
            , concatMap (schemaTypeToXML "note") $ medicationRequest_note x
            , concatMap (schemaTypeToXML "dosageInstruction") $ medicationRequest_dosageInstruction x
            , maybe [] (schemaTypeToXML "dispenseRequest") $ medicationRequest_dispenseRequest x
            , maybe [] (schemaTypeToXML "substitution") $ medicationRequest_substitution x
            , maybe [] (schemaTypeToXML "priorPrescription") $ medicationRequest_priorPrescription x
            , concatMap (schemaTypeToXML "detectedIssue") $ medicationRequest_detectedIssue x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationRequest_eventHistory x
            ]
instance Extension MedicationRequest DomainResource where
    supertype (MedicationRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationRequest -> DomainResource)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequest'Requester = MedicationRequest'Requester
        { medicationRequest'Requester_id :: Maybe String'primitive
        , medicationRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequest'Requester_agent :: Reference
          -- ^ The healthcare professional responsible for authorizing the 
          --   initial prescription.
        , medicationRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ medicationRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationRequest'Requester_onBehalfOf x
            ]
instance Extension MedicationRequest'Requester BackboneElement where
    supertype (MedicationRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequest'Requester -> BackboneElement)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequest'DispenseRequest = MedicationRequest'DispenseRequest
        { medicationRequest'DispenseRequest_id :: Maybe String'primitive
        , medicationRequest'DispenseRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequest'DispenseRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequest'DispenseRequest_validityPeriod :: Maybe Period
          -- ^ This indicates the validity period of a prescription (stale 
          --   dating the Prescription).
        , medicationRequest'DispenseRequest_numberOfRepeatsAllowed :: Maybe PositiveInt
          -- ^ An integer indicating the number of times, in addition to 
          --   the original dispense, (aka refills or repeats) that the 
          --   patient can receive the prescribed medication. Usage Notes: 
          --   This integer does not include the original order dispense. 
          --   This means that if an order indicates dispense 30 tablets 
          --   plus &quot;3 repeats&quot;, then the order can be dispensed 
          --   a total of 4 times and the patient can receive a total of 
          --   120 tablets.
        , medicationRequest'DispenseRequest_quantity :: Maybe Quantity
          -- ^ The amount that is to be dispensed for one fill.
        , medicationRequest'DispenseRequest_expectedSupplyDuration :: Maybe Duration
          -- ^ Identifies the period time over which the supplied product 
          --   is expected to be used, or the length of time the dispense 
          --   is expected to last.
        , medicationRequest'DispenseRequest_performer :: Maybe Reference
          -- ^ Indicates the intended dispensing Organization specified by 
          --   the prescriber.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequest'DispenseRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequest'DispenseRequest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "validityPeriod")
            `apply` optional (parseSchemaType "numberOfRepeatsAllowed")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "expectedSupplyDuration")
            `apply` optional (parseSchemaType "performer")
    schemaTypeToXML s x@MedicationRequest'DispenseRequest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequest'DispenseRequest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequest'DispenseRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequest'DispenseRequest_modifierExtension x
            , maybe [] (schemaTypeToXML "validityPeriod") $ medicationRequest'DispenseRequest_validityPeriod x
            , maybe [] (schemaTypeToXML "numberOfRepeatsAllowed") $ medicationRequest'DispenseRequest_numberOfRepeatsAllowed x
            , maybe [] (schemaTypeToXML "quantity") $ medicationRequest'DispenseRequest_quantity x
            , maybe [] (schemaTypeToXML "expectedSupplyDuration") $ medicationRequest'DispenseRequest_expectedSupplyDuration x
            , maybe [] (schemaTypeToXML "performer") $ medicationRequest'DispenseRequest_performer x
            ]
instance Extension MedicationRequest'DispenseRequest BackboneElement where
    supertype (MedicationRequest'DispenseRequest a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequest'DispenseRequest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequest'DispenseRequest -> BackboneElement)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequest'Substitution = MedicationRequest'Substitution
        { medicationRequest'Substitution_id :: Maybe String'primitive
        , medicationRequest'Substitution_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequest'Substitution_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequest'Substitution_allowed :: Boolean
          -- ^ True if the prescriber allows a different drug to be 
          --   dispensed from what was prescribed.
        , medicationRequest'Substitution_reason :: Maybe CodeableConcept
          -- ^ Indicates the reason for the substitution, or why 
          --   substitution must or must not be performed.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequest'Substitution where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequest'Substitution a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "allowed"
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@MedicationRequest'Substitution{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequest'Substitution_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequest'Substitution_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequest'Substitution_modifierExtension x
            , schemaTypeToXML "allowed" $ medicationRequest'Substitution_allowed x
            , maybe [] (schemaTypeToXML "reason") $ medicationRequest'Substitution_reason x
            ]
instance Extension MedicationRequest'Substitution BackboneElement where
    supertype (MedicationRequest'Substitution a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequest'Substitution Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequest'Substitution -> BackboneElement)
              
 
data MedicationRequestStatus'list
    = MedicationRequestStatus'list_Active
      -- ^ Active
    | MedicationRequestStatus'list_On'hold
      -- ^ On Hold
    | MedicationRequestStatus'list_Cancelled
      -- ^ Cancelled
    | MedicationRequestStatus'list_Completed
      -- ^ Completed
    | MedicationRequestStatus'list_Entered'in'error
      -- ^ Entered In Error
    | MedicationRequestStatus'list_Stopped
      -- ^ Stopped
    | MedicationRequestStatus'list_Draft
      -- ^ Draft
    | MedicationRequestStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestStatus'list where
    acceptingParser =  do literal "active"; return MedicationRequestStatus'list_Active
                      `onFail` do literal "on-hold"; return MedicationRequestStatus'list_On'hold
                      `onFail` do literal "cancelled"; return MedicationRequestStatus'list_Cancelled
                      `onFail` do literal "completed"; return MedicationRequestStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationRequestStatus'list_Entered'in'error
                      `onFail` do literal "stopped"; return MedicationRequestStatus'list_Stopped
                      `onFail` do literal "draft"; return MedicationRequestStatus'list_Draft
                      `onFail` do literal "unknown"; return MedicationRequestStatus'list_Unknown
                      
    simpleTypeText MedicationRequestStatus'list_Active = "active"
    simpleTypeText MedicationRequestStatus'list_On'hold = "on-hold"
    simpleTypeText MedicationRequestStatus'list_Cancelled = "cancelled"
    simpleTypeText MedicationRequestStatus'list_Completed = "completed"
    simpleTypeText MedicationRequestStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText MedicationRequestStatus'list_Stopped = "stopped"
    simpleTypeText MedicationRequestStatus'list_Draft = "draft"
    simpleTypeText MedicationRequestStatus'list_Unknown = "unknown"
 
data MedicationRequestStatus = MedicationRequestStatus
        { medicationRequestStatus_id :: Maybe String'primitive
        , medicationRequestStatus_value :: Maybe MedicationRequestStatus'list
        , medicationRequestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestStatus_extension x
            ]
instance Extension MedicationRequestStatus Element where
    supertype (MedicationRequestStatus a0 a1 e0) =
               Element a0 e0
 
data MedicationRequestPriority'list
    = MedicationRequestPriority'list_Routine
      -- ^ Routine
    | MedicationRequestPriority'list_Urgent
      -- ^ Urgent
    | MedicationRequestPriority'list_Stat
      -- ^ Stat
    | MedicationRequestPriority'list_Asap
      -- ^ ASAP
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestPriority'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestPriority'list where
    acceptingParser =  do literal "routine"; return MedicationRequestPriority'list_Routine
                      `onFail` do literal "urgent"; return MedicationRequestPriority'list_Urgent
                      `onFail` do literal "stat"; return MedicationRequestPriority'list_Stat
                      `onFail` do literal "asap"; return MedicationRequestPriority'list_Asap
                      
    simpleTypeText MedicationRequestPriority'list_Routine = "routine"
    simpleTypeText MedicationRequestPriority'list_Urgent = "urgent"
    simpleTypeText MedicationRequestPriority'list_Stat = "stat"
    simpleTypeText MedicationRequestPriority'list_Asap = "asap"
 
data MedicationRequestPriority = MedicationRequestPriority
        { medicationRequestPriority_id :: Maybe String'primitive
        , medicationRequestPriority_value :: Maybe MedicationRequestPriority'list
        , medicationRequestPriority_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestPriority where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestPriority a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestPriority{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestPriority_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestPriority_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestPriority_extension x
            ]
instance Extension MedicationRequestPriority Element where
    supertype (MedicationRequestPriority a0 a1 e0) =
               Element a0 e0
 
data MedicationRequestIntent'list
    = MedicationRequestIntent'list_Proposal
      -- ^ Proposal
    | MedicationRequestIntent'list_Plan
      -- ^ Plan
    | MedicationRequestIntent'list_Order
      -- ^ Order
    | MedicationRequestIntent'list_Instance'order
      -- ^ Instance Order
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestIntent'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestIntent'list where
    acceptingParser =  do literal "proposal"; return MedicationRequestIntent'list_Proposal
                      `onFail` do literal "plan"; return MedicationRequestIntent'list_Plan
                      `onFail` do literal "order"; return MedicationRequestIntent'list_Order
                      `onFail` do literal "instance-order"; return MedicationRequestIntent'list_Instance'order
                      
    simpleTypeText MedicationRequestIntent'list_Proposal = "proposal"
    simpleTypeText MedicationRequestIntent'list_Plan = "plan"
    simpleTypeText MedicationRequestIntent'list_Order = "order"
    simpleTypeText MedicationRequestIntent'list_Instance'order = "instance-order"
 
data MedicationRequestIntent = MedicationRequestIntent
        { medicationRequestIntent_id :: Maybe String'primitive
        , medicationRequestIntent_value :: Maybe MedicationRequestIntent'list
        , medicationRequestIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestIntent_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestIntent_extension x
            ]
instance Extension MedicationRequestIntent Element where
    supertype (MedicationRequestIntent a0 a1 e0) =
               Element a0 e0
 
-- | A record of a medication that is being consumed by a 
--   patient. A MedicationStatement may indicate that the 
--   patient may be taking the medication now, or has taken the 
--   medication in the past or will be taking the medication in 
--   the future. The source of this information can be the 
--   patient, significant other (such as a family member or 
--   spouse), or a clinician. A common scenario where this 
--   information is captured is during the history taking 
--   process during a patient visit or stay. The medication 
--   information may come from sources such as the patient's 
--   memory, from a prescription bottle, or from a list of 
--   medications the patient, clinician or other party maintains 
--   The primary difference between a medication statement and a 
--   medication administration is that the medication 
--   administration has complete administration information and 
--   is based on actual administration information from the 
--   person who administered the medication. A medication 
--   statement is often, if not always, less specific. There is 
--   no required date/time when the medication was administered, 
--   in fact we only know that a source has reported the patient 
--   is taking this medication, where details such as time, 
--   quantity, or rate or even medication product may be 
--   incomplete or missing or less precise. As stated earlier, 
--   the medication statement information may come from the 
--   patient's memory, from a prescription bottle or from a list 
--   of medications the patient, clinician or other party 
--   maintains. Medication administration is more formal and is 
--   not missing detailed information.
elementMedicationStatement :: XMLParser MedicationStatement
elementMedicationStatement = parseSchemaType "MedicationStatement"
elementToXMLMedicationStatement :: MedicationStatement -> [Content ()]
elementToXMLMedicationStatement = schemaTypeToXML "MedicationStatement"
 
data MedicationStatement = MedicationStatement
        { medicationStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationStatement_identifier :: [Identifier]
          -- ^ External identifier - FHIR will generate its own internal 
          --   identifiers (probably URLs) which do not need to be 
          --   explicitly managed by the resource. The identifier here is 
          --   one that would be used by another non-FHIR system - for 
          --   example an automated medication pump would provide a record 
          --   each time it operated; an administration while the patient 
          --   was off the ward might be made with a different system and 
          --   entered after the event. Particularly important if these 
          --   records have to be updated.
        , medicationStatement_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , medicationStatement_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , medicationStatement_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this MedicationStatement.
        , medicationStatement_status :: MedicationStatementStatus
          -- ^ A code representing the patient or other source's judgment 
          --   about the state of the medication used that this statement 
          --   is about. Generally this will be active or completed.
        , medicationStatement_category :: Maybe CodeableConcept
          -- ^ Indicates where type of medication statement and where the 
          --   medication is expected to be consumed or administered.
        , medicationStatement_choice14 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationStatement_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The interval of time during which it is being asserted that 
          --   the patient was taking the medication (or was not taking, 
          --   when the wasNotGiven element is true).
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , medicationStatement_dateAsserted :: Maybe DateTime
          -- ^ The date when the medication statement was asserted by the 
          --   information source.
        , medicationStatement_informationSource :: Maybe Reference
          -- ^ The person or organization that provided the information 
          --   about the taking of this medication. Note: Use derivedFrom 
          --   when a MedicationStatement is derived from other resources, 
          --   e.g Claim or MedicationRequest.
        , medicationStatement_subject :: Reference
          -- ^ The person, animal or group who is/was taking the 
          --   medication.
        , medicationStatement_derivedFrom :: [Reference]
          -- ^ Allows linking the MedicationStatement to the underlying 
          --   MedicationRequest, or to other information that supports or 
          --   is used to derive the MedicationStatement.
        , medicationStatement_taken :: MedicationStatementTaken
          -- ^ Indicator of the certainty of whether the medication was 
          --   taken by the patient.
        , medicationStatement_reasonNotTaken :: [CodeableConcept]
          -- ^ A code indicating why the medication was not taken.
        , medicationStatement_reasonCode :: [CodeableConcept]
          -- ^ A reason for why the medication is being/was taken.
        , medicationStatement_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   is being/was taken.
        , medicationStatement_note :: [Annotation]
          -- ^ Provides extra information about the medication statement 
          --   that is not conveyed by the other attributes.
        , medicationStatement_dosage :: [Dosage]
          -- ^ Indicates how the medication is/was or should be taken by 
          --   the patient.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "context")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dateAsserted")
            `apply` optional (parseSchemaType "informationSource")
            `apply` parseSchemaType "subject"
            `apply` many (parseSchemaType "derivedFrom")
            `apply` parseSchemaType "taken"
            `apply` many (parseSchemaType "reasonNotTaken")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosage")
    schemaTypeToXML s x@MedicationStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationStatement_language x
            , maybe [] (schemaTypeToXML "text") $ medicationStatement_text x
            , concatMap (schemaTypeToXML "contained") $ medicationStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationStatement_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationStatement_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ medicationStatement_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ medicationStatement_partOf x
            , maybe [] (schemaTypeToXML "context") $ medicationStatement_context x
            , schemaTypeToXML "status" $ medicationStatement_status x
            , maybe [] (schemaTypeToXML "category") $ medicationStatement_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationStatement_choice14 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ medicationStatement_choice15 x
            , maybe [] (schemaTypeToXML "dateAsserted") $ medicationStatement_dateAsserted x
            , maybe [] (schemaTypeToXML "informationSource") $ medicationStatement_informationSource x
            , schemaTypeToXML "subject" $ medicationStatement_subject x
            , concatMap (schemaTypeToXML "derivedFrom") $ medicationStatement_derivedFrom x
            , schemaTypeToXML "taken" $ medicationStatement_taken x
            , concatMap (schemaTypeToXML "reasonNotTaken") $ medicationStatement_reasonNotTaken x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationStatement_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationStatement_reasonReference x
            , concatMap (schemaTypeToXML "note") $ medicationStatement_note x
            , concatMap (schemaTypeToXML "dosage") $ medicationStatement_dosage x
            ]
instance Extension MedicationStatement DomainResource where
    supertype (MedicationStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationStatement -> DomainResource)
              
 
data MedicationStatementStatus'list
    = MedicationStatementStatus'list_Active
      -- ^ Active
    | MedicationStatementStatus'list_Completed
      -- ^ Completed
    | MedicationStatementStatus'list_Entered'in'error
      -- ^ Entered in Error
    | MedicationStatementStatus'list_Intended
      -- ^ Intended
    | MedicationStatementStatus'list_Stopped
      -- ^ Stopped
    | MedicationStatementStatus'list_On'hold
      -- ^ On Hold
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatementStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatementStatus'list where
    acceptingParser =  do literal "active"; return MedicationStatementStatus'list_Active
                      `onFail` do literal "completed"; return MedicationStatementStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationStatementStatus'list_Entered'in'error
                      `onFail` do literal "intended"; return MedicationStatementStatus'list_Intended
                      `onFail` do literal "stopped"; return MedicationStatementStatus'list_Stopped
                      `onFail` do literal "on-hold"; return MedicationStatementStatus'list_On'hold
                      
    simpleTypeText MedicationStatementStatus'list_Active = "active"
    simpleTypeText MedicationStatementStatus'list_Completed = "completed"
    simpleTypeText MedicationStatementStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText MedicationStatementStatus'list_Intended = "intended"
    simpleTypeText MedicationStatementStatus'list_Stopped = "stopped"
    simpleTypeText MedicationStatementStatus'list_On'hold = "on-hold"
 
data MedicationStatementStatus = MedicationStatementStatus
        { medicationStatementStatus_id :: Maybe String'primitive
        , medicationStatementStatus_value :: Maybe MedicationStatementStatus'list
        , medicationStatementStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatementStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatementStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatementStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatementStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatementStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatementStatus_extension x
            ]
instance Extension MedicationStatementStatus Element where
    supertype (MedicationStatementStatus a0 a1 e0) =
               Element a0 e0
 
data MedicationStatementTaken'list
    = MedicationStatementTaken'list_Y
      -- ^ Yes
    | MedicationStatementTaken'list_N
      -- ^ No
    | MedicationStatementTaken'list_Unk
      -- ^ Unknown
    | MedicationStatementTaken'list_Na
      -- ^ Not Applicable
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatementTaken'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatementTaken'list where
    acceptingParser =  do literal "y"; return MedicationStatementTaken'list_Y
                      `onFail` do literal "n"; return MedicationStatementTaken'list_N
                      `onFail` do literal "unk"; return MedicationStatementTaken'list_Unk
                      `onFail` do literal "na"; return MedicationStatementTaken'list_Na
                      
    simpleTypeText MedicationStatementTaken'list_Y = "y"
    simpleTypeText MedicationStatementTaken'list_N = "n"
    simpleTypeText MedicationStatementTaken'list_Unk = "unk"
    simpleTypeText MedicationStatementTaken'list_Na = "na"
 
data MedicationStatementTaken = MedicationStatementTaken
        { medicationStatementTaken_id :: Maybe String'primitive
        , medicationStatementTaken_value :: Maybe MedicationStatementTaken'list
        , medicationStatementTaken_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatementTaken where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatementTaken a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatementTaken{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatementTaken_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatementTaken_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatementTaken_extension x
            ]
instance Extension MedicationStatementTaken Element where
    supertype (MedicationStatementTaken a0 a1 e0) =
               Element a0 e0
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
elementMessageDefinition :: XMLParser MessageDefinition
elementMessageDefinition = parseSchemaType "MessageDefinition"
elementToXMLMessageDefinition :: MessageDefinition -> [Content ()]
elementToXMLMessageDefinition = schemaTypeToXML "MessageDefinition"
 
data MessageDefinition = MessageDefinition
        { messageDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , messageDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , messageDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , messageDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , messageDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , messageDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , messageDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this message 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   message definition is (or will be) published. The URL 
          --   SHOULD include the major version of the message definition. 
          --   For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , messageDefinition_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this message 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , messageDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   message definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the message definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , messageDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the message definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , messageDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the message 
          --   definition.
        , messageDefinition_status :: PublicationStatus
          -- ^ The status of this message definition. Enables tracking the 
          --   life-cycle of the content.
        , messageDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this message definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , messageDefinition_date :: DateTime
          -- ^ The date (and optionally time) when the message definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the message definition changes.
        , messageDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the message definition.
        , messageDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , messageDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the message 
          --   definition from a consumer's perspective.
        , messageDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   message definition instances.
        , messageDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the message 
          --   definition is intended to be used.
        , messageDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this message definition is needed and 
          --   why it has been designed as it has.
        , messageDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the message definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the message 
          --   definition.
        , messageDefinition_base :: Maybe Reference
          -- ^ The MessageDefinition that is the basis for the contents of 
          --   this resource.
        , messageDefinition_parent :: [Reference]
          -- ^ Identifies a protocol or workflow that this 
          --   MessageDefinition represents a step in.
        , messageDefinition_replaces :: [Reference]
          -- ^ A MessageDefinition that is superseded by this definition.
        , messageDefinition_event :: Coding
          -- ^ A coded identifier of a supported messaging event.
        , messageDefinition_category :: Maybe MessageSignificanceCategory
          -- ^ The impact of the content of the message.
        , messageDefinition_focus :: [MessageDefinition'Focus]
          -- ^ Identifies the resource (or resources) that are being 
          --   addressed by the event. For example, the Encounter for an 
          --   admit message or two Account records for a merge.
        , messageDefinition_responseRequired :: Maybe Boolean
          -- ^ Indicates whether a response is required for this message.
        , messageDefinition_allowedResponse :: [MessageDefinition'AllowedResponse]
          -- ^ Indicates what types of messages may be sent as an 
          --   application-level response to this message.
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MessageDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "base")
            `apply` many (parseSchemaType "parent")
            `apply` many (parseSchemaType "replaces")
            `apply` parseSchemaType "event"
            `apply` optional (parseSchemaType "category")
            `apply` many (parseSchemaType "focus")
            `apply` optional (parseSchemaType "responseRequired")
            `apply` many (parseSchemaType "allowedResponse")
    schemaTypeToXML s x@MessageDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ messageDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ messageDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ messageDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ messageDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ messageDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ messageDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ messageDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ messageDefinition_url x
            , maybe [] (schemaTypeToXML "identifier") $ messageDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ messageDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ messageDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ messageDefinition_title x
            , schemaTypeToXML "status" $ messageDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ messageDefinition_experimental x
            , schemaTypeToXML "date" $ messageDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ messageDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ messageDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ messageDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ messageDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ messageDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ messageDefinition_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ messageDefinition_copyright x
            , maybe [] (schemaTypeToXML "base") $ messageDefinition_base x
            , concatMap (schemaTypeToXML "parent") $ messageDefinition_parent x
            , concatMap (schemaTypeToXML "replaces") $ messageDefinition_replaces x
            , schemaTypeToXML "event" $ messageDefinition_event x
            , maybe [] (schemaTypeToXML "category") $ messageDefinition_category x
            , concatMap (schemaTypeToXML "focus") $ messageDefinition_focus x
            , maybe [] (schemaTypeToXML "responseRequired") $ messageDefinition_responseRequired x
            , concatMap (schemaTypeToXML "allowedResponse") $ messageDefinition_allowedResponse x
            ]
instance Extension MessageDefinition DomainResource where
    supertype (MessageDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MessageDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MessageDefinition -> DomainResource)
              
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
data MessageDefinition'Focus = MessageDefinition'Focus
        { messageDefinition'Focus_id :: Maybe String'primitive
        , messageDefinition'Focus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinition'Focus_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinition'Focus_code :: ResourceType
          -- ^ The kind of resource that must be the focus for this 
          --   message.
        , messageDefinition'Focus_profile :: Maybe Reference
          -- ^ A profile that reflects constraints for the focal resource 
          --   (and potentially for related resources).
        , messageDefinition'Focus_min :: Maybe UnsignedInt
          -- ^ Identifies the minimum number of resources of this type 
          --   that must be pointed to by a message in order for it to be 
          --   valid against this MessageDefinition.
        , messageDefinition'Focus_max :: Maybe Xsd.XsdString
          -- ^ Identifies the maximum number of resources of this type 
          --   that must be pointed to by a message in order for it to be 
          --   valid against this MessageDefinition.
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinition'Focus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageDefinition'Focus a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
    schemaTypeToXML s x@MessageDefinition'Focus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageDefinition'Focus_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageDefinition'Focus_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinition'Focus_modifierExtension x
            , schemaTypeToXML "code" $ messageDefinition'Focus_code x
            , maybe [] (schemaTypeToXML "profile") $ messageDefinition'Focus_profile x
            , maybe [] (schemaTypeToXML "min") $ messageDefinition'Focus_min x
            , maybe [] (schemaTypeToXML "max") $ messageDefinition'Focus_max x
            ]
instance Extension MessageDefinition'Focus BackboneElement where
    supertype (MessageDefinition'Focus a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MessageDefinition'Focus Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageDefinition'Focus -> BackboneElement)
              
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
data MessageDefinition'AllowedResponse = MessageDefinition'AllowedResponse
        { messageDefinition'AllowedResponse_id :: Maybe String'primitive
        , messageDefinition'AllowedResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinition'AllowedResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinition'AllowedResponse_message :: Reference
          -- ^ A reference to the message definition that must be adhered 
          --   to by this supported response.
        , messageDefinition'AllowedResponse_situation :: Maybe Markdown
          -- ^ Provides a description of the circumstances in which this 
          --   response should be used (as opposed to one of the 
          --   alternative responses).
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinition'AllowedResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageDefinition'AllowedResponse a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "message"
            `apply` optional (parseSchemaType "situation")
    schemaTypeToXML s x@MessageDefinition'AllowedResponse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageDefinition'AllowedResponse_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageDefinition'AllowedResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinition'AllowedResponse_modifierExtension x
            , schemaTypeToXML "message" $ messageDefinition'AllowedResponse_message x
            , maybe [] (schemaTypeToXML "situation") $ messageDefinition'AllowedResponse_situation x
            ]
instance Extension MessageDefinition'AllowedResponse BackboneElement where
    supertype (MessageDefinition'AllowedResponse a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MessageDefinition'AllowedResponse Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageDefinition'AllowedResponse -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
elementMessageHeader :: XMLParser MessageHeader
elementMessageHeader = parseSchemaType "MessageHeader"
elementToXMLMessageHeader :: MessageHeader -> [Content ()]
elementToXMLMessageHeader = schemaTypeToXML "MessageHeader"
 
data MessageHeader = MessageHeader
        { messageHeader_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , messageHeader_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , messageHeader_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , messageHeader_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , messageHeader_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , messageHeader_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , messageHeader_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeader_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeader_event :: Coding
          -- ^ Code that identifies the event this message represents and 
          --   connects it with its definition. Events defined as part of 
          --   the FHIR specification have the system value 
          --   &quot;http://hl7.org/fhir/message-events&quot;.
        , messageHeader_destination :: [MessageHeader'Destination]
          -- ^ The destination application which the message is intended 
          --   for.
        , messageHeader_receiver :: Maybe Reference
          -- ^ Allows data conveyed by a message to be addressed to a 
          --   particular person or department when routing to a specific 
          --   application isn't sufficient.
        , messageHeader_sender :: Maybe Reference
          -- ^ Identifies the sending system to allow the use of a trust 
          --   relationship.
        , messageHeader_timestamp :: Instant
          -- ^ The time that the message was sent.
        , messageHeader_enterer :: Maybe Reference
          -- ^ The person or device that performed the data entry leading 
          --   to this message. When there is more than one candidate, 
          --   pick the most proximal to the message. Can provide other 
          --   enterers in extensions.
        , messageHeader_author :: Maybe Reference
          -- ^ The logical author of the message - the person or device 
          --   that decided the described event should happen. When there 
          --   is more than one candidate, pick the most proximal to the 
          --   MessageHeader. Can provide other authors in extensions.
        , messageHeader_source :: MessageHeader'Source
          -- ^ The source application from which this message originated.
        , messageHeader_responsible :: Maybe Reference
          -- ^ The person or organization that accepts overall 
          --   responsibility for the contents of the message. The 
          --   implication is that the message event happened under the 
          --   policies of the responsible party.
        , messageHeader_reason :: Maybe CodeableConcept
          -- ^ Coded indication of the cause for the event - indicates a 
          --   reason for the occurrence of the event that is a focus of 
          --   this message.
        , messageHeader_response :: Maybe MessageHeader'Response
          -- ^ Information about the message that this message is a 
          --   response to. Only present if this message is a response.
        , messageHeader_focus :: [Reference]
          -- ^ The actual data of the message - a reference to the 
          --   root/focus class of the event.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeader where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MessageHeader
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "event"
            `apply` many (parseSchemaType "destination")
            `apply` optional (parseSchemaType "receiver")
            `apply` optional (parseSchemaType "sender")
            `apply` parseSchemaType "timestamp"
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "author")
            `apply` parseSchemaType "source"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "response")
            `apply` many (parseSchemaType "focus")
    schemaTypeToXML s x@MessageHeader{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ messageHeader_id x
            , maybe [] (schemaTypeToXML "meta") $ messageHeader_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ messageHeader_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ messageHeader_language x
            , maybe [] (schemaTypeToXML "text") $ messageHeader_text x
            , concatMap (schemaTypeToXML "contained") $ messageHeader_contained x
            , concatMap (schemaTypeToXML "extension") $ messageHeader_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeader_modifierExtension x
            , schemaTypeToXML "event" $ messageHeader_event x
            , concatMap (schemaTypeToXML "destination") $ messageHeader_destination x
            , maybe [] (schemaTypeToXML "receiver") $ messageHeader_receiver x
            , maybe [] (schemaTypeToXML "sender") $ messageHeader_sender x
            , schemaTypeToXML "timestamp" $ messageHeader_timestamp x
            , maybe [] (schemaTypeToXML "enterer") $ messageHeader_enterer x
            , maybe [] (schemaTypeToXML "author") $ messageHeader_author x
            , schemaTypeToXML "source" $ messageHeader_source x
            , maybe [] (schemaTypeToXML "responsible") $ messageHeader_responsible x
            , maybe [] (schemaTypeToXML "reason") $ messageHeader_reason x
            , maybe [] (schemaTypeToXML "response") $ messageHeader_response x
            , concatMap (schemaTypeToXML "focus") $ messageHeader_focus x
            ]
instance Extension MessageHeader DomainResource where
    supertype (MessageHeader e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MessageHeader Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MessageHeader -> DomainResource)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeader'Destination = MessageHeader'Destination
        { messageHeader'Destination_id :: Maybe String'primitive
        , messageHeader'Destination_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeader'Destination_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeader'Destination_name :: Maybe Xsd.XsdString
          -- ^ Human-readable name for the target system.
        , messageHeader'Destination_target :: Maybe Reference
          -- ^ Identifies the target end system in situations where the 
          --   initial message transmission is to an intermediary system.
        , messageHeader'Destination_endpoint :: Uri
          -- ^ Indicates where the message should be routed to.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeader'Destination where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeader'Destination a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "target")
            `apply` parseSchemaType "endpoint"
    schemaTypeToXML s x@MessageHeader'Destination{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeader'Destination_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeader'Destination_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeader'Destination_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ messageHeader'Destination_name x
            , maybe [] (schemaTypeToXML "target") $ messageHeader'Destination_target x
            , schemaTypeToXML "endpoint" $ messageHeader'Destination_endpoint x
            ]
instance Extension MessageHeader'Destination BackboneElement where
    supertype (MessageHeader'Destination a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MessageHeader'Destination Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeader'Destination -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeader'Source = MessageHeader'Source
        { messageHeader'Source_id :: Maybe String'primitive
        , messageHeader'Source_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeader'Source_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeader'Source_name :: Maybe Xsd.XsdString
          -- ^ Human-readable name for the source system.
        , messageHeader'Source_software :: Maybe Xsd.XsdString
          -- ^ May include configuration or other information useful in 
          --   debugging.
        , messageHeader'Source_version :: Maybe Xsd.XsdString
          -- ^ Can convey versions of multiple systems in situations where 
          --   a message passes through multiple hands.
        , messageHeader'Source_contact :: Maybe ContactPoint
          -- ^ An e-mail, phone, website or other contact point to use to 
          --   resolve issues with message communications.
        , messageHeader'Source_endpoint :: Uri
          -- ^ Identifies the routing target to send acknowledgements to.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeader'Source where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeader'Source a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "software")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "contact")
            `apply` parseSchemaType "endpoint"
    schemaTypeToXML s x@MessageHeader'Source{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeader'Source_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeader'Source_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeader'Source_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ messageHeader'Source_name x
            , maybe [] (schemaTypeToXML "software") $ messageHeader'Source_software x
            , maybe [] (schemaTypeToXML "version") $ messageHeader'Source_version x
            , maybe [] (schemaTypeToXML "contact") $ messageHeader'Source_contact x
            , schemaTypeToXML "endpoint" $ messageHeader'Source_endpoint x
            ]
instance Extension MessageHeader'Source BackboneElement where
    supertype (MessageHeader'Source a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MessageHeader'Source Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeader'Source -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeader'Response = MessageHeader'Response
        { messageHeader'Response_id :: Maybe String'primitive
        , messageHeader'Response_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeader'Response_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeader'Response_identifier :: Id
          -- ^ The MessageHeader.id of the message to which this message 
          --   is a response.
        , messageHeader'Response_code :: ResponseType
          -- ^ Code that identifies the type of response to the message - 
          --   whether it was successful or not, and whether it should be 
          --   resent or not.
        , messageHeader'Response_details :: Maybe Reference
          -- ^ Full details of any issues found in the message.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeader'Response where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeader'Response a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "details")
    schemaTypeToXML s x@MessageHeader'Response{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeader'Response_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeader'Response_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeader'Response_modifierExtension x
            , schemaTypeToXML "identifier" $ messageHeader'Response_identifier x
            , schemaTypeToXML "code" $ messageHeader'Response_code x
            , maybe [] (schemaTypeToXML "details") $ messageHeader'Response_details x
            ]
instance Extension MessageHeader'Response BackboneElement where
    supertype (MessageHeader'Response a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MessageHeader'Response Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeader'Response -> BackboneElement)
              
 
data ResponseType'list
    = ResponseType'list_Ok
      -- ^ OK
    | ResponseType'list_Transient'error
      -- ^ Transient Error
    | ResponseType'list_Fatal'error
      -- ^ Fatal Error
    deriving (Eq,Show,Enum)
instance SchemaType ResponseType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResponseType'list where
    acceptingParser =  do literal "ok"; return ResponseType'list_Ok
                      `onFail` do literal "transient-error"; return ResponseType'list_Transient'error
                      `onFail` do literal "fatal-error"; return ResponseType'list_Fatal'error
                      
    simpleTypeText ResponseType'list_Ok = "ok"
    simpleTypeText ResponseType'list_Transient'error = "transient-error"
    simpleTypeText ResponseType'list_Fatal'error = "fatal-error"
 
data ResponseType = ResponseType
        { responseType_id :: Maybe String'primitive
        , responseType_value :: Maybe ResponseType'list
        , responseType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResponseType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResponseType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResponseType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ responseType_id x
                       , maybe [] (toXMLAttribute "value") $ responseType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ responseType_extension x
            ]
instance Extension ResponseType Element where
    supertype (ResponseType a0 a1 e0) =
               Element a0 e0
 
-- | A curated namespace that issues unique symbols within that 
--   namespace for the identification of concepts, people, 
--   devices, etc. Represents a &quot;System&quot; used within 
--   the Identifier and Coding data types.
elementNamingSystem :: XMLParser NamingSystem
elementNamingSystem = parseSchemaType "NamingSystem"
elementToXMLNamingSystem :: NamingSystem -> [Content ()]
elementToXMLNamingSystem = schemaTypeToXML "NamingSystem"
 
data NamingSystem = NamingSystem
        { namingSystem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , namingSystem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , namingSystem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , namingSystem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , namingSystem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , namingSystem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , namingSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , namingSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , namingSystem_name :: Xsd.XsdString
          -- ^ A natural language name identifying the naming system. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , namingSystem_status :: PublicationStatus
          -- ^ The status of this naming system. Enables tracking the 
          --   life-cycle of the content.
        , namingSystem_kind :: NamingSystemType
          -- ^ Indicates the purpose for the naming system - what kinds of 
          --   things does it make unique?
        , namingSystem_date :: DateTime
          -- ^ The date (and optionally time) when the naming system was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the naming system changes.
        , namingSystem_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the naming system.
        , namingSystem_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , namingSystem_responsible :: Maybe Xsd.XsdString
          -- ^ The name of the organization that is responsible for 
          --   issuing identifiers or codes for this namespace and 
          --   ensuring their non-collision.
        , namingSystem_type :: Maybe CodeableConcept
          -- ^ Categorizes a naming system for easier search by grouping 
          --   related naming systems.
        , namingSystem_description :: Maybe Markdown
          -- ^ A free text natural language description of the naming 
          --   system from a consumer's perspective. Details about what 
          --   the namespace identifies including scope, granularity, 
          --   version labeling, etc.
        , namingSystem_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   naming system instances.
        , namingSystem_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the naming system is 
          --   intended to be used.
        , namingSystem_usage :: Maybe Xsd.XsdString
          -- ^ Provides guidance on the use of the namespace, including 
          --   the handling of formatting characters, use of upper vs. 
          --   lower case, etc.
        , namingSystem_uniqueId :: [NamingSystem'UniqueId]
          -- ^ Indicates how the system may be identified when referenced 
          --   in electronic exchange.
        , namingSystem_replacedBy :: Maybe Reference
          -- ^ For naming systems that are retired, indicates the naming 
          --   system that should be used in their place (if any).
        }
        deriving (Eq,Show)
instance SchemaType NamingSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return NamingSystem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "kind"
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "usage")
            `apply` many1 (parseSchemaType "uniqueId")
            `apply` optional (parseSchemaType "replacedBy")
    schemaTypeToXML s x@NamingSystem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ namingSystem_id x
            , maybe [] (schemaTypeToXML "meta") $ namingSystem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ namingSystem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ namingSystem_language x
            , maybe [] (schemaTypeToXML "text") $ namingSystem_text x
            , concatMap (schemaTypeToXML "contained") $ namingSystem_contained x
            , concatMap (schemaTypeToXML "extension") $ namingSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ namingSystem_modifierExtension x
            , schemaTypeToXML "name" $ namingSystem_name x
            , schemaTypeToXML "status" $ namingSystem_status x
            , schemaTypeToXML "kind" $ namingSystem_kind x
            , schemaTypeToXML "date" $ namingSystem_date x
            , maybe [] (schemaTypeToXML "publisher") $ namingSystem_publisher x
            , concatMap (schemaTypeToXML "contact") $ namingSystem_contact x
            , maybe [] (schemaTypeToXML "responsible") $ namingSystem_responsible x
            , maybe [] (schemaTypeToXML "type") $ namingSystem_type x
            , maybe [] (schemaTypeToXML "description") $ namingSystem_description x
            , concatMap (schemaTypeToXML "useContext") $ namingSystem_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ namingSystem_jurisdiction x
            , maybe [] (schemaTypeToXML "usage") $ namingSystem_usage x
            , concatMap (schemaTypeToXML "uniqueId") $ namingSystem_uniqueId x
            , maybe [] (schemaTypeToXML "replacedBy") $ namingSystem_replacedBy x
            ]
instance Extension NamingSystem DomainResource where
    supertype (NamingSystem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension NamingSystem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: NamingSystem -> DomainResource)
              
 
-- | A curated namespace that issues unique symbols within that 
--   namespace for the identification of concepts, people, 
--   devices, etc. Represents a &quot;System&quot; used within 
--   the Identifier and Coding data types.
data NamingSystem'UniqueId = NamingSystem'UniqueId
        { namingSystem'UniqueId_id :: Maybe String'primitive
        , namingSystem'UniqueId_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , namingSystem'UniqueId_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , namingSystem'UniqueId_type :: NamingSystemIdentifierType
          -- ^ Identifies the unique identifier scheme used for this 
          --   particular identifier.
        , namingSystem'UniqueId_value :: Xsd.XsdString
          -- ^ The string that should be sent over the wire to identify 
          --   the code system or identifier system.
        , namingSystem'UniqueId_preferred :: Maybe Boolean
          -- ^ Indicates whether this identifier is the 
          --   &quot;preferred&quot; identifier of this type.
        , namingSystem'UniqueId_comment :: Maybe Xsd.XsdString
          -- ^ Notes about the past or intended usage of this identifier.
        , namingSystem'UniqueId_period :: Maybe Period
          -- ^ Identifies the period of time over which this identifier is 
          --   considered appropriate to refer to the naming system. 
          --   Outside of this window, the identifier might be 
          --   non-deterministic.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystem'UniqueId where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NamingSystem'UniqueId a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "value"
            `apply` optional (parseSchemaType "preferred")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@NamingSystem'UniqueId{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystem'UniqueId_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystem'UniqueId_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ namingSystem'UniqueId_modifierExtension x
            , schemaTypeToXML "type" $ namingSystem'UniqueId_type x
            , schemaTypeToXML "value" $ namingSystem'UniqueId_value x
            , maybe [] (schemaTypeToXML "preferred") $ namingSystem'UniqueId_preferred x
            , maybe [] (schemaTypeToXML "comment") $ namingSystem'UniqueId_comment x
            , maybe [] (schemaTypeToXML "period") $ namingSystem'UniqueId_period x
            ]
instance Extension NamingSystem'UniqueId BackboneElement where
    supertype (NamingSystem'UniqueId a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension NamingSystem'UniqueId Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NamingSystem'UniqueId -> BackboneElement)
              
 
data NamingSystemIdentifierType'list
    = NamingSystemIdentifierType'list_Oid
      -- ^ OID
    | NamingSystemIdentifierType'list_Uuid
      -- ^ UUID
    | NamingSystemIdentifierType'list_Uri
      -- ^ URI
    | NamingSystemIdentifierType'list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType NamingSystemIdentifierType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NamingSystemIdentifierType'list where
    acceptingParser =  do literal "oid"; return NamingSystemIdentifierType'list_Oid
                      `onFail` do literal "uuid"; return NamingSystemIdentifierType'list_Uuid
                      `onFail` do literal "uri"; return NamingSystemIdentifierType'list_Uri
                      `onFail` do literal "other"; return NamingSystemIdentifierType'list_Other
                      
    simpleTypeText NamingSystemIdentifierType'list_Oid = "oid"
    simpleTypeText NamingSystemIdentifierType'list_Uuid = "uuid"
    simpleTypeText NamingSystemIdentifierType'list_Uri = "uri"
    simpleTypeText NamingSystemIdentifierType'list_Other = "other"
 
data NamingSystemIdentifierType = NamingSystemIdentifierType
        { namingSystemIdentifierType_id :: Maybe String'primitive
        , namingSystemIdentifierType_value :: Maybe NamingSystemIdentifierType'list
        , namingSystemIdentifierType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystemIdentifierType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NamingSystemIdentifierType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NamingSystemIdentifierType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystemIdentifierType_id x
                       , maybe [] (toXMLAttribute "value") $ namingSystemIdentifierType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystemIdentifierType_extension x
            ]
instance Extension NamingSystemIdentifierType Element where
    supertype (NamingSystemIdentifierType a0 a1 e0) =
               Element a0 e0
 
data NamingSystemType'list
    = NamingSystemType'list_Codesystem
      -- ^ Code System
    | NamingSystemType'list_Identifier
      -- ^ Identifier
    | NamingSystemType'list_Root
      -- ^ Root
    deriving (Eq,Show,Enum)
instance SchemaType NamingSystemType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NamingSystemType'list where
    acceptingParser =  do literal "codesystem"; return NamingSystemType'list_Codesystem
                      `onFail` do literal "identifier"; return NamingSystemType'list_Identifier
                      `onFail` do literal "root"; return NamingSystemType'list_Root
                      
    simpleTypeText NamingSystemType'list_Codesystem = "codesystem"
    simpleTypeText NamingSystemType'list_Identifier = "identifier"
    simpleTypeText NamingSystemType'list_Root = "root"
 
data NamingSystemType = NamingSystemType
        { namingSystemType_id :: Maybe String'primitive
        , namingSystemType_value :: Maybe NamingSystemType'list
        , namingSystemType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystemType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NamingSystemType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NamingSystemType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystemType_id x
                       , maybe [] (toXMLAttribute "value") $ namingSystemType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystemType_extension x
            ]
instance Extension NamingSystemType Element where
    supertype (NamingSystemType a0 a1 e0) =
               Element a0 e0
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
elementNutritionOrder :: XMLParser NutritionOrder
elementNutritionOrder = parseSchemaType "NutritionOrder"
elementToXMLNutritionOrder :: NutritionOrder -> [Content ()]
elementToXMLNutritionOrder = schemaTypeToXML "NutritionOrder"
 
data NutritionOrder = NutritionOrder
        { nutritionOrder_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , nutritionOrder_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , nutritionOrder_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , nutritionOrder_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , nutritionOrder_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , nutritionOrder_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , nutritionOrder_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order by the order sender or 
          --   by the order receiver.
        , nutritionOrder_status :: Maybe NutritionOrderStatus
          -- ^ The workflow status of the nutrition order/request.
        , nutritionOrder_patient :: Reference
          -- ^ The person (patient) who needs the nutrition order for an 
          --   oral diet, nutritional supplement and/or enteral or formula 
          --   feeding.
        , nutritionOrder_encounter :: Maybe Reference
          -- ^ An encounter that provides additional information about the 
          --   healthcare context in which this request is made.
        , nutritionOrder_dateTime :: DateTime
          -- ^ The date and time that this nutrition order was requested.
        , nutritionOrder_orderer :: Maybe Reference
          -- ^ The practitioner that holds legal responsibility for 
          --   ordering the diet, nutritional supplement, or formula 
          --   feedings.
        , nutritionOrder_allergyIntolerance :: [Reference]
          -- ^ A link to a record of allergies or intolerances which 
          --   should be included in the nutrition order.
        , nutritionOrder_foodPreferenceModifier :: [CodeableConcept]
          -- ^ This modifier is used to convey order-specific modifiers 
          --   about the type of food that should be given. These can be 
          --   derived from patient allergies, intolerances, or 
          --   preferences such as Halal, Vegan or Kosher. This modifier 
          --   applies to the entire nutrition order inclusive of the oral 
          --   diet, nutritional supplements and enteral formula feedings.
        , nutritionOrder_excludeFoodModifier :: [CodeableConcept]
          -- ^ This modifier is used to convey order-specific modifiers 
          --   about the type of food that should NOT be given. These can 
          --   be derived from patient allergies, intolerances, or 
          --   preferences such as No Red Meat, No Soy or No Wheat or 
          --   Gluten-Free. While it should not be necessary to repeat 
          --   allergy or intolerance information captured in the 
          --   referenced AllergyIntolerance resource in the 
          --   excludeFoodModifier, this element may be used to convey 
          --   additional specificity related to foods that should be 
          --   eliminated from the patientâ€™s diet for any reason. This 
          --   modifier applies to the entire nutrition order inclusive of 
          --   the oral diet, nutritional supplements and enteral formula 
          --   feedings.
        , nutritionOrder_oralDiet :: Maybe NutritionOrder'OralDiet
          -- ^ Diet given orally in contrast to enteral (tube) feeding.
        , nutritionOrder_supplement :: [NutritionOrder'Supplement]
          -- ^ Oral nutritional products given in order to add further 
          --   nutritional value to the patient's diet.
        , nutritionOrder_enteralFormula :: Maybe NutritionOrder'EnteralFormula
          -- ^ Feeding provided through the gastrointestinal tract via a 
          --   tube, catheter, or stoma that delivers nutrition distal to 
          --   the oral cavity.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return NutritionOrder
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "encounter")
            `apply` parseSchemaType "dateTime"
            `apply` optional (parseSchemaType "orderer")
            `apply` many (parseSchemaType "allergyIntolerance")
            `apply` many (parseSchemaType "foodPreferenceModifier")
            `apply` many (parseSchemaType "excludeFoodModifier")
            `apply` optional (parseSchemaType "oralDiet")
            `apply` many (parseSchemaType "supplement")
            `apply` optional (parseSchemaType "enteralFormula")
    schemaTypeToXML s x@NutritionOrder{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ nutritionOrder_id x
            , maybe [] (schemaTypeToXML "meta") $ nutritionOrder_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ nutritionOrder_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ nutritionOrder_language x
            , maybe [] (schemaTypeToXML "text") $ nutritionOrder_text x
            , concatMap (schemaTypeToXML "contained") $ nutritionOrder_contained x
            , concatMap (schemaTypeToXML "extension") $ nutritionOrder_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ nutritionOrder_identifier x
            , maybe [] (schemaTypeToXML "status") $ nutritionOrder_status x
            , schemaTypeToXML "patient" $ nutritionOrder_patient x
            , maybe [] (schemaTypeToXML "encounter") $ nutritionOrder_encounter x
            , schemaTypeToXML "dateTime" $ nutritionOrder_dateTime x
            , maybe [] (schemaTypeToXML "orderer") $ nutritionOrder_orderer x
            , concatMap (schemaTypeToXML "allergyIntolerance") $ nutritionOrder_allergyIntolerance x
            , concatMap (schemaTypeToXML "foodPreferenceModifier") $ nutritionOrder_foodPreferenceModifier x
            , concatMap (schemaTypeToXML "excludeFoodModifier") $ nutritionOrder_excludeFoodModifier x
            , maybe [] (schemaTypeToXML "oralDiet") $ nutritionOrder_oralDiet x
            , concatMap (schemaTypeToXML "supplement") $ nutritionOrder_supplement x
            , maybe [] (schemaTypeToXML "enteralFormula") $ nutritionOrder_enteralFormula x
            ]
instance Extension NutritionOrder DomainResource where
    supertype (NutritionOrder e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension NutritionOrder Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: NutritionOrder -> DomainResource)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'OralDiet = NutritionOrder'OralDiet
        { nutritionOrder'OralDiet_id :: Maybe String'primitive
        , nutritionOrder'OralDiet_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'OralDiet_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'OralDiet_type :: [CodeableConcept]
          -- ^ The kind of diet or dietary restriction such as fiber 
          --   restricted diet or diabetic diet.
        , nutritionOrder'OralDiet_schedule :: [Timing]
          -- ^ The time period and frequency at which the diet should be 
          --   given. The diet should be given for the combination of all 
          --   schedules if more than one schedule is present.
        , nutritionOrder'OralDiet_nutrient :: [NutritionOrder'Nutrient]
          -- ^ Class that defines the quantity and type of nutrient 
          --   modifications (for example carbohydrate, fiber or sodium) 
          --   required for the oral diet.
        , nutritionOrder'OralDiet_texture :: [NutritionOrder'Texture]
          -- ^ Class that describes any texture modifications required for 
          --   the patient to safely consume various types of solid foods.
        , nutritionOrder'OralDiet_fluidConsistencyType :: [CodeableConcept]
          -- ^ The required consistency (e.g. honey-thick, nectar-thick, 
          --   thin, thickened.) of liquids or fluids served to the 
          --   patient.
        , nutritionOrder'OralDiet_instruction :: Maybe Xsd.XsdString
          -- ^ Free text or additional instructions or information 
          --   pertaining to the oral diet.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'OralDiet where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'OralDiet a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "schedule")
            `apply` many (parseSchemaType "nutrient")
            `apply` many (parseSchemaType "texture")
            `apply` many (parseSchemaType "fluidConsistencyType")
            `apply` optional (parseSchemaType "instruction")
    schemaTypeToXML s x@NutritionOrder'OralDiet{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'OralDiet_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'OralDiet_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'OralDiet_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ nutritionOrder'OralDiet_type x
            , concatMap (schemaTypeToXML "schedule") $ nutritionOrder'OralDiet_schedule x
            , concatMap (schemaTypeToXML "nutrient") $ nutritionOrder'OralDiet_nutrient x
            , concatMap (schemaTypeToXML "texture") $ nutritionOrder'OralDiet_texture x
            , concatMap (schemaTypeToXML "fluidConsistencyType") $ nutritionOrder'OralDiet_fluidConsistencyType x
            , maybe [] (schemaTypeToXML "instruction") $ nutritionOrder'OralDiet_instruction x
            ]
instance Extension NutritionOrder'OralDiet BackboneElement where
    supertype (NutritionOrder'OralDiet a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'OralDiet Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'OralDiet -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'Nutrient = NutritionOrder'Nutrient
        { nutritionOrder'Nutrient_id :: Maybe String'primitive
        , nutritionOrder'Nutrient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'Nutrient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'Nutrient_modifier :: Maybe CodeableConcept
          -- ^ The nutrient that is being modified such as carbohydrate or 
          --   sodium.
        , nutritionOrder'Nutrient_amount :: Maybe Quantity
          -- ^ The quantity of the specified nutrient to include in diet.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'Nutrient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'Nutrient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@NutritionOrder'Nutrient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'Nutrient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'Nutrient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'Nutrient_modifierExtension x
            , maybe [] (schemaTypeToXML "modifier") $ nutritionOrder'Nutrient_modifier x
            , maybe [] (schemaTypeToXML "amount") $ nutritionOrder'Nutrient_amount x
            ]
instance Extension NutritionOrder'Nutrient BackboneElement where
    supertype (NutritionOrder'Nutrient a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'Nutrient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'Nutrient -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'Texture = NutritionOrder'Texture
        { nutritionOrder'Texture_id :: Maybe String'primitive
        , nutritionOrder'Texture_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'Texture_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'Texture_modifier :: Maybe CodeableConcept
          -- ^ Any texture modifications (for solid foods) that should be 
          --   made, e.g. easy to chew, chopped, ground, and pureed.
        , nutritionOrder'Texture_foodType :: Maybe CodeableConcept
          -- ^ The food type(s) (e.g. meats, all foods) that the texture 
          --   modification applies to. This could be all foods types.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'Texture where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'Texture a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "foodType")
    schemaTypeToXML s x@NutritionOrder'Texture{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'Texture_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'Texture_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'Texture_modifierExtension x
            , maybe [] (schemaTypeToXML "modifier") $ nutritionOrder'Texture_modifier x
            , maybe [] (schemaTypeToXML "foodType") $ nutritionOrder'Texture_foodType x
            ]
instance Extension NutritionOrder'Texture BackboneElement where
    supertype (NutritionOrder'Texture a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'Texture Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'Texture -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'Supplement = NutritionOrder'Supplement
        { nutritionOrder'Supplement_id :: Maybe String'primitive
        , nutritionOrder'Supplement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'Supplement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'Supplement_type :: Maybe CodeableConcept
          -- ^ The kind of nutritional supplement product required such as 
          --   a high protein or pediatric clear liquid supplement.
        , nutritionOrder'Supplement_productName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the nutritional supplement 
          --   such as &quot;Acme Protein Shake&quot;.
        , nutritionOrder'Supplement_schedule :: [Timing]
          -- ^ The time period and frequency at which the supplement(s) 
          --   should be given. The supplement should be given for the 
          --   combination of all schedules if more than one schedule is 
          --   present.
        , nutritionOrder'Supplement_quantity :: Maybe Quantity
          -- ^ The amount of the nutritional supplement to be given.
        , nutritionOrder'Supplement_instruction :: Maybe Xsd.XsdString
          -- ^ Free text or additional instructions or information 
          --   pertaining to the oral supplement.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'Supplement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'Supplement a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "productName")
            `apply` many (parseSchemaType "schedule")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "instruction")
    schemaTypeToXML s x@NutritionOrder'Supplement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'Supplement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'Supplement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'Supplement_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ nutritionOrder'Supplement_type x
            , maybe [] (schemaTypeToXML "productName") $ nutritionOrder'Supplement_productName x
            , concatMap (schemaTypeToXML "schedule") $ nutritionOrder'Supplement_schedule x
            , maybe [] (schemaTypeToXML "quantity") $ nutritionOrder'Supplement_quantity x
            , maybe [] (schemaTypeToXML "instruction") $ nutritionOrder'Supplement_instruction x
            ]
instance Extension NutritionOrder'Supplement BackboneElement where
    supertype (NutritionOrder'Supplement a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'Supplement Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'Supplement -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'EnteralFormula = NutritionOrder'EnteralFormula
        { nutritionOrder'EnteralFormula_id :: Maybe String'primitive
        , nutritionOrder'EnteralFormula_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'EnteralFormula_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'EnteralFormula_baseFormulaType :: Maybe CodeableConcept
          -- ^ The type of enteral or infant formula such as an adult 
          --   standard formula with fiber or a soy-based infant formula.
        , nutritionOrder'EnteralFormula_baseFormulaProductName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the enteral or infant formula 
          --   product such as &quot;ACME Adult Standard Formula&quot;.
        , nutritionOrder'EnteralFormula_additiveType :: Maybe CodeableConcept
          -- ^ Indicates the type of modular component such as protein, 
          --   carbohydrate, fat or fiber to be provided in addition to or 
          --   mixed with the base formula.
        , nutritionOrder'EnteralFormula_additiveProductName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the type of modular component 
          --   to be added to the formula.
        , nutritionOrder'EnteralFormula_caloricDensity :: Maybe Quantity
          -- ^ The amount of energy (calories) that the formula should 
          --   provide per specified volume, typically per mL or fluid oz. 
          --   For example, an infant may require a formula that provides 
          --   24 calories per fluid ounce or an adult may require an 
          --   enteral formula that provides 1.5 calorie/mL.
        , nutritionOrder'EnteralFormula_routeofAdministration :: Maybe CodeableConcept
          -- ^ The route or physiological path of administration into the 
          --   patient's gastrointestinal tract for purposes of providing 
          --   the formula feeding, e.g. nasogastric tube.
        , nutritionOrder'EnteralFormula_administration :: [NutritionOrder'Administration]
          -- ^ Formula administration instructions as structured data. 
          --   This repeating structure allows for changing the 
          --   administration rate or volume over time for both bolus and 
          --   continuous feeding. An example of this would be an 
          --   instruction to increase the rate of continuous feeding 
          --   every 2 hours.
        , nutritionOrder'EnteralFormula_maxVolumeToDeliver :: Maybe Quantity
          -- ^ The maximum total quantity of formula that may be 
          --   administered to a subject over the period of time, e.g. 
          --   1440 mL over 24 hours.
        , nutritionOrder'EnteralFormula_administrationInstruction :: Maybe Xsd.XsdString
          -- ^ Free text formula administration, feeding instructions or 
          --   additional instructions or information.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'EnteralFormula where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'EnteralFormula a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "baseFormulaType")
            `apply` optional (parseSchemaType "baseFormulaProductName")
            `apply` optional (parseSchemaType "additiveType")
            `apply` optional (parseSchemaType "additiveProductName")
            `apply` optional (parseSchemaType "caloricDensity")
            `apply` optional (parseSchemaType "routeofAdministration")
            `apply` many (parseSchemaType "administration")
            `apply` optional (parseSchemaType "maxVolumeToDeliver")
            `apply` optional (parseSchemaType "administrationInstruction")
    schemaTypeToXML s x@NutritionOrder'EnteralFormula{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'EnteralFormula_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'EnteralFormula_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'EnteralFormula_modifierExtension x
            , maybe [] (schemaTypeToXML "baseFormulaType") $ nutritionOrder'EnteralFormula_baseFormulaType x
            , maybe [] (schemaTypeToXML "baseFormulaProductName") $ nutritionOrder'EnteralFormula_baseFormulaProductName x
            , maybe [] (schemaTypeToXML "additiveType") $ nutritionOrder'EnteralFormula_additiveType x
            , maybe [] (schemaTypeToXML "additiveProductName") $ nutritionOrder'EnteralFormula_additiveProductName x
            , maybe [] (schemaTypeToXML "caloricDensity") $ nutritionOrder'EnteralFormula_caloricDensity x
            , maybe [] (schemaTypeToXML "routeofAdministration") $ nutritionOrder'EnteralFormula_routeofAdministration x
            , concatMap (schemaTypeToXML "administration") $ nutritionOrder'EnteralFormula_administration x
            , maybe [] (schemaTypeToXML "maxVolumeToDeliver") $ nutritionOrder'EnteralFormula_maxVolumeToDeliver x
            , maybe [] (schemaTypeToXML "administrationInstruction") $ nutritionOrder'EnteralFormula_administrationInstruction x
            ]
instance Extension NutritionOrder'EnteralFormula BackboneElement where
    supertype (NutritionOrder'EnteralFormula a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'EnteralFormula Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'EnteralFormula -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrder'Administration = NutritionOrder'Administration
        { nutritionOrder'Administration_id :: Maybe String'primitive
        , nutritionOrder'Administration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder'Administration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder'Administration_schedule :: Maybe Timing
          -- ^ The time period and frequency at which the enteral formula 
          --   should be delivered to the patient.
        , nutritionOrder'Administration_quantity :: Maybe Quantity
          -- ^ The volume of formula to provide to the patient per the 
          --   specified administration schedule.
        , nutritionOrder'Administration_choice4 :: (Maybe (OneOf2 Quantity Ratio))
          -- ^ The rate of administration of formula via a feeding pump, 
          --   e.g. 60 mL per hour, according to the specified schedule.
          --   
          --   Choice between:
          --   
          --   (1) rateQuantity
          --   
          --   (2) rateRatio
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder'Administration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrder'Administration a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "schedule")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf2 (parseSchemaType "rateQuantity"))
                                     , ("Ratio", fmap TwoOf2 (parseSchemaType "rateRatio"))
                                     ])
    schemaTypeToXML s x@NutritionOrder'Administration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrder'Administration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrder'Administration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder'Administration_modifierExtension x
            , maybe [] (schemaTypeToXML "schedule") $ nutritionOrder'Administration_schedule x
            , maybe [] (schemaTypeToXML "quantity") $ nutritionOrder'Administration_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "rateQuantity")
                                    (schemaTypeToXML "rateRatio")
                                   ) $ nutritionOrder'Administration_choice4 x
            ]
instance Extension NutritionOrder'Administration BackboneElement where
    supertype (NutritionOrder'Administration a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrder'Administration Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrder'Administration -> BackboneElement)
              
 
data NutritionOrderStatus'list
    = NutritionOrderStatus'list_Proposed
      -- ^ Proposed
    | NutritionOrderStatus'list_Draft
      -- ^ Draft
    | NutritionOrderStatus'list_Planned
      -- ^ Planned
    | NutritionOrderStatus'list_Requested
      -- ^ Requested
    | NutritionOrderStatus'list_Active
      -- ^ Active
    | NutritionOrderStatus'list_On'hold
      -- ^ On-Hold
    | NutritionOrderStatus'list_Completed
      -- ^ Completed
    | NutritionOrderStatus'list_Cancelled
      -- ^ Cancelled
    | NutritionOrderStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType NutritionOrderStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NutritionOrderStatus'list where
    acceptingParser =  do literal "proposed"; return NutritionOrderStatus'list_Proposed
                      `onFail` do literal "draft"; return NutritionOrderStatus'list_Draft
                      `onFail` do literal "planned"; return NutritionOrderStatus'list_Planned
                      `onFail` do literal "requested"; return NutritionOrderStatus'list_Requested
                      `onFail` do literal "active"; return NutritionOrderStatus'list_Active
                      `onFail` do literal "on-hold"; return NutritionOrderStatus'list_On'hold
                      `onFail` do literal "completed"; return NutritionOrderStatus'list_Completed
                      `onFail` do literal "cancelled"; return NutritionOrderStatus'list_Cancelled
                      `onFail` do literal "entered-in-error"; return NutritionOrderStatus'list_Entered'in'error
                      
    simpleTypeText NutritionOrderStatus'list_Proposed = "proposed"
    simpleTypeText NutritionOrderStatus'list_Draft = "draft"
    simpleTypeText NutritionOrderStatus'list_Planned = "planned"
    simpleTypeText NutritionOrderStatus'list_Requested = "requested"
    simpleTypeText NutritionOrderStatus'list_Active = "active"
    simpleTypeText NutritionOrderStatus'list_On'hold = "on-hold"
    simpleTypeText NutritionOrderStatus'list_Completed = "completed"
    simpleTypeText NutritionOrderStatus'list_Cancelled = "cancelled"
    simpleTypeText NutritionOrderStatus'list_Entered'in'error = "entered-in-error"
 
data NutritionOrderStatus = NutritionOrderStatus
        { nutritionOrderStatus_id :: Maybe String'primitive
        , nutritionOrderStatus_value :: Maybe NutritionOrderStatus'list
        , nutritionOrderStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NutritionOrderStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NutritionOrderStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderStatus_id x
                       , maybe [] (toXMLAttribute "value") $ nutritionOrderStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderStatus_extension x
            ]
instance Extension NutritionOrderStatus Element where
    supertype (NutritionOrderStatus a0 a1 e0) =
               Element a0 e0
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
elementObservation :: XMLParser Observation
elementObservation = parseSchemaType "Observation"
elementToXMLObservation :: Observation -> [Content ()]
elementToXMLObservation = schemaTypeToXML "Observation"
 
data Observation = Observation
        { observation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , observation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , observation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , observation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , observation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , observation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , observation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observation_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this observation.
        , observation_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , observation_status :: ObservationStatus
          -- ^ The status of the result value.
        , observation_category :: [CodeableConcept]
          -- ^ A code that classifies the general type of observation 
          --   being made.
        , observation_code :: CodeableConcept
          -- ^ Describes what was observed. Sometimes this is called the 
          --   observation &quot;name&quot;.
        , observation_subject :: Maybe Reference
          -- ^ The patient, or group of patients, location, or device 
          --   whose characteristics (direct or indirect) are described by 
          --   the observation and into whose record the observation is 
          --   placed. Comments: Indirect characteristics may be those of 
          --   a specimen, fetus, donor, other observer (for example a 
          --   relative or EMT), or any observation made about the 
          --   subject.
        , observation_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) during which this observation is 
          --   made.
        , observation_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time or time-period the observed value is asserted as 
          --   being true. For biological subjects - e.g. human patients - 
          --   this is usually called the &quot;physiologically relevant 
          --   time&quot;. This is usually either the time of the 
          --   procedure or of specimen collection, but very often the 
          --   source of the date/time is not known, only the date/time 
          --   itself.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , observation_issued :: Maybe Instant
          -- ^ The date and time this observation was made available to 
          --   providers, typically after the results have been reviewed 
          --   and verified.
        , observation_performer :: [Reference]
          -- ^ Who was responsible for asserting the observed value as 
          --   &quot;true&quot;.
        , observation_choice18 :: (Maybe (OneOf11 Quantity CodeableConcept Xsd.XsdString Boolean Range Ratio SampledData Attachment Time DateTime Period))
          -- ^ The information determined as a result of making the 
          --   observation, if the information has a simple value.
          --   
          --   Choice between:
          --   
          --   (1) valueQuantity
          --   
          --   (2) valueCodeableConcept
          --   
          --   (3) valueString
          --   
          --   (4) valueBoolean
          --   
          --   (5) valueRange
          --   
          --   (6) valueRatio
          --   
          --   (7) valueSampledData
          --   
          --   (8) valueAttachment
          --   
          --   (9) valueTime
          --   
          --   (10) valueDateTime
          --   
          --   (11) valuePeriod
        , observation_dataAbsentReason :: Maybe CodeableConcept
          -- ^ Provides a reason why the expected value in the element 
          --   Observation.value[x] is missing.
        , observation_interpretation :: Maybe CodeableConcept
          -- ^ The assessment made based on the result of the observation. 
          --   Intended as a simple compact code often placed adjacent to 
          --   the result value in reports and flow sheets to signal the 
          --   meaning/normalcy status of the result. Otherwise known as 
          --   abnormal flag.
        , observation_comment :: Maybe Xsd.XsdString
          -- ^ May include statements about significant, unexpected or 
          --   unreliable values, or information about the source of the 
          --   value where this may be relevant to the interpretation of 
          --   the result.
        , observation_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the 
          --   observation was made (i.e. the target site).
        , observation_method :: Maybe CodeableConcept
          -- ^ Indicates the mechanism used to perform the observation.
        , observation_specimen :: Maybe Reference
          -- ^ The specimen that was used when this observation was made.
        , observation_device :: Maybe Reference
          -- ^ The device used to generate the observation data.
        , observation_referenceRange :: [Observation'ReferenceRange]
          -- ^ Guidance on how to interpret the value by comparison to a 
          --   normal or recommended range.
        , observation_related :: [Observation'Related]
          -- ^ A reference to another resource (usually another 
          --   Observation) whose relationship is defined by the 
          --   relationship type code.
        , observation_component :: [Observation'Component]
          -- ^ Some observations have multiple component observations. 
          --   These component observations are expressed as separate code 
          --   value pairs that share the same attributes. Examples 
          --   include systolic and diastolic component observations for 
          --   blood pressure measurement and multiple component 
          --   observations for genetics observations.
        }
        deriving (Eq,Show)
instance SchemaType Observation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Observation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf11 (parseSchemaType "valueQuantity"))
                                     , ("CodeableConcept", fmap TwoOf11 (parseSchemaType "valueCodeableConcept"))
                                     , ("Xsd.XsdString", fmap ThreeOf11 (parseSchemaType "valueString"))
                                     , ("Boolean", fmap FourOf11 (parseSchemaType "valueBoolean"))
                                     , ("Range", fmap FiveOf11 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap SixOf11 (parseSchemaType "valueRatio"))
                                     , ("SampledData", fmap SevenOf11 (parseSchemaType "valueSampledData"))
                                     , ("Attachment", fmap EightOf11 (parseSchemaType "valueAttachment"))
                                     , ("Time", fmap NineOf11 (parseSchemaType "valueTime"))
                                     , ("DateTime", fmap TenOf11 (parseSchemaType "valueDateTime"))
                                     , ("Period", fmap ElevenOf11 (parseSchemaType "valuePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dataAbsentReason")
            `apply` optional (parseSchemaType "interpretation")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "specimen")
            `apply` optional (parseSchemaType "device")
            `apply` many (parseSchemaType "referenceRange")
            `apply` many (parseSchemaType "related")
            `apply` many (parseSchemaType "component")
    schemaTypeToXML s x@Observation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ observation_id x
            , maybe [] (schemaTypeToXML "meta") $ observation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ observation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ observation_language x
            , maybe [] (schemaTypeToXML "text") $ observation_text x
            , concatMap (schemaTypeToXML "contained") $ observation_contained x
            , concatMap (schemaTypeToXML "extension") $ observation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ observation_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ observation_basedOn x
            , schemaTypeToXML "status" $ observation_status x
            , concatMap (schemaTypeToXML "category") $ observation_category x
            , schemaTypeToXML "code" $ observation_code x
            , maybe [] (schemaTypeToXML "subject") $ observation_subject x
            , maybe [] (schemaTypeToXML "context") $ observation_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ observation_choice15 x
            , maybe [] (schemaTypeToXML "issued") $ observation_issued x
            , concatMap (schemaTypeToXML "performer") $ observation_performer x
            , maybe [] (foldOneOf11  (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valuePeriod")
                                    ) $ observation_choice18 x
            , maybe [] (schemaTypeToXML "dataAbsentReason") $ observation_dataAbsentReason x
            , maybe [] (schemaTypeToXML "interpretation") $ observation_interpretation x
            , maybe [] (schemaTypeToXML "comment") $ observation_comment x
            , maybe [] (schemaTypeToXML "bodySite") $ observation_bodySite x
            , maybe [] (schemaTypeToXML "method") $ observation_method x
            , maybe [] (schemaTypeToXML "specimen") $ observation_specimen x
            , maybe [] (schemaTypeToXML "device") $ observation_device x
            , concatMap (schemaTypeToXML "referenceRange") $ observation_referenceRange x
            , concatMap (schemaTypeToXML "related") $ observation_related x
            , concatMap (schemaTypeToXML "component") $ observation_component x
            ]
instance Extension Observation DomainResource where
    supertype (Observation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Observation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Observation -> DomainResource)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data Observation'ReferenceRange = Observation'ReferenceRange
        { observation'ReferenceRange_id :: Maybe String'primitive
        , observation'ReferenceRange_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observation'ReferenceRange_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observation'ReferenceRange_low :: Maybe Quantity
          -- ^ The value of the low bound of the reference range. The low 
          --   bound of the reference range endpoint is inclusive of the 
          --   value (e.g. reference range is &gt;=5 - &lt;=9). If the low 
          --   bound is omitted, it is assumed to be meaningless (e.g. 
          --   reference range is &lt;=2.3).
        , observation'ReferenceRange_high :: Maybe Quantity
          -- ^ The value of the high bound of the reference range. The 
          --   high bound of the reference range endpoint is inclusive of 
          --   the value (e.g. reference range is &gt;=5 - &lt;=9). If the 
          --   high bound is omitted, it is assumed to be meaningless 
          --   (e.g. reference range is &gt;= 2.3).
        , observation'ReferenceRange_type :: Maybe CodeableConcept
          -- ^ Codes to indicate the what part of the targeted reference 
          --   population it applies to. For example, the normal or 
          --   therapeutic range.
        , observation'ReferenceRange_appliesTo :: [CodeableConcept]
          -- ^ Codes to indicate the target population this reference 
          --   range applies to. For example, a reference range may be 
          --   based on the normal population or a particular sex or race.
        , observation'ReferenceRange_age :: Maybe Range
          -- ^ The age at which this reference range is applicable. This 
          --   is a neonatal age (e.g. number of weeks at term) if the 
          --   meaning says so.
        , observation'ReferenceRange_text :: Maybe Xsd.XsdString
          -- ^ Text based reference range in an observation which may be 
          --   used when a quantitative range is not appropriate for an 
          --   observation. An example would be a reference value of 
          --   &quot;Negative&quot; or a list or table of 'normals'.
        }
        deriving (Eq,Show)
instance SchemaType Observation'ReferenceRange where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Observation'ReferenceRange a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "low")
            `apply` optional (parseSchemaType "high")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "appliesTo")
            `apply` optional (parseSchemaType "age")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@Observation'ReferenceRange{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observation'ReferenceRange_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observation'ReferenceRange_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observation'ReferenceRange_modifierExtension x
            , maybe [] (schemaTypeToXML "low") $ observation'ReferenceRange_low x
            , maybe [] (schemaTypeToXML "high") $ observation'ReferenceRange_high x
            , maybe [] (schemaTypeToXML "type") $ observation'ReferenceRange_type x
            , concatMap (schemaTypeToXML "appliesTo") $ observation'ReferenceRange_appliesTo x
            , maybe [] (schemaTypeToXML "age") $ observation'ReferenceRange_age x
            , maybe [] (schemaTypeToXML "text") $ observation'ReferenceRange_text x
            ]
instance Extension Observation'ReferenceRange BackboneElement where
    supertype (Observation'ReferenceRange a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Observation'ReferenceRange Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Observation'ReferenceRange -> BackboneElement)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data Observation'Related = Observation'Related
        { observation'Related_id :: Maybe String'primitive
        , observation'Related_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observation'Related_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observation'Related_type :: Maybe ObservationRelationshipType
          -- ^ A code specifying the kind of relationship that exists with 
          --   the target resource.
        , observation'Related_target :: Reference
          -- ^ A reference to the observation or 
          --   [[[QuestionnaireResponse]]] resource that is related to 
          --   this observation.
        }
        deriving (Eq,Show)
instance SchemaType Observation'Related where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Observation'Related a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "target"
    schemaTypeToXML s x@Observation'Related{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observation'Related_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observation'Related_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observation'Related_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ observation'Related_type x
            , schemaTypeToXML "target" $ observation'Related_target x
            ]
instance Extension Observation'Related BackboneElement where
    supertype (Observation'Related a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Observation'Related Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Observation'Related -> BackboneElement)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data Observation'Component = Observation'Component
        { observation'Component_id :: Maybe String'primitive
        , observation'Component_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observation'Component_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observation'Component_code :: CodeableConcept
          -- ^ Describes what was observed. Sometimes this is called the 
          --   observation &quot;code&quot;.
        , observation'Component_choice3 :: (Maybe (OneOf10 Quantity CodeableConcept Xsd.XsdString Range Ratio SampledData Attachment Time DateTime Period))
          -- ^ The information determined as a result of making the 
          --   observation, if the information has a simple value.
          --   
          --   Choice between:
          --   
          --   (1) valueQuantity
          --   
          --   (2) valueCodeableConcept
          --   
          --   (3) valueString
          --   
          --   (4) valueRange
          --   
          --   (5) valueRatio
          --   
          --   (6) valueSampledData
          --   
          --   (7) valueAttachment
          --   
          --   (8) valueTime
          --   
          --   (9) valueDateTime
          --   
          --   (10) valuePeriod
        , observation'Component_dataAbsentReason :: Maybe CodeableConcept
          -- ^ Provides a reason why the expected value in the element 
          --   Observation.value[x] is missing.
        , observation'Component_interpretation :: Maybe CodeableConcept
          -- ^ The assessment made based on the result of the observation. 
          --   Intended as a simple compact code often placed adjacent to 
          --   the result value in reports and flow sheets to signal the 
          --   meaning/normalcy status of the result. Otherwise known as 
          --   abnormal flag.
        , observation'Component_referenceRange :: [Observation'ReferenceRange]
          -- ^ Guidance on how to interpret the value by comparison to a 
          --   normal or recommended range.
        }
        deriving (Eq,Show)
instance SchemaType Observation'Component where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Observation'Component a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf10 (parseSchemaType "valueQuantity"))
                                     , ("CodeableConcept", fmap TwoOf10 (parseSchemaType "valueCodeableConcept"))
                                     , ("Xsd.XsdString", fmap ThreeOf10 (parseSchemaType "valueString"))
                                     , ("Range", fmap FourOf10 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap FiveOf10 (parseSchemaType "valueRatio"))
                                     , ("SampledData", fmap SixOf10 (parseSchemaType "valueSampledData"))
                                     , ("Attachment", fmap SevenOf10 (parseSchemaType "valueAttachment"))
                                     , ("Time", fmap EightOf10 (parseSchemaType "valueTime"))
                                     , ("DateTime", fmap NineOf10 (parseSchemaType "valueDateTime"))
                                     , ("Period", fmap TenOf10 (parseSchemaType "valuePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dataAbsentReason")
            `apply` optional (parseSchemaType "interpretation")
            `apply` many (parseSchemaType "referenceRange")
    schemaTypeToXML s x@Observation'Component{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observation'Component_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observation'Component_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observation'Component_modifierExtension x
            , schemaTypeToXML "code" $ observation'Component_code x
            , maybe [] (foldOneOf10  (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valuePeriod")
                                    ) $ observation'Component_choice3 x
            , maybe [] (schemaTypeToXML "dataAbsentReason") $ observation'Component_dataAbsentReason x
            , maybe [] (schemaTypeToXML "interpretation") $ observation'Component_interpretation x
            , concatMap (schemaTypeToXML "referenceRange") $ observation'Component_referenceRange x
            ]
instance Extension Observation'Component BackboneElement where
    supertype (Observation'Component a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Observation'Component Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Observation'Component -> BackboneElement)
              
 
data ObservationRelationshipType'list
    = ObservationRelationshipType'list_Has'member
      -- ^ Has Member
    | ObservationRelationshipType'list_Derived'from
      -- ^ Derived From
    | ObservationRelationshipType'list_Sequel'to
      -- ^ Sequel To
    | ObservationRelationshipType'list_Replaces
      -- ^ Replaces
    | ObservationRelationshipType'list_Qualified'by
      -- ^ Qualified By
    | ObservationRelationshipType'list_Interfered'by
      -- ^ Interfered By
    deriving (Eq,Show,Enum)
instance SchemaType ObservationRelationshipType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ObservationRelationshipType'list where
    acceptingParser =  do literal "has-member"; return ObservationRelationshipType'list_Has'member
                      `onFail` do literal "derived-from"; return ObservationRelationshipType'list_Derived'from
                      `onFail` do literal "sequel-to"; return ObservationRelationshipType'list_Sequel'to
                      `onFail` do literal "replaces"; return ObservationRelationshipType'list_Replaces
                      `onFail` do literal "qualified-by"; return ObservationRelationshipType'list_Qualified'by
                      `onFail` do literal "interfered-by"; return ObservationRelationshipType'list_Interfered'by
                      
    simpleTypeText ObservationRelationshipType'list_Has'member = "has-member"
    simpleTypeText ObservationRelationshipType'list_Derived'from = "derived-from"
    simpleTypeText ObservationRelationshipType'list_Sequel'to = "sequel-to"
    simpleTypeText ObservationRelationshipType'list_Replaces = "replaces"
    simpleTypeText ObservationRelationshipType'list_Qualified'by = "qualified-by"
    simpleTypeText ObservationRelationshipType'list_Interfered'by = "interfered-by"
 
data ObservationRelationshipType = ObservationRelationshipType
        { observationRelationshipType_id :: Maybe String'primitive
        , observationRelationshipType_value :: Maybe ObservationRelationshipType'list
        , observationRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ObservationRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ObservationRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ObservationRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ observationRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationRelationshipType_extension x
            ]
instance Extension ObservationRelationshipType Element where
    supertype (ObservationRelationshipType a0 a1 e0) =
               Element a0 e0
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
elementOperationDefinition :: XMLParser OperationDefinition
elementOperationDefinition = parseSchemaType "OperationDefinition"
elementToXMLOperationDefinition :: OperationDefinition -> [Content ()]
elementToXMLOperationDefinition = schemaTypeToXML "OperationDefinition"
 
data OperationDefinition = OperationDefinition
        { operationDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , operationDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , operationDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , operationDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , operationDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , operationDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , operationDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this operation 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   operation definition is (or will be) published. The URL 
          --   SHOULD include the major version of the operation 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , operationDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   operation definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the operation definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , operationDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the operation 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , operationDefinition_status :: PublicationStatus
          -- ^ The status of this operation definition. Enables tracking 
          --   the life-cycle of the content.
        , operationDefinition_kind :: OperationKind
          -- ^ Whether this is an operation or a named query.
        , operationDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this operation definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , operationDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the operation 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the operation definition changes.
        , operationDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the operation definition.
        , operationDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , operationDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the operation 
          --   definition from a consumer's perspective.
        , operationDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   operation definition instances.
        , operationDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the operation 
          --   definition is intended to be used.
        , operationDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this operation definition is needed and 
          --   why it has been designed as it has.
        , operationDefinition_idempotent :: Maybe Boolean
          -- ^ Operations that are idempotent (see [HTTP specification 
          --   definition of 
          --   idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) 
          --   may be invoked by performing an HTTP GET operation instead 
          --   of a POST.
        , operationDefinition_code :: Code
          -- ^ The name used to invoke the operation.
        , operationDefinition_comment :: Maybe Xsd.XsdString
          -- ^ Additional information about how to use this operation or 
          --   named query.
        , operationDefinition_base :: Maybe Reference
          -- ^ Indicates that this operation definition is a constraining 
          --   profile on the base.
        , operationDefinition_resource :: [ResourceType]
          -- ^ The types on which this operation can be executed.
        , operationDefinition_system :: Boolean
          -- ^ Indicates whether this operation or named query can be 
          --   invoked at the system level (e.g. without needing to choose 
          --   a resource type for the context).
        , operationDefinition_type :: Boolean
          -- ^ Indicates whether this operation or named query can be 
          --   invoked at the resource type level for any given resource 
          --   type level (e.g. without needing to choose a specific 
          --   resource id for the context).
        , operationDefinition_instance :: Boolean
          -- ^ Indicates whether this operation can be invoked on a 
          --   particular instance of one of the given types.
        , operationDefinition_parameter :: [OperationDefinition'Parameter]
          -- ^ The parameters for the operation/query.
        , operationDefinition_overload :: [OperationDefinition'Overload]
          -- ^ Defines an appropriate combination of parameters to use 
          --   when invoking this operation, to help code generators when 
          --   generating overloaded parameter sets for this operation.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return OperationDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "idempotent")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "base")
            `apply` many (parseSchemaType "resource")
            `apply` parseSchemaType "system"
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "instance"
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "overload")
    schemaTypeToXML s x@OperationDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ operationDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ operationDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ operationDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ operationDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ operationDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ operationDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ operationDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ operationDefinition_url x
            , maybe [] (schemaTypeToXML "version") $ operationDefinition_version x
            , schemaTypeToXML "name" $ operationDefinition_name x
            , schemaTypeToXML "status" $ operationDefinition_status x
            , schemaTypeToXML "kind" $ operationDefinition_kind x
            , maybe [] (schemaTypeToXML "experimental") $ operationDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ operationDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ operationDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ operationDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ operationDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ operationDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ operationDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ operationDefinition_purpose x
            , maybe [] (schemaTypeToXML "idempotent") $ operationDefinition_idempotent x
            , schemaTypeToXML "code" $ operationDefinition_code x
            , maybe [] (schemaTypeToXML "comment") $ operationDefinition_comment x
            , maybe [] (schemaTypeToXML "base") $ operationDefinition_base x
            , concatMap (schemaTypeToXML "resource") $ operationDefinition_resource x
            , schemaTypeToXML "system" $ operationDefinition_system x
            , schemaTypeToXML "type" $ operationDefinition_type x
            , schemaTypeToXML "instance" $ operationDefinition_instance x
            , concatMap (schemaTypeToXML "parameter") $ operationDefinition_parameter x
            , concatMap (schemaTypeToXML "overload") $ operationDefinition_overload x
            ]
instance Extension OperationDefinition DomainResource where
    supertype (OperationDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension OperationDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: OperationDefinition -> DomainResource)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinition'Parameter = OperationDefinition'Parameter
        { operationDefinition'Parameter_id :: Maybe String'primitive
        , operationDefinition'Parameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinition'Parameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinition'Parameter_name :: Code
          -- ^ The name of used to identify the parameter.
        , operationDefinition'Parameter_use :: OperationParameterUse
          -- ^ Whether this is an input or an output parameter.
        , operationDefinition'Parameter_min :: Integer
          -- ^ The minimum number of times this parameter SHALL appear in 
          --   the request or response.
        , operationDefinition'Parameter_max :: Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the request or response.
        , operationDefinition'Parameter_documentation :: Maybe Xsd.XsdString
          -- ^ Describes the meaning or use of this parameter.
        , operationDefinition'Parameter_type :: Maybe FHIRAllTypes
          -- ^ The type for this parameter.
        , operationDefinition'Parameter_searchType :: Maybe SearchParamType
          -- ^ How the parameter is understood as a search parameter. This 
          --   is only used if the parameter type is 'string'.
        , operationDefinition'Parameter_profile :: Maybe Reference
          -- ^ A profile the specifies the rules that this parameter must 
          --   conform to.
        , operationDefinition'Parameter_binding :: Maybe OperationDefinition'Binding
          -- ^ Binds to a value set if this parameter is coded (code, 
          --   Coding, CodeableConcept).
        , operationDefinition'Parameter_part :: [OperationDefinition'Parameter]
          -- ^ The parts of a nested Parameter.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinition'Parameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinition'Parameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "use"
            `apply` parseSchemaType "min"
            `apply` parseSchemaType "max"
            `apply` optional (parseSchemaType "documentation")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "searchType")
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "binding")
            `apply` many (parseSchemaType "part")
    schemaTypeToXML s x@OperationDefinition'Parameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinition'Parameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinition'Parameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinition'Parameter_modifierExtension x
            , schemaTypeToXML "name" $ operationDefinition'Parameter_name x
            , schemaTypeToXML "use" $ operationDefinition'Parameter_use x
            , schemaTypeToXML "min" $ operationDefinition'Parameter_min x
            , schemaTypeToXML "max" $ operationDefinition'Parameter_max x
            , maybe [] (schemaTypeToXML "documentation") $ operationDefinition'Parameter_documentation x
            , maybe [] (schemaTypeToXML "type") $ operationDefinition'Parameter_type x
            , maybe [] (schemaTypeToXML "searchType") $ operationDefinition'Parameter_searchType x
            , maybe [] (schemaTypeToXML "profile") $ operationDefinition'Parameter_profile x
            , maybe [] (schemaTypeToXML "binding") $ operationDefinition'Parameter_binding x
            , concatMap (schemaTypeToXML "part") $ operationDefinition'Parameter_part x
            ]
instance Extension OperationDefinition'Parameter BackboneElement where
    supertype (OperationDefinition'Parameter a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinition'Parameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinition'Parameter -> BackboneElement)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinition'Binding = OperationDefinition'Binding
        { operationDefinition'Binding_id :: Maybe String'primitive
        , operationDefinition'Binding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinition'Binding_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinition'Binding_strength :: BindingStrength
          -- ^ Indicates the degree of conformance expectations associated 
          --   with this binding - that is, the degree to which the 
          --   provided value set must be adhered to in the instances.
        , operationDefinition'Binding_choice3 :: OneOf2 Uri Reference
          -- ^ Points to the value set or external definition (e.g. 
          --   implicit value set) that identifies the set of codes to be 
          --   used.
          --   
          --   Choice between:
          --   
          --   (1) valueSetUri
          --   
          --   (2) valueSetReference
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinition'Binding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinition'Binding a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "strength"
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "valueSetUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "valueSetReference"))
                           ]
    schemaTypeToXML s x@OperationDefinition'Binding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinition'Binding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinition'Binding_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinition'Binding_modifierExtension x
            , schemaTypeToXML "strength" $ operationDefinition'Binding_strength x
            , foldOneOf2  (schemaTypeToXML "valueSetUri")
                          (schemaTypeToXML "valueSetReference")
                          $ operationDefinition'Binding_choice3 x
            ]
instance Extension OperationDefinition'Binding BackboneElement where
    supertype (OperationDefinition'Binding a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinition'Binding Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinition'Binding -> BackboneElement)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinition'Overload = OperationDefinition'Overload
        { operationDefinition'Overload_id :: Maybe String'primitive
        , operationDefinition'Overload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinition'Overload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinition'Overload_parameterName :: [Xsd.XsdString]
          -- ^ Name of parameter to include in overload.
        , operationDefinition'Overload_comment :: Maybe Xsd.XsdString
          -- ^ Comments to go on overload.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinition'Overload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinition'Overload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "parameterName")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@OperationDefinition'Overload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinition'Overload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinition'Overload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinition'Overload_modifierExtension x
            , concatMap (schemaTypeToXML "parameterName") $ operationDefinition'Overload_parameterName x
            , maybe [] (schemaTypeToXML "comment") $ operationDefinition'Overload_comment x
            ]
instance Extension OperationDefinition'Overload BackboneElement where
    supertype (OperationDefinition'Overload a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinition'Overload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinition'Overload -> BackboneElement)
              
 
data FHIRAllTypes'list
    = FHIRAllTypes'list_Address
      -- ^ Address
    | FHIRAllTypes'list_Age
      -- ^ Age
    | FHIRAllTypes'list_Annotation
      -- ^ Annotation
    | FHIRAllTypes'list_Attachment
      -- ^ Attachment
    | FHIRAllTypes'list_BackboneElement
      -- ^ BackboneElement
    | FHIRAllTypes'list_CodeableConcept
      -- ^ CodeableConcept
    | FHIRAllTypes'list_Coding
      -- ^ Coding
    | FHIRAllTypes'list_ContactDetail
      -- ^ ContactDetail
    | FHIRAllTypes'list_ContactPoint
      -- ^ ContactPoint
    | FHIRAllTypes'list_Contributor
      -- ^ Contributor
    | FHIRAllTypes'list_Count
      -- ^ Count
    | FHIRAllTypes'list_DataRequirement
      -- ^ DataRequirement
    | FHIRAllTypes'list_Distance
      -- ^ Distance
    | FHIRAllTypes'list_Dosage
      -- ^ Dosage
    | FHIRAllTypes'list_Duration
      -- ^ Duration
    | FHIRAllTypes'list_Element
      -- ^ Element
    | FHIRAllTypes'list_ElementDefinition
      -- ^ ElementDefinition
    | FHIRAllTypes'list_Extension
      -- ^ Extension
    | FHIRAllTypes'list_HumanName
      -- ^ HumanName
    | FHIRAllTypes'list_Identifier
      -- ^ Identifier
    | FHIRAllTypes'list_Meta
      -- ^ Meta
    | FHIRAllTypes'list_Money
      -- ^ Money
    | FHIRAllTypes'list_Narrative
      -- ^ Narrative
    | FHIRAllTypes'list_ParameterDefinition
      -- ^ ParameterDefinition
    | FHIRAllTypes'list_Period
      -- ^ Period
    | FHIRAllTypes'list_Quantity
      -- ^ Quantity
    | FHIRAllTypes'list_Range
      -- ^ Range
    | FHIRAllTypes'list_Ratio
      -- ^ Ratio
    | FHIRAllTypes'list_Reference
      -- ^ Reference
    | FHIRAllTypes'list_RelatedArtifact
      -- ^ RelatedArtifact
    | FHIRAllTypes'list_SampledData
      -- ^ SampledData
    | FHIRAllTypes'list_Signature
      -- ^ Signature
    | FHIRAllTypes'list_SimpleQuantity
      -- ^ SimpleQuantity
    | FHIRAllTypes'list_Timing
      -- ^ Timing
    | FHIRAllTypes'list_TriggerDefinition
      -- ^ TriggerDefinition
    | FHIRAllTypes'list_UsageContext
      -- ^ UsageContext
    | FHIRAllTypes'list_Base64Binary
      -- ^ base64Binary
    | FHIRAllTypes'list_Boolean
      -- ^ boolean
    | FHIRAllTypes'list_Code
      -- ^ code
    | FHIRAllTypes'list_Date
      -- ^ date
    | FHIRAllTypes'list_DateTime
      -- ^ dateTime
    | FHIRAllTypes'list_Decimal
      -- ^ decimal
    | FHIRAllTypes'list_Id
      -- ^ id
    | FHIRAllTypes'list_Instant
      -- ^ instant
    | FHIRAllTypes'list_Integer
      -- ^ integer
    | FHIRAllTypes'list_Markdown
      -- ^ markdown
    | FHIRAllTypes'list_Oid
      -- ^ oid
    | FHIRAllTypes'list_PositiveInt
      -- ^ positiveInt
    | FHIRAllTypes'list_Xsd.XsdString
      -- ^ string
    | FHIRAllTypes'list_Time
      -- ^ time
    | FHIRAllTypes'list_UnsignedInt
      -- ^ unsignedInt
    | FHIRAllTypes'list_Uri
      -- ^ uri
    | FHIRAllTypes'list_Uuid
      -- ^ uuid
    | FHIRAllTypes'list_Xhtml
      -- ^ XHTML
    | FHIRAllTypes'list_Account
      -- ^ Account
    | FHIRAllTypes'list_ActivityDefinition
      -- ^ ActivityDefinition
    | FHIRAllTypes'list_AdverseEvent
      -- ^ AdverseEvent
    | FHIRAllTypes'list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | FHIRAllTypes'list_Appointment
      -- ^ Appointment
    | FHIRAllTypes'list_AppointmentResponse
      -- ^ AppointmentResponse
    | FHIRAllTypes'list_AuditEvent
      -- ^ AuditEvent
    | FHIRAllTypes'list_Basic
      -- ^ Basic
    | FHIRAllTypes'list_Binary
      -- ^ Binary
    | FHIRAllTypes'list_BodySite
      -- ^ BodySite
    | FHIRAllTypes'list_Bundle
      -- ^ Bundle
    | FHIRAllTypes'list_CapabilityStatement
      -- ^ CapabilityStatement
    | FHIRAllTypes'list_CarePlan
      -- ^ CarePlan
    | FHIRAllTypes'list_CareTeam
      -- ^ CareTeam
    | FHIRAllTypes'list_ChargeItem
      -- ^ ChargeItem
    | FHIRAllTypes'list_Claim
      -- ^ Claim
    | FHIRAllTypes'list_ClaimResponse
      -- ^ ClaimResponse
    | FHIRAllTypes'list_ClinicalImpression
      -- ^ ClinicalImpression
    | FHIRAllTypes'list_CodeSystem
      -- ^ CodeSystem
    | FHIRAllTypes'list_Communication
      -- ^ Communication
    | FHIRAllTypes'list_CommunicationRequest
      -- ^ CommunicationRequest
    | FHIRAllTypes'list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | FHIRAllTypes'list_Composition
      -- ^ Composition
    | FHIRAllTypes'list_ConceptMap
      -- ^ ConceptMap
    | FHIRAllTypes'list_Condition
      -- ^ Condition
    | FHIRAllTypes'list_Consent
      -- ^ Consent
    | FHIRAllTypes'list_Contract
      -- ^ Contract
    | FHIRAllTypes'list_Coverage
      -- ^ Coverage
    | FHIRAllTypes'list_DataElement
      -- ^ DataElement
    | FHIRAllTypes'list_DetectedIssue
      -- ^ DetectedIssue
    | FHIRAllTypes'list_Device
      -- ^ Device
    | FHIRAllTypes'list_DeviceComponent
      -- ^ DeviceComponent
    | FHIRAllTypes'list_DeviceMetric
      -- ^ DeviceMetric
    | FHIRAllTypes'list_DeviceRequest
      -- ^ DeviceRequest
    | FHIRAllTypes'list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | FHIRAllTypes'list_DiagnosticReport
      -- ^ DiagnosticReport
    | FHIRAllTypes'list_DocumentManifest
      -- ^ DocumentManifest
    | FHIRAllTypes'list_DocumentReference
      -- ^ DocumentReference
    | FHIRAllTypes'list_DomainResource
      -- ^ DomainResource
    | FHIRAllTypes'list_EligibilityRequest
      -- ^ EligibilityRequest
    | FHIRAllTypes'list_EligibilityResponse
      -- ^ EligibilityResponse
    | FHIRAllTypes'list_Encounter
      -- ^ Encounter
    | FHIRAllTypes'list_Endpoint
      -- ^ Endpoint
    | FHIRAllTypes'list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | FHIRAllTypes'list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | FHIRAllTypes'list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | FHIRAllTypes'list_ExpansionProfile
      -- ^ ExpansionProfile
    | FHIRAllTypes'list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | FHIRAllTypes'list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | FHIRAllTypes'list_Flag
      -- ^ Flag
    | FHIRAllTypes'list_Goal
      -- ^ Goal
    | FHIRAllTypes'list_GraphDefinition
      -- ^ GraphDefinition
    | FHIRAllTypes'list_Group
      -- ^ Group
    | FHIRAllTypes'list_GuidanceResponse
      -- ^ GuidanceResponse
    | FHIRAllTypes'list_HealthcareService
      -- ^ HealthcareService
    | FHIRAllTypes'list_ImagingManifest
      -- ^ ImagingManifest
    | FHIRAllTypes'list_ImagingStudy
      -- ^ ImagingStudy
    | FHIRAllTypes'list_Immunization
      -- ^ Immunization
    | FHIRAllTypes'list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | FHIRAllTypes'list_ImplementationGuide
      -- ^ ImplementationGuide
    | FHIRAllTypes'list_Library
      -- ^ Library
    | FHIRAllTypes'list_Linkage
      -- ^ Linkage
    | FHIRAllTypes'list_List
      -- ^ List
    | FHIRAllTypes'list_Location
      -- ^ Location
    | FHIRAllTypes'list_Measure
      -- ^ Measure
    | FHIRAllTypes'list_MeasureReport
      -- ^ MeasureReport
    | FHIRAllTypes'list_Media
      -- ^ Media
    | FHIRAllTypes'list_Medication
      -- ^ Medication
    | FHIRAllTypes'list_MedicationAdministration
      -- ^ MedicationAdministration
    | FHIRAllTypes'list_MedicationDispense
      -- ^ MedicationDispense
    | FHIRAllTypes'list_MedicationRequest
      -- ^ MedicationRequest
    | FHIRAllTypes'list_MedicationStatement
      -- ^ MedicationStatement
    | FHIRAllTypes'list_MessageDefinition
      -- ^ MessageDefinition
    | FHIRAllTypes'list_MessageHeader
      -- ^ MessageHeader
    | FHIRAllTypes'list_NamingSystem
      -- ^ NamingSystem
    | FHIRAllTypes'list_NutritionOrder
      -- ^ NutritionOrder
    | FHIRAllTypes'list_Observation
      -- ^ Observation
    | FHIRAllTypes'list_OperationDefinition
      -- ^ OperationDefinition
    | FHIRAllTypes'list_OperationOutcome
      -- ^ OperationOutcome
    | FHIRAllTypes'list_Organization
      -- ^ Organization
    | FHIRAllTypes'list_Parameters
      -- ^ Parameters
    | FHIRAllTypes'list_Patient
      -- ^ Patient
    | FHIRAllTypes'list_PaymentNotice
      -- ^ PaymentNotice
    | FHIRAllTypes'list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | FHIRAllTypes'list_Person
      -- ^ Person
    | FHIRAllTypes'list_PlanDefinition
      -- ^ PlanDefinition
    | FHIRAllTypes'list_Practitioner
      -- ^ Practitioner
    | FHIRAllTypes'list_PractitionerRole
      -- ^ PractitionerRole
    | FHIRAllTypes'list_Procedure
      -- ^ Procedure
    | FHIRAllTypes'list_ProcedureRequest
      -- ^ ProcedureRequest
    | FHIRAllTypes'list_ProcessRequest
      -- ^ ProcessRequest
    | FHIRAllTypes'list_ProcessResponse
      -- ^ ProcessResponse
    | FHIRAllTypes'list_Provenance
      -- ^ Provenance
    | FHIRAllTypes'list_Questionnaire
      -- ^ Questionnaire
    | FHIRAllTypes'list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | FHIRAllTypes'list_ReferralRequest
      -- ^ ReferralRequest
    | FHIRAllTypes'list_RelatedPerson
      -- ^ RelatedPerson
    | FHIRAllTypes'list_RequestGroup
      -- ^ RequestGroup
    | FHIRAllTypes'list_ResearchStudy
      -- ^ ResearchStudy
    | FHIRAllTypes'list_ResearchSubject
      -- ^ ResearchSubject
    | FHIRAllTypes'list_Resource
      -- ^ Resource
    | FHIRAllTypes'list_RiskAssessment
      -- ^ RiskAssessment
    | FHIRAllTypes'list_Schedule
      -- ^ Schedule
    | FHIRAllTypes'list_SearchParameter
      -- ^ SearchParameter
    | FHIRAllTypes'list_Sequence
      -- ^ Sequence
    | FHIRAllTypes'list_ServiceDefinition
      -- ^ ServiceDefinition
    | FHIRAllTypes'list_Slot
      -- ^ Slot
    | FHIRAllTypes'list_Specimen
      -- ^ Specimen
    | FHIRAllTypes'list_StructureDefinition
      -- ^ StructureDefinition
    | FHIRAllTypes'list_StructureMap
      -- ^ StructureMap
    | FHIRAllTypes'list_Subscription
      -- ^ Subscription
    | FHIRAllTypes'list_Substance
      -- ^ Substance
    | FHIRAllTypes'list_SupplyDelivery
      -- ^ SupplyDelivery
    | FHIRAllTypes'list_SupplyRequest
      -- ^ SupplyRequest
    | FHIRAllTypes'list_Task
      -- ^ Task
    | FHIRAllTypes'list_TestReport
      -- ^ TestReport
    | FHIRAllTypes'list_TestScript
      -- ^ TestScript
    | FHIRAllTypes'list_ValueSet
      -- ^ ValueSet
    | FHIRAllTypes'list_VisionPrescription
      -- ^ VisionPrescription
    | FHIRAllTypes'list_Type
      -- ^ Type
    | FHIRAllTypes'list_Any
      -- ^ Any
    deriving (Eq,Show,Enum)
instance SchemaType FHIRAllTypes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRAllTypes'list where
    acceptingParser =  do literal "Address"; return FHIRAllTypes'list_Address
                      `onFail` do literal "Age"; return FHIRAllTypes'list_Age
                      `onFail` do literal "Annotation"; return FHIRAllTypes'list_Annotation
                      `onFail` do literal "Attachment"; return FHIRAllTypes'list_Attachment
                      `onFail` do literal "BackboneElement"; return FHIRAllTypes'list_BackboneElement
                      `onFail` do literal "CodeableConcept"; return FHIRAllTypes'list_CodeableConcept
                      `onFail` do literal "Coding"; return FHIRAllTypes'list_Coding
                      `onFail` do literal "ContactDetail"; return FHIRAllTypes'list_ContactDetail
                      `onFail` do literal "ContactPoint"; return FHIRAllTypes'list_ContactPoint
                      `onFail` do literal "Contributor"; return FHIRAllTypes'list_Contributor
                      `onFail` do literal "Count"; return FHIRAllTypes'list_Count
                      `onFail` do literal "DataRequirement"; return FHIRAllTypes'list_DataRequirement
                      `onFail` do literal "Distance"; return FHIRAllTypes'list_Distance
                      `onFail` do literal "Dosage"; return FHIRAllTypes'list_Dosage
                      `onFail` do literal "Duration"; return FHIRAllTypes'list_Duration
                      `onFail` do literal "Element"; return FHIRAllTypes'list_Element
                      `onFail` do literal "ElementDefinition"; return FHIRAllTypes'list_ElementDefinition
                      `onFail` do literal "Extension"; return FHIRAllTypes'list_Extension
                      `onFail` do literal "HumanName"; return FHIRAllTypes'list_HumanName
                      `onFail` do literal "Identifier"; return FHIRAllTypes'list_Identifier
                      `onFail` do literal "Meta"; return FHIRAllTypes'list_Meta
                      `onFail` do literal "Money"; return FHIRAllTypes'list_Money
                      `onFail` do literal "Narrative"; return FHIRAllTypes'list_Narrative
                      `onFail` do literal "ParameterDefinition"; return FHIRAllTypes'list_ParameterDefinition
                      `onFail` do literal "Period"; return FHIRAllTypes'list_Period
                      `onFail` do literal "Quantity"; return FHIRAllTypes'list_Quantity
                      `onFail` do literal "Range"; return FHIRAllTypes'list_Range
                      `onFail` do literal "Ratio"; return FHIRAllTypes'list_Ratio
                      `onFail` do literal "Reference"; return FHIRAllTypes'list_Reference
                      `onFail` do literal "RelatedArtifact"; return FHIRAllTypes'list_RelatedArtifact
                      `onFail` do literal "SampledData"; return FHIRAllTypes'list_SampledData
                      `onFail` do literal "Signature"; return FHIRAllTypes'list_Signature
                      `onFail` do literal "SimpleQuantity"; return FHIRAllTypes'list_SimpleQuantity
                      `onFail` do literal "Timing"; return FHIRAllTypes'list_Timing
                      `onFail` do literal "TriggerDefinition"; return FHIRAllTypes'list_TriggerDefinition
                      `onFail` do literal "UsageContext"; return FHIRAllTypes'list_UsageContext
                      `onFail` do literal "base64Binary"; return FHIRAllTypes'list_Base64Binary
                      `onFail` do literal "boolean"; return FHIRAllTypes'list_Boolean
                      `onFail` do literal "code"; return FHIRAllTypes'list_Code
                      `onFail` do literal "date"; return FHIRAllTypes'list_Date
                      `onFail` do literal "dateTime"; return FHIRAllTypes'list_DateTime
                      `onFail` do literal "decimal"; return FHIRAllTypes'list_Decimal
                      `onFail` do literal "id"; return FHIRAllTypes'list_Id
                      `onFail` do literal "instant"; return FHIRAllTypes'list_Instant
                      `onFail` do literal "integer"; return FHIRAllTypes'list_Integer
                      `onFail` do literal "markdown"; return FHIRAllTypes'list_Markdown
                      `onFail` do literal "oid"; return FHIRAllTypes'list_Oid
                      `onFail` do literal "positiveInt"; return FHIRAllTypes'list_PositiveInt
                      `onFail` do literal "string"; return FHIRAllTypes'list_Xsd.XsdString
                      `onFail` do literal "time"; return FHIRAllTypes'list_Time
                      `onFail` do literal "unsignedInt"; return FHIRAllTypes'list_UnsignedInt
                      `onFail` do literal "uri"; return FHIRAllTypes'list_Uri
                      `onFail` do literal "uuid"; return FHIRAllTypes'list_Uuid
                      `onFail` do literal "xhtml"; return FHIRAllTypes'list_Xhtml
                      `onFail` do literal "Account"; return FHIRAllTypes'list_Account
                      `onFail` do literal "ActivityDefinition"; return FHIRAllTypes'list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return FHIRAllTypes'list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return FHIRAllTypes'list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return FHIRAllTypes'list_Appointment
                      `onFail` do literal "AppointmentResponse"; return FHIRAllTypes'list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return FHIRAllTypes'list_AuditEvent
                      `onFail` do literal "Basic"; return FHIRAllTypes'list_Basic
                      `onFail` do literal "Binary"; return FHIRAllTypes'list_Binary
                      `onFail` do literal "BodySite"; return FHIRAllTypes'list_BodySite
                      `onFail` do literal "Bundle"; return FHIRAllTypes'list_Bundle
                      `onFail` do literal "CapabilityStatement"; return FHIRAllTypes'list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return FHIRAllTypes'list_CarePlan
                      `onFail` do literal "CareTeam"; return FHIRAllTypes'list_CareTeam
                      `onFail` do literal "ChargeItem"; return FHIRAllTypes'list_ChargeItem
                      `onFail` do literal "Claim"; return FHIRAllTypes'list_Claim
                      `onFail` do literal "ClaimResponse"; return FHIRAllTypes'list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return FHIRAllTypes'list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return FHIRAllTypes'list_CodeSystem
                      `onFail` do literal "Communication"; return FHIRAllTypes'list_Communication
                      `onFail` do literal "CommunicationRequest"; return FHIRAllTypes'list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return FHIRAllTypes'list_CompartmentDefinition
                      `onFail` do literal "Composition"; return FHIRAllTypes'list_Composition
                      `onFail` do literal "ConceptMap"; return FHIRAllTypes'list_ConceptMap
                      `onFail` do literal "Condition"; return FHIRAllTypes'list_Condition
                      `onFail` do literal "Consent"; return FHIRAllTypes'list_Consent
                      `onFail` do literal "Contract"; return FHIRAllTypes'list_Contract
                      `onFail` do literal "Coverage"; return FHIRAllTypes'list_Coverage
                      `onFail` do literal "DataElement"; return FHIRAllTypes'list_DataElement
                      `onFail` do literal "DetectedIssue"; return FHIRAllTypes'list_DetectedIssue
                      `onFail` do literal "Device"; return FHIRAllTypes'list_Device
                      `onFail` do literal "DeviceComponent"; return FHIRAllTypes'list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return FHIRAllTypes'list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return FHIRAllTypes'list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return FHIRAllTypes'list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return FHIRAllTypes'list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return FHIRAllTypes'list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return FHIRAllTypes'list_DocumentReference
                      `onFail` do literal "DomainResource"; return FHIRAllTypes'list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return FHIRAllTypes'list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return FHIRAllTypes'list_EligibilityResponse
                      `onFail` do literal "Encounter"; return FHIRAllTypes'list_Encounter
                      `onFail` do literal "Endpoint"; return FHIRAllTypes'list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return FHIRAllTypes'list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return FHIRAllTypes'list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return FHIRAllTypes'list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return FHIRAllTypes'list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return FHIRAllTypes'list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return FHIRAllTypes'list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return FHIRAllTypes'list_Flag
                      `onFail` do literal "Goal"; return FHIRAllTypes'list_Goal
                      `onFail` do literal "GraphDefinition"; return FHIRAllTypes'list_GraphDefinition
                      `onFail` do literal "Group"; return FHIRAllTypes'list_Group
                      `onFail` do literal "GuidanceResponse"; return FHIRAllTypes'list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return FHIRAllTypes'list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return FHIRAllTypes'list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return FHIRAllTypes'list_ImagingStudy
                      `onFail` do literal "Immunization"; return FHIRAllTypes'list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return FHIRAllTypes'list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return FHIRAllTypes'list_ImplementationGuide
                      `onFail` do literal "Library"; return FHIRAllTypes'list_Library
                      `onFail` do literal "Linkage"; return FHIRAllTypes'list_Linkage
                      `onFail` do literal "List"; return FHIRAllTypes'list_List
                      `onFail` do literal "Location"; return FHIRAllTypes'list_Location
                      `onFail` do literal "Measure"; return FHIRAllTypes'list_Measure
                      `onFail` do literal "MeasureReport"; return FHIRAllTypes'list_MeasureReport
                      `onFail` do literal "Media"; return FHIRAllTypes'list_Media
                      `onFail` do literal "Medication"; return FHIRAllTypes'list_Medication
                      `onFail` do literal "MedicationAdministration"; return FHIRAllTypes'list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return FHIRAllTypes'list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return FHIRAllTypes'list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return FHIRAllTypes'list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return FHIRAllTypes'list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return FHIRAllTypes'list_MessageHeader
                      `onFail` do literal "NamingSystem"; return FHIRAllTypes'list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return FHIRAllTypes'list_NutritionOrder
                      `onFail` do literal "Observation"; return FHIRAllTypes'list_Observation
                      `onFail` do literal "OperationDefinition"; return FHIRAllTypes'list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return FHIRAllTypes'list_OperationOutcome
                      `onFail` do literal "Organization"; return FHIRAllTypes'list_Organization
                      `onFail` do literal "Parameters"; return FHIRAllTypes'list_Parameters
                      `onFail` do literal "Patient"; return FHIRAllTypes'list_Patient
                      `onFail` do literal "PaymentNotice"; return FHIRAllTypes'list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return FHIRAllTypes'list_PaymentReconciliation
                      `onFail` do literal "Person"; return FHIRAllTypes'list_Person
                      `onFail` do literal "PlanDefinition"; return FHIRAllTypes'list_PlanDefinition
                      `onFail` do literal "Practitioner"; return FHIRAllTypes'list_Practitioner
                      `onFail` do literal "PractitionerRole"; return FHIRAllTypes'list_PractitionerRole
                      `onFail` do literal "Procedure"; return FHIRAllTypes'list_Procedure
                      `onFail` do literal "ProcedureRequest"; return FHIRAllTypes'list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return FHIRAllTypes'list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return FHIRAllTypes'list_ProcessResponse
                      `onFail` do literal "Provenance"; return FHIRAllTypes'list_Provenance
                      `onFail` do literal "Questionnaire"; return FHIRAllTypes'list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return FHIRAllTypes'list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return FHIRAllTypes'list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return FHIRAllTypes'list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return FHIRAllTypes'list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return FHIRAllTypes'list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return FHIRAllTypes'list_ResearchSubject
                      `onFail` do literal "Resource"; return FHIRAllTypes'list_Resource
                      `onFail` do literal "RiskAssessment"; return FHIRAllTypes'list_RiskAssessment
                      `onFail` do literal "Schedule"; return FHIRAllTypes'list_Schedule
                      `onFail` do literal "SearchParameter"; return FHIRAllTypes'list_SearchParameter
                      `onFail` do literal "Sequence"; return FHIRAllTypes'list_Sequence
                      `onFail` do literal "ServiceDefinition"; return FHIRAllTypes'list_ServiceDefinition
                      `onFail` do literal "Slot"; return FHIRAllTypes'list_Slot
                      `onFail` do literal "Specimen"; return FHIRAllTypes'list_Specimen
                      `onFail` do literal "StructureDefinition"; return FHIRAllTypes'list_StructureDefinition
                      `onFail` do literal "StructureMap"; return FHIRAllTypes'list_StructureMap
                      `onFail` do literal "Subscription"; return FHIRAllTypes'list_Subscription
                      `onFail` do literal "Substance"; return FHIRAllTypes'list_Substance
                      `onFail` do literal "SupplyDelivery"; return FHIRAllTypes'list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return FHIRAllTypes'list_SupplyRequest
                      `onFail` do literal "Task"; return FHIRAllTypes'list_Task
                      `onFail` do literal "TestReport"; return FHIRAllTypes'list_TestReport
                      `onFail` do literal "TestScript"; return FHIRAllTypes'list_TestScript
                      `onFail` do literal "ValueSet"; return FHIRAllTypes'list_ValueSet
                      `onFail` do literal "VisionPrescription"; return FHIRAllTypes'list_VisionPrescription
                      `onFail` do literal "Type"; return FHIRAllTypes'list_Type
                      `onFail` do literal "Any"; return FHIRAllTypes'list_Any
                      
    simpleTypeText FHIRAllTypes'list_Address = "Address"
    simpleTypeText FHIRAllTypes'list_Age = "Age"
    simpleTypeText FHIRAllTypes'list_Annotation = "Annotation"
    simpleTypeText FHIRAllTypes'list_Attachment = "Attachment"
    simpleTypeText FHIRAllTypes'list_BackboneElement = "BackboneElement"
    simpleTypeText FHIRAllTypes'list_CodeableConcept = "CodeableConcept"
    simpleTypeText FHIRAllTypes'list_Coding = "Coding"
    simpleTypeText FHIRAllTypes'list_ContactDetail = "ContactDetail"
    simpleTypeText FHIRAllTypes'list_ContactPoint = "ContactPoint"
    simpleTypeText FHIRAllTypes'list_Contributor = "Contributor"
    simpleTypeText FHIRAllTypes'list_Count = "Count"
    simpleTypeText FHIRAllTypes'list_DataRequirement = "DataRequirement"
    simpleTypeText FHIRAllTypes'list_Distance = "Distance"
    simpleTypeText FHIRAllTypes'list_Dosage = "Dosage"
    simpleTypeText FHIRAllTypes'list_Duration = "Duration"
    simpleTypeText FHIRAllTypes'list_Element = "Element"
    simpleTypeText FHIRAllTypes'list_ElementDefinition = "ElementDefinition"
    simpleTypeText FHIRAllTypes'list_Extension = "Extension"
    simpleTypeText FHIRAllTypes'list_HumanName = "HumanName"
    simpleTypeText FHIRAllTypes'list_Identifier = "Identifier"
    simpleTypeText FHIRAllTypes'list_Meta = "Meta"
    simpleTypeText FHIRAllTypes'list_Money = "Money"
    simpleTypeText FHIRAllTypes'list_Narrative = "Narrative"
    simpleTypeText FHIRAllTypes'list_ParameterDefinition = "ParameterDefinition"
    simpleTypeText FHIRAllTypes'list_Period = "Period"
    simpleTypeText FHIRAllTypes'list_Quantity = "Quantity"
    simpleTypeText FHIRAllTypes'list_Range = "Range"
    simpleTypeText FHIRAllTypes'list_Ratio = "Ratio"
    simpleTypeText FHIRAllTypes'list_Reference = "Reference"
    simpleTypeText FHIRAllTypes'list_RelatedArtifact = "RelatedArtifact"
    simpleTypeText FHIRAllTypes'list_SampledData = "SampledData"
    simpleTypeText FHIRAllTypes'list_Signature = "Signature"
    simpleTypeText FHIRAllTypes'list_SimpleQuantity = "SimpleQuantity"
    simpleTypeText FHIRAllTypes'list_Timing = "Timing"
    simpleTypeText FHIRAllTypes'list_TriggerDefinition = "TriggerDefinition"
    simpleTypeText FHIRAllTypes'list_UsageContext = "UsageContext"
    simpleTypeText FHIRAllTypes'list_Base64Binary = "base64Binary"
    simpleTypeText FHIRAllTypes'list_Boolean = "boolean"
    simpleTypeText FHIRAllTypes'list_Code = "code"
    simpleTypeText FHIRAllTypes'list_Date = "date"
    simpleTypeText FHIRAllTypes'list_DateTime = "dateTime"
    simpleTypeText FHIRAllTypes'list_Decimal = "decimal"
    simpleTypeText FHIRAllTypes'list_Id = "id"
    simpleTypeText FHIRAllTypes'list_Instant = "instant"
    simpleTypeText FHIRAllTypes'list_Integer = "integer"
    simpleTypeText FHIRAllTypes'list_Markdown = "markdown"
    simpleTypeText FHIRAllTypes'list_Oid = "oid"
    simpleTypeText FHIRAllTypes'list_PositiveInt = "positiveInt"
    simpleTypeText FHIRAllTypes'list_Xsd.XsdString = "string"
    simpleTypeText FHIRAllTypes'list_Time = "time"
    simpleTypeText FHIRAllTypes'list_UnsignedInt = "unsignedInt"
    simpleTypeText FHIRAllTypes'list_Uri = "uri"
    simpleTypeText FHIRAllTypes'list_Uuid = "uuid"
    simpleTypeText FHIRAllTypes'list_Xhtml = "xhtml"
    simpleTypeText FHIRAllTypes'list_Account = "Account"
    simpleTypeText FHIRAllTypes'list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText FHIRAllTypes'list_AdverseEvent = "AdverseEvent"
    simpleTypeText FHIRAllTypes'list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText FHIRAllTypes'list_Appointment = "Appointment"
    simpleTypeText FHIRAllTypes'list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText FHIRAllTypes'list_AuditEvent = "AuditEvent"
    simpleTypeText FHIRAllTypes'list_Basic = "Basic"
    simpleTypeText FHIRAllTypes'list_Binary = "Binary"
    simpleTypeText FHIRAllTypes'list_BodySite = "BodySite"
    simpleTypeText FHIRAllTypes'list_Bundle = "Bundle"
    simpleTypeText FHIRAllTypes'list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText FHIRAllTypes'list_CarePlan = "CarePlan"
    simpleTypeText FHIRAllTypes'list_CareTeam = "CareTeam"
    simpleTypeText FHIRAllTypes'list_ChargeItem = "ChargeItem"
    simpleTypeText FHIRAllTypes'list_Claim = "Claim"
    simpleTypeText FHIRAllTypes'list_ClaimResponse = "ClaimResponse"
    simpleTypeText FHIRAllTypes'list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText FHIRAllTypes'list_CodeSystem = "CodeSystem"
    simpleTypeText FHIRAllTypes'list_Communication = "Communication"
    simpleTypeText FHIRAllTypes'list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText FHIRAllTypes'list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText FHIRAllTypes'list_Composition = "Composition"
    simpleTypeText FHIRAllTypes'list_ConceptMap = "ConceptMap"
    simpleTypeText FHIRAllTypes'list_Condition = "Condition"
    simpleTypeText FHIRAllTypes'list_Consent = "Consent"
    simpleTypeText FHIRAllTypes'list_Contract = "Contract"
    simpleTypeText FHIRAllTypes'list_Coverage = "Coverage"
    simpleTypeText FHIRAllTypes'list_DataElement = "DataElement"
    simpleTypeText FHIRAllTypes'list_DetectedIssue = "DetectedIssue"
    simpleTypeText FHIRAllTypes'list_Device = "Device"
    simpleTypeText FHIRAllTypes'list_DeviceComponent = "DeviceComponent"
    simpleTypeText FHIRAllTypes'list_DeviceMetric = "DeviceMetric"
    simpleTypeText FHIRAllTypes'list_DeviceRequest = "DeviceRequest"
    simpleTypeText FHIRAllTypes'list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText FHIRAllTypes'list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText FHIRAllTypes'list_DocumentManifest = "DocumentManifest"
    simpleTypeText FHIRAllTypes'list_DocumentReference = "DocumentReference"
    simpleTypeText FHIRAllTypes'list_DomainResource = "DomainResource"
    simpleTypeText FHIRAllTypes'list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText FHIRAllTypes'list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText FHIRAllTypes'list_Encounter = "Encounter"
    simpleTypeText FHIRAllTypes'list_Endpoint = "Endpoint"
    simpleTypeText FHIRAllTypes'list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText FHIRAllTypes'list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText FHIRAllTypes'list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText FHIRAllTypes'list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText FHIRAllTypes'list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText FHIRAllTypes'list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText FHIRAllTypes'list_Flag = "Flag"
    simpleTypeText FHIRAllTypes'list_Goal = "Goal"
    simpleTypeText FHIRAllTypes'list_GraphDefinition = "GraphDefinition"
    simpleTypeText FHIRAllTypes'list_Group = "Group"
    simpleTypeText FHIRAllTypes'list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText FHIRAllTypes'list_HealthcareService = "HealthcareService"
    simpleTypeText FHIRAllTypes'list_ImagingManifest = "ImagingManifest"
    simpleTypeText FHIRAllTypes'list_ImagingStudy = "ImagingStudy"
    simpleTypeText FHIRAllTypes'list_Immunization = "Immunization"
    simpleTypeText FHIRAllTypes'list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText FHIRAllTypes'list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText FHIRAllTypes'list_Library = "Library"
    simpleTypeText FHIRAllTypes'list_Linkage = "Linkage"
    simpleTypeText FHIRAllTypes'list_List = "List"
    simpleTypeText FHIRAllTypes'list_Location = "Location"
    simpleTypeText FHIRAllTypes'list_Measure = "Measure"
    simpleTypeText FHIRAllTypes'list_MeasureReport = "MeasureReport"
    simpleTypeText FHIRAllTypes'list_Media = "Media"
    simpleTypeText FHIRAllTypes'list_Medication = "Medication"
    simpleTypeText FHIRAllTypes'list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText FHIRAllTypes'list_MedicationDispense = "MedicationDispense"
    simpleTypeText FHIRAllTypes'list_MedicationRequest = "MedicationRequest"
    simpleTypeText FHIRAllTypes'list_MedicationStatement = "MedicationStatement"
    simpleTypeText FHIRAllTypes'list_MessageDefinition = "MessageDefinition"
    simpleTypeText FHIRAllTypes'list_MessageHeader = "MessageHeader"
    simpleTypeText FHIRAllTypes'list_NamingSystem = "NamingSystem"
    simpleTypeText FHIRAllTypes'list_NutritionOrder = "NutritionOrder"
    simpleTypeText FHIRAllTypes'list_Observation = "Observation"
    simpleTypeText FHIRAllTypes'list_OperationDefinition = "OperationDefinition"
    simpleTypeText FHIRAllTypes'list_OperationOutcome = "OperationOutcome"
    simpleTypeText FHIRAllTypes'list_Organization = "Organization"
    simpleTypeText FHIRAllTypes'list_Parameters = "Parameters"
    simpleTypeText FHIRAllTypes'list_Patient = "Patient"
    simpleTypeText FHIRAllTypes'list_PaymentNotice = "PaymentNotice"
    simpleTypeText FHIRAllTypes'list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText FHIRAllTypes'list_Person = "Person"
    simpleTypeText FHIRAllTypes'list_PlanDefinition = "PlanDefinition"
    simpleTypeText FHIRAllTypes'list_Practitioner = "Practitioner"
    simpleTypeText FHIRAllTypes'list_PractitionerRole = "PractitionerRole"
    simpleTypeText FHIRAllTypes'list_Procedure = "Procedure"
    simpleTypeText FHIRAllTypes'list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText FHIRAllTypes'list_ProcessRequest = "ProcessRequest"
    simpleTypeText FHIRAllTypes'list_ProcessResponse = "ProcessResponse"
    simpleTypeText FHIRAllTypes'list_Provenance = "Provenance"
    simpleTypeText FHIRAllTypes'list_Questionnaire = "Questionnaire"
    simpleTypeText FHIRAllTypes'list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText FHIRAllTypes'list_ReferralRequest = "ReferralRequest"
    simpleTypeText FHIRAllTypes'list_RelatedPerson = "RelatedPerson"
    simpleTypeText FHIRAllTypes'list_RequestGroup = "RequestGroup"
    simpleTypeText FHIRAllTypes'list_ResearchStudy = "ResearchStudy"
    simpleTypeText FHIRAllTypes'list_ResearchSubject = "ResearchSubject"
    simpleTypeText FHIRAllTypes'list_Resource = "Resource"
    simpleTypeText FHIRAllTypes'list_RiskAssessment = "RiskAssessment"
    simpleTypeText FHIRAllTypes'list_Schedule = "Schedule"
    simpleTypeText FHIRAllTypes'list_SearchParameter = "SearchParameter"
    simpleTypeText FHIRAllTypes'list_Sequence = "Sequence"
    simpleTypeText FHIRAllTypes'list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText FHIRAllTypes'list_Slot = "Slot"
    simpleTypeText FHIRAllTypes'list_Specimen = "Specimen"
    simpleTypeText FHIRAllTypes'list_StructureDefinition = "StructureDefinition"
    simpleTypeText FHIRAllTypes'list_StructureMap = "StructureMap"
    simpleTypeText FHIRAllTypes'list_Subscription = "Subscription"
    simpleTypeText FHIRAllTypes'list_Substance = "Substance"
    simpleTypeText FHIRAllTypes'list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText FHIRAllTypes'list_SupplyRequest = "SupplyRequest"
    simpleTypeText FHIRAllTypes'list_Task = "Task"
    simpleTypeText FHIRAllTypes'list_TestReport = "TestReport"
    simpleTypeText FHIRAllTypes'list_TestScript = "TestScript"
    simpleTypeText FHIRAllTypes'list_ValueSet = "ValueSet"
    simpleTypeText FHIRAllTypes'list_VisionPrescription = "VisionPrescription"
    simpleTypeText FHIRAllTypes'list_Type = "Type"
    simpleTypeText FHIRAllTypes'list_Any = "Any"
 
data FHIRAllTypes = FHIRAllTypes
        { fHIRAllTypes_id :: Maybe String'primitive
        , fHIRAllTypes_value :: Maybe FHIRAllTypes'list
        , fHIRAllTypes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRAllTypes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRAllTypes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRAllTypes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRAllTypes_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRAllTypes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRAllTypes_extension x
            ]
instance Extension FHIRAllTypes Element where
    supertype (FHIRAllTypes a0 a1 e0) =
               Element a0 e0
 
data OperationParameterUse'list
    = OperationParameterUse'list_In
      -- ^ In
    | OperationParameterUse'list_Out
      -- ^ Out
    deriving (Eq,Show,Enum)
instance SchemaType OperationParameterUse'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType OperationParameterUse'list where
    acceptingParser =  do literal "in"; return OperationParameterUse'list_In
                      `onFail` do literal "out"; return OperationParameterUse'list_Out
                      
    simpleTypeText OperationParameterUse'list_In = "in"
    simpleTypeText OperationParameterUse'list_Out = "out"
 
data OperationParameterUse = OperationParameterUse
        { operationParameterUse_id :: Maybe String'primitive
        , operationParameterUse_value :: Maybe OperationParameterUse'list
        , operationParameterUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType OperationParameterUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (OperationParameterUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@OperationParameterUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationParameterUse_id x
                       , maybe [] (toXMLAttribute "value") $ operationParameterUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationParameterUse_extension x
            ]
instance Extension OperationParameterUse Element where
    supertype (OperationParameterUse a0 a1 e0) =
               Element a0 e0
 
data OperationKind'list
    = OperationKind'list_Operation
      -- ^ Operation
    | OperationKind'list_Query
      -- ^ Query
    deriving (Eq,Show,Enum)
instance SchemaType OperationKind'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType OperationKind'list where
    acceptingParser =  do literal "operation"; return OperationKind'list_Operation
                      `onFail` do literal "query"; return OperationKind'list_Query
                      
    simpleTypeText OperationKind'list_Operation = "operation"
    simpleTypeText OperationKind'list_Query = "query"
 
data OperationKind = OperationKind
        { operationKind_id :: Maybe String'primitive
        , operationKind_value :: Maybe OperationKind'list
        , operationKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType OperationKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (OperationKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@OperationKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationKind_id x
                       , maybe [] (toXMLAttribute "value") $ operationKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationKind_extension x
            ]
instance Extension OperationKind Element where
    supertype (OperationKind a0 a1 e0) =
               Element a0 e0
 
-- | A collection of error, warning or information messages that 
--   result from a system action.
elementOperationOutcome :: XMLParser OperationOutcome
elementOperationOutcome = parseSchemaType "OperationOutcome"
elementToXMLOperationOutcome :: OperationOutcome -> [Content ()]
elementToXMLOperationOutcome = schemaTypeToXML "OperationOutcome"
 
data OperationOutcome = OperationOutcome
        { operationOutcome_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , operationOutcome_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , operationOutcome_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , operationOutcome_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , operationOutcome_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , operationOutcome_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , operationOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationOutcome_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationOutcome_issue :: [OperationOutcome'Issue]
          -- ^ An error, warning or information message that results from 
          --   a system action.
        }
        deriving (Eq,Show)
instance SchemaType OperationOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return OperationOutcome
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "issue")
    schemaTypeToXML s x@OperationOutcome{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ operationOutcome_id x
            , maybe [] (schemaTypeToXML "meta") $ operationOutcome_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ operationOutcome_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ operationOutcome_language x
            , maybe [] (schemaTypeToXML "text") $ operationOutcome_text x
            , concatMap (schemaTypeToXML "contained") $ operationOutcome_contained x
            , concatMap (schemaTypeToXML "extension") $ operationOutcome_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationOutcome_modifierExtension x
            , concatMap (schemaTypeToXML "issue") $ operationOutcome_issue x
            ]
instance Extension OperationOutcome DomainResource where
    supertype (OperationOutcome e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension OperationOutcome Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: OperationOutcome -> DomainResource)
              
 
-- | A collection of error, warning or information messages that 
--   result from a system action.
data OperationOutcome'Issue = OperationOutcome'Issue
        { operationOutcome'Issue_id :: Maybe String'primitive
        , operationOutcome'Issue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationOutcome'Issue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationOutcome'Issue_severity :: IssueSeverity
          -- ^ Indicates whether the issue indicates a variation from 
          --   successful processing.
        , operationOutcome'Issue_code :: IssueType
          -- ^ Describes the type of the issue. The system that creates an 
          --   OperationOutcome SHALL choose the most applicable code from 
          --   the IssueType value set, and may additional provide its own 
          --   code for the error in the details element.
        , operationOutcome'Issue_details :: Maybe CodeableConcept
          -- ^ Additional details about the error. This may be a text 
          --   description of the error, or a system code that identifies 
          --   the error.
        , operationOutcome'Issue_diagnostics :: Maybe Xsd.XsdString
          -- ^ Additional diagnostic information about the issue. 
          --   Typically, this may be a description of how a value is 
          --   erroneous, or a stack dump to help trace the issue.
        , operationOutcome'Issue_location :: [Xsd.XsdString]
          -- ^ For resource issues, this will be a simple XPath limited to 
          --   element names, repetition indicators and the default child 
          --   access that identifies one of the elements in the resource 
          --   that caused this issue to be raised. For HTTP errors, will 
          --   be &quot;http.&quot; + the parameter name.
        , operationOutcome'Issue_expression :: [Xsd.XsdString]
          -- ^ A simple FHIRPath limited to element names, repetition 
          --   indicators and the default child access that identifies one 
          --   of the elements in the resource that caused this issue to 
          --   be raised.
        }
        deriving (Eq,Show)
instance SchemaType OperationOutcome'Issue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationOutcome'Issue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "severity"
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "details")
            `apply` optional (parseSchemaType "diagnostics")
            `apply` many (parseSchemaType "location")
            `apply` many (parseSchemaType "expression")
    schemaTypeToXML s x@OperationOutcome'Issue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationOutcome'Issue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationOutcome'Issue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationOutcome'Issue_modifierExtension x
            , schemaTypeToXML "severity" $ operationOutcome'Issue_severity x
            , schemaTypeToXML "code" $ operationOutcome'Issue_code x
            , maybe [] (schemaTypeToXML "details") $ operationOutcome'Issue_details x
            , maybe [] (schemaTypeToXML "diagnostics") $ operationOutcome'Issue_diagnostics x
            , concatMap (schemaTypeToXML "location") $ operationOutcome'Issue_location x
            , concatMap (schemaTypeToXML "expression") $ operationOutcome'Issue_expression x
            ]
instance Extension OperationOutcome'Issue BackboneElement where
    supertype (OperationOutcome'Issue a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension OperationOutcome'Issue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationOutcome'Issue -> BackboneElement)
              
 
data IssueType'list
    = IssueType'list_Invalid
      -- ^ Invalid Content
    | IssueType'list_Structure
      -- ^ Structural Issue
    | IssueType'list_Required
      -- ^ Required element missing
    | IssueType'list_Value
      -- ^ Element value invalid
    | IssueType'list_Invariant
      -- ^ Validation rule failed
    | IssueType'list_Security
      -- ^ Security Problem
    | IssueType'list_Login
      -- ^ Login Required
    | IssueType'list_Unknown
      -- ^ Unknown User
    | IssueType'list_Expired
      -- ^ Session Expired
    | IssueType'list_Forbidden
      -- ^ Forbidden
    | IssueType'list_Suppressed
      -- ^ Information Suppressed
    | IssueType'list_Processing
      -- ^ Processing Failure
    | IssueType'list_Not'supported
      -- ^ Content not supported
    | IssueType'list_Duplicate
      -- ^ Duplicate
    | IssueType'list_Not'found
      -- ^ Not Found
    | IssueType'list_Too'long
      -- ^ Content Too Long
    | IssueType'list_Code'invalid
      -- ^ Invalid Code
    | IssueType'list_Extension
      -- ^ Unacceptable Extension
    | IssueType'list_Too'costly
      -- ^ Operation Too Costly
    | IssueType'list_Business'rule
      -- ^ Business Rule Violation
    | IssueType'list_Conflict
      -- ^ Edit Version Conflict
    | IssueType'list_Incomplete
      -- ^ Incomplete Results
    | IssueType'list_Transient
      -- ^ Transient Issue
    | IssueType'list_Lock'error
      -- ^ Lock Error
    | IssueType'list_No'store
      -- ^ No Store Available
    | IssueType'list_Exception
      -- ^ Exception
    | IssueType'list_Timeout
      -- ^ Timeout
    | IssueType'list_Throttled
      -- ^ Throttled
    | IssueType'list_Informational
      -- ^ Informational Note
    deriving (Eq,Show,Enum)
instance SchemaType IssueType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IssueType'list where
    acceptingParser =  do literal "invalid"; return IssueType'list_Invalid
                      `onFail` do literal "structure"; return IssueType'list_Structure
                      `onFail` do literal "required"; return IssueType'list_Required
                      `onFail` do literal "value"; return IssueType'list_Value
                      `onFail` do literal "invariant"; return IssueType'list_Invariant
                      `onFail` do literal "security"; return IssueType'list_Security
                      `onFail` do literal "login"; return IssueType'list_Login
                      `onFail` do literal "unknown"; return IssueType'list_Unknown
                      `onFail` do literal "expired"; return IssueType'list_Expired
                      `onFail` do literal "forbidden"; return IssueType'list_Forbidden
                      `onFail` do literal "suppressed"; return IssueType'list_Suppressed
                      `onFail` do literal "processing"; return IssueType'list_Processing
                      `onFail` do literal "not-supported"; return IssueType'list_Not'supported
                      `onFail` do literal "duplicate"; return IssueType'list_Duplicate
                      `onFail` do literal "not-found"; return IssueType'list_Not'found
                      `onFail` do literal "too-long"; return IssueType'list_Too'long
                      `onFail` do literal "code-invalid"; return IssueType'list_Code'invalid
                      `onFail` do literal "extension"; return IssueType'list_Extension
                      `onFail` do literal "too-costly"; return IssueType'list_Too'costly
                      `onFail` do literal "business-rule"; return IssueType'list_Business'rule
                      `onFail` do literal "conflict"; return IssueType'list_Conflict
                      `onFail` do literal "incomplete"; return IssueType'list_Incomplete
                      `onFail` do literal "transient"; return IssueType'list_Transient
                      `onFail` do literal "lock-error"; return IssueType'list_Lock'error
                      `onFail` do literal "no-store"; return IssueType'list_No'store
                      `onFail` do literal "exception"; return IssueType'list_Exception
                      `onFail` do literal "timeout"; return IssueType'list_Timeout
                      `onFail` do literal "throttled"; return IssueType'list_Throttled
                      `onFail` do literal "informational"; return IssueType'list_Informational
                      
    simpleTypeText IssueType'list_Invalid = "invalid"
    simpleTypeText IssueType'list_Structure = "structure"
    simpleTypeText IssueType'list_Required = "required"
    simpleTypeText IssueType'list_Value = "value"
    simpleTypeText IssueType'list_Invariant = "invariant"
    simpleTypeText IssueType'list_Security = "security"
    simpleTypeText IssueType'list_Login = "login"
    simpleTypeText IssueType'list_Unknown = "unknown"
    simpleTypeText IssueType'list_Expired = "expired"
    simpleTypeText IssueType'list_Forbidden = "forbidden"
    simpleTypeText IssueType'list_Suppressed = "suppressed"
    simpleTypeText IssueType'list_Processing = "processing"
    simpleTypeText IssueType'list_Not'supported = "not-supported"
    simpleTypeText IssueType'list_Duplicate = "duplicate"
    simpleTypeText IssueType'list_Not'found = "not-found"
    simpleTypeText IssueType'list_Too'long = "too-long"
    simpleTypeText IssueType'list_Code'invalid = "code-invalid"
    simpleTypeText IssueType'list_Extension = "extension"
    simpleTypeText IssueType'list_Too'costly = "too-costly"
    simpleTypeText IssueType'list_Business'rule = "business-rule"
    simpleTypeText IssueType'list_Conflict = "conflict"
    simpleTypeText IssueType'list_Incomplete = "incomplete"
    simpleTypeText IssueType'list_Transient = "transient"
    simpleTypeText IssueType'list_Lock'error = "lock-error"
    simpleTypeText IssueType'list_No'store = "no-store"
    simpleTypeText IssueType'list_Exception = "exception"
    simpleTypeText IssueType'list_Timeout = "timeout"
    simpleTypeText IssueType'list_Throttled = "throttled"
    simpleTypeText IssueType'list_Informational = "informational"
 
data IssueType = IssueType
        { issueType_id :: Maybe String'primitive
        , issueType_value :: Maybe IssueType'list
        , issueType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IssueType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IssueType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IssueType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ issueType_id x
                       , maybe [] (toXMLAttribute "value") $ issueType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ issueType_extension x
            ]
instance Extension IssueType Element where
    supertype (IssueType a0 a1 e0) =
               Element a0 e0
 
data IssueSeverity'list
    = IssueSeverity'list_Fatal
      -- ^ Fatal
    | IssueSeverity'list_Error
      -- ^ Error
    | IssueSeverity'list_Warning
      -- ^ Warning
    | IssueSeverity'list_Information
      -- ^ Information
    deriving (Eq,Show,Enum)
instance SchemaType IssueSeverity'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IssueSeverity'list where
    acceptingParser =  do literal "fatal"; return IssueSeverity'list_Fatal
                      `onFail` do literal "error"; return IssueSeverity'list_Error
                      `onFail` do literal "warning"; return IssueSeverity'list_Warning
                      `onFail` do literal "information"; return IssueSeverity'list_Information
                      
    simpleTypeText IssueSeverity'list_Fatal = "fatal"
    simpleTypeText IssueSeverity'list_Error = "error"
    simpleTypeText IssueSeverity'list_Warning = "warning"
    simpleTypeText IssueSeverity'list_Information = "information"
 
data IssueSeverity = IssueSeverity
        { issueSeverity_id :: Maybe String'primitive
        , issueSeverity_value :: Maybe IssueSeverity'list
        , issueSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IssueSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IssueSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IssueSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ issueSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ issueSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ issueSeverity_extension x
            ]
instance Extension IssueSeverity Element where
    supertype (IssueSeverity a0 a1 e0) =
               Element a0 e0
 
-- | A formally or informally recognized grouping of people or 
--   organizations formed for the purpose of achieving some form 
--   of collective action. Includes companies, institutions, 
--   corporations, departments, community groups, healthcare 
--   practice groups, etc.
elementOrganization :: XMLParser Organization
elementOrganization = parseSchemaType "Organization"
elementToXMLOrganization :: Organization -> [Content ()]
elementToXMLOrganization = schemaTypeToXML "Organization"
 
data Organization = Organization
        { organization_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , organization_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , organization_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , organization_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , organization_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , organization_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , organization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , organization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , organization_identifier :: [Identifier]
          -- ^ Identifier for the organization that is used to identify 
          --   the organization across multiple disparate systems.
        , organization_active :: Maybe Boolean
          -- ^ Whether the organization's record is still in active use.
        , organization_type :: [CodeableConcept]
          -- ^ The kind(s) of organization that this is.
        , organization_name :: Maybe Xsd.XsdString
          -- ^ A name associated with the organization.
        , organization_alias :: [Xsd.XsdString]
          -- ^ A list of alternate names that the organization is known 
          --   as, or was known as in the past.
        , organization_telecom :: [ContactPoint]
          -- ^ A contact detail for the organization.
        , organization_address :: [Address]
          -- ^ An address for the organization.
        , organization_partOf :: Maybe Reference
          -- ^ The organization of which this organization forms a part.
        , organization_contact :: [Organization'Contact]
          -- ^ Contact for the organization for a certain purpose.
        , organization_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the organization.
        }
        deriving (Eq,Show)
instance SchemaType Organization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Organization
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "alias")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "partOf")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@Organization{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ organization_id x
            , maybe [] (schemaTypeToXML "meta") $ organization_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ organization_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ organization_language x
            , maybe [] (schemaTypeToXML "text") $ organization_text x
            , concatMap (schemaTypeToXML "contained") $ organization_contained x
            , concatMap (schemaTypeToXML "extension") $ organization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ organization_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ organization_identifier x
            , maybe [] (schemaTypeToXML "active") $ organization_active x
            , concatMap (schemaTypeToXML "type") $ organization_type x
            , maybe [] (schemaTypeToXML "name") $ organization_name x
            , concatMap (schemaTypeToXML "alias") $ organization_alias x
            , concatMap (schemaTypeToXML "telecom") $ organization_telecom x
            , concatMap (schemaTypeToXML "address") $ organization_address x
            , maybe [] (schemaTypeToXML "partOf") $ organization_partOf x
            , concatMap (schemaTypeToXML "contact") $ organization_contact x
            , concatMap (schemaTypeToXML "endpoint") $ organization_endpoint x
            ]
instance Extension Organization DomainResource where
    supertype (Organization e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Organization Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Organization -> DomainResource)
              
 
-- | A formally or informally recognized grouping of people or 
--   organizations formed for the purpose of achieving some form 
--   of collective action. Includes companies, institutions, 
--   corporations, departments, community groups, healthcare 
--   practice groups, etc.
data Organization'Contact = Organization'Contact
        { organization'Contact_id :: Maybe String'primitive
        , organization'Contact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , organization'Contact_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , organization'Contact_purpose :: Maybe CodeableConcept
          -- ^ Indicates a purpose for which the contact can be reached.
        , organization'Contact_name :: Maybe HumanName
          -- ^ A name associated with the contact.
        , organization'Contact_telecom :: [ContactPoint]
          -- ^ A contact detail (e.g. a telephone number or an email 
          --   address) by which the party may be contacted.
        , organization'Contact_address :: Maybe Address
          -- ^ Visiting or postal addresses for the contact.
        }
        deriving (Eq,Show)
instance SchemaType Organization'Contact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Organization'Contact a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
    schemaTypeToXML s x@Organization'Contact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ organization'Contact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ organization'Contact_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ organization'Contact_modifierExtension x
            , maybe [] (schemaTypeToXML "purpose") $ organization'Contact_purpose x
            , maybe [] (schemaTypeToXML "name") $ organization'Contact_name x
            , concatMap (schemaTypeToXML "telecom") $ organization'Contact_telecom x
            , maybe [] (schemaTypeToXML "address") $ organization'Contact_address x
            ]
instance Extension Organization'Contact BackboneElement where
    supertype (Organization'Contact a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Organization'Contact Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Organization'Contact -> BackboneElement)
              
 
-- | This special resource type is used to represent an 
--   operation request and response (operations.html). It has no 
--   other use, and there is no RESTful endpoint associated with 
--   it.
elementParameters :: XMLParser Parameters
elementParameters = parseSchemaType "Parameters"
elementToXMLParameters :: Parameters -> [Content ()]
elementToXMLParameters = schemaTypeToXML "Parameters"
 
data Parameters = Parameters
        { parameters_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , parameters_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , parameters_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , parameters_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , parameters_parameter :: [Parameters'Parameter]
          -- ^ A parameter passed to or received from the operation.
        }
        deriving (Eq,Show)
instance SchemaType Parameters where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Parameters
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` many (parseSchemaType "parameter")
    schemaTypeToXML s x@Parameters{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ parameters_id x
            , maybe [] (schemaTypeToXML "meta") $ parameters_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ parameters_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ parameters_language x
            , concatMap (schemaTypeToXML "parameter") $ parameters_parameter x
            ]
instance Extension Parameters Resource where
    supertype (Parameters e0 e1 e2 e3 e4) =
               Resource e0 e1 e2 e3
 
-- | This special resource type is used to represent an 
--   operation request and response (operations.html). It has no 
--   other use, and there is no RESTful endpoint associated with 
--   it.
data Parameters'Parameter = Parameters'Parameter
        { parameters'Parameter_id :: Maybe String'primitive
        , parameters'Parameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , parameters'Parameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , parameters'Parameter_name :: Xsd.XsdString
          -- ^ The name of the parameter (reference to the operation 
          --   definition).
        , parameters'Parameter_choice3 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ If the parameter is a data type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        , parameters'Parameter_resource :: Maybe ResourceContainer
          -- ^ If the parameter is a whole resource.
        , parameters'Parameter_part :: [Parameters'Parameter]
          -- ^ A named part of a multi-part parameter.
        }
        deriving (Eq,Show)
instance SchemaType Parameters'Parameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Parameters'Parameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                                     ])
            `apply` optional (parseSchemaType "resource")
            `apply` many (parseSchemaType "part")
    schemaTypeToXML s x@Parameters'Parameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ parameters'Parameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ parameters'Parameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ parameters'Parameter_modifierExtension x
            , schemaTypeToXML "name" $ parameters'Parameter_name x
            , maybe [] (foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueCode")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueId")
                                     (schemaTypeToXML "valueInstant")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueMarkdown")
                                     (schemaTypeToXML "valueOid")
                                     (schemaTypeToXML "valuePositiveInt")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueUnsignedInt")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAddress")
                                     (schemaTypeToXML "valueAge")
                                     (schemaTypeToXML "valueAnnotation")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueContactPoint")
                                     (schemaTypeToXML "valueCount")
                                     (schemaTypeToXML "valueDistance")
                                     (schemaTypeToXML "valueDuration")
                                     (schemaTypeToXML "valueHumanName")
                                     (schemaTypeToXML "valueIdentifier")
                                     (schemaTypeToXML "valueMoney")
                                     (schemaTypeToXML "valuePeriod")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueReference")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueSignature")
                                     (schemaTypeToXML "valueTiming")
                                     (schemaTypeToXML "valueMeta")
                                    ) $ parameters'Parameter_choice3 x
            , maybe [] (schemaTypeToXML "resource") $ parameters'Parameter_resource x
            , concatMap (schemaTypeToXML "part") $ parameters'Parameter_part x
            ]
instance Extension Parameters'Parameter BackboneElement where
    supertype (Parameters'Parameter a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Parameters'Parameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Parameters'Parameter -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
elementPatient :: XMLParser Patient
elementPatient = parseSchemaType "Patient"
elementToXMLPatient :: Patient -> [Content ()]
elementToXMLPatient = schemaTypeToXML "Patient"
 
data Patient = Patient
        { patient_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , patient_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , patient_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , patient_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , patient_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , patient_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , patient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient_identifier :: [Identifier]
          -- ^ An identifier for this patient.
        , patient_active :: Maybe Boolean
          -- ^ Whether this patient record is in active use.
        , patient_name :: [HumanName]
          -- ^ A name associated with the individual.
        , patient_telecom :: [ContactPoint]
          -- ^ A contact detail (e.g. a telephone number or an email 
          --   address) by which the individual may be contacted.
        , patient_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the patient is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , patient_birthDate :: Maybe Date
          -- ^ The date of birth for the individual.
        , patient_choice14 :: (Maybe (OneOf2 Boolean DateTime))
          -- ^ Indicates if the individual is deceased or not.
          --   
          --   Choice between:
          --   
          --   (1) deceasedBoolean
          --   
          --   (2) deceasedDateTime
        , patient_address :: [Address]
          -- ^ Addresses for the individual.
        , patient_maritalStatus :: Maybe CodeableConcept
          -- ^ This field contains a patient's most recent marital (civil) 
          --   status.
        , patient_choice17 :: (Maybe (OneOf2 Boolean Integer))
          -- ^ Indicates whether the patient is part of a multiple (bool) 
          --   or indicates the actual birth order (integer).
          --   
          --   Choice between:
          --   
          --   (1) multipleBirthBoolean
          --   
          --   (2) multipleBirthInteger
        , patient_photo :: [Attachment]
          -- ^ Image of the patient.
        , patient_contact :: [Patient'Contact]
          -- ^ A contact party (e.g. guardian, partner, friend) for the 
          --   patient.
        , patient_animal :: Maybe Patient'Animal
          -- ^ This patient is known to be an animal.
        , patient_communication :: [Patient'Communication]
          -- ^ Languages which may be used to communicate with the patient 
          --   about his or her health.
        , patient_generalPractitioner :: [Reference]
          -- ^ Patient's nominated care provider.
        , patient_managingOrganization :: Maybe Reference
          -- ^ Organization that is the custodian of the patient record.
        , patient_link :: [Patient'Link]
          -- ^ Link to another patient resource that concerns the same 
          --   actual patient.
        }
        deriving (Eq,Show)
instance SchemaType Patient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Patient
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "deceasedBoolean"))
                                     , ("DateTime", fmap TwoOf2 (parseSchemaType "deceasedDateTime"))
                                     ])
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "maritalStatus")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "multipleBirthBoolean"))
                                     , ("Integer", fmap TwoOf2 (parseSchemaType "multipleBirthInteger"))
                                     ])
            `apply` many (parseSchemaType "photo")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "animal")
            `apply` many (parseSchemaType "communication")
            `apply` many (parseSchemaType "generalPractitioner")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@Patient{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ patient_id x
            , maybe [] (schemaTypeToXML "meta") $ patient_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ patient_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ patient_language x
            , maybe [] (schemaTypeToXML "text") $ patient_text x
            , concatMap (schemaTypeToXML "contained") $ patient_contained x
            , concatMap (schemaTypeToXML "extension") $ patient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ patient_identifier x
            , maybe [] (schemaTypeToXML "active") $ patient_active x
            , concatMap (schemaTypeToXML "name") $ patient_name x
            , concatMap (schemaTypeToXML "telecom") $ patient_telecom x
            , maybe [] (schemaTypeToXML "gender") $ patient_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ patient_birthDate x
            , maybe [] (foldOneOf2  (schemaTypeToXML "deceasedBoolean")
                                    (schemaTypeToXML "deceasedDateTime")
                                   ) $ patient_choice14 x
            , concatMap (schemaTypeToXML "address") $ patient_address x
            , maybe [] (schemaTypeToXML "maritalStatus") $ patient_maritalStatus x
            , maybe [] (foldOneOf2  (schemaTypeToXML "multipleBirthBoolean")
                                    (schemaTypeToXML "multipleBirthInteger")
                                   ) $ patient_choice17 x
            , concatMap (schemaTypeToXML "photo") $ patient_photo x
            , concatMap (schemaTypeToXML "contact") $ patient_contact x
            , maybe [] (schemaTypeToXML "animal") $ patient_animal x
            , concatMap (schemaTypeToXML "communication") $ patient_communication x
            , concatMap (schemaTypeToXML "generalPractitioner") $ patient_generalPractitioner x
            , maybe [] (schemaTypeToXML "managingOrganization") $ patient_managingOrganization x
            , concatMap (schemaTypeToXML "link") $ patient_link x
            ]
instance Extension Patient DomainResource where
    supertype (Patient e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Patient Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Patient -> DomainResource)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data Patient'Contact = Patient'Contact
        { patient'Contact_id :: Maybe String'primitive
        , patient'Contact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient'Contact_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient'Contact_relationship :: [CodeableConcept]
          -- ^ The nature of the relationship between the patient and the 
          --   contact person.
        , patient'Contact_name :: Maybe HumanName
          -- ^ A name associated with the contact person.
        , patient'Contact_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , patient'Contact_address :: Maybe Address
          -- ^ Address for the contact person.
        , patient'Contact_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the contact person 
          --   is considered to have for administration and record keeping 
          --   purposes.
        , patient'Contact_organization :: Maybe Reference
          -- ^ Organization on behalf of which the contact is acting or 
          --   for which the contact is working.
        , patient'Contact_period :: Maybe Period
          -- ^ The period during which this contact person or organization 
          --   is valid to be contacted relating to this patient.
        }
        deriving (Eq,Show)
instance SchemaType Patient'Contact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Patient'Contact a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Patient'Contact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patient'Contact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patient'Contact_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient'Contact_modifierExtension x
            , concatMap (schemaTypeToXML "relationship") $ patient'Contact_relationship x
            , maybe [] (schemaTypeToXML "name") $ patient'Contact_name x
            , concatMap (schemaTypeToXML "telecom") $ patient'Contact_telecom x
            , maybe [] (schemaTypeToXML "address") $ patient'Contact_address x
            , maybe [] (schemaTypeToXML "gender") $ patient'Contact_gender x
            , maybe [] (schemaTypeToXML "organization") $ patient'Contact_organization x
            , maybe [] (schemaTypeToXML "period") $ patient'Contact_period x
            ]
instance Extension Patient'Contact BackboneElement where
    supertype (Patient'Contact a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension Patient'Contact Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Patient'Contact -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data Patient'Animal = Patient'Animal
        { patient'Animal_id :: Maybe String'primitive
        , patient'Animal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient'Animal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient'Animal_species :: CodeableConcept
          -- ^ Identifies the high level taxonomic categorization of the 
          --   kind of animal.
        , patient'Animal_breed :: Maybe CodeableConcept
          -- ^ Identifies the detailed categorization of the kind of 
          --   animal.
        , patient'Animal_genderStatus :: Maybe CodeableConcept
          -- ^ Indicates the current state of the animal's reproductive 
          --   organs.
        }
        deriving (Eq,Show)
instance SchemaType Patient'Animal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Patient'Animal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "species"
            `apply` optional (parseSchemaType "breed")
            `apply` optional (parseSchemaType "genderStatus")
    schemaTypeToXML s x@Patient'Animal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patient'Animal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patient'Animal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient'Animal_modifierExtension x
            , schemaTypeToXML "species" $ patient'Animal_species x
            , maybe [] (schemaTypeToXML "breed") $ patient'Animal_breed x
            , maybe [] (schemaTypeToXML "genderStatus") $ patient'Animal_genderStatus x
            ]
instance Extension Patient'Animal BackboneElement where
    supertype (Patient'Animal a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Patient'Animal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Patient'Animal -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data Patient'Communication = Patient'Communication
        { patient'Communication_id :: Maybe String'primitive
        , patient'Communication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient'Communication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient'Communication_language :: CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        , patient'Communication_preferred :: Maybe Boolean
          -- ^ Indicates whether or not the patient prefers this language 
          --   (over other languages he masters up a certain level).
        }
        deriving (Eq,Show)
instance SchemaType Patient'Communication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Patient'Communication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "language"
            `apply` optional (parseSchemaType "preferred")
    schemaTypeToXML s x@Patient'Communication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patient'Communication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patient'Communication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient'Communication_modifierExtension x
            , schemaTypeToXML "language" $ patient'Communication_language x
            , maybe [] (schemaTypeToXML "preferred") $ patient'Communication_preferred x
            ]
instance Extension Patient'Communication BackboneElement where
    supertype (Patient'Communication a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Patient'Communication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Patient'Communication -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data Patient'Link = Patient'Link
        { patient'Link_id :: Maybe String'primitive
        , patient'Link_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient'Link_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient'Link_other :: Reference
          -- ^ The other patient resource that the link refers to.
        , patient'Link_type :: LinkType
          -- ^ The type of link between this patient resource and another 
          --   patient resource.
        }
        deriving (Eq,Show)
instance SchemaType Patient'Link where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Patient'Link a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "other"
            `apply` parseSchemaType "type"
    schemaTypeToXML s x@Patient'Link{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patient'Link_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patient'Link_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient'Link_modifierExtension x
            , schemaTypeToXML "other" $ patient'Link_other x
            , schemaTypeToXML "type" $ patient'Link_type x
            ]
instance Extension Patient'Link BackboneElement where
    supertype (Patient'Link a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Patient'Link Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Patient'Link -> BackboneElement)
              
 
data LinkType'list
    = LinkType'list_Replaced'by
    | LinkType'list_Replaces
      -- ^ Replaces
    | LinkType'list_Refer
    | LinkType'list_Seealso
    deriving (Eq,Show,Enum)
instance SchemaType LinkType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LinkType'list where
    acceptingParser =  do literal "replaced-by"; return LinkType'list_Replaced'by
                      `onFail` do literal "replaces"; return LinkType'list_Replaces
                      `onFail` do literal "refer"; return LinkType'list_Refer
                      `onFail` do literal "seealso"; return LinkType'list_Seealso
                      
    simpleTypeText LinkType'list_Replaced'by = "replaced-by"
    simpleTypeText LinkType'list_Replaces = "replaces"
    simpleTypeText LinkType'list_Refer = "refer"
    simpleTypeText LinkType'list_Seealso = "seealso"
 
data LinkType = LinkType
        { linkType_id :: Maybe String'primitive
        , linkType_value :: Maybe LinkType'list
        , linkType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LinkType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LinkType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LinkType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkType_id x
                       , maybe [] (toXMLAttribute "value") $ linkType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkType_extension x
            ]
instance Extension LinkType Element where
    supertype (LinkType a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the status of the payment for goods 
--   and services rendered, and the request and response 
--   resource references.
elementPaymentNotice :: XMLParser PaymentNotice
elementPaymentNotice = parseSchemaType "PaymentNotice"
elementToXMLPaymentNotice :: PaymentNotice -> [Content ()]
elementToXMLPaymentNotice = schemaTypeToXML "PaymentNotice"
 
data PaymentNotice = PaymentNotice
        { paymentNotice_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , paymentNotice_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , paymentNotice_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , paymentNotice_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , paymentNotice_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , paymentNotice_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , paymentNotice_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentNotice_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentNotice_identifier :: [Identifier]
          -- ^ The notice business identifier.
        , paymentNotice_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , paymentNotice_request :: Maybe Reference
          -- ^ Reference of resource for which payment is being made.
        , paymentNotice_response :: Maybe Reference
          -- ^ Reference of response to resource for which payment is 
          --   being made.
        , paymentNotice_statusDate :: Maybe Date
          -- ^ The date when the above payment action occurrred.
        , paymentNotice_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , paymentNotice_target :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , paymentNotice_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , paymentNotice_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , paymentNotice_paymentStatus :: Maybe CodeableConcept
          -- ^ The payment status, typically paid: payment sent, cleared: 
          --   payment received.
        }
        deriving (Eq,Show)
instance SchemaType PaymentNotice where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PaymentNotice
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "statusDate")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "paymentStatus")
    schemaTypeToXML s x@PaymentNotice{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ paymentNotice_id x
            , maybe [] (schemaTypeToXML "meta") $ paymentNotice_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ paymentNotice_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ paymentNotice_language x
            , maybe [] (schemaTypeToXML "text") $ paymentNotice_text x
            , concatMap (schemaTypeToXML "contained") $ paymentNotice_contained x
            , concatMap (schemaTypeToXML "extension") $ paymentNotice_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentNotice_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ paymentNotice_identifier x
            , maybe [] (schemaTypeToXML "status") $ paymentNotice_status x
            , maybe [] (schemaTypeToXML "request") $ paymentNotice_request x
            , maybe [] (schemaTypeToXML "response") $ paymentNotice_response x
            , maybe [] (schemaTypeToXML "statusDate") $ paymentNotice_statusDate x
            , maybe [] (schemaTypeToXML "created") $ paymentNotice_created x
            , maybe [] (schemaTypeToXML "target") $ paymentNotice_target x
            , maybe [] (schemaTypeToXML "provider") $ paymentNotice_provider x
            , maybe [] (schemaTypeToXML "organization") $ paymentNotice_organization x
            , maybe [] (schemaTypeToXML "paymentStatus") $ paymentNotice_paymentStatus x
            ]
instance Extension PaymentNotice DomainResource where
    supertype (PaymentNotice e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PaymentNotice Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PaymentNotice -> DomainResource)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
elementPaymentReconciliation :: XMLParser PaymentReconciliation
elementPaymentReconciliation = parseSchemaType "PaymentReconciliation"
elementToXMLPaymentReconciliation :: PaymentReconciliation -> [Content ()]
elementToXMLPaymentReconciliation = schemaTypeToXML "PaymentReconciliation"
 
data PaymentReconciliation = PaymentReconciliation
        { paymentReconciliation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , paymentReconciliation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , paymentReconciliation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , paymentReconciliation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , paymentReconciliation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , paymentReconciliation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , paymentReconciliation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliation_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , paymentReconciliation_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , paymentReconciliation_period :: Maybe Period
          -- ^ The period of time for which payments have been gathered 
          --   into this bulk payment for settlement.
        , paymentReconciliation_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , paymentReconciliation_organization :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , paymentReconciliation_request :: Maybe Reference
          -- ^ Original request resource reference.
        , paymentReconciliation_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete.
        , paymentReconciliation_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , paymentReconciliation_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , paymentReconciliation_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , paymentReconciliation_detail :: [PaymentReconciliation'Detail]
          -- ^ List of individual settlement amounts and the corresponding 
          --   transaction.
        , paymentReconciliation_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , paymentReconciliation_total :: Maybe Money
          -- ^ Total payment amount.
        , paymentReconciliation_processNote :: [PaymentReconciliation'ProcessNote]
          -- ^ Suite of notes.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PaymentReconciliation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` many (parseSchemaType "detail")
            `apply` optional (parseSchemaType "form")
            `apply` optional (parseSchemaType "total")
            `apply` many (parseSchemaType "processNote")
    schemaTypeToXML s x@PaymentReconciliation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ paymentReconciliation_id x
            , maybe [] (schemaTypeToXML "meta") $ paymentReconciliation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ paymentReconciliation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ paymentReconciliation_language x
            , maybe [] (schemaTypeToXML "text") $ paymentReconciliation_text x
            , concatMap (schemaTypeToXML "contained") $ paymentReconciliation_contained x
            , concatMap (schemaTypeToXML "extension") $ paymentReconciliation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ paymentReconciliation_identifier x
            , maybe [] (schemaTypeToXML "status") $ paymentReconciliation_status x
            , maybe [] (schemaTypeToXML "period") $ paymentReconciliation_period x
            , maybe [] (schemaTypeToXML "created") $ paymentReconciliation_created x
            , maybe [] (schemaTypeToXML "organization") $ paymentReconciliation_organization x
            , maybe [] (schemaTypeToXML "request") $ paymentReconciliation_request x
            , maybe [] (schemaTypeToXML "outcome") $ paymentReconciliation_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ paymentReconciliation_disposition x
            , maybe [] (schemaTypeToXML "requestProvider") $ paymentReconciliation_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ paymentReconciliation_requestOrganization x
            , concatMap (schemaTypeToXML "detail") $ paymentReconciliation_detail x
            , maybe [] (schemaTypeToXML "form") $ paymentReconciliation_form x
            , maybe [] (schemaTypeToXML "total") $ paymentReconciliation_total x
            , concatMap (schemaTypeToXML "processNote") $ paymentReconciliation_processNote x
            ]
instance Extension PaymentReconciliation DomainResource where
    supertype (PaymentReconciliation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PaymentReconciliation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PaymentReconciliation -> DomainResource)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
data PaymentReconciliation'Detail = PaymentReconciliation'Detail
        { paymentReconciliation'Detail_id :: Maybe String'primitive
        , paymentReconciliation'Detail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliation'Detail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliation'Detail_type :: CodeableConcept
          -- ^ Code to indicate the nature of the payment, adjustment, 
          --   funds advance, etc.
        , paymentReconciliation'Detail_request :: Maybe Reference
          -- ^ The claim or financial resource.
        , paymentReconciliation'Detail_response :: Maybe Reference
          -- ^ The claim response resource.
        , paymentReconciliation'Detail_submitter :: Maybe Reference
          -- ^ The Organization which submitted the claim or financial 
          --   transaction.
        , paymentReconciliation'Detail_payee :: Maybe Reference
          -- ^ The organization which is receiving the payment.
        , paymentReconciliation'Detail_date :: Maybe Date
          -- ^ The date of the invoice or financial resource.
        , paymentReconciliation'Detail_amount :: Maybe Money
          -- ^ Amount paid for this detail.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliation'Detail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PaymentReconciliation'Detail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "submitter")
            `apply` optional (parseSchemaType "payee")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@PaymentReconciliation'Detail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ paymentReconciliation'Detail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ paymentReconciliation'Detail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliation'Detail_modifierExtension x
            , schemaTypeToXML "type" $ paymentReconciliation'Detail_type x
            , maybe [] (schemaTypeToXML "request") $ paymentReconciliation'Detail_request x
            , maybe [] (schemaTypeToXML "response") $ paymentReconciliation'Detail_response x
            , maybe [] (schemaTypeToXML "submitter") $ paymentReconciliation'Detail_submitter x
            , maybe [] (schemaTypeToXML "payee") $ paymentReconciliation'Detail_payee x
            , maybe [] (schemaTypeToXML "date") $ paymentReconciliation'Detail_date x
            , maybe [] (schemaTypeToXML "amount") $ paymentReconciliation'Detail_amount x
            ]
instance Extension PaymentReconciliation'Detail BackboneElement where
    supertype (PaymentReconciliation'Detail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension PaymentReconciliation'Detail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PaymentReconciliation'Detail -> BackboneElement)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
data PaymentReconciliation'ProcessNote = PaymentReconciliation'ProcessNote
        { paymentReconciliation'ProcessNote_id :: Maybe String'primitive
        , paymentReconciliation'ProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliation'ProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliation'ProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , paymentReconciliation'ProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliation'ProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PaymentReconciliation'ProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@PaymentReconciliation'ProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ paymentReconciliation'ProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ paymentReconciliation'ProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliation'ProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ paymentReconciliation'ProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ paymentReconciliation'ProcessNote_text x
            ]
instance Extension PaymentReconciliation'ProcessNote BackboneElement where
    supertype (PaymentReconciliation'ProcessNote a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PaymentReconciliation'ProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PaymentReconciliation'ProcessNote -> BackboneElement)
              
 
-- | Demographics and administrative information about a person 
--   independent of a specific health-related context.
elementPerson :: XMLParser Person
elementPerson = parseSchemaType "Person"
elementToXMLPerson :: Person -> [Content ()]
elementToXMLPerson = schemaTypeToXML "Person"
 
data Person = Person
        { person_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , person_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , person_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , person_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , person_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , person_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , person_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , person_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , person_identifier :: [Identifier]
          -- ^ Identifier for a person within a particular scope.
        , person_name :: [HumanName]
          -- ^ A name associated with the person.
        , person_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , person_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender.
        , person_birthDate :: Maybe Date
          -- ^ The birth date for the person.
        , person_address :: [Address]
          -- ^ One or more addresses for the person.
        , person_photo :: Maybe Attachment
          -- ^ An image that can be displayed as a thumbnail of the person 
          --   to enhance the identification of the individual.
        , person_managingOrganization :: Maybe Reference
          -- ^ The organization that is the custodian of the person 
          --   record.
        , person_active :: Maybe Boolean
          -- ^ Whether this person's record is in active use.
        , person_link :: [Person'Link]
          -- ^ Link to a resource that concerns the same actual person.
        }
        deriving (Eq,Show)
instance SchemaType Person where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Person
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "photo")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@Person{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ person_id x
            , maybe [] (schemaTypeToXML "meta") $ person_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ person_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ person_language x
            , maybe [] (schemaTypeToXML "text") $ person_text x
            , concatMap (schemaTypeToXML "contained") $ person_contained x
            , concatMap (schemaTypeToXML "extension") $ person_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ person_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ person_identifier x
            , concatMap (schemaTypeToXML "name") $ person_name x
            , concatMap (schemaTypeToXML "telecom") $ person_telecom x
            , maybe [] (schemaTypeToXML "gender") $ person_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ person_birthDate x
            , concatMap (schemaTypeToXML "address") $ person_address x
            , maybe [] (schemaTypeToXML "photo") $ person_photo x
            , maybe [] (schemaTypeToXML "managingOrganization") $ person_managingOrganization x
            , maybe [] (schemaTypeToXML "active") $ person_active x
            , concatMap (schemaTypeToXML "link") $ person_link x
            ]
instance Extension Person DomainResource where
    supertype (Person e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Person Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Person -> DomainResource)
              
 
-- | Demographics and administrative information about a person 
--   independent of a specific health-related context.
data Person'Link = Person'Link
        { person'Link_id :: Maybe String'primitive
        , person'Link_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , person'Link_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , person'Link_target :: Reference
          -- ^ The resource to which this actual person is associated.
        , person'Link_assurance :: Maybe IdentityAssuranceLevel
          -- ^ Level of assurance that this link is actually associated 
          --   with the target resource.
        }
        deriving (Eq,Show)
instance SchemaType Person'Link where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Person'Link a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "target"
            `apply` optional (parseSchemaType "assurance")
    schemaTypeToXML s x@Person'Link{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ person'Link_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ person'Link_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ person'Link_modifierExtension x
            , schemaTypeToXML "target" $ person'Link_target x
            , maybe [] (schemaTypeToXML "assurance") $ person'Link_assurance x
            ]
instance Extension Person'Link BackboneElement where
    supertype (Person'Link a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Person'Link Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Person'Link -> BackboneElement)
              
 
data IdentityAssuranceLevel'list
    = IdentityAssuranceLevel'list_Level1
      -- ^ Level 1
    | IdentityAssuranceLevel'list_Level2
      -- ^ Level 2
    | IdentityAssuranceLevel'list_Level3
      -- ^ Level 3
    | IdentityAssuranceLevel'list_Level4
      -- ^ Level 4
    deriving (Eq,Show,Enum)
instance SchemaType IdentityAssuranceLevel'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IdentityAssuranceLevel'list where
    acceptingParser =  do literal "level1"; return IdentityAssuranceLevel'list_Level1
                      `onFail` do literal "level2"; return IdentityAssuranceLevel'list_Level2
                      `onFail` do literal "level3"; return IdentityAssuranceLevel'list_Level3
                      `onFail` do literal "level4"; return IdentityAssuranceLevel'list_Level4
                      
    simpleTypeText IdentityAssuranceLevel'list_Level1 = "level1"
    simpleTypeText IdentityAssuranceLevel'list_Level2 = "level2"
    simpleTypeText IdentityAssuranceLevel'list_Level3 = "level3"
    simpleTypeText IdentityAssuranceLevel'list_Level4 = "level4"
 
data IdentityAssuranceLevel = IdentityAssuranceLevel
        { identityAssuranceLevel_id :: Maybe String'primitive
        , identityAssuranceLevel_value :: Maybe IdentityAssuranceLevel'list
        , identityAssuranceLevel_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IdentityAssuranceLevel where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IdentityAssuranceLevel a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IdentityAssuranceLevel{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identityAssuranceLevel_id x
                       , maybe [] (toXMLAttribute "value") $ identityAssuranceLevel_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identityAssuranceLevel_extension x
            ]
instance Extension IdentityAssuranceLevel Element where
    supertype (IdentityAssuranceLevel a0 a1 e0) =
               Element a0 e0
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
elementPlanDefinition :: XMLParser PlanDefinition
elementPlanDefinition = parseSchemaType "PlanDefinition"
elementToXMLPlanDefinition :: PlanDefinition -> [Content ()]
elementToXMLPlanDefinition = schemaTypeToXML "PlanDefinition"
 
data PlanDefinition = PlanDefinition
        { planDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , planDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , planDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , planDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , planDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , planDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , planDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this plan 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   plan definition is (or will be) published. The URL SHOULD 
          --   include the major version of the plan definition. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , planDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this plan 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , planDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   plan definition when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the plan definition author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , planDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the plan definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , planDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the plan 
          --   definition.
        , planDefinition_type :: Maybe CodeableConcept
          -- ^ The type of asset the plan definition represents, e.g. an 
          --   order set, protocol, or event-condition-action rule.
        , planDefinition_status :: PublicationStatus
          -- ^ The status of this plan definition. Enables tracking the 
          --   life-cycle of the content.
        , planDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this plan definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , planDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the plan definition was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the plan definition changes.
        , planDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the plan definition.
        , planDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the plan 
          --   definition from a consumer's perspective.
        , planDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this plan definition is needed and why 
          --   it has been designed as it has.
        , planDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the asset is used from a 
          --   clinical perspective.
        , planDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , planDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , planDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the plan definition content was or 
          --   is planned to be in active use.
        , planDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   plan definition instances.
        , planDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the plan definition 
          --   is intended to be used.
        , planDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the plan 
          --   definition. Topics provide a high-level categorization of 
          --   the definition that can be useful for filtering and 
          --   searching.
        , planDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the asset, including 
          --   authors, editors, reviewers, and endorsers.
        , planDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , planDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the plan definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the plan 
          --   definition.
        , planDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , planDefinition_library :: [Reference]
          -- ^ A reference to a Library resource containing any formal 
          --   logic used by the plan definition.
        , planDefinition_goal :: [PlanDefinition'Goal]
          -- ^ Goals that describe what the activities within the plan are 
          --   intended to achieve. For example, weight loss, restoring an 
          --   activity of daily living, obtaining herd immunity via 
          --   immunization, meeting a process improvement objective, etc.
        , planDefinition_action :: [PlanDefinition'Action]
          -- ^ An action to be taken as part of the plan.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PlanDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` many (parseSchemaType "goal")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@PlanDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ planDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ planDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ planDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ planDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ planDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ planDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ planDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ planDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ planDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ planDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ planDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ planDefinition_title x
            , maybe [] (schemaTypeToXML "type") $ planDefinition_type x
            , schemaTypeToXML "status" $ planDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ planDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ planDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ planDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ planDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ planDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ planDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ planDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ planDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ planDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ planDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ planDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ planDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ planDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ planDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ planDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ planDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ planDefinition_library x
            , concatMap (schemaTypeToXML "goal") $ planDefinition_goal x
            , concatMap (schemaTypeToXML "action") $ planDefinition_action x
            ]
instance Extension PlanDefinition DomainResource where
    supertype (PlanDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PlanDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PlanDefinition -> DomainResource)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'Goal = PlanDefinition'Goal
        { planDefinition'Goal_id :: Maybe String'primitive
        , planDefinition'Goal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'Goal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'Goal_category :: Maybe CodeableConcept
          -- ^ Indicates a category the goal falls within.
        , planDefinition'Goal_description :: CodeableConcept
          -- ^ Human-readable and/or coded description of a specific 
          --   desired objective of care, such as &quot;control blood 
          --   pressure&quot; or &quot;negotiate an obstacle course&quot; 
          --   or &quot;dance with child at wedding&quot;.
        , planDefinition'Goal_priority :: Maybe CodeableConcept
          -- ^ Identifies the expected level of importance associated with 
          --   reaching/sustaining the defined goal.
        , planDefinition'Goal_start :: Maybe CodeableConcept
          -- ^ The event after which the goal should begin being pursued.
        , planDefinition'Goal_addresses :: [CodeableConcept]
          -- ^ Identifies problems, conditions, issues, or concerns the 
          --   goal is intended to address.
        , planDefinition'Goal_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the goal that provide further supporting information about 
          --   the goal. Information resources can include inline text 
          --   commentary and links to web resources.
        , planDefinition'Goal_target :: [PlanDefinition'Target]
          -- ^ Indicates what should be done and within what timeframe.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'Goal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'Goal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "start")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "target")
    schemaTypeToXML s x@PlanDefinition'Goal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'Goal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'Goal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'Goal_modifierExtension x
            , maybe [] (schemaTypeToXML "category") $ planDefinition'Goal_category x
            , schemaTypeToXML "description" $ planDefinition'Goal_description x
            , maybe [] (schemaTypeToXML "priority") $ planDefinition'Goal_priority x
            , maybe [] (schemaTypeToXML "start") $ planDefinition'Goal_start x
            , concatMap (schemaTypeToXML "addresses") $ planDefinition'Goal_addresses x
            , concatMap (schemaTypeToXML "documentation") $ planDefinition'Goal_documentation x
            , concatMap (schemaTypeToXML "target") $ planDefinition'Goal_target x
            ]
instance Extension PlanDefinition'Goal BackboneElement where
    supertype (PlanDefinition'Goal a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'Goal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'Goal -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'Target = PlanDefinition'Target
        { planDefinition'Target_id :: Maybe String'primitive
        , planDefinition'Target_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'Target_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'Target_measure :: Maybe CodeableConcept
          -- ^ The parameter whose value is to be tracked, e.g. body 
          --   weigth, blood pressure, or hemoglobin A1c level.
        , planDefinition'Target_choice3 :: (Maybe (OneOf3 Quantity Range CodeableConcept))
          -- ^ The target value of the measure to be achieved to signify 
          --   fulfillment of the goal, e.g. 150 pounds or 7.0%. Either 
          --   the high or low or both values of the range can be 
          --   specified. Whan a low value is missing, it indicates that 
          --   the goal is achieved at any value at or below the high 
          --   value. Similarly, if the high value is missing, it 
          --   indicates that the goal is achieved at any value at or 
          --   above the low value.
          --   
          --   Choice between:
          --   
          --   (1) detailQuantity
          --   
          --   (2) detailRange
          --   
          --   (3) detailCodeableConcept
        , planDefinition'Target_due :: Maybe Duration
          -- ^ Indicates the timeframe after the start of the goal in 
          --   which the goal should be met.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'Target where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'Target a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "measure")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf3 (parseSchemaType "detailQuantity"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "detailRange"))
                                     , ("CodeableConcept", fmap ThreeOf3 (parseSchemaType "detailCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "due")
    schemaTypeToXML s x@PlanDefinition'Target{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'Target_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'Target_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'Target_modifierExtension x
            , maybe [] (schemaTypeToXML "measure") $ planDefinition'Target_measure x
            , maybe [] (foldOneOf3  (schemaTypeToXML "detailQuantity")
                                    (schemaTypeToXML "detailRange")
                                    (schemaTypeToXML "detailCodeableConcept")
                                   ) $ planDefinition'Target_choice3 x
            , maybe [] (schemaTypeToXML "due") $ planDefinition'Target_due x
            ]
instance Extension PlanDefinition'Target BackboneElement where
    supertype (PlanDefinition'Target a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'Target Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'Target -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'Action = PlanDefinition'Action
        { planDefinition'Action_id :: Maybe String'primitive
        , planDefinition'Action_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'Action_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'Action_label :: Maybe Xsd.XsdString
          -- ^ A user-visible label for the action.
        , planDefinition'Action_title :: Maybe Xsd.XsdString
          -- ^ The title of the action displayed to a user.
        , planDefinition'Action_description :: Maybe Xsd.XsdString
          -- ^ A short description of the action used to provide a summary 
          --   to display to the user.
        , planDefinition'Action_textEquivalent :: Maybe Xsd.XsdString
          -- ^ A text equivalent of the action to be performed. This 
          --   provides a human-interpretable description of the action 
          --   when the definition is consumed by a system that may not be 
          --   capable of interpreting it dynamically.
        , planDefinition'Action_code :: [CodeableConcept]
          -- ^ A code that provides meaning for the action or action 
          --   group. For example, a section may have a LOINC code for a 
          --   the section of a documentation template.
        , planDefinition'Action_reason :: [CodeableConcept]
          -- ^ A description of why this action is necessary or 
          --   appropriate.
        , planDefinition'Action_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the action that can be provided to the CDS recipient. 
          --   Information resources can include inline text commentary 
          --   and links to web resources.
        , planDefinition'Action_goalId :: [Id]
          -- ^ Identifies goals that this action supports. The reference 
          --   must be to a goal element defined within this plan 
          --   definition.
        , planDefinition'Action_triggerDefinition :: [TriggerDefinition]
          -- ^ A description of when the action should be triggered.
        , planDefinition'Action_condition :: [PlanDefinition'Condition]
          -- ^ An expression that describes applicability criteria, or 
          --   start/stop conditions for the action.
        , planDefinition'Action_input :: [DataRequirement]
          -- ^ Defines input data requirements for the action.
        , planDefinition'Action_output :: [DataRequirement]
          -- ^ Defines the outputs of the action, if any.
        , planDefinition'Action_relatedAction :: [PlanDefinition'RelatedAction]
          -- ^ A relationship to another action such as &quot;before&quot; 
          --   or &quot;30-60 minutes after start of&quot;.
        , planDefinition'Action_choice15 :: (Maybe (OneOf5 DateTime Period Duration Range Timing))
          -- ^ An optional value describing when the action should be 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) timingDateTime
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDuration
          --   
          --   (4) timingRange
          --   
          --   (5) timingTiming
        , planDefinition'Action_participant :: [PlanDefinition'Participant]
          -- ^ Indicates who should participate in performing the action 
          --   described.
        , planDefinition'Action_type :: Maybe Coding
          -- ^ The type of action to perform (create, update, remove).
        , planDefinition'Action_groupingBehavior :: Maybe ActionGroupingBehavior
          -- ^ Defines the grouping behavior for the action and its 
          --   children.
        , planDefinition'Action_selectionBehavior :: Maybe ActionSelectionBehavior
          -- ^ Defines the selection behavior for the action and its 
          --   children.
        , planDefinition'Action_requiredBehavior :: Maybe ActionRequiredBehavior
          -- ^ Defines the requiredness behavior for the action.
        , planDefinition'Action_precheckBehavior :: Maybe ActionPrecheckBehavior
          -- ^ Defines whether the action should usually be preselected.
        , planDefinition'Action_cardinalityBehavior :: Maybe ActionCardinalityBehavior
          -- ^ Defines whether the action can be selected multiple times.
        , planDefinition'Action_definition :: Maybe Reference
          -- ^ A reference to an ActivityDefinition that describes the 
          --   action to be taken in detail, or a PlanDefinition that 
          --   describes a series of actions to be taken.
        , planDefinition'Action_transform :: Maybe Reference
          -- ^ A reference to a StructureMap resource that defines a 
          --   transform that can be executed to produce the intent 
          --   resource using the ActivityDefinition instance as the 
          --   input.
        , planDefinition'Action_dynamicValue :: [PlanDefinition'DynamicValue]
          -- ^ Customizations that should be applied to the statically 
          --   defined resource. For example, if the dosage of a 
          --   medication must be computed based on the patient's weight, 
          --   a customization would be used to specify an expression that 
          --   calculated the weight, and the path on the resource that 
          --   would contain the result.
        , planDefinition'Action_action :: [PlanDefinition'Action]
          -- ^ Sub actions that are contained within the action. The 
          --   behavior of this action determines the functionality of the 
          --   sub-actions. For example, a selection behavior of 
          --   at-most-one indicates that of the sub-actions, at most one 
          --   may be chosen as part of realizing the action definition.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'Action where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'Action a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "textEquivalent")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "goalId")
            `apply` many (parseSchemaType "triggerDefinition")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "input")
            `apply` many (parseSchemaType "output")
            `apply` many (parseSchemaType "relatedAction")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap TwoOf5 (parseSchemaType "timingPeriod"))
                                     , ("Duration", fmap ThreeOf5 (parseSchemaType "timingDuration"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "timingRange"))
                                     , ("Timing", fmap FiveOf5 (parseSchemaType "timingTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "groupingBehavior")
            `apply` optional (parseSchemaType "selectionBehavior")
            `apply` optional (parseSchemaType "requiredBehavior")
            `apply` optional (parseSchemaType "precheckBehavior")
            `apply` optional (parseSchemaType "cardinalityBehavior")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "dynamicValue")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@PlanDefinition'Action{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'Action_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'Action_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'Action_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ planDefinition'Action_label x
            , maybe [] (schemaTypeToXML "title") $ planDefinition'Action_title x
            , maybe [] (schemaTypeToXML "description") $ planDefinition'Action_description x
            , maybe [] (schemaTypeToXML "textEquivalent") $ planDefinition'Action_textEquivalent x
            , concatMap (schemaTypeToXML "code") $ planDefinition'Action_code x
            , concatMap (schemaTypeToXML "reason") $ planDefinition'Action_reason x
            , concatMap (schemaTypeToXML "documentation") $ planDefinition'Action_documentation x
            , concatMap (schemaTypeToXML "goalId") $ planDefinition'Action_goalId x
            , concatMap (schemaTypeToXML "triggerDefinition") $ planDefinition'Action_triggerDefinition x
            , concatMap (schemaTypeToXML "condition") $ planDefinition'Action_condition x
            , concatMap (schemaTypeToXML "input") $ planDefinition'Action_input x
            , concatMap (schemaTypeToXML "output") $ planDefinition'Action_output x
            , concatMap (schemaTypeToXML "relatedAction") $ planDefinition'Action_relatedAction x
            , maybe [] (foldOneOf5  (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDuration")
                                    (schemaTypeToXML "timingRange")
                                    (schemaTypeToXML "timingTiming")
                                   ) $ planDefinition'Action_choice15 x
            , concatMap (schemaTypeToXML "participant") $ planDefinition'Action_participant x
            , maybe [] (schemaTypeToXML "type") $ planDefinition'Action_type x
            , maybe [] (schemaTypeToXML "groupingBehavior") $ planDefinition'Action_groupingBehavior x
            , maybe [] (schemaTypeToXML "selectionBehavior") $ planDefinition'Action_selectionBehavior x
            , maybe [] (schemaTypeToXML "requiredBehavior") $ planDefinition'Action_requiredBehavior x
            , maybe [] (schemaTypeToXML "precheckBehavior") $ planDefinition'Action_precheckBehavior x
            , maybe [] (schemaTypeToXML "cardinalityBehavior") $ planDefinition'Action_cardinalityBehavior x
            , maybe [] (schemaTypeToXML "definition") $ planDefinition'Action_definition x
            , maybe [] (schemaTypeToXML "transform") $ planDefinition'Action_transform x
            , concatMap (schemaTypeToXML "dynamicValue") $ planDefinition'Action_dynamicValue x
            , concatMap (schemaTypeToXML "action") $ planDefinition'Action_action x
            ]
instance Extension PlanDefinition'Action BackboneElement where
    supertype (PlanDefinition'Action a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'Action Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'Action -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'Condition = PlanDefinition'Condition
        { planDefinition'Condition_id :: Maybe String'primitive
        , planDefinition'Condition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'Condition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'Condition_kind :: ActionConditionKind
          -- ^ The kind of condition.
        , planDefinition'Condition_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the condition that 
          --   effectively communicates the intended semantics.
        , planDefinition'Condition_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , planDefinition'Condition_expression :: Maybe Xsd.XsdString
          -- ^ An expression that returns true or false, indicating 
          --   whether or not the condition is satisfied.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'Condition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'Condition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@PlanDefinition'Condition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'Condition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'Condition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'Condition_modifierExtension x
            , schemaTypeToXML "kind" $ planDefinition'Condition_kind x
            , maybe [] (schemaTypeToXML "description") $ planDefinition'Condition_description x
            , maybe [] (schemaTypeToXML "language") $ planDefinition'Condition_language x
            , maybe [] (schemaTypeToXML "expression") $ planDefinition'Condition_expression x
            ]
instance Extension PlanDefinition'Condition BackboneElement where
    supertype (PlanDefinition'Condition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'Condition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'Condition -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'RelatedAction = PlanDefinition'RelatedAction
        { planDefinition'RelatedAction_id :: Maybe String'primitive
        , planDefinition'RelatedAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'RelatedAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'RelatedAction_actionId :: Id
          -- ^ The element id of the related action.
        , planDefinition'RelatedAction_relationship :: ActionRelationshipType
          -- ^ The relationship of this action to the related action.
        , planDefinition'RelatedAction_choice4 :: (Maybe (OneOf2 Duration Range))
          -- ^ A duration or range of durations to apply to the 
          --   relationship. For example, 30-60 minutes before.
          --   
          --   Choice between:
          --   
          --   (1) offsetDuration
          --   
          --   (2) offsetRange
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'RelatedAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'RelatedAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actionId"
            `apply` parseSchemaType "relationship"
            `apply` optional (oneOf' [ ("Duration", fmap OneOf2 (parseSchemaType "offsetDuration"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "offsetRange"))
                                     ])
    schemaTypeToXML s x@PlanDefinition'RelatedAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'RelatedAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'RelatedAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'RelatedAction_modifierExtension x
            , schemaTypeToXML "actionId" $ planDefinition'RelatedAction_actionId x
            , schemaTypeToXML "relationship" $ planDefinition'RelatedAction_relationship x
            , maybe [] (foldOneOf2  (schemaTypeToXML "offsetDuration")
                                    (schemaTypeToXML "offsetRange")
                                   ) $ planDefinition'RelatedAction_choice4 x
            ]
instance Extension PlanDefinition'RelatedAction BackboneElement where
    supertype (PlanDefinition'RelatedAction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'RelatedAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'RelatedAction -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'Participant = PlanDefinition'Participant
        { planDefinition'Participant_id :: Maybe String'primitive
        , planDefinition'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'Participant_type :: ActionParticipantType
          -- ^ The type of participant in the action.
        , planDefinition'Participant_role :: Maybe CodeableConcept
          -- ^ The role the participant should play in performing the 
          --   described action.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "role")
    schemaTypeToXML s x@PlanDefinition'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'Participant_modifierExtension x
            , schemaTypeToXML "type" $ planDefinition'Participant_type x
            , maybe [] (schemaTypeToXML "role") $ planDefinition'Participant_role x
            ]
instance Extension PlanDefinition'Participant BackboneElement where
    supertype (PlanDefinition'Participant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'Participant -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinition'DynamicValue = PlanDefinition'DynamicValue
        { planDefinition'DynamicValue_id :: Maybe String'primitive
        , planDefinition'DynamicValue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition'DynamicValue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition'DynamicValue_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the intended 
          --   semantics of the dynamic value.
        , planDefinition'DynamicValue_path :: Maybe Xsd.XsdString
          -- ^ The path to the element to be customized. This is the path 
          --   on the resource that will hold the result of the 
          --   calculation defined by the expression.
        , planDefinition'DynamicValue_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , planDefinition'DynamicValue_expression :: Maybe Xsd.XsdString
          -- ^ An expression specifying the value of the customized 
          --   element.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition'DynamicValue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinition'DynamicValue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@PlanDefinition'DynamicValue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinition'DynamicValue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinition'DynamicValue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition'DynamicValue_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ planDefinition'DynamicValue_description x
            , maybe [] (schemaTypeToXML "path") $ planDefinition'DynamicValue_path x
            , maybe [] (schemaTypeToXML "language") $ planDefinition'DynamicValue_language x
            , maybe [] (schemaTypeToXML "expression") $ planDefinition'DynamicValue_expression x
            ]
instance Extension PlanDefinition'DynamicValue BackboneElement where
    supertype (PlanDefinition'DynamicValue a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinition'DynamicValue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinition'DynamicValue -> BackboneElement)
              
 
data ActionRequiredBehavior'list
    = ActionRequiredBehavior'list_Must
      -- ^ Must
    | ActionRequiredBehavior'list_Could
      -- ^ Could
    | ActionRequiredBehavior'list_Must'unless'documented
      -- ^ Must Unless Documented
    deriving (Eq,Show,Enum)
instance SchemaType ActionRequiredBehavior'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionRequiredBehavior'list where
    acceptingParser =  do literal "must"; return ActionRequiredBehavior'list_Must
                      `onFail` do literal "could"; return ActionRequiredBehavior'list_Could
                      `onFail` do literal "must-unless-documented"; return ActionRequiredBehavior'list_Must'unless'documented
                      
    simpleTypeText ActionRequiredBehavior'list_Must = "must"
    simpleTypeText ActionRequiredBehavior'list_Could = "could"
    simpleTypeText ActionRequiredBehavior'list_Must'unless'documented = "must-unless-documented"
 
data ActionRequiredBehavior = ActionRequiredBehavior
        { actionRequiredBehavior_id :: Maybe String'primitive
        , actionRequiredBehavior_value :: Maybe ActionRequiredBehavior'list
        , actionRequiredBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionRequiredBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionRequiredBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionRequiredBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionRequiredBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionRequiredBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionRequiredBehavior_extension x
            ]
instance Extension ActionRequiredBehavior Element where
    supertype (ActionRequiredBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionRelationshipType'list
    = ActionRelationshipType'list_Before'start
      -- ^ Before Start
    | ActionRelationshipType'list_Before
      -- ^ Before
    | ActionRelationshipType'list_Before'end
      -- ^ Before End
    | ActionRelationshipType'list_Concurrent'with'start
      -- ^ Concurrent With Start
    | ActionRelationshipType'list_Concurrent
      -- ^ Concurrent
    | ActionRelationshipType'list_Concurrent'with'end
      -- ^ Concurrent With End
    | ActionRelationshipType'list_After'start
      -- ^ After Start
    | ActionRelationshipType'list_After
      -- ^ After
    | ActionRelationshipType'list_After'end
      -- ^ After End
    deriving (Eq,Show,Enum)
instance SchemaType ActionRelationshipType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionRelationshipType'list where
    acceptingParser =  do literal "before-start"; return ActionRelationshipType'list_Before'start
                      `onFail` do literal "before"; return ActionRelationshipType'list_Before
                      `onFail` do literal "before-end"; return ActionRelationshipType'list_Before'end
                      `onFail` do literal "concurrent-with-start"; return ActionRelationshipType'list_Concurrent'with'start
                      `onFail` do literal "concurrent"; return ActionRelationshipType'list_Concurrent
                      `onFail` do literal "concurrent-with-end"; return ActionRelationshipType'list_Concurrent'with'end
                      `onFail` do literal "after-start"; return ActionRelationshipType'list_After'start
                      `onFail` do literal "after"; return ActionRelationshipType'list_After
                      `onFail` do literal "after-end"; return ActionRelationshipType'list_After'end
                      
    simpleTypeText ActionRelationshipType'list_Before'start = "before-start"
    simpleTypeText ActionRelationshipType'list_Before = "before"
    simpleTypeText ActionRelationshipType'list_Before'end = "before-end"
    simpleTypeText ActionRelationshipType'list_Concurrent'with'start = "concurrent-with-start"
    simpleTypeText ActionRelationshipType'list_Concurrent = "concurrent"
    simpleTypeText ActionRelationshipType'list_Concurrent'with'end = "concurrent-with-end"
    simpleTypeText ActionRelationshipType'list_After'start = "after-start"
    simpleTypeText ActionRelationshipType'list_After = "after"
    simpleTypeText ActionRelationshipType'list_After'end = "after-end"
 
data ActionRelationshipType = ActionRelationshipType
        { actionRelationshipType_id :: Maybe String'primitive
        , actionRelationshipType_value :: Maybe ActionRelationshipType'list
        , actionRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ actionRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionRelationshipType_extension x
            ]
instance Extension ActionRelationshipType Element where
    supertype (ActionRelationshipType a0 a1 e0) =
               Element a0 e0
 
data ActionGroupingBehavior'list
    = ActionGroupingBehavior'list_Visual'group
      -- ^ Visual Group
    | ActionGroupingBehavior'list_Logical'group
      -- ^ Logical Group
    | ActionGroupingBehavior'list_Sentence'group
      -- ^ Sentence Group
    deriving (Eq,Show,Enum)
instance SchemaType ActionGroupingBehavior'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionGroupingBehavior'list where
    acceptingParser =  do literal "visual-group"; return ActionGroupingBehavior'list_Visual'group
                      `onFail` do literal "logical-group"; return ActionGroupingBehavior'list_Logical'group
                      `onFail` do literal "sentence-group"; return ActionGroupingBehavior'list_Sentence'group
                      
    simpleTypeText ActionGroupingBehavior'list_Visual'group = "visual-group"
    simpleTypeText ActionGroupingBehavior'list_Logical'group = "logical-group"
    simpleTypeText ActionGroupingBehavior'list_Sentence'group = "sentence-group"
 
data ActionGroupingBehavior = ActionGroupingBehavior
        { actionGroupingBehavior_id :: Maybe String'primitive
        , actionGroupingBehavior_value :: Maybe ActionGroupingBehavior'list
        , actionGroupingBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionGroupingBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionGroupingBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionGroupingBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionGroupingBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionGroupingBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionGroupingBehavior_extension x
            ]
instance Extension ActionGroupingBehavior Element where
    supertype (ActionGroupingBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionSelectionBehavior'list
    = ActionSelectionBehavior'list_Any
      -- ^ Any
    | ActionSelectionBehavior'list_All
      -- ^ All
    | ActionSelectionBehavior'list_All'or'none
      -- ^ All Or None
    | ActionSelectionBehavior'list_Exactly'one
      -- ^ Exactly One
    | ActionSelectionBehavior'list_At'most'one
      -- ^ At Most One
    | ActionSelectionBehavior'list_One'or'more
      -- ^ One Or More
    deriving (Eq,Show,Enum)
instance SchemaType ActionSelectionBehavior'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionSelectionBehavior'list where
    acceptingParser =  do literal "any"; return ActionSelectionBehavior'list_Any
                      `onFail` do literal "all"; return ActionSelectionBehavior'list_All
                      `onFail` do literal "all-or-none"; return ActionSelectionBehavior'list_All'or'none
                      `onFail` do literal "exactly-one"; return ActionSelectionBehavior'list_Exactly'one
                      `onFail` do literal "at-most-one"; return ActionSelectionBehavior'list_At'most'one
                      `onFail` do literal "one-or-more"; return ActionSelectionBehavior'list_One'or'more
                      
    simpleTypeText ActionSelectionBehavior'list_Any = "any"
    simpleTypeText ActionSelectionBehavior'list_All = "all"
    simpleTypeText ActionSelectionBehavior'list_All'or'none = "all-or-none"
    simpleTypeText ActionSelectionBehavior'list_Exactly'one = "exactly-one"
    simpleTypeText ActionSelectionBehavior'list_At'most'one = "at-most-one"
    simpleTypeText ActionSelectionBehavior'list_One'or'more = "one-or-more"
 
data ActionSelectionBehavior = ActionSelectionBehavior
        { actionSelectionBehavior_id :: Maybe String'primitive
        , actionSelectionBehavior_value :: Maybe ActionSelectionBehavior'list
        , actionSelectionBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionSelectionBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionSelectionBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionSelectionBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionSelectionBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionSelectionBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionSelectionBehavior_extension x
            ]
instance Extension ActionSelectionBehavior Element where
    supertype (ActionSelectionBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionCardinalityBehavior'list
    = ActionCardinalityBehavior'list_Single
      -- ^ Single
    | ActionCardinalityBehavior'list_Multiple
      -- ^ Multiple
    deriving (Eq,Show,Enum)
instance SchemaType ActionCardinalityBehavior'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionCardinalityBehavior'list where
    acceptingParser =  do literal "single"; return ActionCardinalityBehavior'list_Single
                      `onFail` do literal "multiple"; return ActionCardinalityBehavior'list_Multiple
                      
    simpleTypeText ActionCardinalityBehavior'list_Single = "single"
    simpleTypeText ActionCardinalityBehavior'list_Multiple = "multiple"
 
data ActionCardinalityBehavior = ActionCardinalityBehavior
        { actionCardinalityBehavior_id :: Maybe String'primitive
        , actionCardinalityBehavior_value :: Maybe ActionCardinalityBehavior'list
        , actionCardinalityBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionCardinalityBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionCardinalityBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionCardinalityBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionCardinalityBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionCardinalityBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionCardinalityBehavior_extension x
            ]
instance Extension ActionCardinalityBehavior Element where
    supertype (ActionCardinalityBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionPrecheckBehavior'list
    = ActionPrecheckBehavior'list_Yes
      -- ^ Yes
    | ActionPrecheckBehavior'list_No
      -- ^ No
    deriving (Eq,Show,Enum)
instance SchemaType ActionPrecheckBehavior'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionPrecheckBehavior'list where
    acceptingParser =  do literal "yes"; return ActionPrecheckBehavior'list_Yes
                      `onFail` do literal "no"; return ActionPrecheckBehavior'list_No
                      
    simpleTypeText ActionPrecheckBehavior'list_Yes = "yes"
    simpleTypeText ActionPrecheckBehavior'list_No = "no"
 
data ActionPrecheckBehavior = ActionPrecheckBehavior
        { actionPrecheckBehavior_id :: Maybe String'primitive
        , actionPrecheckBehavior_value :: Maybe ActionPrecheckBehavior'list
        , actionPrecheckBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionPrecheckBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionPrecheckBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionPrecheckBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionPrecheckBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionPrecheckBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionPrecheckBehavior_extension x
            ]
instance Extension ActionPrecheckBehavior Element where
    supertype (ActionPrecheckBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionConditionKind'list
    = ActionConditionKind'list_Applicability
      -- ^ Applicability
    | ActionConditionKind'list_Start
      -- ^ Start
    | ActionConditionKind'list_Stop
      -- ^ Stop
    deriving (Eq,Show,Enum)
instance SchemaType ActionConditionKind'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionConditionKind'list where
    acceptingParser =  do literal "applicability"; return ActionConditionKind'list_Applicability
                      `onFail` do literal "start"; return ActionConditionKind'list_Start
                      `onFail` do literal "stop"; return ActionConditionKind'list_Stop
                      
    simpleTypeText ActionConditionKind'list_Applicability = "applicability"
    simpleTypeText ActionConditionKind'list_Start = "start"
    simpleTypeText ActionConditionKind'list_Stop = "stop"
 
data ActionConditionKind = ActionConditionKind
        { actionConditionKind_id :: Maybe String'primitive
        , actionConditionKind_value :: Maybe ActionConditionKind'list
        , actionConditionKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionConditionKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionConditionKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionConditionKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionConditionKind_id x
                       , maybe [] (toXMLAttribute "value") $ actionConditionKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionConditionKind_extension x
            ]
instance Extension ActionConditionKind Element where
    supertype (ActionConditionKind a0 a1 e0) =
               Element a0 e0
 
-- | A person who is directly or indirectly involved in the 
--   provisioning of healthcare.
elementPractitioner :: XMLParser Practitioner
elementPractitioner = parseSchemaType "Practitioner"
elementToXMLPractitioner :: Practitioner -> [Content ()]
elementToXMLPractitioner = schemaTypeToXML "Practitioner"
 
data Practitioner = Practitioner
        { practitioner_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , practitioner_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , practitioner_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , practitioner_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , practitioner_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , practitioner_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , practitioner_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitioner_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitioner_identifier :: [Identifier]
          -- ^ An identifier that applies to this person in this role.
        , practitioner_active :: Maybe Boolean
          -- ^ Whether this practitioner's record is in active use.
        , practitioner_name :: [HumanName]
          -- ^ The name(s) associated with the practitioner.
        , practitioner_telecom :: [ContactPoint]
          -- ^ A contact detail for the practitioner, e.g. a telephone 
          --   number or an email address.
        , practitioner_address :: [Address]
          -- ^ Address(es) of the practitioner that are not role specific 
          --   (typically home address). Work addresses are not typically 
          --   entered in this property as they are usually role 
          --   dependent.
        , practitioner_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the person is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , practitioner_birthDate :: Maybe Date
          -- ^ The date of birth for the practitioner.
        , practitioner_photo :: [Attachment]
          -- ^ Image of the person.
        , practitioner_qualification :: [Practitioner'Qualification]
          -- ^ Qualifications obtained by training and certification.
        , practitioner_communication :: [CodeableConcept]
          -- ^ A language the practitioner is able to use in patient 
          --   communication.
        }
        deriving (Eq,Show)
instance SchemaType Practitioner where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Practitioner
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "photo")
            `apply` many (parseSchemaType "qualification")
            `apply` many (parseSchemaType "communication")
    schemaTypeToXML s x@Practitioner{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ practitioner_id x
            , maybe [] (schemaTypeToXML "meta") $ practitioner_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ practitioner_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ practitioner_language x
            , maybe [] (schemaTypeToXML "text") $ practitioner_text x
            , concatMap (schemaTypeToXML "contained") $ practitioner_contained x
            , concatMap (schemaTypeToXML "extension") $ practitioner_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitioner_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitioner_identifier x
            , maybe [] (schemaTypeToXML "active") $ practitioner_active x
            , concatMap (schemaTypeToXML "name") $ practitioner_name x
            , concatMap (schemaTypeToXML "telecom") $ practitioner_telecom x
            , concatMap (schemaTypeToXML "address") $ practitioner_address x
            , maybe [] (schemaTypeToXML "gender") $ practitioner_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ practitioner_birthDate x
            , concatMap (schemaTypeToXML "photo") $ practitioner_photo x
            , concatMap (schemaTypeToXML "qualification") $ practitioner_qualification x
            , concatMap (schemaTypeToXML "communication") $ practitioner_communication x
            ]
instance Extension Practitioner DomainResource where
    supertype (Practitioner e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Practitioner Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Practitioner -> DomainResource)
              
 
-- | A person who is directly or indirectly involved in the 
--   provisioning of healthcare.
data Practitioner'Qualification = Practitioner'Qualification
        { practitioner'Qualification_id :: Maybe String'primitive
        , practitioner'Qualification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitioner'Qualification_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitioner'Qualification_identifier :: [Identifier]
          -- ^ An identifier that applies to this person's qualification 
          --   in this role.
        , practitioner'Qualification_code :: CodeableConcept
          -- ^ Coded representation of the qualification.
        , practitioner'Qualification_period :: Maybe Period
          -- ^ Period during which the qualification is valid.
        , practitioner'Qualification_issuer :: Maybe Reference
          -- ^ Organization that regulates and issues the qualification.
        }
        deriving (Eq,Show)
instance SchemaType Practitioner'Qualification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Practitioner'Qualification a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "issuer")
    schemaTypeToXML s x@Practitioner'Qualification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitioner'Qualification_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitioner'Qualification_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitioner'Qualification_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitioner'Qualification_identifier x
            , schemaTypeToXML "code" $ practitioner'Qualification_code x
            , maybe [] (schemaTypeToXML "period") $ practitioner'Qualification_period x
            , maybe [] (schemaTypeToXML "issuer") $ practitioner'Qualification_issuer x
            ]
instance Extension Practitioner'Qualification BackboneElement where
    supertype (Practitioner'Qualification a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Practitioner'Qualification Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Practitioner'Qualification -> BackboneElement)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
elementPractitionerRole :: XMLParser PractitionerRole
elementPractitionerRole = parseSchemaType "PractitionerRole"
elementToXMLPractitionerRole :: PractitionerRole -> [Content ()]
elementToXMLPractitionerRole = schemaTypeToXML "PractitionerRole"
 
data PractitionerRole = PractitionerRole
        { practitionerRole_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , practitionerRole_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , practitionerRole_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , practitionerRole_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , practitionerRole_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , practitionerRole_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , practitionerRole_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRole_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRole_identifier :: [Identifier]
          -- ^ Business Identifiers that are specific to a role/location.
        , practitionerRole_active :: Maybe Boolean
          -- ^ Whether this practitioner's record is in active use.
        , practitionerRole_period :: Maybe Period
          -- ^ The period during which the person is authorized to act as 
          --   a practitioner in these role(s) for the organization.
        , practitionerRole_practitioner :: Maybe Reference
          -- ^ Practitioner that is able to provide the defined services 
          --   for the organation.
        , practitionerRole_organization :: Maybe Reference
          -- ^ The organization where the Practitioner performs the roles 
          --   associated.
        , practitionerRole_code :: [CodeableConcept]
          -- ^ Roles which this practitioner is authorized to perform for 
          --   the organization.
        , practitionerRole_specialty :: [CodeableConcept]
          -- ^ Specific specialty of the practitioner.
        , practitionerRole_location :: [Reference]
          -- ^ The location(s) at which this practitioner provides care.
        , practitionerRole_healthcareService :: [Reference]
          -- ^ The list of healthcare services that this worker provides 
          --   for this role's Organization/Location(s).
        , practitionerRole_telecom :: [ContactPoint]
          -- ^ Contact details that are specific to the 
          --   role/location/service.
        , practitionerRole_availableTime :: [PractitionerRole'AvailableTime]
          -- ^ A collection of times that the Service Site is available.
        , practitionerRole_notAvailable :: [PractitionerRole'NotAvailable]
          -- ^ The HealthcareService is not available during this period 
          --   of time due to the provided reason.
        , practitionerRole_availabilityExceptions :: Maybe Xsd.XsdString
          -- ^ A description of site availability exceptions, e.g. public 
          --   holiday availability. Succinctly describing all possible 
          --   exceptions to normal site availability as details in the 
          --   available Times and not available Times.
        , practitionerRole_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the practitioner with this role.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRole where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PractitionerRole
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "practitioner")
            `apply` optional (parseSchemaType "organization")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "specialty")
            `apply` many (parseSchemaType "location")
            `apply` many (parseSchemaType "healthcareService")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "availableTime")
            `apply` many (parseSchemaType "notAvailable")
            `apply` optional (parseSchemaType "availabilityExceptions")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@PractitionerRole{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ practitionerRole_id x
            , maybe [] (schemaTypeToXML "meta") $ practitionerRole_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ practitionerRole_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ practitionerRole_language x
            , maybe [] (schemaTypeToXML "text") $ practitionerRole_text x
            , concatMap (schemaTypeToXML "contained") $ practitionerRole_contained x
            , concatMap (schemaTypeToXML "extension") $ practitionerRole_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRole_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitionerRole_identifier x
            , maybe [] (schemaTypeToXML "active") $ practitionerRole_active x
            , maybe [] (schemaTypeToXML "period") $ practitionerRole_period x
            , maybe [] (schemaTypeToXML "practitioner") $ practitionerRole_practitioner x
            , maybe [] (schemaTypeToXML "organization") $ practitionerRole_organization x
            , concatMap (schemaTypeToXML "code") $ practitionerRole_code x
            , concatMap (schemaTypeToXML "specialty") $ practitionerRole_specialty x
            , concatMap (schemaTypeToXML "location") $ practitionerRole_location x
            , concatMap (schemaTypeToXML "healthcareService") $ practitionerRole_healthcareService x
            , concatMap (schemaTypeToXML "telecom") $ practitionerRole_telecom x
            , concatMap (schemaTypeToXML "availableTime") $ practitionerRole_availableTime x
            , concatMap (schemaTypeToXML "notAvailable") $ practitionerRole_notAvailable x
            , maybe [] (schemaTypeToXML "availabilityExceptions") $ practitionerRole_availabilityExceptions x
            , concatMap (schemaTypeToXML "endpoint") $ practitionerRole_endpoint x
            ]
instance Extension PractitionerRole DomainResource where
    supertype (PractitionerRole e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PractitionerRole Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PractitionerRole -> DomainResource)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
data PractitionerRole'AvailableTime = PractitionerRole'AvailableTime
        { practitionerRole'AvailableTime_id :: Maybe String'primitive
        , practitionerRole'AvailableTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRole'AvailableTime_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRole'AvailableTime_daysOfWeek :: [DaysOfWeek]
          -- ^ Indicates which days of the week are available between the 
          --   start and end Times.
        , practitionerRole'AvailableTime_allDay :: Maybe Boolean
          -- ^ Is this always available? (hence times are irrelevant) e.g. 
          --   24 hour service.
        , practitionerRole'AvailableTime_availableStartTime :: Maybe Time
          -- ^ The opening time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        , practitionerRole'AvailableTime_availableEndTime :: Maybe Time
          -- ^ The closing time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRole'AvailableTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PractitionerRole'AvailableTime a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "daysOfWeek")
            `apply` optional (parseSchemaType "allDay")
            `apply` optional (parseSchemaType "availableStartTime")
            `apply` optional (parseSchemaType "availableEndTime")
    schemaTypeToXML s x@PractitionerRole'AvailableTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitionerRole'AvailableTime_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitionerRole'AvailableTime_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRole'AvailableTime_modifierExtension x
            , concatMap (schemaTypeToXML "daysOfWeek") $ practitionerRole'AvailableTime_daysOfWeek x
            , maybe [] (schemaTypeToXML "allDay") $ practitionerRole'AvailableTime_allDay x
            , maybe [] (schemaTypeToXML "availableStartTime") $ practitionerRole'AvailableTime_availableStartTime x
            , maybe [] (schemaTypeToXML "availableEndTime") $ practitionerRole'AvailableTime_availableEndTime x
            ]
instance Extension PractitionerRole'AvailableTime BackboneElement where
    supertype (PractitionerRole'AvailableTime a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PractitionerRole'AvailableTime Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PractitionerRole'AvailableTime -> BackboneElement)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
data PractitionerRole'NotAvailable = PractitionerRole'NotAvailable
        { practitionerRole'NotAvailable_id :: Maybe String'primitive
        , practitionerRole'NotAvailable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRole'NotAvailable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRole'NotAvailable_description :: Xsd.XsdString
          -- ^ The reason that can be presented to the user as to why this 
          --   time is not available.
        , practitionerRole'NotAvailable_during :: Maybe Period
          -- ^ Service is not available (seasonally or for a public 
          --   holiday) from this date.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRole'NotAvailable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PractitionerRole'NotAvailable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "during")
    schemaTypeToXML s x@PractitionerRole'NotAvailable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitionerRole'NotAvailable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitionerRole'NotAvailable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRole'NotAvailable_modifierExtension x
            , schemaTypeToXML "description" $ practitionerRole'NotAvailable_description x
            , maybe [] (schemaTypeToXML "during") $ practitionerRole'NotAvailable_during x
            ]
instance Extension PractitionerRole'NotAvailable BackboneElement where
    supertype (PractitionerRole'NotAvailable a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PractitionerRole'NotAvailable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PractitionerRole'NotAvailable -> BackboneElement)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
elementProcedure :: XMLParser Procedure
elementProcedure = parseSchemaType "Procedure"
elementToXMLProcedure :: Procedure -> [Content ()]
elementToXMLProcedure = schemaTypeToXML "Procedure"
 
data Procedure = Procedure
        { procedure_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , procedure_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , procedure_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , procedure_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , procedure_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , procedure_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , procedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedure_identifier :: [Identifier]
          -- ^ This records identifiers associated with this procedure 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , procedure_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that 
          --   was adhered to in whole or in part by this procedure.
        , procedure_basedOn :: [Reference]
          -- ^ A reference to a resource that contains details of the 
          --   request for this procedure.
        , procedure_partOf :: [Reference]
          -- ^ A larger event of which this particular procedure is a 
          --   component or step.
        , procedure_status :: EventStatus
          -- ^ A code specifying the state of the procedure. Generally 
          --   this will be in-progress or completed state.
        , procedure_notDone :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the procedure 
          --   was NOT performed.
        , procedure_notDoneReason :: Maybe CodeableConcept
          -- ^ A code indicating why the procedure was not performed.
        , procedure_category :: Maybe CodeableConcept
          -- ^ A code that classifies the procedure for searching, sorting 
          --   and display purposes (e.g. &quot;Surgical Procedure&quot;).
        , procedure_code :: Maybe CodeableConcept
          -- ^ The specific procedure that is performed. Use text if the 
          --   exact nature of the procedure cannot be coded (e.g. 
          --   &quot;Laparoscopic Appendectomy&quot;).
        , procedure_subject :: Reference
          -- ^ The person, animal or group on which the procedure was 
          --   performed.
        , procedure_context :: Maybe Reference
          -- ^ The encounter during which the procedure was performed.
        , procedure_choice19 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date(time)/period over which the procedure was 
          --   performed. Allows a period to support complex procedures 
          --   that span more than one date, and also allows for the 
          --   length of the procedure to be captured.
          --   
          --   Choice between:
          --   
          --   (1) performedDateTime
          --   
          --   (2) performedPeriod
        , procedure_performer :: [Procedure'Performer]
          -- ^ Limited to 'real' people rather than equipment.
        , procedure_location :: Maybe Reference
          -- ^ The location where the procedure actually happened. E.g. a 
          --   newborn at home, a tracheostomy at a restaurant.
        , procedure_reasonCode :: [CodeableConcept]
          -- ^ The coded reason why the procedure was performed. This may 
          --   be coded entity of some type, or may simply be present as 
          --   text.
        , procedure_reasonReference :: [Reference]
          -- ^ The condition that is the reason why the procedure was 
          --   performed.
        , procedure_bodySite :: [CodeableConcept]
          -- ^ Detailed and structured anatomical location information. 
          --   Multiple locations are allowed - e.g. multiple punch 
          --   biopsies of a lesion.
        , procedure_outcome :: Maybe CodeableConcept
          -- ^ The outcome of the procedure - did it resolve reasons for 
          --   the procedure being performed?
        , procedure_report :: [Reference]
          -- ^ This could be a histology result, pathology report, 
          --   surgical report, etc..
        , procedure_complication :: [CodeableConcept]
          -- ^ Any complications that occurred during the procedure, or in 
          --   the immediate post-performance period. These are generally 
          --   tracked separately from the notes, which will typically 
          --   describe the procedure itself rather than any 'post 
          --   procedure' issues.
        , procedure_complicationDetail :: [Reference]
          -- ^ Any complications that occurred during the procedure, or in 
          --   the immediate post-performance period.
        , procedure_followUp :: [CodeableConcept]
          -- ^ If the procedure required specific follow up - e.g. removal 
          --   of sutures. The followup may be represented as a simple 
          --   note, or could potentially be more complex in which case 
          --   the CarePlan resource can be used.
        , procedure_note :: [Annotation]
          -- ^ Any other notes about the procedure. E.g. the operative 
          --   notes.
        , procedure_focalDevice :: [Procedure'FocalDevice]
          -- ^ A device that is implanted, removed or otherwise 
          --   manipulated (calibration, battery replacement, fitting a 
          --   prosthesis, attaching a wound-vac, etc.) as a focal portion 
          --   of the Procedure.
        , procedure_usedReference :: [Reference]
          -- ^ Identifies medications, devices and any other substance 
          --   used as part of the procedure.
        , procedure_usedCode :: [CodeableConcept]
          -- ^ Identifies coded items that were used as part of the 
          --   procedure.
        }
        deriving (Eq,Show)
instance SchemaType Procedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Procedure
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "code")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "performedDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "performedPeriod"))
                                     ])
            `apply` many (parseSchemaType "performer")
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "outcome")
            `apply` many (parseSchemaType "report")
            `apply` many (parseSchemaType "complication")
            `apply` many (parseSchemaType "complicationDetail")
            `apply` many (parseSchemaType "followUp")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "focalDevice")
            `apply` many (parseSchemaType "usedReference")
            `apply` many (parseSchemaType "usedCode")
    schemaTypeToXML s x@Procedure{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ procedure_id x
            , maybe [] (schemaTypeToXML "meta") $ procedure_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ procedure_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ procedure_language x
            , maybe [] (schemaTypeToXML "text") $ procedure_text x
            , concatMap (schemaTypeToXML "contained") $ procedure_contained x
            , concatMap (schemaTypeToXML "extension") $ procedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedure_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ procedure_identifier x
            , concatMap (schemaTypeToXML "definition") $ procedure_definition x
            , concatMap (schemaTypeToXML "basedOn") $ procedure_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ procedure_partOf x
            , schemaTypeToXML "status" $ procedure_status x
            , maybe [] (schemaTypeToXML "notDone") $ procedure_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ procedure_notDoneReason x
            , maybe [] (schemaTypeToXML "category") $ procedure_category x
            , maybe [] (schemaTypeToXML "code") $ procedure_code x
            , schemaTypeToXML "subject" $ procedure_subject x
            , maybe [] (schemaTypeToXML "context") $ procedure_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "performedDateTime")
                                    (schemaTypeToXML "performedPeriod")
                                   ) $ procedure_choice19 x
            , concatMap (schemaTypeToXML "performer") $ procedure_performer x
            , maybe [] (schemaTypeToXML "location") $ procedure_location x
            , concatMap (schemaTypeToXML "reasonCode") $ procedure_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ procedure_reasonReference x
            , concatMap (schemaTypeToXML "bodySite") $ procedure_bodySite x
            , maybe [] (schemaTypeToXML "outcome") $ procedure_outcome x
            , concatMap (schemaTypeToXML "report") $ procedure_report x
            , concatMap (schemaTypeToXML "complication") $ procedure_complication x
            , concatMap (schemaTypeToXML "complicationDetail") $ procedure_complicationDetail x
            , concatMap (schemaTypeToXML "followUp") $ procedure_followUp x
            , concatMap (schemaTypeToXML "note") $ procedure_note x
            , concatMap (schemaTypeToXML "focalDevice") $ procedure_focalDevice x
            , concatMap (schemaTypeToXML "usedReference") $ procedure_usedReference x
            , concatMap (schemaTypeToXML "usedCode") $ procedure_usedCode x
            ]
instance Extension Procedure DomainResource where
    supertype (Procedure e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Procedure Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Procedure -> DomainResource)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
data Procedure'Performer = Procedure'Performer
        { procedure'Performer_id :: Maybe String'primitive
        , procedure'Performer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedure'Performer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedure'Performer_role :: Maybe CodeableConcept
          -- ^ For example: surgeon, anaethetist, endoscopist.
        , procedure'Performer_actor :: Reference
          -- ^ The practitioner who was involved in the procedure.
        , procedure'Performer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType Procedure'Performer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Procedure'Performer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@Procedure'Performer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedure'Performer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedure'Performer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedure'Performer_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ procedure'Performer_role x
            , schemaTypeToXML "actor" $ procedure'Performer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ procedure'Performer_onBehalfOf x
            ]
instance Extension Procedure'Performer BackboneElement where
    supertype (Procedure'Performer a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Procedure'Performer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Procedure'Performer -> BackboneElement)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
data Procedure'FocalDevice = Procedure'FocalDevice
        { procedure'FocalDevice_id :: Maybe String'primitive
        , procedure'FocalDevice_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedure'FocalDevice_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedure'FocalDevice_action :: Maybe CodeableConcept
          -- ^ The kind of change that happened to the device during the 
          --   procedure.
        , procedure'FocalDevice_manipulated :: Reference
          -- ^ The device that was manipulated (changed) during the 
          --   procedure.
        }
        deriving (Eq,Show)
instance SchemaType Procedure'FocalDevice where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Procedure'FocalDevice a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "action")
            `apply` parseSchemaType "manipulated"
    schemaTypeToXML s x@Procedure'FocalDevice{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedure'FocalDevice_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedure'FocalDevice_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedure'FocalDevice_modifierExtension x
            , maybe [] (schemaTypeToXML "action") $ procedure'FocalDevice_action x
            , schemaTypeToXML "manipulated" $ procedure'FocalDevice_manipulated x
            ]
instance Extension Procedure'FocalDevice BackboneElement where
    supertype (Procedure'FocalDevice a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Procedure'FocalDevice Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Procedure'FocalDevice -> BackboneElement)
              
 
-- | A record of a request for diagnostic investigations, 
--   treatments, or operations to be performed.
elementProcedureRequest :: XMLParser ProcedureRequest
elementProcedureRequest = parseSchemaType "ProcedureRequest"
elementToXMLProcedureRequest :: ProcedureRequest -> [Content ()]
elementToXMLProcedureRequest = schemaTypeToXML "ProcedureRequest"
 
data ProcedureRequest = ProcedureRequest
        { procedureRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , procedureRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , procedureRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , procedureRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , procedureRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , procedureRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , procedureRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedureRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedureRequest_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order instance by the orderer 
          --   and/or the receiver and/or order fulfiller.
        , procedureRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request.
        , procedureRequest_basedOn :: [Reference]
          -- ^ Plan/proposal/order fulfilled by this request.
        , procedureRequest_replaces :: [Reference]
          -- ^ The request takes the place of the referenced completed or 
          --   terminated request(s).
        , procedureRequest_requisition :: Maybe Identifier
          -- ^ A shared identifier common to all procedure or diagnostic 
          --   requests that were authorized more or less simultaneously 
          --   by a single author, representing the composite or group 
          --   identifier.
        , procedureRequest_status :: RequestStatus
          -- ^ The status of the order.
        , procedureRequest_intent :: RequestIntent
          -- ^ Whether the request is a proposal, plan, an original order 
          --   or a reflex order.
        , procedureRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the ProcedureRequest should be 
          --   addressed with respect to other requests.
        , procedureRequest_doNotPerform :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the procedure 
          --   should NOT be performed.
        , procedureRequest_category :: [CodeableConcept]
          -- ^ A code that classifies the procedure for searching, sorting 
          --   and display purposes (e.g. &quot;Surgical Procedure&quot;).
        , procedureRequest_code :: CodeableConcept
          -- ^ A code that identifies a particular procedure, diagnostic 
          --   investigation, or panel of investigations, that have been 
          --   requested.
        , procedureRequest_subject :: Reference
          -- ^ On whom or what the procedure or diagnostic is to be 
          --   performed. This is usually a human patient, but can also be 
          --   requested on animals, groups of humans or animals, devices 
          --   such as dialysis machines, or even locations (typically for 
          --   environmental scans).
        , procedureRequest_context :: Maybe Reference
          -- ^ An encounter or episode of care that provides additional 
          --   information about the healthcare context in which this 
          --   request is made.
        , procedureRequest_choice21 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The date/time at which the diagnostic testing should occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , procedureRequest_choice22 :: (Maybe (OneOf2 Boolean CodeableConcept))
          -- ^ If a CodeableConcept is present, it indicates the 
          --   pre-condition for performing the procedure. For example 
          --   &quot;pain&quot;, &quot;on flare-up&quot;, etc.
          --   
          --   Choice between:
          --   
          --   (1) asNeededBoolean
          --   
          --   (2) asNeededCodeableConcept
        , procedureRequest_authoredOn :: Maybe DateTime
          -- ^ When the request transitioned to being actionable.
        , procedureRequest_requester :: Maybe ProcedureRequest'Requester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , procedureRequest_performerType :: Maybe CodeableConcept
          -- ^ Desired type of performer for doing the diagnostic testing.
        , procedureRequest_performer :: Maybe Reference
          -- ^ The desired perfomer for doing the diagnostic testing. For 
          --   example, the surgeon, dermatopathologist, endoscopist, etc.
        , procedureRequest_reasonCode :: [CodeableConcept]
          -- ^ An explanation or justification for why this diagnostic 
          --   investigation is being requested in coded or textual form. 
          --   This is often for billing purposes. May relate to the 
          --   resources referred to in supportingInformation.
        , procedureRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource that provides a justification 
          --   for why this diagnostic investigation is being requested. 
          --   May relate to the resources referred to in 
          --   supportingInformation.
        , procedureRequest_supportingInfo :: [Reference]
          -- ^ Additional clinical information about the patient or 
          --   specimen that may influence the procedure or diagnostics or 
          --   their interpretations. This information includes diagnosis, 
          --   clinical findings and other observations. In laboratory 
          --   ordering these are typically referred to as &quot;ask at 
          --   order entry questions (AOEs)&quot;. This includes 
          --   observations explicitly requested by the producer (filler) 
          --   to provide context or supporting information needed to 
          --   complete the order. For example, reporting the amount of 
          --   inspired oxygen for blood gas measurements.
        , procedureRequest_specimen :: [Reference]
          -- ^ One or more specimens that the laboratory procedure will 
          --   use.
        , procedureRequest_bodySite :: [CodeableConcept]
          -- ^ Anatomic location where the procedure should be performed. 
          --   This is the target site.
        , procedureRequest_note :: [Annotation]
          -- ^ Any other notes and comments made about the service 
          --   request. For example, letting provider know that 
          --   &quot;patient hates needles&quot; or other provider 
          --   instructions.
        , procedureRequest_relevantHistory :: [Reference]
          -- ^ Key events in the history of the request.
        }
        deriving (Eq,Show)
instance SchemaType ProcedureRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcedureRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "requisition")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "doNotPerform")
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "asNeededBoolean"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "asNeededCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "performer")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "specimen")
            `apply` many (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@ProcedureRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ procedureRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ procedureRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ procedureRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ procedureRequest_language x
            , maybe [] (schemaTypeToXML "text") $ procedureRequest_text x
            , concatMap (schemaTypeToXML "contained") $ procedureRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ procedureRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedureRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ procedureRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ procedureRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ procedureRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ procedureRequest_replaces x
            , maybe [] (schemaTypeToXML "requisition") $ procedureRequest_requisition x
            , schemaTypeToXML "status" $ procedureRequest_status x
            , schemaTypeToXML "intent" $ procedureRequest_intent x
            , maybe [] (schemaTypeToXML "priority") $ procedureRequest_priority x
            , maybe [] (schemaTypeToXML "doNotPerform") $ procedureRequest_doNotPerform x
            , concatMap (schemaTypeToXML "category") $ procedureRequest_category x
            , schemaTypeToXML "code" $ procedureRequest_code x
            , schemaTypeToXML "subject" $ procedureRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ procedureRequest_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ procedureRequest_choice21 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "asNeededBoolean")
                                    (schemaTypeToXML "asNeededCodeableConcept")
                                   ) $ procedureRequest_choice22 x
            , maybe [] (schemaTypeToXML "authoredOn") $ procedureRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ procedureRequest_requester x
            , maybe [] (schemaTypeToXML "performerType") $ procedureRequest_performerType x
            , maybe [] (schemaTypeToXML "performer") $ procedureRequest_performer x
            , concatMap (schemaTypeToXML "reasonCode") $ procedureRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ procedureRequest_reasonReference x
            , concatMap (schemaTypeToXML "supportingInfo") $ procedureRequest_supportingInfo x
            , concatMap (schemaTypeToXML "specimen") $ procedureRequest_specimen x
            , concatMap (schemaTypeToXML "bodySite") $ procedureRequest_bodySite x
            , concatMap (schemaTypeToXML "note") $ procedureRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ procedureRequest_relevantHistory x
            ]
instance Extension ProcedureRequest DomainResource where
    supertype (ProcedureRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcedureRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcedureRequest -> DomainResource)
              
 
-- | A record of a request for diagnostic investigations, 
--   treatments, or operations to be performed.
data ProcedureRequest'Requester = ProcedureRequest'Requester
        { procedureRequest'Requester_id :: Maybe String'primitive
        , procedureRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedureRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedureRequest'Requester_agent :: Reference
          -- ^ The device, practitioner or organization who initiated the 
          --   request.
        , procedureRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType ProcedureRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcedureRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@ProcedureRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedureRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedureRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedureRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ procedureRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ procedureRequest'Requester_onBehalfOf x
            ]
instance Extension ProcedureRequest'Requester BackboneElement where
    supertype (ProcedureRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ProcedureRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcedureRequest'Requester -> BackboneElement)
              
 
data RequestIntent'list
    = RequestIntent'list_Proposal
      -- ^ Proposal
    | RequestIntent'list_Plan
      -- ^ Plan
    | RequestIntent'list_Order
      -- ^ Order
    | RequestIntent'list_Original'order
      -- ^ Original Order
    | RequestIntent'list_Reflex'order
      -- ^ Reflex Order
    | RequestIntent'list_Filler'order
      -- ^ Filler Order
    | RequestIntent'list_Instance'order
      -- ^ Instance Order
    | RequestIntent'list_Option
      -- ^ Option
    deriving (Eq,Show,Enum)
instance SchemaType RequestIntent'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestIntent'list where
    acceptingParser =  do literal "proposal"; return RequestIntent'list_Proposal
                      `onFail` do literal "plan"; return RequestIntent'list_Plan
                      `onFail` do literal "order"; return RequestIntent'list_Order
                      `onFail` do literal "original-order"; return RequestIntent'list_Original'order
                      `onFail` do literal "reflex-order"; return RequestIntent'list_Reflex'order
                      `onFail` do literal "filler-order"; return RequestIntent'list_Filler'order
                      `onFail` do literal "instance-order"; return RequestIntent'list_Instance'order
                      `onFail` do literal "option"; return RequestIntent'list_Option
                      
    simpleTypeText RequestIntent'list_Proposal = "proposal"
    simpleTypeText RequestIntent'list_Plan = "plan"
    simpleTypeText RequestIntent'list_Order = "order"
    simpleTypeText RequestIntent'list_Original'order = "original-order"
    simpleTypeText RequestIntent'list_Reflex'order = "reflex-order"
    simpleTypeText RequestIntent'list_Filler'order = "filler-order"
    simpleTypeText RequestIntent'list_Instance'order = "instance-order"
    simpleTypeText RequestIntent'list_Option = "option"
 
data RequestIntent = RequestIntent
        { requestIntent_id :: Maybe String'primitive
        , requestIntent_value :: Maybe RequestIntent'list
        , requestIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestIntent_id x
                       , maybe [] (toXMLAttribute "value") $ requestIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestIntent_extension x
            ]
instance Extension RequestIntent Element where
    supertype (RequestIntent a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the target, request and response, 
--   and action details for an action to be performed by the 
--   target on or about existing resources.
elementProcessRequest :: XMLParser ProcessRequest
elementProcessRequest = parseSchemaType "ProcessRequest"
elementToXMLProcessRequest :: ProcessRequest -> [Content ()]
elementToXMLProcessRequest = schemaTypeToXML "ProcessRequest"
 
data ProcessRequest = ProcessRequest
        { processRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , processRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , processRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , processRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , processRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , processRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , processRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processRequest_identifier :: [Identifier]
          -- ^ The ProcessRequest business identifier.
        , processRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , processRequest_action :: Maybe ActionList
          -- ^ The type of processing action being requested, for example 
          --   Reversal, Readjudication, StatusRequest,PendedRequest.
        , processRequest_target :: Maybe Reference
          -- ^ The organization which is the target of the request.
        , processRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , processRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the action 
          --   specified in this request.
        , processRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the action 
          --   speccified in this request.
        , processRequest_request :: Maybe Reference
          -- ^ Reference of resource which is the target or subject of 
          --   this action.
        , processRequest_response :: Maybe Reference
          -- ^ Reference of a prior response to resource which is the 
          --   target or subject of this action.
        , processRequest_nullify :: Maybe Boolean
          -- ^ If true remove all history excluding audit.
        , processRequest_reference :: Maybe Xsd.XsdString
          -- ^ A reference to supply which authenticates the process.
        , processRequest_item :: [ProcessRequest'Item]
          -- ^ List of top level items to be re-adjudicated, if none 
          --   specified then the entire submission is re-adjudicated.
        , processRequest_include :: [Xsd.XsdString]
          -- ^ Names of resource types to include.
        , processRequest_exclude :: [Xsd.XsdString]
          -- ^ Names of resource types to exclude.
        , processRequest_period :: Maybe Period
          -- ^ A period of time during which the fulfilling resources 
          --   would have been created.
        }
        deriving (Eq,Show)
instance SchemaType ProcessRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcessRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "action")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "nullify")
            `apply` optional (parseSchemaType "reference")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "include")
            `apply` many (parseSchemaType "exclude")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@ProcessRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ processRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ processRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ processRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ processRequest_language x
            , maybe [] (schemaTypeToXML "text") $ processRequest_text x
            , concatMap (schemaTypeToXML "contained") $ processRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ processRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ processRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ processRequest_status x
            , maybe [] (schemaTypeToXML "action") $ processRequest_action x
            , maybe [] (schemaTypeToXML "target") $ processRequest_target x
            , maybe [] (schemaTypeToXML "created") $ processRequest_created x
            , maybe [] (schemaTypeToXML "provider") $ processRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ processRequest_organization x
            , maybe [] (schemaTypeToXML "request") $ processRequest_request x
            , maybe [] (schemaTypeToXML "response") $ processRequest_response x
            , maybe [] (schemaTypeToXML "nullify") $ processRequest_nullify x
            , maybe [] (schemaTypeToXML "reference") $ processRequest_reference x
            , concatMap (schemaTypeToXML "item") $ processRequest_item x
            , concatMap (schemaTypeToXML "include") $ processRequest_include x
            , concatMap (schemaTypeToXML "exclude") $ processRequest_exclude x
            , maybe [] (schemaTypeToXML "period") $ processRequest_period x
            ]
instance Extension ProcessRequest DomainResource where
    supertype (ProcessRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcessRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcessRequest -> DomainResource)
              
 
-- | This resource provides the target, request and response, 
--   and action details for an action to be performed by the 
--   target on or about existing resources.
data ProcessRequest'Item = ProcessRequest'Item
        { processRequest'Item_id :: Maybe String'primitive
        , processRequest'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processRequest'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processRequest'Item_sequenceLinkId :: Integer
          -- ^ A service line number.
        }
        deriving (Eq,Show)
instance SchemaType ProcessRequest'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcessRequest'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
    schemaTypeToXML s x@ProcessRequest'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ processRequest'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ processRequest'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processRequest'Item_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ processRequest'Item_sequenceLinkId x
            ]
instance Extension ProcessRequest'Item BackboneElement where
    supertype (ProcessRequest'Item a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ProcessRequest'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcessRequest'Item -> BackboneElement)
              
 
data ActionList'list
    = ActionList'list_Cancel
      -- ^ Cancel, Reverse or Nullify
    | ActionList'list_Poll
      -- ^ Poll
    | ActionList'list_Reprocess
      -- ^ Re-Process
    | ActionList'list_Status
      -- ^ Status Check
    deriving (Eq,Show,Enum)
instance SchemaType ActionList'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionList'list where
    acceptingParser =  do literal "cancel"; return ActionList'list_Cancel
                      `onFail` do literal "poll"; return ActionList'list_Poll
                      `onFail` do literal "reprocess"; return ActionList'list_Reprocess
                      `onFail` do literal "status"; return ActionList'list_Status
                      
    simpleTypeText ActionList'list_Cancel = "cancel"
    simpleTypeText ActionList'list_Poll = "poll"
    simpleTypeText ActionList'list_Reprocess = "reprocess"
    simpleTypeText ActionList'list_Status = "status"
 
data ActionList = ActionList
        { actionList_id :: Maybe String'primitive
        , actionList_value :: Maybe ActionList'list
        , actionList_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionList where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionList a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionList{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionList_id x
                       , maybe [] (toXMLAttribute "value") $ actionList_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionList_extension x
            ]
instance Extension ActionList Element where
    supertype (ActionList a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides processing status, errors and notes 
--   from the processing of a resource.
elementProcessResponse :: XMLParser ProcessResponse
elementProcessResponse = parseSchemaType "ProcessResponse"
elementToXMLProcessResponse :: ProcessResponse -> [Content ()]
elementToXMLProcessResponse = schemaTypeToXML "ProcessResponse"
 
data ProcessResponse = ProcessResponse
        { processResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , processResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , processResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , processResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , processResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , processResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , processResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , processResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , processResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , processResponse_organization :: Maybe Reference
          -- ^ The organization who produced this adjudicated response.
        , processResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , processResponse_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete, held.
        , processResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication or 
          --   processing.
        , processResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , processResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , processResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , processResponse_processNote :: [ProcessResponse'ProcessNote]
          -- ^ Suite of processing notes or additional requirements if the 
          --   processing has been held.
        , processResponse_error :: [CodeableConcept]
          -- ^ Processing errors.
        , processResponse_communicationRequest :: [Reference]
          -- ^ Request for additional supporting or authorizing 
          --   information, such as: documents, images or resources.
        }
        deriving (Eq,Show)
instance SchemaType ProcessResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcessResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "error")
            `apply` many (parseSchemaType "communicationRequest")
    schemaTypeToXML s x@ProcessResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ processResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ processResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ processResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ processResponse_language x
            , maybe [] (schemaTypeToXML "text") $ processResponse_text x
            , concatMap (schemaTypeToXML "contained") $ processResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ processResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ processResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ processResponse_status x
            , maybe [] (schemaTypeToXML "created") $ processResponse_created x
            , maybe [] (schemaTypeToXML "organization") $ processResponse_organization x
            , maybe [] (schemaTypeToXML "request") $ processResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ processResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ processResponse_disposition x
            , maybe [] (schemaTypeToXML "requestProvider") $ processResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ processResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "form") $ processResponse_form x
            , concatMap (schemaTypeToXML "processNote") $ processResponse_processNote x
            , concatMap (schemaTypeToXML "error") $ processResponse_error x
            , concatMap (schemaTypeToXML "communicationRequest") $ processResponse_communicationRequest x
            ]
instance Extension ProcessResponse DomainResource where
    supertype (ProcessResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcessResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcessResponse -> DomainResource)
              
 
-- | This resource provides processing status, errors and notes 
--   from the processing of a resource.
data ProcessResponse'ProcessNote = ProcessResponse'ProcessNote
        { processResponse'ProcessNote_id :: Maybe String'primitive
        , processResponse'ProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processResponse'ProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processResponse'ProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , processResponse'ProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        }
        deriving (Eq,Show)
instance SchemaType ProcessResponse'ProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcessResponse'ProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@ProcessResponse'ProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ processResponse'ProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ processResponse'ProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processResponse'ProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ processResponse'ProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ processResponse'ProcessNote_text x
            ]
instance Extension ProcessResponse'ProcessNote BackboneElement where
    supertype (ProcessResponse'ProcessNote a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ProcessResponse'ProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcessResponse'ProcessNote -> BackboneElement)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
elementProvenance :: XMLParser Provenance
elementProvenance = parseSchemaType "Provenance"
elementToXMLProvenance :: Provenance -> [Content ()]
elementToXMLProvenance = schemaTypeToXML "Provenance"
 
data Provenance = Provenance
        { provenance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , provenance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , provenance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , provenance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , provenance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , provenance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , provenance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenance_target :: [Reference]
          -- ^ The Reference(s) that were generated or updated by the 
          --   activity described in this resource. A provenance can point 
          --   to more than one target if multiple resources were 
          --   created/updated by the same activity.
        , provenance_period :: Maybe Period
          -- ^ The period during which the activity occurred.
        , provenance_recorded :: Instant
          -- ^ The instant of time at which the activity was recorded.
        , provenance_policy :: [Uri]
          -- ^ Policy or plan the activity was defined by. Typically, a 
          --   single activity may have multiple applicable policy 
          --   documents, such as patient consent, guarantor funding, etc.
        , provenance_location :: Maybe Reference
          -- ^ Where the activity occurred, if relevant.
        , provenance_reason :: [Coding]
          -- ^ The reason that the activity was taking place.
        , provenance_activity :: Maybe Coding
          -- ^ An activity is something that occurs over a period of time 
          --   and acts upon or with entities; it may include consuming, 
          --   processing, transforming, modifying, relocating, using, or 
          --   generating entities.
        , provenance_agent :: [Provenance'Agent]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , provenance_entity :: [Provenance'Entity]
          -- ^ An entity used in this activity.
        , provenance_signature :: [Signature]
          -- ^ A digital signature on the target Reference(s). The signer 
          --   should match a Provenance.agent. The purpose of the 
          --   signature is indicated.
        }
        deriving (Eq,Show)
instance SchemaType Provenance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Provenance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "target")
            `apply` optional (parseSchemaType "period")
            `apply` parseSchemaType "recorded"
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "reason")
            `apply` optional (parseSchemaType "activity")
            `apply` many1 (parseSchemaType "agent")
            `apply` many (parseSchemaType "entity")
            `apply` many (parseSchemaType "signature")
    schemaTypeToXML s x@Provenance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ provenance_id x
            , maybe [] (schemaTypeToXML "meta") $ provenance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ provenance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ provenance_language x
            , maybe [] (schemaTypeToXML "text") $ provenance_text x
            , concatMap (schemaTypeToXML "contained") $ provenance_contained x
            , concatMap (schemaTypeToXML "extension") $ provenance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenance_modifierExtension x
            , concatMap (schemaTypeToXML "target") $ provenance_target x
            , maybe [] (schemaTypeToXML "period") $ provenance_period x
            , schemaTypeToXML "recorded" $ provenance_recorded x
            , concatMap (schemaTypeToXML "policy") $ provenance_policy x
            , maybe [] (schemaTypeToXML "location") $ provenance_location x
            , concatMap (schemaTypeToXML "reason") $ provenance_reason x
            , maybe [] (schemaTypeToXML "activity") $ provenance_activity x
            , concatMap (schemaTypeToXML "agent") $ provenance_agent x
            , concatMap (schemaTypeToXML "entity") $ provenance_entity x
            , concatMap (schemaTypeToXML "signature") $ provenance_signature x
            ]
instance Extension Provenance DomainResource where
    supertype (Provenance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Provenance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Provenance -> DomainResource)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
data Provenance'Agent = Provenance'Agent
        { provenance'Agent_id :: Maybe String'primitive
        , provenance'Agent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenance'Agent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenance'Agent_role :: [CodeableConcept]
          -- ^ The function of the agent with respect to the activity. The 
          --   security role enabling the agent with respect to the 
          --   activity.
        , provenance'Agent_choice3 :: OneOf2 Uri Reference
          -- ^ The individual, device or organization that participated in 
          --   the event.
          --   
          --   Choice between:
          --   
          --   (1) whoUri
          --   
          --   (2) whoReference
        , provenance'Agent_choice4 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The individual, device, or organization for whom the change 
          --   was made.
          --   
          --   Choice between:
          --   
          --   (1) onBehalfOfUri
          --   
          --   (2) onBehalfOfReference
        , provenance'Agent_relatedAgentType :: Maybe CodeableConcept
          -- ^ The type of relationship between agents.
        }
        deriving (Eq,Show)
instance SchemaType Provenance'Agent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Provenance'Agent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "role")
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "whoUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "whoReference"))
                           ]
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "onBehalfOfUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "onBehalfOfReference"))
                                     ])
            `apply` optional (parseSchemaType "relatedAgentType")
    schemaTypeToXML s x@Provenance'Agent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenance'Agent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenance'Agent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenance'Agent_modifierExtension x
            , concatMap (schemaTypeToXML "role") $ provenance'Agent_role x
            , foldOneOf2  (schemaTypeToXML "whoUri")
                          (schemaTypeToXML "whoReference")
                          $ provenance'Agent_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "onBehalfOfUri")
                                    (schemaTypeToXML "onBehalfOfReference")
                                   ) $ provenance'Agent_choice4 x
            , maybe [] (schemaTypeToXML "relatedAgentType") $ provenance'Agent_relatedAgentType x
            ]
instance Extension Provenance'Agent BackboneElement where
    supertype (Provenance'Agent a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Provenance'Agent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Provenance'Agent -> BackboneElement)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
data Provenance'Entity = Provenance'Entity
        { provenance'Entity_id :: Maybe String'primitive
        , provenance'Entity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenance'Entity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenance'Entity_role :: ProvenanceEntityRole
          -- ^ How the entity was used during the activity.
        , provenance'Entity_choice3 :: OneOf3 Uri Reference Identifier
          -- ^ Identity of the Entity used. May be a logical or physical 
          --   uri and maybe absolute or relative.
          --   
          --   Choice between:
          --   
          --   (1) whatUri
          --   
          --   (2) whatReference
          --   
          --   (3) whatIdentifier
        , provenance'Entity_agent :: [Provenance'Agent]
          -- ^ The entity is attributed to an agent to express the agent's 
          --   responsibility for that entity, possibly along with other 
          --   agents. This description can be understood as shorthand for 
          --   saying that the agent was responsible for the activity 
          --   which generated the entity.
        }
        deriving (Eq,Show)
instance SchemaType Provenance'Entity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Provenance'Entity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` oneOf' [ ("Uri", fmap OneOf3 (parseSchemaType "whatUri"))
                           , ("Reference", fmap TwoOf3 (parseSchemaType "whatReference"))
                           , ("Identifier", fmap ThreeOf3 (parseSchemaType "whatIdentifier"))
                           ]
            `apply` many (parseSchemaType "agent")
    schemaTypeToXML s x@Provenance'Entity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenance'Entity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenance'Entity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenance'Entity_modifierExtension x
            , schemaTypeToXML "role" $ provenance'Entity_role x
            , foldOneOf3  (schemaTypeToXML "whatUri")
                          (schemaTypeToXML "whatReference")
                          (schemaTypeToXML "whatIdentifier")
                          $ provenance'Entity_choice3 x
            , concatMap (schemaTypeToXML "agent") $ provenance'Entity_agent x
            ]
instance Extension Provenance'Entity BackboneElement where
    supertype (Provenance'Entity a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Provenance'Entity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Provenance'Entity -> BackboneElement)
              
 
data ProvenanceEntityRole'list
    = ProvenanceEntityRole'list_Derivation
      -- ^ Derivation
    | ProvenanceEntityRole'list_Revision
      -- ^ Revision
    | ProvenanceEntityRole'list_Quotation
      -- ^ Quotation
    | ProvenanceEntityRole'list_Source
      -- ^ Source
    | ProvenanceEntityRole'list_Removal
      -- ^ Removal
    deriving (Eq,Show,Enum)
instance SchemaType ProvenanceEntityRole'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ProvenanceEntityRole'list where
    acceptingParser =  do literal "derivation"; return ProvenanceEntityRole'list_Derivation
                      `onFail` do literal "revision"; return ProvenanceEntityRole'list_Revision
                      `onFail` do literal "quotation"; return ProvenanceEntityRole'list_Quotation
                      `onFail` do literal "source"; return ProvenanceEntityRole'list_Source
                      `onFail` do literal "removal"; return ProvenanceEntityRole'list_Removal
                      
    simpleTypeText ProvenanceEntityRole'list_Derivation = "derivation"
    simpleTypeText ProvenanceEntityRole'list_Revision = "revision"
    simpleTypeText ProvenanceEntityRole'list_Quotation = "quotation"
    simpleTypeText ProvenanceEntityRole'list_Source = "source"
    simpleTypeText ProvenanceEntityRole'list_Removal = "removal"
 
data ProvenanceEntityRole = ProvenanceEntityRole
        { provenanceEntityRole_id :: Maybe String'primitive
        , provenanceEntityRole_value :: Maybe ProvenanceEntityRole'list
        , provenanceEntityRole_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ProvenanceEntityRole where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ProvenanceEntityRole a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ProvenanceEntityRole{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenanceEntityRole_id x
                       , maybe [] (toXMLAttribute "value") $ provenanceEntityRole_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenanceEntityRole_extension x
            ]
instance Extension ProvenanceEntityRole Element where
    supertype (ProvenanceEntityRole a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
elementQuestionnaire :: XMLParser Questionnaire
elementQuestionnaire = parseSchemaType "Questionnaire"
elementToXMLQuestionnaire :: Questionnaire -> [Content ()]
elementToXMLQuestionnaire = schemaTypeToXML "Questionnaire"
 
data Questionnaire = Questionnaire
        { questionnaire_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , questionnaire_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , questionnaire_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , questionnaire_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , questionnaire_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , questionnaire_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , questionnaire_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaire_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaire_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this questionnaire 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this 
          --   questionnaire is (or will be) published. The URL SHOULD 
          --   include the major version of the questionnaire. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , questionnaire_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this 
          --   questionnaire when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , questionnaire_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   questionnaire when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the questionnaire author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , questionnaire_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the questionnaire. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , questionnaire_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   questionnaire.
        , questionnaire_status :: PublicationStatus
          -- ^ The status of this questionnaire. Enables tracking the 
          --   life-cycle of the content.
        , questionnaire_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this questionnaire is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , questionnaire_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the questionnaire was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the questionnaire changes.
        , questionnaire_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the questionnaire.
        , questionnaire_description :: Maybe Markdown
          -- ^ A free text natural language description of the 
          --   questionnaire from a consumer's perspective.
        , questionnaire_purpose :: Maybe Markdown
          -- ^ Explaination of why this questionnaire is needed and why it 
          --   has been designed as it has.
        , questionnaire_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , questionnaire_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , questionnaire_effectivePeriod :: Maybe Period
          -- ^ The period during which the questionnaire content was or is 
          --   planned to be in active use.
        , questionnaire_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   questionnaire instances.
        , questionnaire_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the questionnaire is 
          --   intended to be used.
        , questionnaire_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , questionnaire_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the questionnaire and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the 
          --   questionnaire.
        , questionnaire_code :: [Coding]
          -- ^ An identifier for this question or group of questions in a 
          --   particular terminology such as LOINC.
        , questionnaire_subjectType :: [ResourceType]
          -- ^ The types of subjects that can be the subject of responses 
          --   created for the questionnaire.
        , questionnaire_item :: [Questionnaire'Item]
          -- ^ A particular question, question grouping or display text 
          --   that is part of the questionnaire.
        }
        deriving (Eq,Show)
instance SchemaType Questionnaire where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Questionnaire
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "subjectType")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@Questionnaire{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ questionnaire_id x
            , maybe [] (schemaTypeToXML "meta") $ questionnaire_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ questionnaire_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ questionnaire_language x
            , maybe [] (schemaTypeToXML "text") $ questionnaire_text x
            , concatMap (schemaTypeToXML "contained") $ questionnaire_contained x
            , concatMap (schemaTypeToXML "extension") $ questionnaire_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaire_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ questionnaire_url x
            , concatMap (schemaTypeToXML "identifier") $ questionnaire_identifier x
            , maybe [] (schemaTypeToXML "version") $ questionnaire_version x
            , maybe [] (schemaTypeToXML "name") $ questionnaire_name x
            , maybe [] (schemaTypeToXML "title") $ questionnaire_title x
            , schemaTypeToXML "status" $ questionnaire_status x
            , maybe [] (schemaTypeToXML "experimental") $ questionnaire_experimental x
            , maybe [] (schemaTypeToXML "date") $ questionnaire_date x
            , maybe [] (schemaTypeToXML "publisher") $ questionnaire_publisher x
            , maybe [] (schemaTypeToXML "description") $ questionnaire_description x
            , maybe [] (schemaTypeToXML "purpose") $ questionnaire_purpose x
            , maybe [] (schemaTypeToXML "approvalDate") $ questionnaire_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ questionnaire_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ questionnaire_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ questionnaire_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ questionnaire_jurisdiction x
            , concatMap (schemaTypeToXML "contact") $ questionnaire_contact x
            , maybe [] (schemaTypeToXML "copyright") $ questionnaire_copyright x
            , concatMap (schemaTypeToXML "code") $ questionnaire_code x
            , concatMap (schemaTypeToXML "subjectType") $ questionnaire_subjectType x
            , concatMap (schemaTypeToXML "item") $ questionnaire_item x
            ]
instance Extension Questionnaire DomainResource where
    supertype (Questionnaire e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Questionnaire Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Questionnaire -> DomainResource)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data Questionnaire'Item = Questionnaire'Item
        { questionnaire'Item_id :: Maybe String'primitive
        , questionnaire'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaire'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaire'Item_linkId :: Xsd.XsdString
          -- ^ An identifier that is unique within the Questionnaire 
          --   allowing linkage to the equivalent item in a 
          --   QuestionnaireResponse resource.
        , questionnaire'Item_definition :: Maybe Uri
          -- ^ A reference to an [[[ElementDefinition]]] that provides the 
          --   details for the item. If a definition is provided, then the 
          --   following element values can be inferred from the 
          --   definition: * code (ElementDefinition.code) * type 
          --   (ElementDefinition.type) * required (ElementDefinition.min) 
          --   * repeats (ElementDefinition.max) * maxLength 
          --   (ElementDefinition.maxLength) * options 
          --   (ElementDefinition.binding) Any information provided in 
          --   these elements on a Questionnaire Item overrides the 
          --   information from the definition.
        , questionnaire'Item_code :: [Coding]
          -- ^ A terminology code that corresponds to this group or 
          --   question (e.g. a code from LOINC, which defines many 
          --   questions and answers).
        , questionnaire'Item_prefix :: Maybe Xsd.XsdString
          -- ^ A short label for a particular group, question or set of 
          --   display text within the questionnaire used for reference by 
          --   the individual completing the questionnaire.
        , questionnaire'Item_text :: Maybe Xsd.XsdString
          -- ^ The name of a section, the text of a question or text 
          --   content for a display item.
        , questionnaire'Item_type :: QuestionnaireItemType
          -- ^ The type of questionnaire item this is - whether text for 
          --   display, a grouping of other items or a particular type of 
          --   data to be captured (string, integer, coded choice, etc.).
        , questionnaire'Item_enableWhen :: [Questionnaire'EnableWhen]
          -- ^ A constraint indicating that this item should only be 
          --   enabled (displayed/allow answers to be captured) when the 
          --   specified condition is true.
        , questionnaire'Item_required :: Maybe Boolean
          -- ^ An indication, if true, that the item must be present in a 
          --   &quot;completed&quot; QuestionnaireResponse. If false, the 
          --   item may be skipped when answering the questionnaire.
        , questionnaire'Item_repeats :: Maybe Boolean
          -- ^ An indication, if true, that the item may occur multiple 
          --   times in the response, collecting multiple answers answers 
          --   for questions or multiple sets of answers for groups.
        , questionnaire'Item_readOnly :: Maybe Boolean
          -- ^ An indication, when true, that the value cannot be changed 
          --   by a human respondent to the Questionnaire.
        , questionnaire'Item_maxLength :: Maybe Integer
          -- ^ The maximum number of characters that are permitted in the 
          --   answer to be considered a &quot;valid&quot; 
          --   QuestionnaireResponse.
        , questionnaire'Item_options :: Maybe Reference
          -- ^ A reference to a value set containing a list of codes 
          --   representing permitted answers for a &quot;choice&quot; or 
          --   &quot;open-choice&quot; question.
        , questionnaire'Item_option :: [Questionnaire'Option]
          -- ^ One of the permitted answers for a &quot;choice&quot; or 
          --   &quot;open-choice&quot; question.
        , questionnaire'Item_choice15 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ The value that should be defaulted when initially rendering 
          --   the questionnaire for user input.
          --   
          --   Choice between:
          --   
          --   (1) initialBoolean
          --   
          --   (2) initialDecimal
          --   
          --   (3) initialInteger
          --   
          --   (4) initialDate
          --   
          --   (5) initialDateTime
          --   
          --   (6) initialTime
          --   
          --   (7) initialString
          --   
          --   (8) initialUri
          --   
          --   (9) initialAttachment
          --   
          --   (10) initialCoding
          --   
          --   (11) initialQuantity
          --   
          --   (12) initialReference
        , questionnaire'Item_item :: [Questionnaire'Item]
          -- ^ Text, questions and other groups to be nested beneath a 
          --   question or group.
        }
        deriving (Eq,Show)
instance SchemaType Questionnaire'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Questionnaire'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "linkId"
            `apply` optional (parseSchemaType "definition")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "prefix")
            `apply` optional (parseSchemaType "text")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "enableWhen")
            `apply` optional (parseSchemaType "required")
            `apply` optional (parseSchemaType "repeats")
            `apply` optional (parseSchemaType "readOnly")
            `apply` optional (parseSchemaType "maxLength")
            `apply` optional (parseSchemaType "options")
            `apply` many (parseSchemaType "option")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "initialBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "initialDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "initialInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "initialDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "initialDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "initialTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "initialString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "initialUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "initialAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "initialCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "initialQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "initialReference"))
                                     ])
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@Questionnaire'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaire'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaire'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaire'Item_modifierExtension x
            , schemaTypeToXML "linkId" $ questionnaire'Item_linkId x
            , maybe [] (schemaTypeToXML "definition") $ questionnaire'Item_definition x
            , concatMap (schemaTypeToXML "code") $ questionnaire'Item_code x
            , maybe [] (schemaTypeToXML "prefix") $ questionnaire'Item_prefix x
            , maybe [] (schemaTypeToXML "text") $ questionnaire'Item_text x
            , schemaTypeToXML "type" $ questionnaire'Item_type x
            , concatMap (schemaTypeToXML "enableWhen") $ questionnaire'Item_enableWhen x
            , maybe [] (schemaTypeToXML "required") $ questionnaire'Item_required x
            , maybe [] (schemaTypeToXML "repeats") $ questionnaire'Item_repeats x
            , maybe [] (schemaTypeToXML "readOnly") $ questionnaire'Item_readOnly x
            , maybe [] (schemaTypeToXML "maxLength") $ questionnaire'Item_maxLength x
            , maybe [] (schemaTypeToXML "options") $ questionnaire'Item_options x
            , concatMap (schemaTypeToXML "option") $ questionnaire'Item_option x
            , maybe [] (foldOneOf12  (schemaTypeToXML "initialBoolean")
                                     (schemaTypeToXML "initialDecimal")
                                     (schemaTypeToXML "initialInteger")
                                     (schemaTypeToXML "initialDate")
                                     (schemaTypeToXML "initialDateTime")
                                     (schemaTypeToXML "initialTime")
                                     (schemaTypeToXML "initialString")
                                     (schemaTypeToXML "initialUri")
                                     (schemaTypeToXML "initialAttachment")
                                     (schemaTypeToXML "initialCoding")
                                     (schemaTypeToXML "initialQuantity")
                                     (schemaTypeToXML "initialReference")
                                    ) $ questionnaire'Item_choice15 x
            , concatMap (schemaTypeToXML "item") $ questionnaire'Item_item x
            ]
instance Extension Questionnaire'Item BackboneElement where
    supertype (Questionnaire'Item a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension Questionnaire'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Questionnaire'Item -> BackboneElement)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data Questionnaire'EnableWhen = Questionnaire'EnableWhen
        { questionnaire'EnableWhen_id :: Maybe String'primitive
        , questionnaire'EnableWhen_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaire'EnableWhen_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaire'EnableWhen_question :: Xsd.XsdString
          -- ^ The linkId for the question whose answer (or lack of 
          --   answer) governs whether this item is enabled.
        , questionnaire'EnableWhen_hasAnswer :: Maybe Boolean
          -- ^ An indication that this item should be enabled only if the 
          --   specified question is answered (hasAnswer=true) or not 
          --   answered (hasAnswer=false).
        , questionnaire'EnableWhen_choice4 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ An answer that the referenced question must match in order 
          --   for the item to be enabled.
          --   
          --   Choice between:
          --   
          --   (1) answerBoolean
          --   
          --   (2) answerDecimal
          --   
          --   (3) answerInteger
          --   
          --   (4) answerDate
          --   
          --   (5) answerDateTime
          --   
          --   (6) answerTime
          --   
          --   (7) answerString
          --   
          --   (8) answerUri
          --   
          --   (9) answerAttachment
          --   
          --   (10) answerCoding
          --   
          --   (11) answerQuantity
          --   
          --   (12) answerReference
        }
        deriving (Eq,Show)
instance SchemaType Questionnaire'EnableWhen where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Questionnaire'EnableWhen a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "question"
            `apply` optional (parseSchemaType "hasAnswer")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "answerBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "answerDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "answerInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "answerDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "answerDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "answerTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "answerString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "answerUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "answerAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "answerCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "answerQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "answerReference"))
                                     ])
    schemaTypeToXML s x@Questionnaire'EnableWhen{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaire'EnableWhen_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaire'EnableWhen_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaire'EnableWhen_modifierExtension x
            , schemaTypeToXML "question" $ questionnaire'EnableWhen_question x
            , maybe [] (schemaTypeToXML "hasAnswer") $ questionnaire'EnableWhen_hasAnswer x
            , maybe [] (foldOneOf12  (schemaTypeToXML "answerBoolean")
                                     (schemaTypeToXML "answerDecimal")
                                     (schemaTypeToXML "answerInteger")
                                     (schemaTypeToXML "answerDate")
                                     (schemaTypeToXML "answerDateTime")
                                     (schemaTypeToXML "answerTime")
                                     (schemaTypeToXML "answerString")
                                     (schemaTypeToXML "answerUri")
                                     (schemaTypeToXML "answerAttachment")
                                     (schemaTypeToXML "answerCoding")
                                     (schemaTypeToXML "answerQuantity")
                                     (schemaTypeToXML "answerReference")
                                    ) $ questionnaire'EnableWhen_choice4 x
            ]
instance Extension Questionnaire'EnableWhen BackboneElement where
    supertype (Questionnaire'EnableWhen a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Questionnaire'EnableWhen Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Questionnaire'EnableWhen -> BackboneElement)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data Questionnaire'Option = Questionnaire'Option
        { questionnaire'Option_id :: Maybe String'primitive
        , questionnaire'Option_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaire'Option_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaire'Option_choice2 :: OneOf5 Integer Date Time Xsd.XsdString Coding
          -- ^ A potential answer that's allowed as the answer to this 
          --   question.
          --   
          --   Choice between:
          --   
          --   (1) valueInteger
          --   
          --   (2) valueDate
          --   
          --   (3) valueTime
          --   
          --   (4) valueString
          --   
          --   (5) valueCoding
        }
        deriving (Eq,Show)
instance SchemaType Questionnaire'Option where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Questionnaire'Option a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Integer", fmap OneOf5 (parseSchemaType "valueInteger"))
                           , ("Date", fmap TwoOf5 (parseSchemaType "valueDate"))
                           , ("Time", fmap ThreeOf5 (parseSchemaType "valueTime"))
                           , ("Xsd.XsdString", fmap FourOf5 (parseSchemaType "valueString"))
                           , ("Coding", fmap FiveOf5 (parseSchemaType "valueCoding"))
                           ]
    schemaTypeToXML s x@Questionnaire'Option{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaire'Option_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaire'Option_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaire'Option_modifierExtension x
            , foldOneOf5  (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueDate")
                          (schemaTypeToXML "valueTime")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueCoding")
                          $ questionnaire'Option_choice2 x
            ]
instance Extension Questionnaire'Option BackboneElement where
    supertype (Questionnaire'Option a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension Questionnaire'Option Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Questionnaire'Option -> BackboneElement)
              
 
data QuestionnaireItemType'list
    = QuestionnaireItemType'list_Group
      -- ^ Group
    | QuestionnaireItemType'list_Display
      -- ^ Display
    | QuestionnaireItemType'list_Boolean
      -- ^ Boolean
    | QuestionnaireItemType'list_Decimal
      -- ^ Decimal
    | QuestionnaireItemType'list_Integer
      -- ^ Integer
    | QuestionnaireItemType'list_Date
      -- ^ Date
    | QuestionnaireItemType'list_DateTime
      -- ^ Date Time
    | QuestionnaireItemType'list_Time
      -- ^ Time
    | QuestionnaireItemType'list_Xsd.XsdString
      -- ^ String
    | QuestionnaireItemType'list_Text
      -- ^ Text
    | QuestionnaireItemType'list_Url
      -- ^ Url
    | QuestionnaireItemType'list_Choice
      -- ^ Choice
    | QuestionnaireItemType'list_Open'choice
      -- ^ Open Choice
    | QuestionnaireItemType'list_Attachment
      -- ^ Attachment
    | QuestionnaireItemType'list_Reference
      -- ^ Reference
    | QuestionnaireItemType'list_Quantity
      -- ^ Quantity
    deriving (Eq,Show,Enum)
instance SchemaType QuestionnaireItemType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuestionnaireItemType'list where
    acceptingParser =  do literal "group"; return QuestionnaireItemType'list_Group
                      `onFail` do literal "display"; return QuestionnaireItemType'list_Display
                      `onFail` do literal "boolean"; return QuestionnaireItemType'list_Boolean
                      `onFail` do literal "decimal"; return QuestionnaireItemType'list_Decimal
                      `onFail` do literal "integer"; return QuestionnaireItemType'list_Integer
                      `onFail` do literal "date"; return QuestionnaireItemType'list_Date
                      `onFail` do literal "dateTime"; return QuestionnaireItemType'list_DateTime
                      `onFail` do literal "time"; return QuestionnaireItemType'list_Time
                      `onFail` do literal "string"; return QuestionnaireItemType'list_Xsd.XsdString
                      `onFail` do literal "text"; return QuestionnaireItemType'list_Text
                      `onFail` do literal "url"; return QuestionnaireItemType'list_Url
                      `onFail` do literal "choice"; return QuestionnaireItemType'list_Choice
                      `onFail` do literal "open-choice"; return QuestionnaireItemType'list_Open'choice
                      `onFail` do literal "attachment"; return QuestionnaireItemType'list_Attachment
                      `onFail` do literal "reference"; return QuestionnaireItemType'list_Reference
                      `onFail` do literal "quantity"; return QuestionnaireItemType'list_Quantity
                      
    simpleTypeText QuestionnaireItemType'list_Group = "group"
    simpleTypeText QuestionnaireItemType'list_Display = "display"
    simpleTypeText QuestionnaireItemType'list_Boolean = "boolean"
    simpleTypeText QuestionnaireItemType'list_Decimal = "decimal"
    simpleTypeText QuestionnaireItemType'list_Integer = "integer"
    simpleTypeText QuestionnaireItemType'list_Date = "date"
    simpleTypeText QuestionnaireItemType'list_DateTime = "dateTime"
    simpleTypeText QuestionnaireItemType'list_Time = "time"
    simpleTypeText QuestionnaireItemType'list_Xsd.XsdString = "string"
    simpleTypeText QuestionnaireItemType'list_Text = "text"
    simpleTypeText QuestionnaireItemType'list_Url = "url"
    simpleTypeText QuestionnaireItemType'list_Choice = "choice"
    simpleTypeText QuestionnaireItemType'list_Open'choice = "open-choice"
    simpleTypeText QuestionnaireItemType'list_Attachment = "attachment"
    simpleTypeText QuestionnaireItemType'list_Reference = "reference"
    simpleTypeText QuestionnaireItemType'list_Quantity = "quantity"
 
data QuestionnaireItemType = QuestionnaireItemType
        { questionnaireItemType_id :: Maybe String'primitive
        , questionnaireItemType_value :: Maybe QuestionnaireItemType'list
        , questionnaireItemType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireItemType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuestionnaireItemType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuestionnaireItemType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireItemType_id x
                       , maybe [] (toXMLAttribute "value") $ questionnaireItemType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireItemType_extension x
            ]
instance Extension QuestionnaireItemType Element where
    supertype (QuestionnaireItemType a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
elementQuestionnaireResponse :: XMLParser QuestionnaireResponse
elementQuestionnaireResponse = parseSchemaType "QuestionnaireResponse"
elementToXMLQuestionnaireResponse :: QuestionnaireResponse -> [Content ()]
elementToXMLQuestionnaireResponse = schemaTypeToXML "QuestionnaireResponse"
 
data QuestionnaireResponse = QuestionnaireResponse
        { questionnaireResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , questionnaireResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , questionnaireResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , questionnaireResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , questionnaireResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , questionnaireResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , questionnaireResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponse_identifier :: Maybe Identifier
          -- ^ A business identifier assigned to a particular completed 
          --   (or partially completed) questionnaire.
        , questionnaireResponse_basedOn :: [Reference]
          -- ^ The order, proposal or plan that is fulfilled in whole or 
          --   in part by this QuestionnaireResponse. For example, a 
          --   ProcedureRequest seeking an intake assessment or a decision 
          --   support recommendation to assess for post-partum 
          --   depression.
        , questionnaireResponse_parent :: [Reference]
          -- ^ A procedure or observation that this questionnaire was 
          --   performed as part of the execution of. For example, the 
          --   surgery a checklist was executed as part of.
        , questionnaireResponse_questionnaire :: Maybe Reference
          -- ^ The Questionnaire that defines and organizes the questions 
          --   for which answers are being provided.
        , questionnaireResponse_status :: QuestionnaireResponseStatus
          -- ^ The position of the questionnaire response within its 
          --   overall lifecycle.
        , questionnaireResponse_subject :: Maybe Reference
          -- ^ The subject of the questionnaire response. This could be a 
          --   patient, organization, practitioner, device, etc. This is 
          --   who/what the answers apply to, but is not necessarily the 
          --   source of information.
        , questionnaireResponse_context :: Maybe Reference
          -- ^ The encounter or episode of care with primary association 
          --   to the questionnaire response.
        , questionnaireResponse_authored :: Maybe DateTime
          -- ^ The date and/or time that this set of answers were last 
          --   changed.
        , questionnaireResponse_author :: Maybe Reference
          -- ^ Person who received the answers to the questions in the 
          --   QuestionnaireResponse and recorded them in the system.
        , questionnaireResponse_source :: Maybe Reference
          -- ^ The person who answered the questions about the subject.
        , questionnaireResponse_item :: [QuestionnaireResponse'Item]
          -- ^ A group or question item from the original questionnaire 
          --   for which answers are provided.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return QuestionnaireResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "parent")
            `apply` optional (parseSchemaType "questionnaire")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "authored")
            `apply` optional (parseSchemaType "author")
            `apply` optional (parseSchemaType "source")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ questionnaireResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ questionnaireResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ questionnaireResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ questionnaireResponse_language x
            , maybe [] (schemaTypeToXML "text") $ questionnaireResponse_text x
            , concatMap (schemaTypeToXML "contained") $ questionnaireResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ questionnaireResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponse_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ questionnaireResponse_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ questionnaireResponse_basedOn x
            , concatMap (schemaTypeToXML "parent") $ questionnaireResponse_parent x
            , maybe [] (schemaTypeToXML "questionnaire") $ questionnaireResponse_questionnaire x
            , schemaTypeToXML "status" $ questionnaireResponse_status x
            , maybe [] (schemaTypeToXML "subject") $ questionnaireResponse_subject x
            , maybe [] (schemaTypeToXML "context") $ questionnaireResponse_context x
            , maybe [] (schemaTypeToXML "authored") $ questionnaireResponse_authored x
            , maybe [] (schemaTypeToXML "author") $ questionnaireResponse_author x
            , maybe [] (schemaTypeToXML "source") $ questionnaireResponse_source x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponse_item x
            ]
instance Extension QuestionnaireResponse DomainResource where
    supertype (QuestionnaireResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension QuestionnaireResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: QuestionnaireResponse -> DomainResource)
              
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
data QuestionnaireResponse'Item = QuestionnaireResponse'Item
        { questionnaireResponse'Item_id :: Maybe String'primitive
        , questionnaireResponse'Item_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponse'Item_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponse'Item_linkId :: Xsd.XsdString
          -- ^ The item from the Questionnaire that corresponds to this 
          --   item in the QuestionnaireResponse resource.
        , questionnaireResponse'Item_definition :: Maybe Uri
          -- ^ A reference to an [[[ElementDefinition]]] that provides the 
          --   details for the item.
        , questionnaireResponse'Item_text :: Maybe Xsd.XsdString
          -- ^ Text that is displayed above the contents of the group or 
          --   as the text of the question being answered.
        , questionnaireResponse'Item_subject :: Maybe Reference
          -- ^ More specific subject this section's answers are about, 
          --   details the subject given in QuestionnaireResponse.
        , questionnaireResponse'Item_answer :: [QuestionnaireResponse'Answer]
          -- ^ The respondent's answer(s) to the question.
        , questionnaireResponse'Item_item :: [QuestionnaireResponse'Item]
          -- ^ Questions or sub-groups nested beneath a question or group.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponse'Item where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireResponse'Item a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "linkId"
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "answer")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponse'Item{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponse'Item_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponse'Item_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponse'Item_modifierExtension x
            , schemaTypeToXML "linkId" $ questionnaireResponse'Item_linkId x
            , maybe [] (schemaTypeToXML "definition") $ questionnaireResponse'Item_definition x
            , maybe [] (schemaTypeToXML "text") $ questionnaireResponse'Item_text x
            , maybe [] (schemaTypeToXML "subject") $ questionnaireResponse'Item_subject x
            , concatMap (schemaTypeToXML "answer") $ questionnaireResponse'Item_answer x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponse'Item_item x
            ]
instance Extension QuestionnaireResponse'Item BackboneElement where
    supertype (QuestionnaireResponse'Item a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireResponse'Item Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireResponse'Item -> BackboneElement)
              
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
data QuestionnaireResponse'Answer = QuestionnaireResponse'Answer
        { questionnaireResponse'Answer_id :: Maybe String'primitive
        , questionnaireResponse'Answer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponse'Answer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponse'Answer_choice2 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ The answer (or one of the answers) provided by the 
          --   respondent to the question.
          --   
          --   Choice between:
          --   
          --   (1) valueBoolean
          --   
          --   (2) valueDecimal
          --   
          --   (3) valueInteger
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueTime
          --   
          --   (7) valueString
          --   
          --   (8) valueUri
          --   
          --   (9) valueAttachment
          --   
          --   (10) valueCoding
          --   
          --   (11) valueQuantity
          --   
          --   (12) valueReference
        , questionnaireResponse'Answer_item :: [QuestionnaireResponse'Item]
          -- ^ Nested groups and/or questions found within this particular 
          --   answer.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponse'Answer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireResponse'Answer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "valueBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "valueDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "valueInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "valueDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "valueTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "valueString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "valueUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "valueAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "valueCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "valueQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "valueReference"))
                                     ])
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponse'Answer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponse'Answer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponse'Answer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponse'Answer_modifierExtension x
            , maybe [] (foldOneOf12  (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueReference")
                                    ) $ questionnaireResponse'Answer_choice2 x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponse'Answer_item x
            ]
instance Extension QuestionnaireResponse'Answer BackboneElement where
    supertype (QuestionnaireResponse'Answer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireResponse'Answer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireResponse'Answer -> BackboneElement)
              
 
data QuestionnaireResponseStatus'list
    = QuestionnaireResponseStatus'list_In'progress
      -- ^ In Progress
    | QuestionnaireResponseStatus'list_Completed
      -- ^ Completed
    | QuestionnaireResponseStatus'list_Amended
      -- ^ Amended
    | QuestionnaireResponseStatus'list_Entered'in'error
      -- ^ Entered in Error
    | QuestionnaireResponseStatus'list_Stopped
      -- ^ Stopped
    deriving (Eq,Show,Enum)
instance SchemaType QuestionnaireResponseStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuestionnaireResponseStatus'list where
    acceptingParser =  do literal "in-progress"; return QuestionnaireResponseStatus'list_In'progress
                      `onFail` do literal "completed"; return QuestionnaireResponseStatus'list_Completed
                      `onFail` do literal "amended"; return QuestionnaireResponseStatus'list_Amended
                      `onFail` do literal "entered-in-error"; return QuestionnaireResponseStatus'list_Entered'in'error
                      `onFail` do literal "stopped"; return QuestionnaireResponseStatus'list_Stopped
                      
    simpleTypeText QuestionnaireResponseStatus'list_In'progress = "in-progress"
    simpleTypeText QuestionnaireResponseStatus'list_Completed = "completed"
    simpleTypeText QuestionnaireResponseStatus'list_Amended = "amended"
    simpleTypeText QuestionnaireResponseStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText QuestionnaireResponseStatus'list_Stopped = "stopped"
 
data QuestionnaireResponseStatus = QuestionnaireResponseStatus
        { questionnaireResponseStatus_id :: Maybe String'primitive
        , questionnaireResponseStatus_value :: Maybe QuestionnaireResponseStatus'list
        , questionnaireResponseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuestionnaireResponseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuestionnaireResponseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ questionnaireResponseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponseStatus_extension x
            ]
instance Extension QuestionnaireResponseStatus Element where
    supertype (QuestionnaireResponseStatus a0 a1 e0) =
               Element a0 e0
 
-- | Used to record and send details about a request for 
--   referral service or transfer of a patient to the care of 
--   another provider or provider organization.
elementReferralRequest :: XMLParser ReferralRequest
elementReferralRequest = parseSchemaType "ReferralRequest"
elementToXMLReferralRequest :: ReferralRequest -> [Content ()]
elementToXMLReferralRequest = schemaTypeToXML "ReferralRequest"
 
data ReferralRequest = ReferralRequest
        { referralRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , referralRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , referralRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , referralRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , referralRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , referralRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , referralRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , referralRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , referralRequest_identifier :: [Identifier]
          -- ^ Business identifier that uniquely identifies the 
          --   referral/care transfer request instance.
        , referralRequest_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that is 
          --   adhered to in whole or in part by this request.
        , referralRequest_basedOn :: [Reference]
          -- ^ Indicates any plans, proposals or orders that this request 
          --   is intended to satisfy - in whole or in part.
        , referralRequest_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , referralRequest_groupIdentifier :: Maybe Identifier
          -- ^ The business identifier of the logical &quot;grouping&quot; 
          --   request/order that this referral is a part of.
        , referralRequest_status :: RequestStatus
          -- ^ The status of the authorization/intention reflected by the 
          --   referral request record.
        , referralRequest_intent :: RequestIntent
          -- ^ Distinguishes the &quot;level&quot; of authorization/demand 
          --   implicit in this request.
        , referralRequest_type :: Maybe CodeableConcept
          -- ^ An indication of the type of referral (or where applicable 
          --   the type of transfer of care) request.
        , referralRequest_priority :: Maybe RequestPriority
          -- ^ An indication of the urgency of referral (or where 
          --   applicable the type of transfer of care) request.
        , referralRequest_serviceRequested :: [CodeableConcept]
          -- ^ The service(s) that is/are requested to be provided to the 
          --   patient. For example: cardiac pacemaker insertion.
        , referralRequest_subject :: Reference
          -- ^ The patient who is the subject of a referral or transfer of 
          --   care request.
        , referralRequest_context :: Maybe Reference
          -- ^ The encounter at which the request for referral or transfer 
          --   of care is initiated.
        , referralRequest_choice20 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The period of time within which the services identified in 
          --   the referral/transfer of care is specified or required to 
          --   occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , referralRequest_authoredOn :: Maybe DateTime
          -- ^ Date/DateTime of creation for draft requests and date of 
          --   activation for active requests.
        , referralRequest_requester :: Maybe ReferralRequest'Requester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , referralRequest_specialty :: Maybe CodeableConcept
          -- ^ Indication of the clinical domain or discipline to which 
          --   the referral or transfer of care request is sent. For 
          --   example: Cardiology Gastroenterology Diabetology.
        , referralRequest_recipient :: [Reference]
          -- ^ The healthcare provider(s) or provider organization(s) 
          --   who/which is to receive the referral/transfer of care 
          --   request.
        , referralRequest_reasonCode :: [CodeableConcept]
          -- ^ Description of clinical condition indicating why 
          --   referral/transfer of care is requested. For example: 
          --   Pathological Anomalies, Disabled (physical or mental), 
          --   Behavioral Management.
        , referralRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   request.
        , referralRequest_description :: Maybe Xsd.XsdString
          -- ^ The reason element gives a short description of why the 
          --   referral is being made, the description expands on this to 
          --   support a more complete clinical summary.
        , referralRequest_supportingInfo :: [Reference]
          -- ^ Any additional (administrative, financial or clinical) 
          --   information required to support request for referral or 
          --   transfer of care. For example: Presenting problems/chief 
          --   complaints Medical History Family History Alerts 
          --   Allergy/Intolerance and Adverse Reactions Medications 
          --   Observations/Assessments (may include cognitive and 
          --   fundtional assessments) Diagnostic Reports Care Plan.
        , referralRequest_note :: [Annotation]
          -- ^ Comments made about the referral request by any of the 
          --   participants.
        , referralRequest_relevantHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this 
          --   resource or fulfilling request or event resources that 
          --   identify key state transitions or updates that are likely 
          --   to be relevant to a user looking at the current version of 
          --   the resource.
        }
        deriving (Eq,Show)
instance SchemaType ReferralRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ReferralRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "priority")
            `apply` many (parseSchemaType "serviceRequested")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "specialty")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@ReferralRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ referralRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ referralRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ referralRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ referralRequest_language x
            , maybe [] (schemaTypeToXML "text") $ referralRequest_text x
            , concatMap (schemaTypeToXML "contained") $ referralRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ referralRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ referralRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ referralRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ referralRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ referralRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ referralRequest_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ referralRequest_groupIdentifier x
            , schemaTypeToXML "status" $ referralRequest_status x
            , schemaTypeToXML "intent" $ referralRequest_intent x
            , maybe [] (schemaTypeToXML "type") $ referralRequest_type x
            , maybe [] (schemaTypeToXML "priority") $ referralRequest_priority x
            , concatMap (schemaTypeToXML "serviceRequested") $ referralRequest_serviceRequested x
            , schemaTypeToXML "subject" $ referralRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ referralRequest_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ referralRequest_choice20 x
            , maybe [] (schemaTypeToXML "authoredOn") $ referralRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ referralRequest_requester x
            , maybe [] (schemaTypeToXML "specialty") $ referralRequest_specialty x
            , concatMap (schemaTypeToXML "recipient") $ referralRequest_recipient x
            , concatMap (schemaTypeToXML "reasonCode") $ referralRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ referralRequest_reasonReference x
            , maybe [] (schemaTypeToXML "description") $ referralRequest_description x
            , concatMap (schemaTypeToXML "supportingInfo") $ referralRequest_supportingInfo x
            , concatMap (schemaTypeToXML "note") $ referralRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ referralRequest_relevantHistory x
            ]
instance Extension ReferralRequest DomainResource where
    supertype (ReferralRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ReferralRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ReferralRequest -> DomainResource)
              
 
-- | Used to record and send details about a request for 
--   referral service or transfer of a patient to the care of 
--   another provider or provider organization.
data ReferralRequest'Requester = ReferralRequest'Requester
        { referralRequest'Requester_id :: Maybe String'primitive
        , referralRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , referralRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , referralRequest'Requester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , referralRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType ReferralRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ReferralRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@ReferralRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referralRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referralRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ referralRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ referralRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ referralRequest'Requester_onBehalfOf x
            ]
instance Extension ReferralRequest'Requester BackboneElement where
    supertype (ReferralRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ReferralRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ReferralRequest'Requester -> BackboneElement)
              
 
-- | Information about a person that is involved in the care for 
--   a patient, but who is not the target of healthcare, nor has 
--   a formal responsibility in the care process.
elementRelatedPerson :: XMLParser RelatedPerson
elementRelatedPerson = parseSchemaType "RelatedPerson"
elementToXMLRelatedPerson :: RelatedPerson -> [Content ()]
elementToXMLRelatedPerson = schemaTypeToXML "RelatedPerson"
 
data RelatedPerson = RelatedPerson
        { relatedPerson_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , relatedPerson_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , relatedPerson_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , relatedPerson_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , relatedPerson_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , relatedPerson_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , relatedPerson_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , relatedPerson_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , relatedPerson_identifier :: [Identifier]
          -- ^ Identifier for a person within a particular scope.
        , relatedPerson_active :: Maybe Boolean
          -- ^ Whether this related person record is in active use.
        , relatedPerson_patient :: Reference
          -- ^ The patient this person is related to.
        , relatedPerson_relationship :: Maybe CodeableConcept
          -- ^ The nature of the relationship between a patient and the 
          --   related person.
        , relatedPerson_name :: [HumanName]
          -- ^ A name associated with the person.
        , relatedPerson_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , relatedPerson_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the person is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , relatedPerson_birthDate :: Maybe Date
          -- ^ The date on which the related person was born.
        , relatedPerson_address :: [Address]
          -- ^ Address where the related person can be contacted or 
          --   visited.
        , relatedPerson_photo :: [Attachment]
          -- ^ Image of the person.
        , relatedPerson_period :: Maybe Period
          -- ^ The period of time that this relationship is considered to 
          --   be valid. If there are no dates defined, then the interval 
          --   is unknown.
        }
        deriving (Eq,Show)
instance SchemaType RelatedPerson where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RelatedPerson
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "relationship")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "address")
            `apply` many (parseSchemaType "photo")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@RelatedPerson{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ relatedPerson_id x
            , maybe [] (schemaTypeToXML "meta") $ relatedPerson_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ relatedPerson_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ relatedPerson_language x
            , maybe [] (schemaTypeToXML "text") $ relatedPerson_text x
            , concatMap (schemaTypeToXML "contained") $ relatedPerson_contained x
            , concatMap (schemaTypeToXML "extension") $ relatedPerson_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ relatedPerson_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ relatedPerson_identifier x
            , maybe [] (schemaTypeToXML "active") $ relatedPerson_active x
            , schemaTypeToXML "patient" $ relatedPerson_patient x
            , maybe [] (schemaTypeToXML "relationship") $ relatedPerson_relationship x
            , concatMap (schemaTypeToXML "name") $ relatedPerson_name x
            , concatMap (schemaTypeToXML "telecom") $ relatedPerson_telecom x
            , maybe [] (schemaTypeToXML "gender") $ relatedPerson_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ relatedPerson_birthDate x
            , concatMap (schemaTypeToXML "address") $ relatedPerson_address x
            , concatMap (schemaTypeToXML "photo") $ relatedPerson_photo x
            , maybe [] (schemaTypeToXML "period") $ relatedPerson_period x
            ]
instance Extension RelatedPerson DomainResource where
    supertype (RelatedPerson e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RelatedPerson Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RelatedPerson -> DomainResource)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
elementRequestGroup :: XMLParser RequestGroup
elementRequestGroup = parseSchemaType "RequestGroup"
elementToXMLRequestGroup :: RequestGroup -> [Content ()]
elementToXMLRequestGroup = schemaTypeToXML "RequestGroup"
 
data RequestGroup = RequestGroup
        { requestGroup_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , requestGroup_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , requestGroup_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , requestGroup_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , requestGroup_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , requestGroup_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , requestGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroup_identifier :: [Identifier]
          -- ^ Allows a service to provide a unique, business identifier 
          --   for the request.
        , requestGroup_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that is 
          --   adhered to in whole or in part by this request.
        , requestGroup_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this request.
        , requestGroup_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , requestGroup_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition, 
          --   prescription or similar form.
        , requestGroup_status :: RequestStatus
          -- ^ The current state of the request. For request groups, the 
          --   status reflects the status of all the requests in the 
          --   group.
        , requestGroup_intent :: RequestIntent
          -- ^ Indicates the level of authority/intentionality associated 
          --   with the request and where the request fits into the 
          --   workflow chain.
        , requestGroup_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the request should be addressed with 
          --   respect to other requests.
        , requestGroup_subject :: Maybe Reference
          -- ^ The subject for which the request group was created.
        , requestGroup_context :: Maybe Reference
          -- ^ Describes the context of the request group, if any.
        , requestGroup_authoredOn :: Maybe DateTime
          -- ^ Indicates when the request group was created.
        , requestGroup_author :: Maybe Reference
          -- ^ Provides a reference to the author of the request group.
        , requestGroup_choice20 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason the request group was created. This is 
          --   typically provided as a parameter to the evaluation and 
          --   echoed by the service, although for some use cases, such as 
          --   subscription- or event-based scenarios, it may provide an 
          --   indication of the cause for the response.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , requestGroup_note :: [Annotation]
          -- ^ Provides a mechanism to communicate additional information 
          --   about the response.
        , requestGroup_action :: [RequestGroup'Action]
          -- ^ The actions, if any, produced by the evaluation of the 
          --   artifact.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RequestGroup
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "author")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@RequestGroup{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ requestGroup_id x
            , maybe [] (schemaTypeToXML "meta") $ requestGroup_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ requestGroup_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ requestGroup_language x
            , maybe [] (schemaTypeToXML "text") $ requestGroup_text x
            , concatMap (schemaTypeToXML "contained") $ requestGroup_contained x
            , concatMap (schemaTypeToXML "extension") $ requestGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroup_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ requestGroup_identifier x
            , concatMap (schemaTypeToXML "definition") $ requestGroup_definition x
            , concatMap (schemaTypeToXML "basedOn") $ requestGroup_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ requestGroup_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ requestGroup_groupIdentifier x
            , schemaTypeToXML "status" $ requestGroup_status x
            , schemaTypeToXML "intent" $ requestGroup_intent x
            , maybe [] (schemaTypeToXML "priority") $ requestGroup_priority x
            , maybe [] (schemaTypeToXML "subject") $ requestGroup_subject x
            , maybe [] (schemaTypeToXML "context") $ requestGroup_context x
            , maybe [] (schemaTypeToXML "authoredOn") $ requestGroup_authoredOn x
            , maybe [] (schemaTypeToXML "author") $ requestGroup_author x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ requestGroup_choice20 x
            , concatMap (schemaTypeToXML "note") $ requestGroup_note x
            , concatMap (schemaTypeToXML "action") $ requestGroup_action x
            ]
instance Extension RequestGroup DomainResource where
    supertype (RequestGroup e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RequestGroup Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RequestGroup -> DomainResource)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroup'Action = RequestGroup'Action
        { requestGroup'Action_id :: Maybe String'primitive
        , requestGroup'Action_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroup'Action_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroup'Action_label :: Maybe Xsd.XsdString
          -- ^ A user-visible label for the action.
        , requestGroup'Action_title :: Maybe Xsd.XsdString
          -- ^ The title of the action displayed to a user.
        , requestGroup'Action_description :: Maybe Xsd.XsdString
          -- ^ A short description of the action used to provide a summary 
          --   to display to the user.
        , requestGroup'Action_textEquivalent :: Maybe Xsd.XsdString
          -- ^ A text equivalent of the action to be performed. This 
          --   provides a human-interpretable description of the action 
          --   when the definition is consumed by a system that may not be 
          --   capable of interpreting it dynamically.
        , requestGroup'Action_code :: [CodeableConcept]
          -- ^ A code that provides meaning for the action or action 
          --   group. For example, a section may have a LOINC code for a 
          --   the section of a documentation template.
        , requestGroup'Action_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the action that can be provided to the CDS recipient. 
          --   Information resources can include inline text commentary 
          --   and links to web resources.
        , requestGroup'Action_condition :: [RequestGroup'Condition]
          -- ^ An expression that describes applicability criteria, or 
          --   start/stop conditions for the action.
        , requestGroup'Action_relatedAction :: [RequestGroup'RelatedAction]
          -- ^ A relationship to another action such as &quot;before&quot; 
          --   or &quot;30-60 minutes after start of&quot;.
        , requestGroup'Action_choice10 :: (Maybe (OneOf5 DateTime Period Duration Range Timing))
          -- ^ An optional value describing when the action should be 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) timingDateTime
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDuration
          --   
          --   (4) timingRange
          --   
          --   (5) timingTiming
        , requestGroup'Action_participant :: [Reference]
          -- ^ The participant that should perform or be responsible for 
          --   this action.
        , requestGroup'Action_type :: Maybe Coding
          -- ^ The type of action to perform (create, update, remove).
        , requestGroup'Action_groupingBehavior :: Maybe ActionGroupingBehavior
          -- ^ Defines the grouping behavior for the action and its 
          --   children.
        , requestGroup'Action_selectionBehavior :: Maybe ActionSelectionBehavior
          -- ^ Defines the selection behavior for the action and its 
          --   children.
        , requestGroup'Action_requiredBehavior :: Maybe ActionRequiredBehavior
          -- ^ Defines the requiredness behavior for the action.
        , requestGroup'Action_precheckBehavior :: Maybe ActionPrecheckBehavior
          -- ^ Defines whether the action should usually be preselected.
        , requestGroup'Action_cardinalityBehavior :: Maybe ActionCardinalityBehavior
          -- ^ Defines whether the action can be selected multiple times.
        , requestGroup'Action_resource :: Maybe Reference
          -- ^ The resource that is the target of the action (e.g. 
          --   CommunicationRequest).
        , requestGroup'Action_action :: [RequestGroup'Action]
          -- ^ Sub actions.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroup'Action where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroup'Action a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "textEquivalent")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "relatedAction")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap TwoOf5 (parseSchemaType "timingPeriod"))
                                     , ("Duration", fmap ThreeOf5 (parseSchemaType "timingDuration"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "timingRange"))
                                     , ("Timing", fmap FiveOf5 (parseSchemaType "timingTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "groupingBehavior")
            `apply` optional (parseSchemaType "selectionBehavior")
            `apply` optional (parseSchemaType "requiredBehavior")
            `apply` optional (parseSchemaType "precheckBehavior")
            `apply` optional (parseSchemaType "cardinalityBehavior")
            `apply` optional (parseSchemaType "resource")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@RequestGroup'Action{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroup'Action_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroup'Action_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroup'Action_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ requestGroup'Action_label x
            , maybe [] (schemaTypeToXML "title") $ requestGroup'Action_title x
            , maybe [] (schemaTypeToXML "description") $ requestGroup'Action_description x
            , maybe [] (schemaTypeToXML "textEquivalent") $ requestGroup'Action_textEquivalent x
            , concatMap (schemaTypeToXML "code") $ requestGroup'Action_code x
            , concatMap (schemaTypeToXML "documentation") $ requestGroup'Action_documentation x
            , concatMap (schemaTypeToXML "condition") $ requestGroup'Action_condition x
            , concatMap (schemaTypeToXML "relatedAction") $ requestGroup'Action_relatedAction x
            , maybe [] (foldOneOf5  (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDuration")
                                    (schemaTypeToXML "timingRange")
                                    (schemaTypeToXML "timingTiming")
                                   ) $ requestGroup'Action_choice10 x
            , concatMap (schemaTypeToXML "participant") $ requestGroup'Action_participant x
            , maybe [] (schemaTypeToXML "type") $ requestGroup'Action_type x
            , maybe [] (schemaTypeToXML "groupingBehavior") $ requestGroup'Action_groupingBehavior x
            , maybe [] (schemaTypeToXML "selectionBehavior") $ requestGroup'Action_selectionBehavior x
            , maybe [] (schemaTypeToXML "requiredBehavior") $ requestGroup'Action_requiredBehavior x
            , maybe [] (schemaTypeToXML "precheckBehavior") $ requestGroup'Action_precheckBehavior x
            , maybe [] (schemaTypeToXML "cardinalityBehavior") $ requestGroup'Action_cardinalityBehavior x
            , maybe [] (schemaTypeToXML "resource") $ requestGroup'Action_resource x
            , concatMap (schemaTypeToXML "action") $ requestGroup'Action_action x
            ]
instance Extension RequestGroup'Action BackboneElement where
    supertype (RequestGroup'Action a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               BackboneElement a0 e0 e1
instance Extension RequestGroup'Action Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroup'Action -> BackboneElement)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroup'Condition = RequestGroup'Condition
        { requestGroup'Condition_id :: Maybe String'primitive
        , requestGroup'Condition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroup'Condition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroup'Condition_kind :: ActionConditionKind
          -- ^ The kind of condition.
        , requestGroup'Condition_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the condition that 
          --   effectively communicates the intended semantics.
        , requestGroup'Condition_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , requestGroup'Condition_expression :: Maybe Xsd.XsdString
          -- ^ An expression that returns true or false, indicating 
          --   whether or not the condition is satisfied.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroup'Condition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroup'Condition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@RequestGroup'Condition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroup'Condition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroup'Condition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroup'Condition_modifierExtension x
            , schemaTypeToXML "kind" $ requestGroup'Condition_kind x
            , maybe [] (schemaTypeToXML "description") $ requestGroup'Condition_description x
            , maybe [] (schemaTypeToXML "language") $ requestGroup'Condition_language x
            , maybe [] (schemaTypeToXML "expression") $ requestGroup'Condition_expression x
            ]
instance Extension RequestGroup'Condition BackboneElement where
    supertype (RequestGroup'Condition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension RequestGroup'Condition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroup'Condition -> BackboneElement)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroup'RelatedAction = RequestGroup'RelatedAction
        { requestGroup'RelatedAction_id :: Maybe String'primitive
        , requestGroup'RelatedAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroup'RelatedAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroup'RelatedAction_actionId :: Id
          -- ^ The element id of the action this is related to.
        , requestGroup'RelatedAction_relationship :: ActionRelationshipType
          -- ^ The relationship of this action to the related action.
        , requestGroup'RelatedAction_choice4 :: (Maybe (OneOf2 Duration Range))
          -- ^ A duration or range of durations to apply to the 
          --   relationship. For example, 30-60 minutes before.
          --   
          --   Choice between:
          --   
          --   (1) offsetDuration
          --   
          --   (2) offsetRange
        }
        deriving (Eq,Show)
instance SchemaType RequestGroup'RelatedAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroup'RelatedAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actionId"
            `apply` parseSchemaType "relationship"
            `apply` optional (oneOf' [ ("Duration", fmap OneOf2 (parseSchemaType "offsetDuration"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "offsetRange"))
                                     ])
    schemaTypeToXML s x@RequestGroup'RelatedAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroup'RelatedAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroup'RelatedAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroup'RelatedAction_modifierExtension x
            , schemaTypeToXML "actionId" $ requestGroup'RelatedAction_actionId x
            , schemaTypeToXML "relationship" $ requestGroup'RelatedAction_relationship x
            , maybe [] (foldOneOf2  (schemaTypeToXML "offsetDuration")
                                    (schemaTypeToXML "offsetRange")
                                   ) $ requestGroup'RelatedAction_choice4 x
            ]
instance Extension RequestGroup'RelatedAction BackboneElement where
    supertype (RequestGroup'RelatedAction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension RequestGroup'RelatedAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroup'RelatedAction -> BackboneElement)
              
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
elementResearchStudy :: XMLParser ResearchStudy
elementResearchStudy = parseSchemaType "ResearchStudy"
elementToXMLResearchStudy :: ResearchStudy -> [Content ()]
elementToXMLResearchStudy = schemaTypeToXML "ResearchStudy"
 
data ResearchStudy = ResearchStudy
        { researchStudy_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , researchStudy_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , researchStudy_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , researchStudy_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , researchStudy_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , researchStudy_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , researchStudy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchStudy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchStudy_identifier :: [Identifier]
          -- ^ Identifiers assigned to this research study by the sponsor 
          --   or other systems.
        , researchStudy_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive user-friendly label for the study.
        , researchStudy_protocol :: [Reference]
          -- ^ The set of steps expected to be performed as part of the 
          --   execution of the study.
        , researchStudy_partOf :: [Reference]
          -- ^ A larger research study of which this particular study is a 
          --   component or step.
        , researchStudy_status :: ResearchStudyStatus
          -- ^ The current state of the study.
        , researchStudy_category :: [CodeableConcept]
          -- ^ Codes categorizing the type of study such as 
          --   investigational vs. observational, type of blinding, type 
          --   of randomization, safety vs. efficacy, etc.
        , researchStudy_focus :: [CodeableConcept]
          -- ^ The condition(s), medication(s), food(s), therapy(ies), 
          --   device(s) or other concerns or interventions that the study 
          --   is seeking to gain more information about.
        , researchStudy_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in learning more about or 
          --   engaging with the study.
        , researchStudy_relatedArtifact :: [RelatedArtifact]
          -- ^ Citations, references and other related documents.
        , researchStudy_keyword :: [CodeableConcept]
          -- ^ Key terms to aid in searching for or filtering the study.
        , researchStudy_jurisdiction :: [CodeableConcept]
          -- ^ Indicates a country, state or other region where the study 
          --   is taking place.
        , researchStudy_description :: Maybe Markdown
          -- ^ A full description of how the study is being conducted.
        , researchStudy_enrollment :: [Reference]
          -- ^ Reference to a Group that defines the criteria for and 
          --   quantity of subjects participating in the study. E.g. 
          --   &quot; 200 female Europeans between the ages of 20 and 45 
          --   with early onset diabetes&quot;.
        , researchStudy_period :: Maybe Period
          -- ^ Identifies the start date and the expected (or actual, 
          --   depending on status) end date for the study.
        , researchStudy_sponsor :: Maybe Reference
          -- ^ The organization responsible for the execution of the 
          --   study.
        , researchStudy_principalInvestigator :: Maybe Reference
          -- ^ Indicates the individual who has primary oversite of the 
          --   execution of the study.
        , researchStudy_site :: [Reference]
          -- ^ Clinic, hospital or other healthcare location that is 
          --   participating in the study.
        , researchStudy_reasonStopped :: Maybe CodeableConcept
          -- ^ A description and/or code explaining the premature 
          --   termination of the study.
        , researchStudy_note :: [Annotation]
          -- ^ Comments made about the event by the performer, subject or 
          --   other participants.
        , researchStudy_arm :: [ResearchStudy'Arm]
          -- ^ Describes an expected sequence of events for one of the 
          --   participants of a study. E.g. Exposure to drug A, wash-out, 
          --   exposure to drug B, wash-out, follow-up.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResearchStudy
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "title")
            `apply` many (parseSchemaType "protocol")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` many (parseSchemaType "focus")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "keyword")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "enrollment")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "sponsor")
            `apply` optional (parseSchemaType "principalInvestigator")
            `apply` many (parseSchemaType "site")
            `apply` optional (parseSchemaType "reasonStopped")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "arm")
    schemaTypeToXML s x@ResearchStudy{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ researchStudy_id x
            , maybe [] (schemaTypeToXML "meta") $ researchStudy_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ researchStudy_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ researchStudy_language x
            , maybe [] (schemaTypeToXML "text") $ researchStudy_text x
            , concatMap (schemaTypeToXML "contained") $ researchStudy_contained x
            , concatMap (schemaTypeToXML "extension") $ researchStudy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchStudy_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ researchStudy_identifier x
            , maybe [] (schemaTypeToXML "title") $ researchStudy_title x
            , concatMap (schemaTypeToXML "protocol") $ researchStudy_protocol x
            , concatMap (schemaTypeToXML "partOf") $ researchStudy_partOf x
            , schemaTypeToXML "status" $ researchStudy_status x
            , concatMap (schemaTypeToXML "category") $ researchStudy_category x
            , concatMap (schemaTypeToXML "focus") $ researchStudy_focus x
            , concatMap (schemaTypeToXML "contact") $ researchStudy_contact x
            , concatMap (schemaTypeToXML "relatedArtifact") $ researchStudy_relatedArtifact x
            , concatMap (schemaTypeToXML "keyword") $ researchStudy_keyword x
            , concatMap (schemaTypeToXML "jurisdiction") $ researchStudy_jurisdiction x
            , maybe [] (schemaTypeToXML "description") $ researchStudy_description x
            , concatMap (schemaTypeToXML "enrollment") $ researchStudy_enrollment x
            , maybe [] (schemaTypeToXML "period") $ researchStudy_period x
            , maybe [] (schemaTypeToXML "sponsor") $ researchStudy_sponsor x
            , maybe [] (schemaTypeToXML "principalInvestigator") $ researchStudy_principalInvestigator x
            , concatMap (schemaTypeToXML "site") $ researchStudy_site x
            , maybe [] (schemaTypeToXML "reasonStopped") $ researchStudy_reasonStopped x
            , concatMap (schemaTypeToXML "note") $ researchStudy_note x
            , concatMap (schemaTypeToXML "arm") $ researchStudy_arm x
            ]
instance Extension ResearchStudy DomainResource where
    supertype (ResearchStudy e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ResearchStudy Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ResearchStudy -> DomainResource)
              
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
data ResearchStudy'Arm = ResearchStudy'Arm
        { researchStudy'Arm_id :: Maybe String'primitive
        , researchStudy'Arm_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchStudy'Arm_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchStudy'Arm_name :: Xsd.XsdString
          -- ^ Unique, human-readable label for this arm of the study.
        , researchStudy'Arm_code :: Maybe CodeableConcept
          -- ^ Categorization of study arm, e.g. experimental, active 
          --   comparator, placebo comparater.
        , researchStudy'Arm_description :: Maybe Xsd.XsdString
          -- ^ A succinct description of the path through the study that 
          --   would be followed by a subject adhering to this arm.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudy'Arm where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ResearchStudy'Arm a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@ResearchStudy'Arm{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchStudy'Arm_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchStudy'Arm_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchStudy'Arm_modifierExtension x
            , schemaTypeToXML "name" $ researchStudy'Arm_name x
            , maybe [] (schemaTypeToXML "code") $ researchStudy'Arm_code x
            , maybe [] (schemaTypeToXML "description") $ researchStudy'Arm_description x
            ]
instance Extension ResearchStudy'Arm BackboneElement where
    supertype (ResearchStudy'Arm a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ResearchStudy'Arm Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ResearchStudy'Arm -> BackboneElement)
              
 
data ResearchStudyStatus'list
    = ResearchStudyStatus'list_Draft
      -- ^ Draft
    | ResearchStudyStatus'list_In'progress
      -- ^ In-progress
    | ResearchStudyStatus'list_Suspended
      -- ^ Suspended
    | ResearchStudyStatus'list_Stopped
      -- ^ Stopped
    | ResearchStudyStatus'list_Completed
      -- ^ Completed
    | ResearchStudyStatus'list_Entered'in'error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType ResearchStudyStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResearchStudyStatus'list where
    acceptingParser =  do literal "draft"; return ResearchStudyStatus'list_Draft
                      `onFail` do literal "in-progress"; return ResearchStudyStatus'list_In'progress
                      `onFail` do literal "suspended"; return ResearchStudyStatus'list_Suspended
                      `onFail` do literal "stopped"; return ResearchStudyStatus'list_Stopped
                      `onFail` do literal "completed"; return ResearchStudyStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return ResearchStudyStatus'list_Entered'in'error
                      
    simpleTypeText ResearchStudyStatus'list_Draft = "draft"
    simpleTypeText ResearchStudyStatus'list_In'progress = "in-progress"
    simpleTypeText ResearchStudyStatus'list_Suspended = "suspended"
    simpleTypeText ResearchStudyStatus'list_Stopped = "stopped"
    simpleTypeText ResearchStudyStatus'list_Completed = "completed"
    simpleTypeText ResearchStudyStatus'list_Entered'in'error = "entered-in-error"
 
data ResearchStudyStatus = ResearchStudyStatus
        { researchStudyStatus_id :: Maybe String'primitive
        , researchStudyStatus_value :: Maybe ResearchStudyStatus'list
        , researchStudyStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudyStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResearchStudyStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResearchStudyStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchStudyStatus_id x
                       , maybe [] (toXMLAttribute "value") $ researchStudyStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchStudyStatus_extension x
            ]
instance Extension ResearchStudyStatus Element where
    supertype (ResearchStudyStatus a0 a1 e0) =
               Element a0 e0
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
elementResearchSubject :: XMLParser ResearchSubject
elementResearchSubject = parseSchemaType "ResearchSubject"
elementToXMLResearchSubject :: ResearchSubject -> [Content ()]
elementToXMLResearchSubject = schemaTypeToXML "ResearchSubject"
 
data ResearchSubject = ResearchSubject
        { researchSubject_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , researchSubject_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , researchSubject_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , researchSubject_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , researchSubject_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , researchSubject_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , researchSubject_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchSubject_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchSubject_identifier :: Maybe Identifier
          -- ^ Identifiers assigned to this research study by the sponsor 
          --   or other systems.
        , researchSubject_status :: ResearchSubjectStatus
          -- ^ The current state of the subject.
        , researchSubject_period :: Maybe Period
          -- ^ The dates the subject began and ended their participation 
          --   in the study.
        , researchSubject_study :: Reference
          -- ^ Reference to the study the subject is participating in.
        , researchSubject_individual :: Reference
          -- ^ The record of the person or animal who is involved in the 
          --   study.
        , researchSubject_assignedArm :: Maybe Xsd.XsdString
          -- ^ The name of the arm in the study the subject is expected to 
          --   follow as part of this study.
        , researchSubject_actualArm :: Maybe Xsd.XsdString
          -- ^ The name of the arm in the study the subject actually 
          --   followed as part of this study.
        , researchSubject_consent :: Maybe Reference
          -- ^ A record of the patient's informed agreement to participate 
          --   in the study.
        }
        deriving (Eq,Show)
instance SchemaType ResearchSubject where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResearchSubject
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "period")
            `apply` parseSchemaType "study"
            `apply` parseSchemaType "individual"
            `apply` optional (parseSchemaType "assignedArm")
            `apply` optional (parseSchemaType "actualArm")
            `apply` optional (parseSchemaType "consent")
    schemaTypeToXML s x@ResearchSubject{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ researchSubject_id x
            , maybe [] (schemaTypeToXML "meta") $ researchSubject_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ researchSubject_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ researchSubject_language x
            , maybe [] (schemaTypeToXML "text") $ researchSubject_text x
            , concatMap (schemaTypeToXML "contained") $ researchSubject_contained x
            , concatMap (schemaTypeToXML "extension") $ researchSubject_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchSubject_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ researchSubject_identifier x
            , schemaTypeToXML "status" $ researchSubject_status x
            , maybe [] (schemaTypeToXML "period") $ researchSubject_period x
            , schemaTypeToXML "study" $ researchSubject_study x
            , schemaTypeToXML "individual" $ researchSubject_individual x
            , maybe [] (schemaTypeToXML "assignedArm") $ researchSubject_assignedArm x
            , maybe [] (schemaTypeToXML "actualArm") $ researchSubject_actualArm x
            , maybe [] (schemaTypeToXML "consent") $ researchSubject_consent x
            ]
instance Extension ResearchSubject DomainResource where
    supertype (ResearchSubject e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ResearchSubject Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ResearchSubject -> DomainResource)
              
 
data ResearchSubjectStatus'list
    = ResearchSubjectStatus'list_Candidate
      -- ^ Candidate
    | ResearchSubjectStatus'list_Enrolled
      -- ^ Enrolled
    | ResearchSubjectStatus'list_Active
      -- ^ Active
    | ResearchSubjectStatus'list_Suspended
      -- ^ Suspended
    | ResearchSubjectStatus'list_Withdrawn
      -- ^ Withdrawn
    | ResearchSubjectStatus'list_Completed
      -- ^ Completed
    deriving (Eq,Show,Enum)
instance SchemaType ResearchSubjectStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResearchSubjectStatus'list where
    acceptingParser =  do literal "candidate"; return ResearchSubjectStatus'list_Candidate
                      `onFail` do literal "enrolled"; return ResearchSubjectStatus'list_Enrolled
                      `onFail` do literal "active"; return ResearchSubjectStatus'list_Active
                      `onFail` do literal "suspended"; return ResearchSubjectStatus'list_Suspended
                      `onFail` do literal "withdrawn"; return ResearchSubjectStatus'list_Withdrawn
                      `onFail` do literal "completed"; return ResearchSubjectStatus'list_Completed
                      
    simpleTypeText ResearchSubjectStatus'list_Candidate = "candidate"
    simpleTypeText ResearchSubjectStatus'list_Enrolled = "enrolled"
    simpleTypeText ResearchSubjectStatus'list_Active = "active"
    simpleTypeText ResearchSubjectStatus'list_Suspended = "suspended"
    simpleTypeText ResearchSubjectStatus'list_Withdrawn = "withdrawn"
    simpleTypeText ResearchSubjectStatus'list_Completed = "completed"
 
data ResearchSubjectStatus = ResearchSubjectStatus
        { researchSubjectStatus_id :: Maybe String'primitive
        , researchSubjectStatus_value :: Maybe ResearchSubjectStatus'list
        , researchSubjectStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResearchSubjectStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResearchSubjectStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResearchSubjectStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchSubjectStatus_id x
                       , maybe [] (toXMLAttribute "value") $ researchSubjectStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchSubjectStatus_extension x
            ]
instance Extension ResearchSubjectStatus Element where
    supertype (ResearchSubjectStatus a0 a1 e0) =
               Element a0 e0
 
-- | An assessment of the likely outcome(s) for a patient or 
--   other subject as well as the likelihood of each outcome.
elementRiskAssessment :: XMLParser RiskAssessment
elementRiskAssessment = parseSchemaType "RiskAssessment"
elementToXMLRiskAssessment :: RiskAssessment -> [Content ()]
elementToXMLRiskAssessment = schemaTypeToXML "RiskAssessment"
 
data RiskAssessment = RiskAssessment
        { riskAssessment_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , riskAssessment_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , riskAssessment_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , riskAssessment_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , riskAssessment_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , riskAssessment_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , riskAssessment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , riskAssessment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , riskAssessment_identifier :: Maybe Identifier
          -- ^ Business identifier assigned to the risk assessment.
        , riskAssessment_basedOn :: Maybe Reference
          -- ^ A reference to the request that is fulfilled by this risk 
          --   assessment.
        , riskAssessment_parent :: Maybe Reference
          -- ^ A reference to a resource that this risk assessment is part 
          --   of, such as a Procedure.
        , riskAssessment_status :: ObservationStatus
          -- ^ The status of the RiskAssessment, using the same statuses 
          --   as an Observation.
        , riskAssessment_method :: Maybe CodeableConcept
          -- ^ The algorithm, process or mechanism used to evaluate the 
          --   risk.
        , riskAssessment_code :: Maybe CodeableConcept
          -- ^ The type of the risk assessment performed.
        , riskAssessment_subject :: Maybe Reference
          -- ^ The patient or group the risk assessment applies to.
        , riskAssessment_context :: Maybe Reference
          -- ^ The encounter where the assessment was performed.
        , riskAssessment_choice16 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date (and possibly time) the risk assessment was 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , riskAssessment_condition :: Maybe Reference
          -- ^ For assessments or prognosis specific to a particular 
          --   condition, indicates the condition being assessed.
        , riskAssessment_performer :: Maybe Reference
          -- ^ The provider or software application that performed the 
          --   assessment.
        , riskAssessment_choice19 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ The reason the risk assessment was performed.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , riskAssessment_basis :: [Reference]
          -- ^ Indicates the source data considered as part of the 
          --   assessment (FamilyHistory, Observations, Procedures, 
          --   Conditions, etc.).
        , riskAssessment_prediction :: [RiskAssessment'Prediction]
          -- ^ Describes the expected outcome for the subject.
        , riskAssessment_mitigation :: Maybe Xsd.XsdString
          -- ^ A description of the steps that might be taken to reduce 
          --   the identified risk(s).
        , riskAssessment_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the risk assessment.
        }
        deriving (Eq,Show)
instance SchemaType RiskAssessment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RiskAssessment
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "parent")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "condition")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "basis")
            `apply` many (parseSchemaType "prediction")
            `apply` optional (parseSchemaType "mitigation")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@RiskAssessment{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ riskAssessment_id x
            , maybe [] (schemaTypeToXML "meta") $ riskAssessment_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ riskAssessment_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ riskAssessment_language x
            , maybe [] (schemaTypeToXML "text") $ riskAssessment_text x
            , concatMap (schemaTypeToXML "contained") $ riskAssessment_contained x
            , concatMap (schemaTypeToXML "extension") $ riskAssessment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ riskAssessment_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ riskAssessment_identifier x
            , maybe [] (schemaTypeToXML "basedOn") $ riskAssessment_basedOn x
            , maybe [] (schemaTypeToXML "parent") $ riskAssessment_parent x
            , schemaTypeToXML "status" $ riskAssessment_status x
            , maybe [] (schemaTypeToXML "method") $ riskAssessment_method x
            , maybe [] (schemaTypeToXML "code") $ riskAssessment_code x
            , maybe [] (schemaTypeToXML "subject") $ riskAssessment_subject x
            , maybe [] (schemaTypeToXML "context") $ riskAssessment_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ riskAssessment_choice16 x
            , maybe [] (schemaTypeToXML "condition") $ riskAssessment_condition x
            , maybe [] (schemaTypeToXML "performer") $ riskAssessment_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ riskAssessment_choice19 x
            , concatMap (schemaTypeToXML "basis") $ riskAssessment_basis x
            , concatMap (schemaTypeToXML "prediction") $ riskAssessment_prediction x
            , maybe [] (schemaTypeToXML "mitigation") $ riskAssessment_mitigation x
            , maybe [] (schemaTypeToXML "comment") $ riskAssessment_comment x
            ]
instance Extension RiskAssessment DomainResource where
    supertype (RiskAssessment e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RiskAssessment Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RiskAssessment -> DomainResource)
              
 
-- | An assessment of the likely outcome(s) for a patient or 
--   other subject as well as the likelihood of each outcome.
data RiskAssessment'Prediction = RiskAssessment'Prediction
        { riskAssessment'Prediction_id :: Maybe String'primitive
        , riskAssessment'Prediction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , riskAssessment'Prediction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , riskAssessment'Prediction_outcome :: CodeableConcept
          -- ^ One of the potential outcomes for the patient (e.g. 
          --   remission, death, a particular condition).
        , riskAssessment'Prediction_choice3 :: (Maybe (OneOf2 Decimal Range))
          -- ^ How likely is the outcome (in the specified timeframe).
          --   
          --   Choice between:
          --   
          --   (1) probabilityDecimal
          --   
          --   (2) probabilityRange
        , riskAssessment'Prediction_qualitativeRisk :: Maybe CodeableConcept
          -- ^ How likely is the outcome (in the specified timeframe), 
          --   expressed as a qualitative value (e.g. low, medium, high).
        , riskAssessment'Prediction_relativeRisk :: Maybe Decimal
          -- ^ Indicates the risk for this particular subject (with their 
          --   specific characteristics) divided by the risk of the 
          --   population in general. (Numbers greater than 1 = higher 
          --   risk than the population, numbers less than 1 = lower 
          --   risk.).
        , riskAssessment'Prediction_choice6 :: (Maybe (OneOf2 Period Range))
          -- ^ Indicates the period of time or age range of the subject to 
          --   which the specified probability applies.
          --   
          --   Choice between:
          --   
          --   (1) whenPeriod
          --   
          --   (2) whenRange
        , riskAssessment'Prediction_rationale :: Maybe Xsd.XsdString
          -- ^ Additional information explaining the basis for the 
          --   prediction.
        }
        deriving (Eq,Show)
instance SchemaType RiskAssessment'Prediction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RiskAssessment'Prediction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "outcome"
            `apply` optional (oneOf' [ ("Decimal", fmap OneOf2 (parseSchemaType "probabilityDecimal"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "probabilityRange"))
                                     ])
            `apply` optional (parseSchemaType "qualitativeRisk")
            `apply` optional (parseSchemaType "relativeRisk")
            `apply` optional (oneOf' [ ("Period", fmap OneOf2 (parseSchemaType "whenPeriod"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "whenRange"))
                                     ])
            `apply` optional (parseSchemaType "rationale")
    schemaTypeToXML s x@RiskAssessment'Prediction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ riskAssessment'Prediction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ riskAssessment'Prediction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ riskAssessment'Prediction_modifierExtension x
            , schemaTypeToXML "outcome" $ riskAssessment'Prediction_outcome x
            , maybe [] (foldOneOf2  (schemaTypeToXML "probabilityDecimal")
                                    (schemaTypeToXML "probabilityRange")
                                   ) $ riskAssessment'Prediction_choice3 x
            , maybe [] (schemaTypeToXML "qualitativeRisk") $ riskAssessment'Prediction_qualitativeRisk x
            , maybe [] (schemaTypeToXML "relativeRisk") $ riskAssessment'Prediction_relativeRisk x
            , maybe [] (foldOneOf2  (schemaTypeToXML "whenPeriod")
                                    (schemaTypeToXML "whenRange")
                                   ) $ riskAssessment'Prediction_choice6 x
            , maybe [] (schemaTypeToXML "rationale") $ riskAssessment'Prediction_rationale x
            ]
instance Extension RiskAssessment'Prediction BackboneElement where
    supertype (RiskAssessment'Prediction a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension RiskAssessment'Prediction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RiskAssessment'Prediction -> BackboneElement)
              
 
-- | A container for slots of time that may be available for 
--   booking appointments.
elementSchedule :: XMLParser Schedule
elementSchedule = parseSchemaType "Schedule"
elementToXMLSchedule :: Schedule -> [Content ()]
elementToXMLSchedule = schemaTypeToXML "Schedule"
 
data Schedule = Schedule
        { schedule_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , schedule_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , schedule_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , schedule_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , schedule_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , schedule_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , schedule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , schedule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , schedule_identifier :: [Identifier]
          -- ^ External Ids for this item.
        , schedule_active :: Maybe Boolean
          -- ^ Whether this schedule record is in active use, or should 
          --   not be used (such as was entered in error).
        , schedule_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , schedule_serviceType :: [CodeableConcept]
          -- ^ The specific service that is to be performed during this 
          --   appointment.
        , schedule_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , schedule_actor :: [Reference]
          -- ^ The resource this Schedule resource is providing 
          --   availability information for. These are expected to usually 
          --   be one of HealthcareService, Location, Practitioner, 
          --   PractitionerRole, Device, Patient or RelatedPerson.
        , schedule_planningHorizon :: Maybe Period
          -- ^ The period of time that the slots that are attached to this 
          --   Schedule resource cover (even if none exist). These cover 
          --   the amount of time that an organization's planning horizon; 
          --   the interval for which they are currently accepting 
          --   appointments. This does not define a &quot;template&quot; 
          --   for planning outside these dates.
        , schedule_comment :: Maybe Xsd.XsdString
          -- ^ Comments on the availability to describe any extended 
          --   information. Such as custom constraints on the slots that 
          --   may be associated.
        }
        deriving (Eq,Show)
instance SchemaType Schedule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Schedule
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` many1 (parseSchemaType "actor")
            `apply` optional (parseSchemaType "planningHorizon")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@Schedule{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ schedule_id x
            , maybe [] (schemaTypeToXML "meta") $ schedule_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ schedule_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ schedule_language x
            , maybe [] (schemaTypeToXML "text") $ schedule_text x
            , concatMap (schemaTypeToXML "contained") $ schedule_contained x
            , concatMap (schemaTypeToXML "extension") $ schedule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ schedule_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ schedule_identifier x
            , maybe [] (schemaTypeToXML "active") $ schedule_active x
            , maybe [] (schemaTypeToXML "serviceCategory") $ schedule_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ schedule_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ schedule_specialty x
            , concatMap (schemaTypeToXML "actor") $ schedule_actor x
            , maybe [] (schemaTypeToXML "planningHorizon") $ schedule_planningHorizon x
            , maybe [] (schemaTypeToXML "comment") $ schedule_comment x
            ]
instance Extension Schedule DomainResource where
    supertype (Schedule e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Schedule Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Schedule -> DomainResource)
              
 
-- | A search parameter that defines a named search item that 
--   can be used to search/filter on a resource.
elementSearchParameter :: XMLParser SearchParameter
elementSearchParameter = parseSchemaType "SearchParameter"
elementToXMLSearchParameter :: SearchParameter -> [Content ()]
elementToXMLSearchParameter = schemaTypeToXML "SearchParameter"
 
data SearchParameter = SearchParameter
        { searchParameter_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , searchParameter_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , searchParameter_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , searchParameter_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , searchParameter_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , searchParameter_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , searchParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , searchParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , searchParameter_url :: Uri
          -- ^ An absolute URI that is used to identify this search 
          --   parameter when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   search parameter is (or will be) published. The URL SHOULD 
          --   include the major version of the search parameter. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , searchParameter_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   search parameter when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the search parameter author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , searchParameter_name :: Xsd.XsdString
          -- ^ A natural language name identifying the search parameter. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , searchParameter_status :: PublicationStatus
          -- ^ The status of this search parameter. Enables tracking the 
          --   life-cycle of the content.
        , searchParameter_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this search parameter is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , searchParameter_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the search parameter 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the search parameter changes.
        , searchParameter_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the search parameter.
        , searchParameter_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , searchParameter_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   search parameter instances.
        , searchParameter_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the search parameter 
          --   is intended to be used.
        , searchParameter_purpose :: Maybe Markdown
          -- ^ Explaination of why this search parameter is needed and why 
          --   it has been designed as it has.
        , searchParameter_code :: Code
          -- ^ The code used in the URL or the parameter name in a 
          --   parameters resource for this search parameter.
        , searchParameter_base :: [ResourceType]
          -- ^ The base resource type(s) that this search parameter can be 
          --   used against.
        , searchParameter_type :: SearchParamType
          -- ^ The type of value a search parameter refers to, and how the 
          --   content is interpreted.
        , searchParameter_derivedFrom :: Maybe Uri
          -- ^ Where this search parameter is originally defined. If a 
          --   derivedFrom is provided, then the details in the search 
          --   parameter must be consistent with the definition from which 
          --   it is defined. I.e. the parameter should have the same 
          --   meaning, and (usually) the functionality should be a proper 
          --   subset of the underlying search parameter.
        , searchParameter_description :: Markdown
          -- ^ A free text natural language description of the search 
          --   parameter from a consumer's perspective. and how it used.
        , searchParameter_expression :: Maybe Xsd.XsdString
          -- ^ A FHIRPath expression that returns a set of elements for 
          --   the search parameter.
        , searchParameter_xpath :: Maybe Xsd.XsdString
          -- ^ An XPath expression that returns a set of elements for the 
          --   search parameter.
        , searchParameter_xpathUsage :: Maybe XPathUsageType
          -- ^ How the search parameter relates to the set of elements 
          --   returned by evaluating the xpath query.
        , searchParameter_target :: [ResourceType]
          -- ^ Types of resource (if a resource is referenced).
        , searchParameter_comparator :: [SearchComparator]
          -- ^ Comparators supported for the search parameter.
        , searchParameter_modifier :: [SearchModifierCode]
          -- ^ A modifier supported for the search parameter.
        , searchParameter_chain :: [Xsd.XsdString]
          -- ^ Contains the names of any search parameters which may be 
          --   chained to the containing search parameter. Chained 
          --   parameters may be added to search parameters of type 
          --   reference, and specify that resources will only be returned 
          --   if they contain a reference to a resource which matches the 
          --   chained parameter value. Values for this field should be 
          --   drawn from SearchParameter.code for a parameter on the 
          --   target resource type.
        , searchParameter_component :: [SearchParameter'Component]
          -- ^ Used to define the parts of a composite search parameter.
        }
        deriving (Eq,Show)
instance SchemaType SearchParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SearchParameter
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` parseSchemaType "code"
            `apply` many1 (parseSchemaType "base")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "derivedFrom")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "xpath")
            `apply` optional (parseSchemaType "xpathUsage")
            `apply` many (parseSchemaType "target")
            `apply` many (parseSchemaType "comparator")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "chain")
            `apply` many (parseSchemaType "component")
    schemaTypeToXML s x@SearchParameter{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ searchParameter_id x
            , maybe [] (schemaTypeToXML "meta") $ searchParameter_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ searchParameter_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ searchParameter_language x
            , maybe [] (schemaTypeToXML "text") $ searchParameter_text x
            , concatMap (schemaTypeToXML "contained") $ searchParameter_contained x
            , concatMap (schemaTypeToXML "extension") $ searchParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ searchParameter_modifierExtension x
            , schemaTypeToXML "url" $ searchParameter_url x
            , maybe [] (schemaTypeToXML "version") $ searchParameter_version x
            , schemaTypeToXML "name" $ searchParameter_name x
            , schemaTypeToXML "status" $ searchParameter_status x
            , maybe [] (schemaTypeToXML "experimental") $ searchParameter_experimental x
            , maybe [] (schemaTypeToXML "date") $ searchParameter_date x
            , maybe [] (schemaTypeToXML "publisher") $ searchParameter_publisher x
            , concatMap (schemaTypeToXML "contact") $ searchParameter_contact x
            , concatMap (schemaTypeToXML "useContext") $ searchParameter_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ searchParameter_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ searchParameter_purpose x
            , schemaTypeToXML "code" $ searchParameter_code x
            , concatMap (schemaTypeToXML "base") $ searchParameter_base x
            , schemaTypeToXML "type" $ searchParameter_type x
            , maybe [] (schemaTypeToXML "derivedFrom") $ searchParameter_derivedFrom x
            , schemaTypeToXML "description" $ searchParameter_description x
            , maybe [] (schemaTypeToXML "expression") $ searchParameter_expression x
            , maybe [] (schemaTypeToXML "xpath") $ searchParameter_xpath x
            , maybe [] (schemaTypeToXML "xpathUsage") $ searchParameter_xpathUsage x
            , concatMap (schemaTypeToXML "target") $ searchParameter_target x
            , concatMap (schemaTypeToXML "comparator") $ searchParameter_comparator x
            , concatMap (schemaTypeToXML "modifier") $ searchParameter_modifier x
            , concatMap (schemaTypeToXML "chain") $ searchParameter_chain x
            , concatMap (schemaTypeToXML "component") $ searchParameter_component x
            ]
instance Extension SearchParameter DomainResource where
    supertype (SearchParameter e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SearchParameter Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SearchParameter -> DomainResource)
              
 
-- | A search parameter that defines a named search item that 
--   can be used to search/filter on a resource.
data SearchParameter'Component = SearchParameter'Component
        { searchParameter'Component_id :: Maybe String'primitive
        , searchParameter'Component_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , searchParameter'Component_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , searchParameter'Component_definition :: Reference
          -- ^ The definition of the search parameter that describes this 
          --   part.
        , searchParameter'Component_expression :: Xsd.XsdString
          -- ^ A sub-expression that defines how to extract values for 
          --   this component from the output of the main 
          --   SearchParameter.expression.
        }
        deriving (Eq,Show)
instance SchemaType SearchParameter'Component where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SearchParameter'Component a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "definition"
            `apply` parseSchemaType "expression"
    schemaTypeToXML s x@SearchParameter'Component{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchParameter'Component_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchParameter'Component_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ searchParameter'Component_modifierExtension x
            , schemaTypeToXML "definition" $ searchParameter'Component_definition x
            , schemaTypeToXML "expression" $ searchParameter'Component_expression x
            ]
instance Extension SearchParameter'Component BackboneElement where
    supertype (SearchParameter'Component a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SearchParameter'Component Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SearchParameter'Component -> BackboneElement)
              
 
data XPathUsageType'list
    = XPathUsageType'list_Normal
      -- ^ Normal
    | XPathUsageType'list_Phonetic
      -- ^ Phonetic
    | XPathUsageType'list_Nearby
      -- ^ Nearby
    | XPathUsageType'list_Distance
      -- ^ Distance
    | XPathUsageType'list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType XPathUsageType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType XPathUsageType'list where
    acceptingParser =  do literal "normal"; return XPathUsageType'list_Normal
                      `onFail` do literal "phonetic"; return XPathUsageType'list_Phonetic
                      `onFail` do literal "nearby"; return XPathUsageType'list_Nearby
                      `onFail` do literal "distance"; return XPathUsageType'list_Distance
                      `onFail` do literal "other"; return XPathUsageType'list_Other
                      
    simpleTypeText XPathUsageType'list_Normal = "normal"
    simpleTypeText XPathUsageType'list_Phonetic = "phonetic"
    simpleTypeText XPathUsageType'list_Nearby = "nearby"
    simpleTypeText XPathUsageType'list_Distance = "distance"
    simpleTypeText XPathUsageType'list_Other = "other"
 
data XPathUsageType = XPathUsageType
        { xPathUsageType_id :: Maybe String'primitive
        , xPathUsageType_value :: Maybe XPathUsageType'list
        , xPathUsageType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType XPathUsageType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (XPathUsageType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@XPathUsageType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ xPathUsageType_id x
                       , maybe [] (toXMLAttribute "value") $ xPathUsageType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ xPathUsageType_extension x
            ]
instance Extension XPathUsageType Element where
    supertype (XPathUsageType a0 a1 e0) =
               Element a0 e0
 
data SearchModifierCode'list
    = SearchModifierCode'list_Missing
      -- ^ Missing
    | SearchModifierCode'list_Exact
      -- ^ Exact
    | SearchModifierCode'list_Contains
      -- ^ Contains
    | SearchModifierCode'list_Not
      -- ^ Not
    | SearchModifierCode'list_Text
      -- ^ Text
    | SearchModifierCode'list_In
      -- ^ In
    | SearchModifierCode'list_Not'in
      -- ^ Not In
    | SearchModifierCode'list_Below
      -- ^ Below
    | SearchModifierCode'list_Above
      -- ^ Above
    | SearchModifierCode'list_Type
      -- ^ Type
    deriving (Eq,Show,Enum)
instance SchemaType SearchModifierCode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchModifierCode'list where
    acceptingParser =  do literal "missing"; return SearchModifierCode'list_Missing
                      `onFail` do literal "exact"; return SearchModifierCode'list_Exact
                      `onFail` do literal "contains"; return SearchModifierCode'list_Contains
                      `onFail` do literal "not"; return SearchModifierCode'list_Not
                      `onFail` do literal "text"; return SearchModifierCode'list_Text
                      `onFail` do literal "in"; return SearchModifierCode'list_In
                      `onFail` do literal "not-in"; return SearchModifierCode'list_Not'in
                      `onFail` do literal "below"; return SearchModifierCode'list_Below
                      `onFail` do literal "above"; return SearchModifierCode'list_Above
                      `onFail` do literal "type"; return SearchModifierCode'list_Type
                      
    simpleTypeText SearchModifierCode'list_Missing = "missing"
    simpleTypeText SearchModifierCode'list_Exact = "exact"
    simpleTypeText SearchModifierCode'list_Contains = "contains"
    simpleTypeText SearchModifierCode'list_Not = "not"
    simpleTypeText SearchModifierCode'list_Text = "text"
    simpleTypeText SearchModifierCode'list_In = "in"
    simpleTypeText SearchModifierCode'list_Not'in = "not-in"
    simpleTypeText SearchModifierCode'list_Below = "below"
    simpleTypeText SearchModifierCode'list_Above = "above"
    simpleTypeText SearchModifierCode'list_Type = "type"
 
data SearchModifierCode = SearchModifierCode
        { searchModifierCode_id :: Maybe String'primitive
        , searchModifierCode_value :: Maybe SearchModifierCode'list
        , searchModifierCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchModifierCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchModifierCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchModifierCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchModifierCode_id x
                       , maybe [] (toXMLAttribute "value") $ searchModifierCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchModifierCode_extension x
            ]
instance Extension SearchModifierCode Element where
    supertype (SearchModifierCode a0 a1 e0) =
               Element a0 e0
 
data SearchComparator'list
    = SearchComparator'list_Eq
      -- ^ Equals
    | SearchComparator'list_Ne
      -- ^ Not Equals
    | SearchComparator'list_Gt
      -- ^ Greater Than
    | SearchComparator'list_Lt
      -- ^ Less Then
    | SearchComparator'list_Ge
      -- ^ Greater or Equals
    | SearchComparator'list_Le
      -- ^ Less of Equal
    | SearchComparator'list_Sa
      -- ^ Starts After
    | SearchComparator'list_Eb
      -- ^ Ends Before
    | SearchComparator'list_Ap
      -- ^ Approximately
    deriving (Eq,Show,Enum)
instance SchemaType SearchComparator'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchComparator'list where
    acceptingParser =  do literal "eq"; return SearchComparator'list_Eq
                      `onFail` do literal "ne"; return SearchComparator'list_Ne
                      `onFail` do literal "gt"; return SearchComparator'list_Gt
                      `onFail` do literal "lt"; return SearchComparator'list_Lt
                      `onFail` do literal "ge"; return SearchComparator'list_Ge
                      `onFail` do literal "le"; return SearchComparator'list_Le
                      `onFail` do literal "sa"; return SearchComparator'list_Sa
                      `onFail` do literal "eb"; return SearchComparator'list_Eb
                      `onFail` do literal "ap"; return SearchComparator'list_Ap
                      
    simpleTypeText SearchComparator'list_Eq = "eq"
    simpleTypeText SearchComparator'list_Ne = "ne"
    simpleTypeText SearchComparator'list_Gt = "gt"
    simpleTypeText SearchComparator'list_Lt = "lt"
    simpleTypeText SearchComparator'list_Ge = "ge"
    simpleTypeText SearchComparator'list_Le = "le"
    simpleTypeText SearchComparator'list_Sa = "sa"
    simpleTypeText SearchComparator'list_Eb = "eb"
    simpleTypeText SearchComparator'list_Ap = "ap"
 
data SearchComparator = SearchComparator
        { searchComparator_id :: Maybe String'primitive
        , searchComparator_value :: Maybe SearchComparator'list
        , searchComparator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchComparator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchComparator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchComparator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchComparator_id x
                       , maybe [] (toXMLAttribute "value") $ searchComparator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchComparator_extension x
            ]
instance Extension SearchComparator Element where
    supertype (SearchComparator a0 a1 e0) =
               Element a0 e0
 
-- | Raw data describing a biological sequence.
elementSequence :: XMLParser Sequence
elementSequence = parseSchemaType "Sequence"
elementToXMLSequence :: Sequence -> [Content ()]
elementToXMLSequence = schemaTypeToXML "Sequence"
 
data Sequence = Sequence
        { sequence_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , sequence_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , sequence_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , sequence_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , sequence_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , sequence_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , sequence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence_identifier :: [Identifier]
          -- ^ A unique identifier for this particular sequence instance. 
          --   This is a FHIR-defined id.
        , sequence_type :: Maybe Code
          -- ^ Amino Acid Sequence/ DNA Sequence / RNA Sequence.
        , sequence_coordinateSystem :: Integer
          -- ^ Whether the sequence is numbered starting at 0 (0-based 
          --   numbering or coordinates, inclusive start, exclusive end) 
          --   or starting at 1 (1-based numbering, inclusive start and 
          --   inclusive end).
        , sequence_patient :: Maybe Reference
          -- ^ The patient whose sequencing results are described by this 
          --   resource.
        , sequence_specimen :: Maybe Reference
          -- ^ Specimen used for sequencing.
        , sequence_device :: Maybe Reference
          -- ^ The method for sequencing, for example, chip information.
        , sequence_performer :: Maybe Reference
          -- ^ The organization or lab that should be responsible for this 
          --   result.
        , sequence_quantity :: Maybe Quantity
          -- ^ The number of copies of the seqeunce of interest. (RNASeq).
        , sequence_referenceSeq :: Maybe Sequence'ReferenceSeq
          -- ^ A sequence that is used as a reference to describe variants 
          --   that are present in a sequence analyzed.
        , sequence_variant :: [Sequence'Variant]
          -- ^ The definition of variant here originates from Sequence 
          --   ontology 
          --   ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). 
          --   This element can represent amino acid or nucleic sequence 
          --   change(including insertion,deletion,SNP,etc.) It can 
          --   represent some complex mutation or segment variation with 
          --   the assist of CIGAR string.
        , sequence_observedSeq :: Maybe Xsd.XsdString
          -- ^ Sequence that was observed. It is the result marked by 
          --   referenceSeq along with variant records on referenceSeq. 
          --   This shall starts from referenceSeq.windowStart and end by 
          --   referenceSeq.windowEnd.
        , sequence_quality :: [Sequence'Quality]
          -- ^ An experimental feature attribute that defines the quality 
          --   of the feature in a quantitative way, such as a phred 
          --   quality score 
          --   ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
        , sequence_readCoverage :: Maybe Integer
          -- ^ Coverage (read depth or depth) is the average number of 
          --   reads representing a given nucleotide in the reconstructed 
          --   sequence.
        , sequence_repository :: [Sequence'Repository]
          -- ^ Configurations of the external repository. The repository 
          --   shall store target's observedSeq or records related with 
          --   target's observedSeq.
        , sequence_pointer :: [Reference]
          -- ^ Pointer to next atomic sequence which at most contains one 
          --   variant.
        }
        deriving (Eq,Show)
instance SchemaType Sequence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Sequence
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "coordinateSystem"
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "specimen")
            `apply` optional (parseSchemaType "device")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "referenceSeq")
            `apply` many (parseSchemaType "variant")
            `apply` optional (parseSchemaType "observedSeq")
            `apply` many (parseSchemaType "quality")
            `apply` optional (parseSchemaType "readCoverage")
            `apply` many (parseSchemaType "repository")
            `apply` many (parseSchemaType "pointer")
    schemaTypeToXML s x@Sequence{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ sequence_id x
            , maybe [] (schemaTypeToXML "meta") $ sequence_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ sequence_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ sequence_language x
            , maybe [] (schemaTypeToXML "text") $ sequence_text x
            , concatMap (schemaTypeToXML "contained") $ sequence_contained x
            , concatMap (schemaTypeToXML "extension") $ sequence_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ sequence_identifier x
            , maybe [] (schemaTypeToXML "type") $ sequence_type x
            , schemaTypeToXML "coordinateSystem" $ sequence_coordinateSystem x
            , maybe [] (schemaTypeToXML "patient") $ sequence_patient x
            , maybe [] (schemaTypeToXML "specimen") $ sequence_specimen x
            , maybe [] (schemaTypeToXML "device") $ sequence_device x
            , maybe [] (schemaTypeToXML "performer") $ sequence_performer x
            , maybe [] (schemaTypeToXML "quantity") $ sequence_quantity x
            , maybe [] (schemaTypeToXML "referenceSeq") $ sequence_referenceSeq x
            , concatMap (schemaTypeToXML "variant") $ sequence_variant x
            , maybe [] (schemaTypeToXML "observedSeq") $ sequence_observedSeq x
            , concatMap (schemaTypeToXML "quality") $ sequence_quality x
            , maybe [] (schemaTypeToXML "readCoverage") $ sequence_readCoverage x
            , concatMap (schemaTypeToXML "repository") $ sequence_repository x
            , concatMap (schemaTypeToXML "pointer") $ sequence_pointer x
            ]
instance Extension Sequence DomainResource where
    supertype (Sequence e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Sequence Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Sequence -> DomainResource)
              
 
-- | Raw data describing a biological sequence.
data Sequence'ReferenceSeq = Sequence'ReferenceSeq
        { sequence'ReferenceSeq_id :: Maybe String'primitive
        , sequence'ReferenceSeq_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence'ReferenceSeq_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence'ReferenceSeq_chromosome :: Maybe CodeableConcept
          -- ^ Structural unit composed of a nucleic acid molecule which 
          --   controls its own replication through the interaction of 
          --   specific proteins at one or more origins of replication 
          --   ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
        , sequence'ReferenceSeq_genomeBuild :: Maybe Xsd.XsdString
          -- ^ The Genome Build used for reference, following GRCh build 
          --   versions e.g. 'GRCh 37'. Version number must be included if 
          --   a versioned release of a primary build was used.
        , sequence'ReferenceSeq_referenceSeqId :: Maybe CodeableConcept
          -- ^ Reference identifier of reference sequence submitted to 
          --   NCBI. It must match the type in the Sequence.type field. 
          --   For example, the prefix, â€œNG_â€ identifies reference 
          --   sequence for genes, â€œNM_â€ for messenger RNA transcripts, 
          --   and â€œNP_â€ for amino acid sequences.
        , sequence'ReferenceSeq_referenceSeqPointer :: Maybe Reference
          -- ^ A Pointer to another Sequence entity as reference sequence.
        , sequence'ReferenceSeq_referenceSeqString :: Maybe Xsd.XsdString
          -- ^ A string like &quot;ACGT&quot;.
        , sequence'ReferenceSeq_strand :: Maybe Integer
          -- ^ Directionality of DNA sequence. Available values are 
          --   &quot;1&quot; for the plus strand (5' to 
          --   3')/Watson/Sense/positive and &quot;-1&quot; for the minus 
          --   strand(3' to 5')/Crick/Antisense/negative.
        , sequence'ReferenceSeq_windowStart :: Integer
          -- ^ Start position of the window on the reference sequence. If 
          --   the coordinate system is either 0-based or 1-based, then 
          --   start position is inclusive.
        , sequence'ReferenceSeq_windowEnd :: Integer
          -- ^ End position of the window on the reference sequence. If 
          --   the coordinate system is 0-based then end is is exclusive 
          --   and does not include the last position. If the coordinate 
          --   system is 1-base, then end is inclusive and includes the 
          --   last position.
        }
        deriving (Eq,Show)
instance SchemaType Sequence'ReferenceSeq where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Sequence'ReferenceSeq a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "chromosome")
            `apply` optional (parseSchemaType "genomeBuild")
            `apply` optional (parseSchemaType "referenceSeqId")
            `apply` optional (parseSchemaType "referenceSeqPointer")
            `apply` optional (parseSchemaType "referenceSeqString")
            `apply` optional (parseSchemaType "strand")
            `apply` parseSchemaType "windowStart"
            `apply` parseSchemaType "windowEnd"
    schemaTypeToXML s x@Sequence'ReferenceSeq{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequence'ReferenceSeq_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequence'ReferenceSeq_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence'ReferenceSeq_modifierExtension x
            , maybe [] (schemaTypeToXML "chromosome") $ sequence'ReferenceSeq_chromosome x
            , maybe [] (schemaTypeToXML "genomeBuild") $ sequence'ReferenceSeq_genomeBuild x
            , maybe [] (schemaTypeToXML "referenceSeqId") $ sequence'ReferenceSeq_referenceSeqId x
            , maybe [] (schemaTypeToXML "referenceSeqPointer") $ sequence'ReferenceSeq_referenceSeqPointer x
            , maybe [] (schemaTypeToXML "referenceSeqString") $ sequence'ReferenceSeq_referenceSeqString x
            , maybe [] (schemaTypeToXML "strand") $ sequence'ReferenceSeq_strand x
            , schemaTypeToXML "windowStart" $ sequence'ReferenceSeq_windowStart x
            , schemaTypeToXML "windowEnd" $ sequence'ReferenceSeq_windowEnd x
            ]
instance Extension Sequence'ReferenceSeq BackboneElement where
    supertype (Sequence'ReferenceSeq a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension Sequence'ReferenceSeq Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Sequence'ReferenceSeq -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data Sequence'Variant = Sequence'Variant
        { sequence'Variant_id :: Maybe String'primitive
        , sequence'Variant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence'Variant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence'Variant_start :: Maybe Integer
          -- ^ Start position of the variant on the reference sequence.If 
          --   the coordinate system is either 0-based or 1-based, then 
          --   start position is inclusive.
        , sequence'Variant_end :: Maybe Integer
          -- ^ End position of the variant on the reference sequence.If 
          --   the coordinate system is 0-based then end is is exclusive 
          --   and does not include the last position. If the coordinate 
          --   system is 1-base, then end is inclusive and includes the 
          --   last position.
        , sequence'Variant_observedAllele :: Maybe Xsd.XsdString
          -- ^ An allele is one of a set of coexisting sequence variants 
          --   of a gene 
          --   ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). 
          --   Nucleotide(s)/amino acids from start position of sequence 
          --   to stop position of sequence on the positive (+) strand of 
          --   the observed sequence. When the sequence type is DNA, it 
          --   should be the sequence on the positive (+) strand. This 
          --   will lay in the range between variant.start and 
          --   variant.end.
        , sequence'Variant_referenceAllele :: Maybe Xsd.XsdString
          -- ^ An allele is one of a set of coexisting sequence variants 
          --   of a gene 
          --   ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). 
          --   Nucleotide(s)/amino acids from start position of sequence 
          --   to stop position of sequence on the positive (+) strand of 
          --   the reference sequence. When the sequence type is DNA, it 
          --   should be the sequence on the positive (+) strand. This 
          --   will lay in the range between variant.start and 
          --   variant.end.
        , sequence'Variant_cigar :: Maybe Xsd.XsdString
          -- ^ Extended CIGAR string for aligning the sequence with 
          --   reference bases. See detailed documentation 
          --   [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
        , sequence'Variant_variantPointer :: Maybe Reference
          -- ^ A pointer to an Observation containing variant information.
        }
        deriving (Eq,Show)
instance SchemaType Sequence'Variant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Sequence'Variant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "observedAllele")
            `apply` optional (parseSchemaType "referenceAllele")
            `apply` optional (parseSchemaType "cigar")
            `apply` optional (parseSchemaType "variantPointer")
    schemaTypeToXML s x@Sequence'Variant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequence'Variant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequence'Variant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence'Variant_modifierExtension x
            , maybe [] (schemaTypeToXML "start") $ sequence'Variant_start x
            , maybe [] (schemaTypeToXML "end") $ sequence'Variant_end x
            , maybe [] (schemaTypeToXML "observedAllele") $ sequence'Variant_observedAllele x
            , maybe [] (schemaTypeToXML "referenceAllele") $ sequence'Variant_referenceAllele x
            , maybe [] (schemaTypeToXML "cigar") $ sequence'Variant_cigar x
            , maybe [] (schemaTypeToXML "variantPointer") $ sequence'Variant_variantPointer x
            ]
instance Extension Sequence'Variant BackboneElement where
    supertype (Sequence'Variant a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Sequence'Variant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Sequence'Variant -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data Sequence'Quality = Sequence'Quality
        { sequence'Quality_id :: Maybe String'primitive
        , sequence'Quality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence'Quality_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence'Quality_type :: QualityType
          -- ^ INDEL / SNP / Undefined variant.
        , sequence'Quality_standardSequence :: Maybe CodeableConcept
          -- ^ Gold standard sequence used for comparing against.
        , sequence'Quality_start :: Maybe Integer
          -- ^ Start position of the sequence. If the coordinate system is 
          --   either 0-based or 1-based, then start position is 
          --   inclusive.
        , sequence'Quality_end :: Maybe Integer
          -- ^ End position of the sequence.If the coordinate system is 
          --   0-based then end is is exclusive and does not include the 
          --   last position. If the coordinate system is 1-base, then end 
          --   is inclusive and includes the last position.
        , sequence'Quality_score :: Maybe Quantity
          -- ^ The score of an experimentally derived feature such as a 
          --   p-value 
          --   ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
        , sequence'Quality_method :: Maybe CodeableConcept
          -- ^ Which method is used to get sequence quality.
        , sequence'Quality_truthTP :: Maybe Decimal
          -- ^ True positives, from the perspective of the truth data, 
          --   i.e. the number of sites in the Truth Call Set for which 
          --   there are paths through the Query Call Set that are 
          --   consistent with all of the alleles at this site, and for 
          --   which there is an accurate genotype call for the event.
        , sequence'Quality_queryTP :: Maybe Decimal
          -- ^ True positives, from the perspective of the query data, 
          --   i.e. the number of sites in the Query Call Set for which 
          --   there are paths through the Truth Call Set that are 
          --   consistent with all of the alleles at this site, and for 
          --   which there is an accurate genotype call for the event.
        , sequence'Quality_truthFN :: Maybe Decimal
          -- ^ False negatives, i.e. the number of sites in the Truth Call 
          --   Set for which there is no path through the Query Call Set 
          --   that is consistent with all of the alleles at this site, or 
          --   sites for which there is an inaccurate genotype call for 
          --   the event. Sites with correct variant but incorrect 
          --   genotype are counted here.
        , sequence'Quality_queryFP :: Maybe Decimal
          -- ^ False positives, i.e. the number of sites in the Query Call 
          --   Set for which there is no path through the Truth Call Set 
          --   that is consistent with this site. Sites with correct 
          --   variant but incorrect genotype are counted here.
        , sequence'Quality_gtFP :: Maybe Decimal
          -- ^ The number of false positives where the non-REF alleles in 
          --   the Truth and Query Call Sets match (i.e. cases where the 
          --   truth is 1/1 and the query is 0/1 or similar).
        , sequence'Quality_precision :: Maybe Decimal
          -- ^ QUERY.TP / (QUERY.TP + QUERY.FP).
        , sequence'Quality_recall :: Maybe Decimal
          -- ^ TRUTH.TP / (TRUTH.TP + TRUTH.FN).
        , sequence'Quality_fScore :: Maybe Decimal
          -- ^ Harmonic mean of Recall and Precision, computed as: 2 * 
          --   precision * recall / (precision + recall).
        }
        deriving (Eq,Show)
instance SchemaType Sequence'Quality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Sequence'Quality a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "standardSequence")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "score")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "truthTP")
            `apply` optional (parseSchemaType "queryTP")
            `apply` optional (parseSchemaType "truthFN")
            `apply` optional (parseSchemaType "queryFP")
            `apply` optional (parseSchemaType "gtFP")
            `apply` optional (parseSchemaType "precision")
            `apply` optional (parseSchemaType "recall")
            `apply` optional (parseSchemaType "fScore")
    schemaTypeToXML s x@Sequence'Quality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequence'Quality_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequence'Quality_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence'Quality_modifierExtension x
            , schemaTypeToXML "type" $ sequence'Quality_type x
            , maybe [] (schemaTypeToXML "standardSequence") $ sequence'Quality_standardSequence x
            , maybe [] (schemaTypeToXML "start") $ sequence'Quality_start x
            , maybe [] (schemaTypeToXML "end") $ sequence'Quality_end x
            , maybe [] (schemaTypeToXML "score") $ sequence'Quality_score x
            , maybe [] (schemaTypeToXML "method") $ sequence'Quality_method x
            , maybe [] (schemaTypeToXML "truthTP") $ sequence'Quality_truthTP x
            , maybe [] (schemaTypeToXML "queryTP") $ sequence'Quality_queryTP x
            , maybe [] (schemaTypeToXML "truthFN") $ sequence'Quality_truthFN x
            , maybe [] (schemaTypeToXML "queryFP") $ sequence'Quality_queryFP x
            , maybe [] (schemaTypeToXML "gtFP") $ sequence'Quality_gtFP x
            , maybe [] (schemaTypeToXML "precision") $ sequence'Quality_precision x
            , maybe [] (schemaTypeToXML "recall") $ sequence'Quality_recall x
            , maybe [] (schemaTypeToXML "fScore") $ sequence'Quality_fScore x
            ]
instance Extension Sequence'Quality BackboneElement where
    supertype (Sequence'Quality a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               BackboneElement a0 e0 e1
instance Extension Sequence'Quality Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Sequence'Quality -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data Sequence'Repository = Sequence'Repository
        { sequence'Repository_id :: Maybe String'primitive
        , sequence'Repository_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence'Repository_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence'Repository_type :: RepositoryType
          -- ^ Click and see / RESTful API / Need login to see / RESTful 
          --   API with authentication / Other ways to see resource.
        , sequence'Repository_url :: Maybe Uri
          -- ^ URI of an external repository which contains further 
          --   details about the genetics data.
        , sequence'Repository_name :: Maybe Xsd.XsdString
          -- ^ URI of an external repository which contains further 
          --   details about the genetics data.
        , sequence'Repository_datasetId :: Maybe Xsd.XsdString
          -- ^ Id of the variant in this external repository. The server 
          --   will understand how to use this id to call for more info 
          --   about datasets in external repository.
        , sequence'Repository_variantsetId :: Maybe Xsd.XsdString
          -- ^ Id of the variantset in this external repository. The 
          --   server will understand how to use this id to call for more 
          --   info about variantsets in external repository.
        , sequence'Repository_readsetId :: Maybe Xsd.XsdString
          -- ^ Id of the read in this external repository.
        }
        deriving (Eq,Show)
instance SchemaType Sequence'Repository where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Sequence'Repository a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "datasetId")
            `apply` optional (parseSchemaType "variantsetId")
            `apply` optional (parseSchemaType "readsetId")
    schemaTypeToXML s x@Sequence'Repository{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequence'Repository_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequence'Repository_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence'Repository_modifierExtension x
            , schemaTypeToXML "type" $ sequence'Repository_type x
            , maybe [] (schemaTypeToXML "url") $ sequence'Repository_url x
            , maybe [] (schemaTypeToXML "name") $ sequence'Repository_name x
            , maybe [] (schemaTypeToXML "datasetId") $ sequence'Repository_datasetId x
            , maybe [] (schemaTypeToXML "variantsetId") $ sequence'Repository_variantsetId x
            , maybe [] (schemaTypeToXML "readsetId") $ sequence'Repository_readsetId x
            ]
instance Extension Sequence'Repository BackboneElement where
    supertype (Sequence'Repository a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Sequence'Repository Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Sequence'Repository -> BackboneElement)
              
 
data RepositoryType'list
    = RepositoryType'list_Directlink
      -- ^ Click and see
    | RepositoryType'list_Openapi
      -- ^ The URL is the RESTful or other kind of API that can access 
      --   to the result.
    | RepositoryType'list_Login
      -- ^ Result cannot be access unless an account is logged in
    | RepositoryType'list_Oauth
      -- ^ Result need to be fetched with API and need LOGIN( or 
      --   cookies are required when visiting the link of resource)
    | RepositoryType'list_Other
      -- ^ Some other complicated or particular way to get resource 
      --   from URL.
    deriving (Eq,Show,Enum)
instance SchemaType RepositoryType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RepositoryType'list where
    acceptingParser =  do literal "directlink"; return RepositoryType'list_Directlink
                      `onFail` do literal "openapi"; return RepositoryType'list_Openapi
                      `onFail` do literal "login"; return RepositoryType'list_Login
                      `onFail` do literal "oauth"; return RepositoryType'list_Oauth
                      `onFail` do literal "other"; return RepositoryType'list_Other
                      
    simpleTypeText RepositoryType'list_Directlink = "directlink"
    simpleTypeText RepositoryType'list_Openapi = "openapi"
    simpleTypeText RepositoryType'list_Login = "login"
    simpleTypeText RepositoryType'list_Oauth = "oauth"
    simpleTypeText RepositoryType'list_Other = "other"
 
data RepositoryType = RepositoryType
        { repositoryType_id :: Maybe String'primitive
        , repositoryType_value :: Maybe RepositoryType'list
        , repositoryType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RepositoryType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RepositoryType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RepositoryType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ repositoryType_id x
                       , maybe [] (toXMLAttribute "value") $ repositoryType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ repositoryType_extension x
            ]
instance Extension RepositoryType Element where
    supertype (RepositoryType a0 a1 e0) =
               Element a0 e0
 
data QualityType'list
    = QualityType'list_Indel
      -- ^ INDEL Comparison
    | QualityType'list_Snp
      -- ^ SNP Comparison
    | QualityType'list_Unknown
      -- ^ UNKNOWN Comparison
    deriving (Eq,Show,Enum)
instance SchemaType QualityType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QualityType'list where
    acceptingParser =  do literal "indel"; return QualityType'list_Indel
                      `onFail` do literal "snp"; return QualityType'list_Snp
                      `onFail` do literal "unknown"; return QualityType'list_Unknown
                      
    simpleTypeText QualityType'list_Indel = "indel"
    simpleTypeText QualityType'list_Snp = "snp"
    simpleTypeText QualityType'list_Unknown = "unknown"
 
data QualityType = QualityType
        { qualityType_id :: Maybe String'primitive
        , qualityType_value :: Maybe QualityType'list
        , qualityType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QualityType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QualityType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QualityType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ qualityType_id x
                       , maybe [] (toXMLAttribute "value") $ qualityType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ qualityType_extension x
            ]
instance Extension QualityType Element where
    supertype (QualityType a0 a1 e0) =
               Element a0 e0
 
-- | The ServiceDefinition describes a unit of decision support 
--   functionality that is made available as a service, such as 
--   immunization modules or drug-drug interaction checking.
elementServiceDefinition :: XMLParser ServiceDefinition
elementServiceDefinition = parseSchemaType "ServiceDefinition"
elementToXMLServiceDefinition :: ServiceDefinition -> [Content ()]
elementToXMLServiceDefinition = schemaTypeToXML "ServiceDefinition"
 
data ServiceDefinition = ServiceDefinition
        { serviceDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , serviceDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , serviceDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , serviceDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , serviceDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , serviceDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , serviceDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , serviceDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , serviceDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this service 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   service definition is (or will be) published. The URL 
          --   SHOULD include the major version of the service definition. 
          --   For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , serviceDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this service 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance. This is used for CMS or NQF identifiers for a 
          --   measure artifact. Note that at least one identifier is 
          --   required for non-experimental active artifacts.
        , serviceDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   service definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the service definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , serviceDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the service definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , serviceDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the service 
          --   definition.
        , serviceDefinition_status :: PublicationStatus
          -- ^ The status of this service definition. Enables tracking the 
          --   life-cycle of the content.
        , serviceDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this service definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , serviceDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the service definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the service definition changes.
        , serviceDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the service definition.
        , serviceDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the service 
          --   definition from a consumer's perspective.
        , serviceDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this service definition is needed and 
          --   why it has been designed as it has.
        , serviceDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the module is used from a 
          --   clinical perspective.
        , serviceDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , serviceDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , serviceDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the service definition content was 
          --   or is planned to be in active use.
        , serviceDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   service definition instances.
        , serviceDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the service 
          --   definition is intended to be used.
        , serviceDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the module. Topics provide a 
          --   high-level categorization of the module that can be useful 
          --   for filtering and searching.
        , serviceDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the module, including 
          --   authors, editors, reviewers, and endorsers.
        , serviceDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , serviceDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the service definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the service 
          --   definition.
        , serviceDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related resources such as additional documentation, 
          --   justification, or bibliographic references.
        , serviceDefinition_trigger :: [TriggerDefinition]
          -- ^ The trigger element defines when the rule should be 
          --   invoked. This information is used by consumers of the rule 
          --   to determine how to integrate the rule into a specific 
          --   workflow.
        , serviceDefinition_dataRequirement :: [DataRequirement]
          -- ^ Data requirements are a machine processable description of 
          --   the data required by the module in order to perform a 
          --   successful evaluation.
        , serviceDefinition_operationDefinition :: Maybe Reference
          -- ^ A reference to the operation that is used to invoke this 
          --   service.
        }
        deriving (Eq,Show)
instance SchemaType ServiceDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ServiceDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "trigger")
            `apply` many (parseSchemaType "dataRequirement")
            `apply` optional (parseSchemaType "operationDefinition")
    schemaTypeToXML s x@ServiceDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ serviceDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ serviceDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ serviceDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ serviceDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ serviceDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ serviceDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ serviceDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ serviceDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ serviceDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ serviceDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ serviceDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ serviceDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ serviceDefinition_title x
            , schemaTypeToXML "status" $ serviceDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ serviceDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ serviceDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ serviceDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ serviceDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ serviceDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ serviceDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ serviceDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ serviceDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ serviceDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ serviceDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ serviceDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ serviceDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ serviceDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ serviceDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ serviceDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ serviceDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "trigger") $ serviceDefinition_trigger x
            , concatMap (schemaTypeToXML "dataRequirement") $ serviceDefinition_dataRequirement x
            , maybe [] (schemaTypeToXML "operationDefinition") $ serviceDefinition_operationDefinition x
            ]
instance Extension ServiceDefinition DomainResource where
    supertype (ServiceDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ServiceDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ServiceDefinition -> DomainResource)
              
 
-- | A slot of time on a schedule that may be available for 
--   booking appointments.
elementSlot :: XMLParser Slot
elementSlot = parseSchemaType "Slot"
elementToXMLSlot :: Slot -> [Content ()]
elementToXMLSlot = schemaTypeToXML "Slot"
 
data Slot = Slot
        { slot_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , slot_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , slot_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , slot_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , slot_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , slot_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , slot_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , slot_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , slot_identifier :: [Identifier]
          -- ^ External Ids for this item.
        , slot_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , slot_serviceType :: [CodeableConcept]
          -- ^ The type of appointments that can be booked into this slot 
          --   (ideally this would be an identifiable service - which is 
          --   at a location, rather than the location itself). If 
          --   provided then this overrides the value provided on the 
          --   availability resource.
        , slot_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , slot_appointmentType :: Maybe CodeableConcept
          -- ^ The style of appointment or patient that may be booked in 
          --   the slot (not service type).
        , slot_schedule :: Reference
          -- ^ The schedule resource that this slot defines an interval of 
          --   status information.
        , slot_status :: SlotStatus
          -- ^ busy | free | busy-unavailable | busy-tentative | 
          --   entered-in-error.
        , slot_start :: Instant
          -- ^ Date/Time that the slot is to begin.
        , slot_end :: Instant
          -- ^ Date/Time that the slot is to conclude.
        , slot_overbooked :: Maybe Boolean
          -- ^ This slot has already been overbooked, appointments are 
          --   unlikely to be accepted for this time.
        , slot_comment :: Maybe Xsd.XsdString
          -- ^ Comments on the slot to describe any extended information. 
          --   Such as custom constraints on the slot.
        }
        deriving (Eq,Show)
instance SchemaType Slot where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Slot
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` optional (parseSchemaType "appointmentType")
            `apply` parseSchemaType "schedule"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "start"
            `apply` parseSchemaType "end"
            `apply` optional (parseSchemaType "overbooked")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@Slot{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ slot_id x
            , maybe [] (schemaTypeToXML "meta") $ slot_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ slot_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ slot_language x
            , maybe [] (schemaTypeToXML "text") $ slot_text x
            , concatMap (schemaTypeToXML "contained") $ slot_contained x
            , concatMap (schemaTypeToXML "extension") $ slot_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ slot_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ slot_identifier x
            , maybe [] (schemaTypeToXML "serviceCategory") $ slot_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ slot_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ slot_specialty x
            , maybe [] (schemaTypeToXML "appointmentType") $ slot_appointmentType x
            , schemaTypeToXML "schedule" $ slot_schedule x
            , schemaTypeToXML "status" $ slot_status x
            , schemaTypeToXML "start" $ slot_start x
            , schemaTypeToXML "end" $ slot_end x
            , maybe [] (schemaTypeToXML "overbooked") $ slot_overbooked x
            , maybe [] (schemaTypeToXML "comment") $ slot_comment x
            ]
instance Extension Slot DomainResource where
    supertype (Slot e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Slot Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Slot -> DomainResource)
              
 
data SlotStatus'list
    = SlotStatus'list_Busy
      -- ^ Busy
    | SlotStatus'list_Free
      -- ^ Free
    | SlotStatus'list_Busy'unavailable
      -- ^ Busy (Unavailable)
    | SlotStatus'list_Busy'tentative
      -- ^ Busy (Tentative)
    | SlotStatus'list_Entered'in'error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType SlotStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SlotStatus'list where
    acceptingParser =  do literal "busy"; return SlotStatus'list_Busy
                      `onFail` do literal "free"; return SlotStatus'list_Free
                      `onFail` do literal "busy-unavailable"; return SlotStatus'list_Busy'unavailable
                      `onFail` do literal "busy-tentative"; return SlotStatus'list_Busy'tentative
                      `onFail` do literal "entered-in-error"; return SlotStatus'list_Entered'in'error
                      
    simpleTypeText SlotStatus'list_Busy = "busy"
    simpleTypeText SlotStatus'list_Free = "free"
    simpleTypeText SlotStatus'list_Busy'unavailable = "busy-unavailable"
    simpleTypeText SlotStatus'list_Busy'tentative = "busy-tentative"
    simpleTypeText SlotStatus'list_Entered'in'error = "entered-in-error"
 
data SlotStatus = SlotStatus
        { slotStatus_id :: Maybe String'primitive
        , slotStatus_value :: Maybe SlotStatus'list
        , slotStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SlotStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SlotStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SlotStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ slotStatus_id x
                       , maybe [] (toXMLAttribute "value") $ slotStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ slotStatus_extension x
            ]
instance Extension SlotStatus Element where
    supertype (SlotStatus a0 a1 e0) =
               Element a0 e0
 
-- | A sample to be used for analysis.
elementSpecimen :: XMLParser Specimen
elementSpecimen = parseSchemaType "Specimen"
elementToXMLSpecimen :: Specimen -> [Content ()]
elementToXMLSpecimen = schemaTypeToXML "Specimen"
 
data Specimen = Specimen
        { specimen_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , specimen_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , specimen_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , specimen_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , specimen_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , specimen_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , specimen_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimen_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimen_identifier :: [Identifier]
          -- ^ Id for specimen.
        , specimen_accessionIdentifier :: Maybe Identifier
          -- ^ The identifier assigned by the lab when accessioning 
          --   specimen(s). This is not necessarily the same as the 
          --   specimen identifier, depending on local lab procedures.
        , specimen_status :: Maybe SpecimenStatus
          -- ^ The availability of the specimen.
        , specimen_type :: Maybe CodeableConcept
          -- ^ The kind of material that forms the specimen.
        , specimen_subject :: Reference
          -- ^ Where the specimen came from. This may be from the 
          --   patient(s) or from the environment or a device.
        , specimen_receivedTime :: Maybe DateTime
          -- ^ Time when specimen was received for processing or testing.
        , specimen_parent :: [Reference]
          -- ^ Reference to the parent (source) specimen which is used 
          --   when the specimen was either derived from or a component of 
          --   another specimen.
        , specimen_request :: [Reference]
          -- ^ Details concerning a test or procedure request that 
          --   required a specimen to be collected.
        , specimen_collection :: Maybe Specimen'Collection
          -- ^ Details concerning the specimen collection.
        , specimen_processing :: [Specimen'Processing]
          -- ^ Details concerning processing and processing steps for the 
          --   specimen.
        , specimen_container :: [Specimen'Container]
          -- ^ The container holding the specimen. The recursive nature of 
          --   containers; i.e. blood in tube in tray in rack is not 
          --   addressed here.
        , specimen_note :: [Annotation]
          -- ^ To communicate any details or issues about the specimen or 
          --   during the specimen collection. (for example: broken vial, 
          --   sent with patient, frozen).
        }
        deriving (Eq,Show)
instance SchemaType Specimen where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Specimen
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "accessionIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "receivedTime")
            `apply` many (parseSchemaType "parent")
            `apply` many (parseSchemaType "request")
            `apply` optional (parseSchemaType "collection")
            `apply` many (parseSchemaType "processing")
            `apply` many (parseSchemaType "container")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Specimen{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ specimen_id x
            , maybe [] (schemaTypeToXML "meta") $ specimen_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ specimen_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ specimen_language x
            , maybe [] (schemaTypeToXML "text") $ specimen_text x
            , concatMap (schemaTypeToXML "contained") $ specimen_contained x
            , concatMap (schemaTypeToXML "extension") $ specimen_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimen_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ specimen_identifier x
            , maybe [] (schemaTypeToXML "accessionIdentifier") $ specimen_accessionIdentifier x
            , maybe [] (schemaTypeToXML "status") $ specimen_status x
            , maybe [] (schemaTypeToXML "type") $ specimen_type x
            , schemaTypeToXML "subject" $ specimen_subject x
            , maybe [] (schemaTypeToXML "receivedTime") $ specimen_receivedTime x
            , concatMap (schemaTypeToXML "parent") $ specimen_parent x
            , concatMap (schemaTypeToXML "request") $ specimen_request x
            , maybe [] (schemaTypeToXML "collection") $ specimen_collection x
            , concatMap (schemaTypeToXML "processing") $ specimen_processing x
            , concatMap (schemaTypeToXML "container") $ specimen_container x
            , concatMap (schemaTypeToXML "note") $ specimen_note x
            ]
instance Extension Specimen DomainResource where
    supertype (Specimen e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Specimen Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Specimen -> DomainResource)
              
 
-- | A sample to be used for analysis.
data Specimen'Collection = Specimen'Collection
        { specimen'Collection_id :: Maybe String'primitive
        , specimen'Collection_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimen'Collection_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimen'Collection_collector :: Maybe Reference
          -- ^ Person who collected the specimen.
        , specimen'Collection_choice3 :: (Maybe (OneOf2 DateTime Period))
          -- ^ Time when specimen was collected from subject - the 
          --   physiologically relevant time.
          --   
          --   Choice between:
          --   
          --   (1) collectedDateTime
          --   
          --   (2) collectedPeriod
        , specimen'Collection_quantity :: Maybe Quantity
          -- ^ The quantity of specimen collected; for instance the volume 
          --   of a blood sample, or the physical measurement of an 
          --   anatomic pathology sample.
        , specimen'Collection_method :: Maybe CodeableConcept
          -- ^ A coded value specifying the technique that is used to 
          --   perform the procedure.
        , specimen'Collection_bodySite :: Maybe CodeableConcept
          -- ^ Anatomical location from which the specimen was collected 
          --   (if subject is a patient). This is the target site. This 
          --   element is not used for environmental specimens.
        }
        deriving (Eq,Show)
instance SchemaType Specimen'Collection where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Specimen'Collection a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "collector")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "collectedDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "collectedPeriod"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "bodySite")
    schemaTypeToXML s x@Specimen'Collection{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimen'Collection_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimen'Collection_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimen'Collection_modifierExtension x
            , maybe [] (schemaTypeToXML "collector") $ specimen'Collection_collector x
            , maybe [] (foldOneOf2  (schemaTypeToXML "collectedDateTime")
                                    (schemaTypeToXML "collectedPeriod")
                                   ) $ specimen'Collection_choice3 x
            , maybe [] (schemaTypeToXML "quantity") $ specimen'Collection_quantity x
            , maybe [] (schemaTypeToXML "method") $ specimen'Collection_method x
            , maybe [] (schemaTypeToXML "bodySite") $ specimen'Collection_bodySite x
            ]
instance Extension Specimen'Collection BackboneElement where
    supertype (Specimen'Collection a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension Specimen'Collection Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Specimen'Collection -> BackboneElement)
              
 
-- | A sample to be used for analysis.
data Specimen'Processing = Specimen'Processing
        { specimen'Processing_id :: Maybe String'primitive
        , specimen'Processing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimen'Processing_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimen'Processing_description :: Maybe Xsd.XsdString
          -- ^ Textual description of procedure.
        , specimen'Processing_procedure :: Maybe CodeableConcept
          -- ^ A coded value specifying the procedure used to process the 
          --   specimen.
        , specimen'Processing_additive :: [Reference]
          -- ^ Material used in the processing step.
        , specimen'Processing_choice5 :: (Maybe (OneOf2 DateTime Period))
          -- ^ A record of the time or period when the specimen processing 
          --   occurred. For example the time of sample fixation or the 
          --   period of time the sample was in formalin.
          --   
          --   Choice between:
          --   
          --   (1) timeDateTime
          --   
          --   (2) timePeriod
        }
        deriving (Eq,Show)
instance SchemaType Specimen'Processing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Specimen'Processing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "procedure")
            `apply` many (parseSchemaType "additive")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "timeDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timePeriod"))
                                     ])
    schemaTypeToXML s x@Specimen'Processing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimen'Processing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimen'Processing_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimen'Processing_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ specimen'Processing_description x
            , maybe [] (schemaTypeToXML "procedure") $ specimen'Processing_procedure x
            , concatMap (schemaTypeToXML "additive") $ specimen'Processing_additive x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timeDateTime")
                                    (schemaTypeToXML "timePeriod")
                                   ) $ specimen'Processing_choice5 x
            ]
instance Extension Specimen'Processing BackboneElement where
    supertype (Specimen'Processing a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Specimen'Processing Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Specimen'Processing -> BackboneElement)
              
 
-- | A sample to be used for analysis.
data Specimen'Container = Specimen'Container
        { specimen'Container_id :: Maybe String'primitive
        , specimen'Container_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimen'Container_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimen'Container_identifier :: [Identifier]
          -- ^ Id for container. There may be multiple; a manufacturer's 
          --   bar code, lab assigned identifier, etc. The container ID 
          --   may differ from the specimen id in some circumstances.
        , specimen'Container_description :: Maybe Xsd.XsdString
          -- ^ Textual description of the container.
        , specimen'Container_type :: Maybe CodeableConcept
          -- ^ The type of container associated with the specimen (e.g. 
          --   slide, aliquot, etc.).
        , specimen'Container_capacity :: Maybe Quantity
          -- ^ The capacity (volume or other measure) the container may 
          --   contain.
        , specimen'Container_specimenQuantity :: Maybe Quantity
          -- ^ The quantity of specimen in the container; may be volume, 
          --   dimensions, or other appropriate measurements, depending on 
          --   the specimen type.
        , specimen'Container_choice7 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Introduced substance to preserve, maintain or enhance the 
          --   specimen. Examples: Formalin, Citrate, EDTA.
          --   
          --   Choice between:
          --   
          --   (1) additiveCodeableConcept
          --   
          --   (2) additiveReference
        }
        deriving (Eq,Show)
instance SchemaType Specimen'Container where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Specimen'Container a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "capacity")
            `apply` optional (parseSchemaType "specimenQuantity")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "additiveCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "additiveReference"))
                                     ])
    schemaTypeToXML s x@Specimen'Container{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimen'Container_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimen'Container_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimen'Container_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ specimen'Container_identifier x
            , maybe [] (schemaTypeToXML "description") $ specimen'Container_description x
            , maybe [] (schemaTypeToXML "type") $ specimen'Container_type x
            , maybe [] (schemaTypeToXML "capacity") $ specimen'Container_capacity x
            , maybe [] (schemaTypeToXML "specimenQuantity") $ specimen'Container_specimenQuantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "additiveCodeableConcept")
                                    (schemaTypeToXML "additiveReference")
                                   ) $ specimen'Container_choice7 x
            ]
instance Extension Specimen'Container BackboneElement where
    supertype (Specimen'Container a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension Specimen'Container Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Specimen'Container -> BackboneElement)
              
 
data SpecimenStatus'list
    = SpecimenStatus'list_Available
      -- ^ Available
    | SpecimenStatus'list_Unavailable
      -- ^ Unavailable
    | SpecimenStatus'list_Unsatisfactory
      -- ^ Unsatisfactory
    | SpecimenStatus'list_Entered'in'error
      -- ^ Entered-in-error
    deriving (Eq,Show,Enum)
instance SchemaType SpecimenStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SpecimenStatus'list where
    acceptingParser =  do literal "available"; return SpecimenStatus'list_Available
                      `onFail` do literal "unavailable"; return SpecimenStatus'list_Unavailable
                      `onFail` do literal "unsatisfactory"; return SpecimenStatus'list_Unsatisfactory
                      `onFail` do literal "entered-in-error"; return SpecimenStatus'list_Entered'in'error
                      
    simpleTypeText SpecimenStatus'list_Available = "available"
    simpleTypeText SpecimenStatus'list_Unavailable = "unavailable"
    simpleTypeText SpecimenStatus'list_Unsatisfactory = "unsatisfactory"
    simpleTypeText SpecimenStatus'list_Entered'in'error = "entered-in-error"
 
data SpecimenStatus = SpecimenStatus
        { specimenStatus_id :: Maybe String'primitive
        , specimenStatus_value :: Maybe SpecimenStatus'list
        , specimenStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SpecimenStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SpecimenStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SpecimenStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimenStatus_id x
                       , maybe [] (toXMLAttribute "value") $ specimenStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimenStatus_extension x
            ]
instance Extension SpecimenStatus Element where
    supertype (SpecimenStatus a0 a1 e0) =
               Element a0 e0
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
elementStructureDefinition :: XMLParser StructureDefinition
elementStructureDefinition = parseSchemaType "StructureDefinition"
elementToXMLStructureDefinition :: StructureDefinition -> [Content ()]
elementToXMLStructureDefinition = schemaTypeToXML "StructureDefinition"
 
data StructureDefinition = StructureDefinition
        { structureDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , structureDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , structureDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , structureDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , structureDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , structureDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , structureDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinition_url :: Uri
          -- ^ An absolute URI that is used to identify this structure 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   structure definition is (or will be) published. The URL 
          --   SHOULD include the major version of the structure 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , structureDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this structure 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , structureDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   structure definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the structure definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , structureDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the structure 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , structureDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the structure 
          --   definition.
        , structureDefinition_status :: PublicationStatus
          -- ^ The status of this structure definition. Enables tracking 
          --   the life-cycle of the content.
        , structureDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this structure definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , structureDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the structure 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the structure definition changes.
        , structureDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the structure definition.
        , structureDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , structureDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the structure 
          --   definition from a consumer's perspective.
        , structureDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   structure definition instances.
        , structureDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the structure 
          --   definition is intended to be used.
        , structureDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this structure definition is needed and 
          --   why it has been designed as it has.
        , structureDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the structure definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   structure definition.
        , structureDefinition_keyword :: [Coding]
          -- ^ A set of key words or terms from external terminologies 
          --   that may be used to assist with indexing and searching of 
          --   templates.
        , structureDefinition_fhirVersion :: Maybe Id
          -- ^ The version of the FHIR specification on which this 
          --   StructureDefinition is based - this is the formal version 
          --   of the specification, without the revision number, e.g. 
          --   [publication].[major].[minor], which is 3.0.1 for this 
          --   version.
        , structureDefinition_mapping :: [StructureDefinition'Mapping]
          -- ^ An external specification that the content is mapped to.
        , structureDefinition_kind :: StructureDefinitionKind
          -- ^ Defines the kind of structure that this definition is 
          --   describing.
        , structureDefinition_abstract :: Boolean
          -- ^ Whether structure this definition describes is abstract or 
          --   not - that is, whether the structure is not intended to be 
          --   instantiated. For Resources and Data types, abstract types 
          --   will never be exchanged between systems.
        , structureDefinition_contextType :: Maybe ExtensionContext
          -- ^ If this is an extension, Identifies the context within FHIR 
          --   resources where the extension can be used.
        , structureDefinition_context :: [Xsd.XsdString]
          -- ^ Identifies the types of resource or data type elements to 
          --   which the extension can be applied.
        , structureDefinition_contextInvariant :: [Xsd.XsdString]
          -- ^ A set of rules as Fluent Invariants about when the 
          --   extension can be used (e.g. co-occurrence variants for the 
          --   extension).
        , structureDefinition_type :: Code
          -- ^ The type this structure describes. If the derivation kind 
          --   is 'specialization' then this is the master definition for 
          --   a type, and there is always one of these (a data type, an 
          --   extension, a resource, including abstract ones). Otherwise 
          --   the structure definition is a constraint on the stated type 
          --   (and in this case, the type cannot be an abstract type).
        , structureDefinition_baseDefinition :: Maybe Uri
          -- ^ An absolute URI that is the base structure from which this 
          --   type is derived, either by specialization or constraint.
        , structureDefinition_derivation :: Maybe TypeDerivationRule
          -- ^ How the type relates to the baseDefinition.
        , structureDefinition_snapshot :: Maybe StructureDefinition'Snapshot
          -- ^ A snapshot view is expressed in a stand alone form that can 
          --   be used and interpreted without considering the base 
          --   StructureDefinition.
        , structureDefinition_differential :: Maybe StructureDefinition'Differential
          -- ^ A differential view is expressed relative to the base 
          --   StructureDefinition - a statement of differences that it 
          --   applies.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return StructureDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "keyword")
            `apply` optional (parseSchemaType "fhirVersion")
            `apply` many (parseSchemaType "mapping")
            `apply` parseSchemaType "kind"
            `apply` parseSchemaType "abstract"
            `apply` optional (parseSchemaType "contextType")
            `apply` many (parseSchemaType "context")
            `apply` many (parseSchemaType "contextInvariant")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "baseDefinition")
            `apply` optional (parseSchemaType "derivation")
            `apply` optional (parseSchemaType "snapshot")
            `apply` optional (parseSchemaType "differential")
    schemaTypeToXML s x@StructureDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ structureDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ structureDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ structureDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ structureDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ structureDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ structureDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ structureDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinition_modifierExtension x
            , schemaTypeToXML "url" $ structureDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ structureDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ structureDefinition_version x
            , schemaTypeToXML "name" $ structureDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ structureDefinition_title x
            , schemaTypeToXML "status" $ structureDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ structureDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ structureDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ structureDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ structureDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ structureDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ structureDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ structureDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ structureDefinition_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ structureDefinition_copyright x
            , concatMap (schemaTypeToXML "keyword") $ structureDefinition_keyword x
            , maybe [] (schemaTypeToXML "fhirVersion") $ structureDefinition_fhirVersion x
            , concatMap (schemaTypeToXML "mapping") $ structureDefinition_mapping x
            , schemaTypeToXML "kind" $ structureDefinition_kind x
            , schemaTypeToXML "abstract" $ structureDefinition_abstract x
            , maybe [] (schemaTypeToXML "contextType") $ structureDefinition_contextType x
            , concatMap (schemaTypeToXML "context") $ structureDefinition_context x
            , concatMap (schemaTypeToXML "contextInvariant") $ structureDefinition_contextInvariant x
            , schemaTypeToXML "type" $ structureDefinition_type x
            , maybe [] (schemaTypeToXML "baseDefinition") $ structureDefinition_baseDefinition x
            , maybe [] (schemaTypeToXML "derivation") $ structureDefinition_derivation x
            , maybe [] (schemaTypeToXML "snapshot") $ structureDefinition_snapshot x
            , maybe [] (schemaTypeToXML "differential") $ structureDefinition_differential x
            ]
instance Extension StructureDefinition DomainResource where
    supertype (StructureDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension StructureDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: StructureDefinition -> DomainResource)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinition'Mapping = StructureDefinition'Mapping
        { structureDefinition'Mapping_id :: Maybe String'primitive
        , structureDefinition'Mapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinition'Mapping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinition'Mapping_identity :: Id
          -- ^ An Internal id that is used to identify this mapping set 
          --   when specific mappings are made.
        , structureDefinition'Mapping_uri :: Maybe Uri
          -- ^ An absolute URI that identifies the specification that this 
          --   mapping is expressed to.
        , structureDefinition'Mapping_name :: Maybe Xsd.XsdString
          -- ^ A name for the specification that is being mapped to.
        , structureDefinition'Mapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments about this mapping, including version notes, 
          --   issues, scope limitations, and other important notes for 
          --   usage.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinition'Mapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinition'Mapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@StructureDefinition'Mapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinition'Mapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinition'Mapping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinition'Mapping_modifierExtension x
            , schemaTypeToXML "identity" $ structureDefinition'Mapping_identity x
            , maybe [] (schemaTypeToXML "uri") $ structureDefinition'Mapping_uri x
            , maybe [] (schemaTypeToXML "name") $ structureDefinition'Mapping_name x
            , maybe [] (schemaTypeToXML "comment") $ structureDefinition'Mapping_comment x
            ]
instance Extension StructureDefinition'Mapping BackboneElement where
    supertype (StructureDefinition'Mapping a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinition'Mapping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinition'Mapping -> BackboneElement)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinition'Snapshot = StructureDefinition'Snapshot
        { structureDefinition'Snapshot_id :: Maybe String'primitive
        , structureDefinition'Snapshot_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinition'Snapshot_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinition'Snapshot_element :: [ElementDefinition]
          -- ^ Captures constraints on each element within the resource.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinition'Snapshot where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinition'Snapshot a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@StructureDefinition'Snapshot{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinition'Snapshot_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinition'Snapshot_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinition'Snapshot_modifierExtension x
            , concatMap (schemaTypeToXML "element") $ structureDefinition'Snapshot_element x
            ]
instance Extension StructureDefinition'Snapshot BackboneElement where
    supertype (StructureDefinition'Snapshot a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinition'Snapshot Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinition'Snapshot -> BackboneElement)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinition'Differential = StructureDefinition'Differential
        { structureDefinition'Differential_id :: Maybe String'primitive
        , structureDefinition'Differential_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinition'Differential_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinition'Differential_element :: [ElementDefinition]
          -- ^ Captures constraints on each element within the resource.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinition'Differential where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinition'Differential a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@StructureDefinition'Differential{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinition'Differential_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinition'Differential_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinition'Differential_modifierExtension x
            , concatMap (schemaTypeToXML "element") $ structureDefinition'Differential_element x
            ]
instance Extension StructureDefinition'Differential BackboneElement where
    supertype (StructureDefinition'Differential a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinition'Differential Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinition'Differential -> BackboneElement)
              
 
data StructureDefinitionKind'list
    = StructureDefinitionKind'list_Primitive'type
      -- ^ Primitive Data Type
    | StructureDefinitionKind'list_Complex'type
      -- ^ Complex Data Type
    | StructureDefinitionKind'list_Resource
      -- ^ Resource
    | StructureDefinitionKind'list_Logical
      -- ^ Logical Model
    deriving (Eq,Show,Enum)
instance SchemaType StructureDefinitionKind'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureDefinitionKind'list where
    acceptingParser =  do literal "primitive-type"; return StructureDefinitionKind'list_Primitive'type
                      `onFail` do literal "complex-type"; return StructureDefinitionKind'list_Complex'type
                      `onFail` do literal "resource"; return StructureDefinitionKind'list_Resource
                      `onFail` do literal "logical"; return StructureDefinitionKind'list_Logical
                      
    simpleTypeText StructureDefinitionKind'list_Primitive'type = "primitive-type"
    simpleTypeText StructureDefinitionKind'list_Complex'type = "complex-type"
    simpleTypeText StructureDefinitionKind'list_Resource = "resource"
    simpleTypeText StructureDefinitionKind'list_Logical = "logical"
 
data StructureDefinitionKind = StructureDefinitionKind
        { structureDefinitionKind_id :: Maybe String'primitive
        , structureDefinitionKind_value :: Maybe StructureDefinitionKind'list
        , structureDefinitionKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinitionKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureDefinitionKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureDefinitionKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinitionKind_id x
                       , maybe [] (toXMLAttribute "value") $ structureDefinitionKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinitionKind_extension x
            ]
instance Extension StructureDefinitionKind Element where
    supertype (StructureDefinitionKind a0 a1 e0) =
               Element a0 e0
 
data TypeDerivationRule'list
    = TypeDerivationRule'list_Specialization
      -- ^ Specialization
    | TypeDerivationRule'list_Constraint
      -- ^ Constraint
    deriving (Eq,Show,Enum)
instance SchemaType TypeDerivationRule'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TypeDerivationRule'list where
    acceptingParser =  do literal "specialization"; return TypeDerivationRule'list_Specialization
                      `onFail` do literal "constraint"; return TypeDerivationRule'list_Constraint
                      
    simpleTypeText TypeDerivationRule'list_Specialization = "specialization"
    simpleTypeText TypeDerivationRule'list_Constraint = "constraint"
 
data TypeDerivationRule = TypeDerivationRule
        { typeDerivationRule_id :: Maybe String'primitive
        , typeDerivationRule_value :: Maybe TypeDerivationRule'list
        , typeDerivationRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TypeDerivationRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TypeDerivationRule a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TypeDerivationRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ typeDerivationRule_id x
                       , maybe [] (toXMLAttribute "value") $ typeDerivationRule_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ typeDerivationRule_extension x
            ]
instance Extension TypeDerivationRule Element where
    supertype (TypeDerivationRule a0 a1 e0) =
               Element a0 e0
 
data ExtensionContext'list
    = ExtensionContext'list_Resource
      -- ^ Resource
    | ExtensionContext'list_Datatype
      -- ^ Datatype
    | ExtensionContext'list_Extension
      -- ^ Extension
    deriving (Eq,Show,Enum)
instance SchemaType ExtensionContext'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ExtensionContext'list where
    acceptingParser =  do literal "resource"; return ExtensionContext'list_Resource
                      `onFail` do literal "datatype"; return ExtensionContext'list_Datatype
                      `onFail` do literal "extension"; return ExtensionContext'list_Extension
                      
    simpleTypeText ExtensionContext'list_Resource = "resource"
    simpleTypeText ExtensionContext'list_Datatype = "datatype"
    simpleTypeText ExtensionContext'list_Extension = "extension"
 
data ExtensionContext = ExtensionContext
        { extensionContext_id :: Maybe String'primitive
        , extensionContext_value :: Maybe ExtensionContext'list
        , extensionContext_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ExtensionContext where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ExtensionContext a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ExtensionContext{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ extensionContext_id x
                       , maybe [] (toXMLAttribute "value") $ extensionContext_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ extensionContext_extension x
            ]
instance Extension ExtensionContext Element where
    supertype (ExtensionContext a0 a1 e0) =
               Element a0 e0
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
elementStructureMap :: XMLParser StructureMap
elementStructureMap = parseSchemaType "StructureMap"
elementToXMLStructureMap :: StructureMap -> [Content ()]
elementToXMLStructureMap = schemaTypeToXML "StructureMap"
 
data StructureMap = StructureMap
        { structureMap_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , structureMap_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , structureMap_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , structureMap_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , structureMap_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , structureMap_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , structureMap_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap_url :: Uri
          -- ^ An absolute URI that is used to identify this structure map 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this structure 
          --   map is (or will be) published. The URL SHOULD include the 
          --   major version of the structure map. For more information 
          --   see [Technical and Business 
          --   Versions](resource.html#versions).
        , structureMap_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this structure 
          --   map when it is represented in other formats, or referenced 
          --   in a specification, model, design or an instance.
        , structureMap_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   structure map when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the structure map author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , structureMap_name :: Xsd.XsdString
          -- ^ A natural language name identifying the structure map. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , structureMap_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the structure 
          --   map.
        , structureMap_status :: PublicationStatus
          -- ^ The status of this structure map. Enables tracking the 
          --   life-cycle of the content.
        , structureMap_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this structure map is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , structureMap_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the structure map was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the structure map changes.
        , structureMap_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the structure map.
        , structureMap_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , structureMap_description :: Maybe Markdown
          -- ^ A free text natural language description of the structure 
          --   map from a consumer's perspective.
        , structureMap_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   structure map instances.
        , structureMap_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the structure map is 
          --   intended to be used.
        , structureMap_purpose :: Maybe Markdown
          -- ^ Explaination of why this structure map is needed and why it 
          --   has been designed as it has.
        , structureMap_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the structure map and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the structure 
          --   map.
        , structureMap_structure :: [StructureMap'Structure]
          -- ^ A structure definition used by this map. The structure 
          --   definition may describe instances that are converted, or 
          --   the instances that are produced.
        , structureMap_import :: [Uri]
          -- ^ Other maps used by this map (canonical URLs).
        , structureMap_group :: [StructureMap'Group]
          -- ^ Organizes the mapping into managable chunks for human 
          --   review/ease of maintenance.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return StructureMap
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "structure")
            `apply` many (parseSchemaType "import")
            `apply` many1 (parseSchemaType "group")
    schemaTypeToXML s x@StructureMap{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ structureMap_id x
            , maybe [] (schemaTypeToXML "meta") $ structureMap_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ structureMap_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ structureMap_language x
            , maybe [] (schemaTypeToXML "text") $ structureMap_text x
            , concatMap (schemaTypeToXML "contained") $ structureMap_contained x
            , concatMap (schemaTypeToXML "extension") $ structureMap_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap_modifierExtension x
            , schemaTypeToXML "url" $ structureMap_url x
            , concatMap (schemaTypeToXML "identifier") $ structureMap_identifier x
            , maybe [] (schemaTypeToXML "version") $ structureMap_version x
            , schemaTypeToXML "name" $ structureMap_name x
            , maybe [] (schemaTypeToXML "title") $ structureMap_title x
            , schemaTypeToXML "status" $ structureMap_status x
            , maybe [] (schemaTypeToXML "experimental") $ structureMap_experimental x
            , maybe [] (schemaTypeToXML "date") $ structureMap_date x
            , maybe [] (schemaTypeToXML "publisher") $ structureMap_publisher x
            , concatMap (schemaTypeToXML "contact") $ structureMap_contact x
            , maybe [] (schemaTypeToXML "description") $ structureMap_description x
            , concatMap (schemaTypeToXML "useContext") $ structureMap_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ structureMap_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ structureMap_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ structureMap_copyright x
            , concatMap (schemaTypeToXML "structure") $ structureMap_structure x
            , concatMap (schemaTypeToXML "import") $ structureMap_import x
            , concatMap (schemaTypeToXML "group") $ structureMap_group x
            ]
instance Extension StructureMap DomainResource where
    supertype (StructureMap e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension StructureMap Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: StructureMap -> DomainResource)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Structure = StructureMap'Structure
        { structureMap'Structure_id :: Maybe String'primitive
        , structureMap'Structure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Structure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Structure_url :: Uri
          -- ^ The canonical URL that identifies the structure.
        , structureMap'Structure_mode :: StructureMapModelMode
          -- ^ How the referenced structure is used in this mapping.
        , structureMap'Structure_alias :: Maybe Xsd.XsdString
          -- ^ The name used for this type in the map.
        , structureMap'Structure_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation that describes how the structure is used in 
          --   the mapping.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Structure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Structure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "alias")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMap'Structure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Structure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Structure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Structure_modifierExtension x
            , schemaTypeToXML "url" $ structureMap'Structure_url x
            , schemaTypeToXML "mode" $ structureMap'Structure_mode x
            , maybe [] (schemaTypeToXML "alias") $ structureMap'Structure_alias x
            , maybe [] (schemaTypeToXML "documentation") $ structureMap'Structure_documentation x
            ]
instance Extension StructureMap'Structure BackboneElement where
    supertype (StructureMap'Structure a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Structure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Structure -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Group = StructureMap'Group
        { structureMap'Group_id :: Maybe String'primitive
        , structureMap'Group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Group_name :: Id
          -- ^ A unique name for the group for the convenience of human 
          --   readers.
        , structureMap'Group_extends :: Maybe Id
          -- ^ Another group that this group adds rules to.
        , structureMap'Group_typeMode :: StructureMapGroupTypeMode
          -- ^ If this is the default rule set to apply for thie source 
          --   type, or this combination of types.
        , structureMap'Group_documentation :: Maybe Xsd.XsdString
          -- ^ Additional supporting documentation that explains the 
          --   purpose of the group and the types of mappings within it.
        , structureMap'Group_input :: [StructureMap'Input]
          -- ^ A name assigned to an instance of data. The instance must 
          --   be provided when the mapping is invoked.
        , structureMap'Group_rule :: [StructureMap'Rule]
          -- ^ Transform Rule from source to target.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Group a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "extends")
            `apply` parseSchemaType "typeMode"
            `apply` optional (parseSchemaType "documentation")
            `apply` many1 (parseSchemaType "input")
            `apply` many1 (parseSchemaType "rule")
    schemaTypeToXML s x@StructureMap'Group{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Group_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Group_modifierExtension x
            , schemaTypeToXML "name" $ structureMap'Group_name x
            , maybe [] (schemaTypeToXML "extends") $ structureMap'Group_extends x
            , schemaTypeToXML "typeMode" $ structureMap'Group_typeMode x
            , maybe [] (schemaTypeToXML "documentation") $ structureMap'Group_documentation x
            , concatMap (schemaTypeToXML "input") $ structureMap'Group_input x
            , concatMap (schemaTypeToXML "rule") $ structureMap'Group_rule x
            ]
instance Extension StructureMap'Group BackboneElement where
    supertype (StructureMap'Group a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Group Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Group -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Input = StructureMap'Input
        { structureMap'Input_id :: Maybe String'primitive
        , structureMap'Input_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Input_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Input_name :: Id
          -- ^ Name for this instance of data.
        , structureMap'Input_type :: Maybe Xsd.XsdString
          -- ^ Type for this instance of data.
        , structureMap'Input_mode :: StructureMapInputMode
          -- ^ Mode for this instance of data.
        , structureMap'Input_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation for this instance of data.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Input where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Input a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMap'Input{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Input_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Input_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Input_modifierExtension x
            , schemaTypeToXML "name" $ structureMap'Input_name x
            , maybe [] (schemaTypeToXML "type") $ structureMap'Input_type x
            , schemaTypeToXML "mode" $ structureMap'Input_mode x
            , maybe [] (schemaTypeToXML "documentation") $ structureMap'Input_documentation x
            ]
instance Extension StructureMap'Input BackboneElement where
    supertype (StructureMap'Input a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Input Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Input -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Rule = StructureMap'Rule
        { structureMap'Rule_id :: Maybe String'primitive
        , structureMap'Rule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Rule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Rule_name :: Id
          -- ^ Name of the rule for internal references.
        , structureMap'Rule_source :: [StructureMap'Source]
          -- ^ Source inputs to the mapping.
        , structureMap'Rule_target :: [StructureMap'Target]
          -- ^ Content to create because of this mapping rule.
        , structureMap'Rule_rule :: [StructureMap'Rule]
          -- ^ Rules contained in this rule.
        , structureMap'Rule_dependent :: [StructureMap'Dependent]
          -- ^ Which other rules to apply in the context of this rule.
        , structureMap'Rule_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation for this instance of data.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Rule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Rule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` many1 (parseSchemaType "source")
            `apply` many (parseSchemaType "target")
            `apply` many (parseSchemaType "rule")
            `apply` many (parseSchemaType "dependent")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMap'Rule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Rule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Rule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Rule_modifierExtension x
            , schemaTypeToXML "name" $ structureMap'Rule_name x
            , concatMap (schemaTypeToXML "source") $ structureMap'Rule_source x
            , concatMap (schemaTypeToXML "target") $ structureMap'Rule_target x
            , concatMap (schemaTypeToXML "rule") $ structureMap'Rule_rule x
            , concatMap (schemaTypeToXML "dependent") $ structureMap'Rule_dependent x
            , maybe [] (schemaTypeToXML "documentation") $ structureMap'Rule_documentation x
            ]
instance Extension StructureMap'Rule BackboneElement where
    supertype (StructureMap'Rule a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Rule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Rule -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Source = StructureMap'Source
        { structureMap'Source_id :: Maybe String'primitive
        , structureMap'Source_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Source_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Source_context :: Id
          -- ^ Type or variable this rule applies to.
        , structureMap'Source_min :: Maybe Integer
          -- ^ Specified minimum cardinality for the element. This is 
          --   optional; if present, it acts an implicit check on the 
          --   input content.
        , structureMap'Source_max :: Maybe Xsd.XsdString
          -- ^ Specified maximum cardinality for the element - a number or 
          --   a &quot;*&quot;. This is optional; if present, it acts an 
          --   implicit check on the input content (* just serves as 
          --   documentation; it's the default value).
        , structureMap'Source_type :: Maybe Xsd.XsdString
          -- ^ Specified type for the element. This works as a condition 
          --   on the mapping - use for polymorphic elements.
        , structureMap'Source_choice6 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ A value to use if there is no existing value in the source 
          --   object.
          --   
          --   Choice between:
          --   
          --   (1) defaultValueBase64Binary
          --   
          --   (2) defaultValueBoolean
          --   
          --   (3) defaultValueCode
          --   
          --   (4) defaultValueDate
          --   
          --   (5) defaultValueDateTime
          --   
          --   (6) defaultValueDecimal
          --   
          --   (7) defaultValueId
          --   
          --   (8) defaultValueInstant
          --   
          --   (9) defaultValueInteger
          --   
          --   (10) defaultValueMarkdown
          --   
          --   (11) defaultValueOid
          --   
          --   (12) defaultValuePositiveInt
          --   
          --   (13) defaultValueString
          --   
          --   (14) defaultValueTime
          --   
          --   (15) defaultValueUnsignedInt
          --   
          --   (16) defaultValueUri
          --   
          --   (17) defaultValueAddress
          --   
          --   (18) defaultValueAge
          --   
          --   (19) defaultValueAnnotation
          --   
          --   (20) defaultValueAttachment
          --   
          --   (21) defaultValueCodeableConcept
          --   
          --   (22) defaultValueCoding
          --   
          --   (23) defaultValueContactPoint
          --   
          --   (24) defaultValueCount
          --   
          --   (25) defaultValueDistance
          --   
          --   (26) defaultValueDuration
          --   
          --   (27) defaultValueHumanName
          --   
          --   (28) defaultValueIdentifier
          --   
          --   (29) defaultValueMoney
          --   
          --   (30) defaultValuePeriod
          --   
          --   (31) defaultValueQuantity
          --   
          --   (32) defaultValueRange
          --   
          --   (33) defaultValueRatio
          --   
          --   (34) defaultValueReference
          --   
          --   (35) defaultValueSampledData
          --   
          --   (36) defaultValueSignature
          --   
          --   (37) defaultValueTiming
          --   
          --   (38) defaultValueMeta
        , structureMap'Source_element :: Maybe Xsd.XsdString
          -- ^ Optional field for this source.
        , structureMap'Source_listMode :: Maybe StructureMapSourceListMode
          -- ^ How to handle the list mode for this element.
        , structureMap'Source_variable :: Maybe Id
          -- ^ Named context for field, if a field is specified.
        , structureMap'Source_condition :: Maybe Xsd.XsdString
          -- ^ FHIRPath expression - must be true or the rule does not 
          --   apply.
        , structureMap'Source_check :: Maybe Xsd.XsdString
          -- ^ FHIRPath expression - must be true or the mapping engine 
          --   throws an error instead of completing.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Source where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Source a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "context"
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "defaultValueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "defaultValueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "defaultValueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "defaultValueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "defaultValueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "defaultValueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "defaultValueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "defaultValueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "defaultValueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "defaultValueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "defaultValueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "defaultValuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "defaultValueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "defaultValueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "defaultValueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "defaultValueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "defaultValueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "defaultValueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "defaultValueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "defaultValueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "defaultValueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "defaultValueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "defaultValueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "defaultValueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "defaultValueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "defaultValueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "defaultValueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "defaultValueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "defaultValueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "defaultValuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "defaultValueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "defaultValueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "defaultValueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "defaultValueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "defaultValueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "defaultValueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "defaultValueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "defaultValueMeta"))
                                     ])
            `apply` optional (parseSchemaType "element")
            `apply` optional (parseSchemaType "listMode")
            `apply` optional (parseSchemaType "variable")
            `apply` optional (parseSchemaType "condition")
            `apply` optional (parseSchemaType "check")
    schemaTypeToXML s x@StructureMap'Source{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Source_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Source_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Source_modifierExtension x
            , schemaTypeToXML "context" $ structureMap'Source_context x
            , maybe [] (schemaTypeToXML "min") $ structureMap'Source_min x
            , maybe [] (schemaTypeToXML "max") $ structureMap'Source_max x
            , maybe [] (schemaTypeToXML "type") $ structureMap'Source_type x
            , maybe [] (foldOneOf38  (schemaTypeToXML "defaultValueBase64Binary")
                                     (schemaTypeToXML "defaultValueBoolean")
                                     (schemaTypeToXML "defaultValueCode")
                                     (schemaTypeToXML "defaultValueDate")
                                     (schemaTypeToXML "defaultValueDateTime")
                                     (schemaTypeToXML "defaultValueDecimal")
                                     (schemaTypeToXML "defaultValueId")
                                     (schemaTypeToXML "defaultValueInstant")
                                     (schemaTypeToXML "defaultValueInteger")
                                     (schemaTypeToXML "defaultValueMarkdown")
                                     (schemaTypeToXML "defaultValueOid")
                                     (schemaTypeToXML "defaultValuePositiveInt")
                                     (schemaTypeToXML "defaultValueString")
                                     (schemaTypeToXML "defaultValueTime")
                                     (schemaTypeToXML "defaultValueUnsignedInt")
                                     (schemaTypeToXML "defaultValueUri")
                                     (schemaTypeToXML "defaultValueAddress")
                                     (schemaTypeToXML "defaultValueAge")
                                     (schemaTypeToXML "defaultValueAnnotation")
                                     (schemaTypeToXML "defaultValueAttachment")
                                     (schemaTypeToXML "defaultValueCodeableConcept")
                                     (schemaTypeToXML "defaultValueCoding")
                                     (schemaTypeToXML "defaultValueContactPoint")
                                     (schemaTypeToXML "defaultValueCount")
                                     (schemaTypeToXML "defaultValueDistance")
                                     (schemaTypeToXML "defaultValueDuration")
                                     (schemaTypeToXML "defaultValueHumanName")
                                     (schemaTypeToXML "defaultValueIdentifier")
                                     (schemaTypeToXML "defaultValueMoney")
                                     (schemaTypeToXML "defaultValuePeriod")
                                     (schemaTypeToXML "defaultValueQuantity")
                                     (schemaTypeToXML "defaultValueRange")
                                     (schemaTypeToXML "defaultValueRatio")
                                     (schemaTypeToXML "defaultValueReference")
                                     (schemaTypeToXML "defaultValueSampledData")
                                     (schemaTypeToXML "defaultValueSignature")
                                     (schemaTypeToXML "defaultValueTiming")
                                     (schemaTypeToXML "defaultValueMeta")
                                    ) $ structureMap'Source_choice6 x
            , maybe [] (schemaTypeToXML "element") $ structureMap'Source_element x
            , maybe [] (schemaTypeToXML "listMode") $ structureMap'Source_listMode x
            , maybe [] (schemaTypeToXML "variable") $ structureMap'Source_variable x
            , maybe [] (schemaTypeToXML "condition") $ structureMap'Source_condition x
            , maybe [] (schemaTypeToXML "check") $ structureMap'Source_check x
            ]
instance Extension StructureMap'Source BackboneElement where
    supertype (StructureMap'Source a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Source Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Source -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Target = StructureMap'Target
        { structureMap'Target_id :: Maybe String'primitive
        , structureMap'Target_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Target_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Target_context :: Maybe Id
          -- ^ Type or variable this rule applies to.
        , structureMap'Target_contextType :: Maybe StructureMapContextType
          -- ^ How to interpret the context.
        , structureMap'Target_element :: Maybe Xsd.XsdString
          -- ^ Field to create in the context.
        , structureMap'Target_variable :: Maybe Id
          -- ^ Named context for field, if desired, and a field is 
          --   specified.
        , structureMap'Target_listMode :: [StructureMapTargetListMode]
          -- ^ If field is a list, how to manage the list.
        , structureMap'Target_listRuleId :: Maybe Id
          -- ^ Internal rule reference for shared list items.
        , structureMap'Target_transform :: Maybe StructureMapTransform
          -- ^ How the data is copied / created.
        , structureMap'Target_parameter :: [StructureMap'Parameter]
          -- ^ Parameters to the transform.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Target where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Target a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "contextType")
            `apply` optional (parseSchemaType "element")
            `apply` optional (parseSchemaType "variable")
            `apply` many (parseSchemaType "listMode")
            `apply` optional (parseSchemaType "listRuleId")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "parameter")
    schemaTypeToXML s x@StructureMap'Target{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Target_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Target_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Target_modifierExtension x
            , maybe [] (schemaTypeToXML "context") $ structureMap'Target_context x
            , maybe [] (schemaTypeToXML "contextType") $ structureMap'Target_contextType x
            , maybe [] (schemaTypeToXML "element") $ structureMap'Target_element x
            , maybe [] (schemaTypeToXML "variable") $ structureMap'Target_variable x
            , concatMap (schemaTypeToXML "listMode") $ structureMap'Target_listMode x
            , maybe [] (schemaTypeToXML "listRuleId") $ structureMap'Target_listRuleId x
            , maybe [] (schemaTypeToXML "transform") $ structureMap'Target_transform x
            , concatMap (schemaTypeToXML "parameter") $ structureMap'Target_parameter x
            ]
instance Extension StructureMap'Target BackboneElement where
    supertype (StructureMap'Target a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Target Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Target -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Parameter = StructureMap'Parameter
        { structureMap'Parameter_id :: Maybe String'primitive
        , structureMap'Parameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Parameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Parameter_choice2 :: OneOf5 Id Xsd.XsdString Boolean Integer Decimal
          -- ^ Parameter value - variable or literal.
          --   
          --   Choice between:
          --   
          --   (1) valueId
          --   
          --   (2) valueString
          --   
          --   (3) valueBoolean
          --   
          --   (4) valueInteger
          --   
          --   (5) valueDecimal
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Parameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Parameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Id", fmap OneOf5 (parseSchemaType "valueId"))
                           , ("Xsd.XsdString", fmap TwoOf5 (parseSchemaType "valueString"))
                           , ("Boolean", fmap ThreeOf5 (parseSchemaType "valueBoolean"))
                           , ("Integer", fmap FourOf5 (parseSchemaType "valueInteger"))
                           , ("Decimal", fmap FiveOf5 (parseSchemaType "valueDecimal"))
                           ]
    schemaTypeToXML s x@StructureMap'Parameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Parameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Parameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Parameter_modifierExtension x
            , foldOneOf5  (schemaTypeToXML "valueId")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueDecimal")
                          $ structureMap'Parameter_choice2 x
            ]
instance Extension StructureMap'Parameter BackboneElement where
    supertype (StructureMap'Parameter a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Parameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Parameter -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMap'Dependent = StructureMap'Dependent
        { structureMap'Dependent_id :: Maybe String'primitive
        , structureMap'Dependent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap'Dependent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap'Dependent_name :: Id
          -- ^ Name of a rule or group to apply.
        , structureMap'Dependent_variable :: [Xsd.XsdString]
          -- ^ Variable to pass to the rule or group.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap'Dependent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMap'Dependent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` many1 (parseSchemaType "variable")
    schemaTypeToXML s x@StructureMap'Dependent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMap'Dependent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMap'Dependent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap'Dependent_modifierExtension x
            , schemaTypeToXML "name" $ structureMap'Dependent_name x
            , concatMap (schemaTypeToXML "variable") $ structureMap'Dependent_variable x
            ]
instance Extension StructureMap'Dependent BackboneElement where
    supertype (StructureMap'Dependent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension StructureMap'Dependent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMap'Dependent -> BackboneElement)
              
 
data StructureMapInputMode'list
    = StructureMapInputMode'list_Source
      -- ^ Source Instance
    | StructureMapInputMode'list_Target
      -- ^ Target Instance
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapInputMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapInputMode'list where
    acceptingParser =  do literal "source"; return StructureMapInputMode'list_Source
                      `onFail` do literal "target"; return StructureMapInputMode'list_Target
                      
    simpleTypeText StructureMapInputMode'list_Source = "source"
    simpleTypeText StructureMapInputMode'list_Target = "target"
 
data StructureMapInputMode = StructureMapInputMode
        { structureMapInputMode_id :: Maybe String'primitive
        , structureMapInputMode_value :: Maybe StructureMapInputMode'list
        , structureMapInputMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapInputMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapInputMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapInputMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapInputMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapInputMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapInputMode_extension x
            ]
instance Extension StructureMapInputMode Element where
    supertype (StructureMapInputMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapContextType'list
    = StructureMapContextType'list_Type
      -- ^ Type
    | StructureMapContextType'list_Variable
      -- ^ Variable
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapContextType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapContextType'list where
    acceptingParser =  do literal "type"; return StructureMapContextType'list_Type
                      `onFail` do literal "variable"; return StructureMapContextType'list_Variable
                      
    simpleTypeText StructureMapContextType'list_Type = "type"
    simpleTypeText StructureMapContextType'list_Variable = "variable"
 
data StructureMapContextType = StructureMapContextType
        { structureMapContextType_id :: Maybe String'primitive
        , structureMapContextType_value :: Maybe StructureMapContextType'list
        , structureMapContextType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapContextType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapContextType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapContextType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapContextType_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapContextType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapContextType_extension x
            ]
instance Extension StructureMapContextType Element where
    supertype (StructureMapContextType a0 a1 e0) =
               Element a0 e0
 
data StructureMapTargetListMode'list
    = StructureMapTargetListMode'list_First
      -- ^ First
    | StructureMapTargetListMode'list_Share
      -- ^ Share
    | StructureMapTargetListMode'list_Last
      -- ^ Last
    | StructureMapTargetListMode'list_Collate
      -- ^ Collate
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapTargetListMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapTargetListMode'list where
    acceptingParser =  do literal "first"; return StructureMapTargetListMode'list_First
                      `onFail` do literal "share"; return StructureMapTargetListMode'list_Share
                      `onFail` do literal "last"; return StructureMapTargetListMode'list_Last
                      `onFail` do literal "collate"; return StructureMapTargetListMode'list_Collate
                      
    simpleTypeText StructureMapTargetListMode'list_First = "first"
    simpleTypeText StructureMapTargetListMode'list_Share = "share"
    simpleTypeText StructureMapTargetListMode'list_Last = "last"
    simpleTypeText StructureMapTargetListMode'list_Collate = "collate"
 
data StructureMapTargetListMode = StructureMapTargetListMode
        { structureMapTargetListMode_id :: Maybe String'primitive
        , structureMapTargetListMode_value :: Maybe StructureMapTargetListMode'list
        , structureMapTargetListMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapTargetListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapTargetListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapTargetListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapTargetListMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapTargetListMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapTargetListMode_extension x
            ]
instance Extension StructureMapTargetListMode Element where
    supertype (StructureMapTargetListMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapTransform'list
    = StructureMapTransform'list_Create
      -- ^ create
    | StructureMapTransform'list_Copy
      -- ^ copy
    | StructureMapTransform'list_Truncate
      -- ^ truncate
    | StructureMapTransform'list_Escape
      -- ^ escape
    | StructureMapTransform'list_Cast
      -- ^ cast
    | StructureMapTransform'list_Append
      -- ^ append
    | StructureMapTransform'list_Translate
      -- ^ translate
    | StructureMapTransform'list_Reference
      -- ^ reference
    | StructureMapTransform'list_DateOp
      -- ^ dateOp
    | StructureMapTransform'list_Uuid
      -- ^ uuid
    | StructureMapTransform'list_Pointer
      -- ^ pointer
    | StructureMapTransform'list_Evaluate
      -- ^ evaluate
    | StructureMapTransform'list_Cc
      -- ^ cc
    | StructureMapTransform'list_C
      -- ^ c
    | StructureMapTransform'list_Qty
      -- ^ qty
    | StructureMapTransform'list_Id
      -- ^ id
    | StructureMapTransform'list_Cp
      -- ^ cp
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapTransform'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapTransform'list where
    acceptingParser =  do literal "create"; return StructureMapTransform'list_Create
                      `onFail` do literal "copy"; return StructureMapTransform'list_Copy
                      `onFail` do literal "truncate"; return StructureMapTransform'list_Truncate
                      `onFail` do literal "escape"; return StructureMapTransform'list_Escape
                      `onFail` do literal "cast"; return StructureMapTransform'list_Cast
                      `onFail` do literal "append"; return StructureMapTransform'list_Append
                      `onFail` do literal "translate"; return StructureMapTransform'list_Translate
                      `onFail` do literal "reference"; return StructureMapTransform'list_Reference
                      `onFail` do literal "dateOp"; return StructureMapTransform'list_DateOp
                      `onFail` do literal "uuid"; return StructureMapTransform'list_Uuid
                      `onFail` do literal "pointer"; return StructureMapTransform'list_Pointer
                      `onFail` do literal "evaluate"; return StructureMapTransform'list_Evaluate
                      `onFail` do literal "cc"; return StructureMapTransform'list_Cc
                      `onFail` do literal "c"; return StructureMapTransform'list_C
                      `onFail` do literal "qty"; return StructureMapTransform'list_Qty
                      `onFail` do literal "id"; return StructureMapTransform'list_Id
                      `onFail` do literal "cp"; return StructureMapTransform'list_Cp
                      
    simpleTypeText StructureMapTransform'list_Create = "create"
    simpleTypeText StructureMapTransform'list_Copy = "copy"
    simpleTypeText StructureMapTransform'list_Truncate = "truncate"
    simpleTypeText StructureMapTransform'list_Escape = "escape"
    simpleTypeText StructureMapTransform'list_Cast = "cast"
    simpleTypeText StructureMapTransform'list_Append = "append"
    simpleTypeText StructureMapTransform'list_Translate = "translate"
    simpleTypeText StructureMapTransform'list_Reference = "reference"
    simpleTypeText StructureMapTransform'list_DateOp = "dateOp"
    simpleTypeText StructureMapTransform'list_Uuid = "uuid"
    simpleTypeText StructureMapTransform'list_Pointer = "pointer"
    simpleTypeText StructureMapTransform'list_Evaluate = "evaluate"
    simpleTypeText StructureMapTransform'list_Cc = "cc"
    simpleTypeText StructureMapTransform'list_C = "c"
    simpleTypeText StructureMapTransform'list_Qty = "qty"
    simpleTypeText StructureMapTransform'list_Id = "id"
    simpleTypeText StructureMapTransform'list_Cp = "cp"
 
data StructureMapTransform = StructureMapTransform
        { structureMapTransform_id :: Maybe String'primitive
        , structureMapTransform_value :: Maybe StructureMapTransform'list
        , structureMapTransform_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapTransform where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapTransform a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapTransform{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapTransform_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapTransform_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapTransform_extension x
            ]
instance Extension StructureMapTransform Element where
    supertype (StructureMapTransform a0 a1 e0) =
               Element a0 e0
 
data StructureMapSourceListMode'list
    = StructureMapSourceListMode'list_First
      -- ^ First
    | StructureMapSourceListMode'list_Not_first
      -- ^ All but the first
    | StructureMapSourceListMode'list_Last
      -- ^ Last
    | StructureMapSourceListMode'list_Not_last
      -- ^ All but the last
    | StructureMapSourceListMode'list_Only_one
      -- ^ Enforce only one
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapSourceListMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapSourceListMode'list where
    acceptingParser =  do literal "first"; return StructureMapSourceListMode'list_First
                      `onFail` do literal "not_first"; return StructureMapSourceListMode'list_Not_first
                      `onFail` do literal "last"; return StructureMapSourceListMode'list_Last
                      `onFail` do literal "not_last"; return StructureMapSourceListMode'list_Not_last
                      `onFail` do literal "only_one"; return StructureMapSourceListMode'list_Only_one
                      
    simpleTypeText StructureMapSourceListMode'list_First = "first"
    simpleTypeText StructureMapSourceListMode'list_Not_first = "not_first"
    simpleTypeText StructureMapSourceListMode'list_Last = "last"
    simpleTypeText StructureMapSourceListMode'list_Not_last = "not_last"
    simpleTypeText StructureMapSourceListMode'list_Only_one = "only_one"
 
data StructureMapSourceListMode = StructureMapSourceListMode
        { structureMapSourceListMode_id :: Maybe String'primitive
        , structureMapSourceListMode_value :: Maybe StructureMapSourceListMode'list
        , structureMapSourceListMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapSourceListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapSourceListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapSourceListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapSourceListMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapSourceListMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapSourceListMode_extension x
            ]
instance Extension StructureMapSourceListMode Element where
    supertype (StructureMapSourceListMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapGroupTypeMode'list
    = StructureMapGroupTypeMode'list_None
      -- ^ Not a Default
    | StructureMapGroupTypeMode'list_Types
      -- ^ Default for Type Combination
    | StructureMapGroupTypeMode'list_Type'and'types
      -- ^ Default for type + combination
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapGroupTypeMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapGroupTypeMode'list where
    acceptingParser =  do literal "none"; return StructureMapGroupTypeMode'list_None
                      `onFail` do literal "types"; return StructureMapGroupTypeMode'list_Types
                      `onFail` do literal "type-and-types"; return StructureMapGroupTypeMode'list_Type'and'types
                      
    simpleTypeText StructureMapGroupTypeMode'list_None = "none"
    simpleTypeText StructureMapGroupTypeMode'list_Types = "types"
    simpleTypeText StructureMapGroupTypeMode'list_Type'and'types = "type-and-types"
 
data StructureMapGroupTypeMode = StructureMapGroupTypeMode
        { structureMapGroupTypeMode_id :: Maybe String'primitive
        , structureMapGroupTypeMode_value :: Maybe StructureMapGroupTypeMode'list
        , structureMapGroupTypeMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapGroupTypeMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapGroupTypeMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapGroupTypeMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapGroupTypeMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapGroupTypeMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapGroupTypeMode_extension x
            ]
instance Extension StructureMapGroupTypeMode Element where
    supertype (StructureMapGroupTypeMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapModelMode'list
    = StructureMapModelMode'list_Source
      -- ^ Source Structure Definition
    | StructureMapModelMode'list_Queried
      -- ^ Queried Structure Definition
    | StructureMapModelMode'list_Target
      -- ^ Target Structure Definition
    | StructureMapModelMode'list_Produced
      -- ^ Produced Structure Definition
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapModelMode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapModelMode'list where
    acceptingParser =  do literal "source"; return StructureMapModelMode'list_Source
                      `onFail` do literal "queried"; return StructureMapModelMode'list_Queried
                      `onFail` do literal "target"; return StructureMapModelMode'list_Target
                      `onFail` do literal "produced"; return StructureMapModelMode'list_Produced
                      
    simpleTypeText StructureMapModelMode'list_Source = "source"
    simpleTypeText StructureMapModelMode'list_Queried = "queried"
    simpleTypeText StructureMapModelMode'list_Target = "target"
    simpleTypeText StructureMapModelMode'list_Produced = "produced"
 
data StructureMapModelMode = StructureMapModelMode
        { structureMapModelMode_id :: Maybe String'primitive
        , structureMapModelMode_value :: Maybe StructureMapModelMode'list
        , structureMapModelMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapModelMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapModelMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapModelMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapModelMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapModelMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapModelMode_extension x
            ]
instance Extension StructureMapModelMode Element where
    supertype (StructureMapModelMode a0 a1 e0) =
               Element a0 e0
 
-- | The subscription resource is used to define a push based 
--   subscription from a server to another system. Once a 
--   subscription is registered with the server, the server 
--   checks every resource that is created or updated, and if 
--   the resource matches the given criteria, it sends a message 
--   on the defined &quot;channel&quot; so that another system 
--   is able to take an appropriate action.
elementSubscription :: XMLParser Subscription
elementSubscription = parseSchemaType "Subscription"
elementToXMLSubscription :: Subscription -> [Content ()]
elementToXMLSubscription = schemaTypeToXML "Subscription"
 
data Subscription = Subscription
        { subscription_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , subscription_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , subscription_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , subscription_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , subscription_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , subscription_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , subscription_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , subscription_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , subscription_status :: SubscriptionStatus
          -- ^ The status of the subscription, which marks the server 
          --   state for managing the subscription.
        , subscription_contact :: [ContactPoint]
          -- ^ Contact details for a human to contact about the 
          --   subscription. The primary use of this for system 
          --   administrator troubleshooting.
        , subscription_end :: Maybe Instant
          -- ^ The time for the server to turn the subscription off.
        , subscription_reason :: Xsd.XsdString
          -- ^ A description of why this subscription is defined.
        , subscription_criteria :: Xsd.XsdString
          -- ^ The rules that the server should use to determine when to 
          --   generate notifications for this subscription.
        , subscription_error :: Maybe Xsd.XsdString
          -- ^ A record of the last error that occurred when the server 
          --   processed a notification.
        , subscription_channel :: Subscription'Channel
          -- ^ Details where to send notifications when resources are 
          --   received that meet the criteria.
        , subscription_tag :: [Coding]
          -- ^ A tag to add to any resource that matches the criteria, 
          --   after the subscription is processed.
        }
        deriving (Eq,Show)
instance SchemaType Subscription where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Subscription
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "end")
            `apply` parseSchemaType "reason"
            `apply` parseSchemaType "criteria"
            `apply` optional (parseSchemaType "error")
            `apply` parseSchemaType "channel"
            `apply` many (parseSchemaType "tag")
    schemaTypeToXML s x@Subscription{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ subscription_id x
            , maybe [] (schemaTypeToXML "meta") $ subscription_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ subscription_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ subscription_language x
            , maybe [] (schemaTypeToXML "text") $ subscription_text x
            , concatMap (schemaTypeToXML "contained") $ subscription_contained x
            , concatMap (schemaTypeToXML "extension") $ subscription_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ subscription_modifierExtension x
            , schemaTypeToXML "status" $ subscription_status x
            , concatMap (schemaTypeToXML "contact") $ subscription_contact x
            , maybe [] (schemaTypeToXML "end") $ subscription_end x
            , schemaTypeToXML "reason" $ subscription_reason x
            , schemaTypeToXML "criteria" $ subscription_criteria x
            , maybe [] (schemaTypeToXML "error") $ subscription_error x
            , schemaTypeToXML "channel" $ subscription_channel x
            , concatMap (schemaTypeToXML "tag") $ subscription_tag x
            ]
instance Extension Subscription DomainResource where
    supertype (Subscription e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Subscription Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Subscription -> DomainResource)
              
 
-- | The subscription resource is used to define a push based 
--   subscription from a server to another system. Once a 
--   subscription is registered with the server, the server 
--   checks every resource that is created or updated, and if 
--   the resource matches the given criteria, it sends a message 
--   on the defined &quot;channel&quot; so that another system 
--   is able to take an appropriate action.
data Subscription'Channel = Subscription'Channel
        { subscription'Channel_id :: Maybe String'primitive
        , subscription'Channel_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , subscription'Channel_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , subscription'Channel_type :: SubscriptionChannelType
          -- ^ The type of channel to send notifications on.
        , subscription'Channel_endpoint :: Maybe Uri
          -- ^ The uri that describes the actual end-point to send 
          --   messages to.
        , subscription'Channel_payload :: Maybe Xsd.XsdString
          -- ^ The mime type to send the payload in - either 
          --   application/fhir+xml, or application/fhir+json. If the 
          --   payload is not present, then there is no payload in the 
          --   notification, just a notification.
        , subscription'Channel_header :: [Xsd.XsdString]
          -- ^ Additional headers / information to send as part of the 
          --   notification.
        }
        deriving (Eq,Show)
instance SchemaType Subscription'Channel where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Subscription'Channel a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "payload")
            `apply` many (parseSchemaType "header")
    schemaTypeToXML s x@Subscription'Channel{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscription'Channel_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscription'Channel_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ subscription'Channel_modifierExtension x
            , schemaTypeToXML "type" $ subscription'Channel_type x
            , maybe [] (schemaTypeToXML "endpoint") $ subscription'Channel_endpoint x
            , maybe [] (schemaTypeToXML "payload") $ subscription'Channel_payload x
            , concatMap (schemaTypeToXML "header") $ subscription'Channel_header x
            ]
instance Extension Subscription'Channel BackboneElement where
    supertype (Subscription'Channel a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension Subscription'Channel Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Subscription'Channel -> BackboneElement)
              
 
data SubscriptionStatus'list
    = SubscriptionStatus'list_Requested
      -- ^ Requested
    | SubscriptionStatus'list_Active
      -- ^ Active
    | SubscriptionStatus'list_Error
      -- ^ Error
    | SubscriptionStatus'list_Off
      -- ^ Off
    deriving (Eq,Show,Enum)
instance SchemaType SubscriptionStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SubscriptionStatus'list where
    acceptingParser =  do literal "requested"; return SubscriptionStatus'list_Requested
                      `onFail` do literal "active"; return SubscriptionStatus'list_Active
                      `onFail` do literal "error"; return SubscriptionStatus'list_Error
                      `onFail` do literal "off"; return SubscriptionStatus'list_Off
                      
    simpleTypeText SubscriptionStatus'list_Requested = "requested"
    simpleTypeText SubscriptionStatus'list_Active = "active"
    simpleTypeText SubscriptionStatus'list_Error = "error"
    simpleTypeText SubscriptionStatus'list_Off = "off"
 
data SubscriptionStatus = SubscriptionStatus
        { subscriptionStatus_id :: Maybe String'primitive
        , subscriptionStatus_value :: Maybe SubscriptionStatus'list
        , subscriptionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SubscriptionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SubscriptionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SubscriptionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscriptionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ subscriptionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscriptionStatus_extension x
            ]
instance Extension SubscriptionStatus Element where
    supertype (SubscriptionStatus a0 a1 e0) =
               Element a0 e0
 
data SubscriptionChannelType'list
    = SubscriptionChannelType'list_Rest'hook
      -- ^ Rest Hook
    | SubscriptionChannelType'list_Websocket
      -- ^ Websocket
    | SubscriptionChannelType'list_Email
      -- ^ Email
    | SubscriptionChannelType'list_Sms
      -- ^ SMS
    | SubscriptionChannelType'list_Message
      -- ^ Message
    deriving (Eq,Show,Enum)
instance SchemaType SubscriptionChannelType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SubscriptionChannelType'list where
    acceptingParser =  do literal "rest-hook"; return SubscriptionChannelType'list_Rest'hook
                      `onFail` do literal "websocket"; return SubscriptionChannelType'list_Websocket
                      `onFail` do literal "email"; return SubscriptionChannelType'list_Email
                      `onFail` do literal "sms"; return SubscriptionChannelType'list_Sms
                      `onFail` do literal "message"; return SubscriptionChannelType'list_Message
                      
    simpleTypeText SubscriptionChannelType'list_Rest'hook = "rest-hook"
    simpleTypeText SubscriptionChannelType'list_Websocket = "websocket"
    simpleTypeText SubscriptionChannelType'list_Email = "email"
    simpleTypeText SubscriptionChannelType'list_Sms = "sms"
    simpleTypeText SubscriptionChannelType'list_Message = "message"
 
data SubscriptionChannelType = SubscriptionChannelType
        { subscriptionChannelType_id :: Maybe String'primitive
        , subscriptionChannelType_value :: Maybe SubscriptionChannelType'list
        , subscriptionChannelType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SubscriptionChannelType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SubscriptionChannelType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SubscriptionChannelType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscriptionChannelType_id x
                       , maybe [] (toXMLAttribute "value") $ subscriptionChannelType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscriptionChannelType_extension x
            ]
instance Extension SubscriptionChannelType Element where
    supertype (SubscriptionChannelType a0 a1 e0) =
               Element a0 e0
 
-- | A homogeneous material with a definite composition.
elementSubstance :: XMLParser Substance
elementSubstance = parseSchemaType "Substance"
elementToXMLSubstance :: Substance -> [Content ()]
elementToXMLSubstance = schemaTypeToXML "Substance"
 
data Substance = Substance
        { substance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , substance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , substance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , substance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , substance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , substance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , substance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substance_identifier :: [Identifier]
          -- ^ Unique identifier for the substance.
        , substance_status :: Maybe FHIRSubstanceStatus
          -- ^ A code to indicate if the substance is actively used.
        , substance_category :: [CodeableConcept]
          -- ^ A code that classifies the general type of substance. This 
          --   is used for searching, sorting and display purposes.
        , substance_code :: CodeableConcept
          -- ^ A code (or set of codes) that identify this substance.
        , substance_description :: Maybe Xsd.XsdString
          -- ^ A description of the substance - its appearance, handling 
          --   requirements, and other usage notes.
        , substance_instance :: [Substance'Instance]
          -- ^ Substance may be used to describe a kind of substance, or a 
          --   specific package/container of the substance: an instance.
        , substance_ingredient :: [Substance'Ingredient]
          -- ^ A substance can be composed of other substances.
        }
        deriving (Eq,Show)
instance SchemaType Substance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Substance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "instance")
            `apply` many (parseSchemaType "ingredient")
    schemaTypeToXML s x@Substance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ substance_id x
            , maybe [] (schemaTypeToXML "meta") $ substance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ substance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ substance_language x
            , maybe [] (schemaTypeToXML "text") $ substance_text x
            , concatMap (schemaTypeToXML "contained") $ substance_contained x
            , concatMap (schemaTypeToXML "extension") $ substance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substance_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ substance_identifier x
            , maybe [] (schemaTypeToXML "status") $ substance_status x
            , concatMap (schemaTypeToXML "category") $ substance_category x
            , schemaTypeToXML "code" $ substance_code x
            , maybe [] (schemaTypeToXML "description") $ substance_description x
            , concatMap (schemaTypeToXML "instance") $ substance_instance x
            , concatMap (schemaTypeToXML "ingredient") $ substance_ingredient x
            ]
instance Extension Substance DomainResource where
    supertype (Substance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Substance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Substance -> DomainResource)
              
 
-- | A homogeneous material with a definite composition.
data Substance'Instance = Substance'Instance
        { substance'Instance_id :: Maybe String'primitive
        , substance'Instance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substance'Instance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substance'Instance_identifier :: Maybe Identifier
          -- ^ Identifier associated with the package/container (usually a 
          --   label affixed directly).
        , substance'Instance_expiry :: Maybe DateTime
          -- ^ When the substance is no longer valid to use. For some 
          --   substances, a single arbitrary date is used for expiry.
        , substance'Instance_quantity :: Maybe Quantity
          -- ^ The amount of the substance.
        }
        deriving (Eq,Show)
instance SchemaType Substance'Instance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Substance'Instance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "expiry")
            `apply` optional (parseSchemaType "quantity")
    schemaTypeToXML s x@Substance'Instance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ substance'Instance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ substance'Instance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substance'Instance_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ substance'Instance_identifier x
            , maybe [] (schemaTypeToXML "expiry") $ substance'Instance_expiry x
            , maybe [] (schemaTypeToXML "quantity") $ substance'Instance_quantity x
            ]
instance Extension Substance'Instance BackboneElement where
    supertype (Substance'Instance a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Substance'Instance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Substance'Instance -> BackboneElement)
              
 
-- | A homogeneous material with a definite composition.
data Substance'Ingredient = Substance'Ingredient
        { substance'Ingredient_id :: Maybe String'primitive
        , substance'Ingredient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substance'Ingredient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substance'Ingredient_quantity :: Maybe Ratio
          -- ^ The amount of the ingredient in the substance - a 
          --   concentration ratio.
        , substance'Ingredient_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ Another substance that is a component of this substance.
          --   
          --   Choice between:
          --   
          --   (1) substanceCodeableConcept
          --   
          --   (2) substanceReference
        }
        deriving (Eq,Show)
instance SchemaType Substance'Ingredient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Substance'Ingredient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "quantity")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "substanceCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "substanceReference"))
                           ]
    schemaTypeToXML s x@Substance'Ingredient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ substance'Ingredient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ substance'Ingredient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substance'Ingredient_modifierExtension x
            , maybe [] (schemaTypeToXML "quantity") $ substance'Ingredient_quantity x
            , foldOneOf2  (schemaTypeToXML "substanceCodeableConcept")
                          (schemaTypeToXML "substanceReference")
                          $ substance'Ingredient_choice3 x
            ]
instance Extension Substance'Ingredient BackboneElement where
    supertype (Substance'Ingredient a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Substance'Ingredient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Substance'Ingredient -> BackboneElement)
              
 
data FHIRSubstanceStatus'list
    = FHIRSubstanceStatus'list_Active
      -- ^ Active
    | FHIRSubstanceStatus'list_Inactive
      -- ^ Inactive
    | FHIRSubstanceStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FHIRSubstanceStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRSubstanceStatus'list where
    acceptingParser =  do literal "active"; return FHIRSubstanceStatus'list_Active
                      `onFail` do literal "inactive"; return FHIRSubstanceStatus'list_Inactive
                      `onFail` do literal "entered-in-error"; return FHIRSubstanceStatus'list_Entered'in'error
                      
    simpleTypeText FHIRSubstanceStatus'list_Active = "active"
    simpleTypeText FHIRSubstanceStatus'list_Inactive = "inactive"
    simpleTypeText FHIRSubstanceStatus'list_Entered'in'error = "entered-in-error"
 
data FHIRSubstanceStatus = FHIRSubstanceStatus
        { fHIRSubstanceStatus_id :: Maybe String'primitive
        , fHIRSubstanceStatus_value :: Maybe FHIRSubstanceStatus'list
        , fHIRSubstanceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRSubstanceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRSubstanceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRSubstanceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRSubstanceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRSubstanceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRSubstanceStatus_extension x
            ]
instance Extension FHIRSubstanceStatus Element where
    supertype (FHIRSubstanceStatus a0 a1 e0) =
               Element a0 e0
 
-- | Record of delivery of what is supplied.
elementSupplyDelivery :: XMLParser SupplyDelivery
elementSupplyDelivery = parseSchemaType "SupplyDelivery"
elementToXMLSupplyDelivery :: SupplyDelivery -> [Content ()]
elementToXMLSupplyDelivery = schemaTypeToXML "SupplyDelivery"
 
data SupplyDelivery = SupplyDelivery
        { supplyDelivery_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , supplyDelivery_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , supplyDelivery_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , supplyDelivery_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , supplyDelivery_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , supplyDelivery_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , supplyDelivery_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyDelivery_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyDelivery_identifier :: Maybe Identifier
          -- ^ Identifier assigned by the dispensing facility when the 
          --   item(s) is dispensed.
        , supplyDelivery_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , supplyDelivery_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , supplyDelivery_status :: Maybe SupplyDeliveryStatus
          -- ^ A code specifying the state of the dispense event.
        , supplyDelivery_patient :: Maybe Reference
          -- ^ A link to a resource representing the person whom the 
          --   delivered item is for.
        , supplyDelivery_type :: Maybe CodeableConcept
          -- ^ Indicates the type of dispensing event that is performed. 
          --   Examples include: Trial Fill, Completion of Trial, Partial 
          --   Fill, Emergency Fill, Samples, etc.
        , supplyDelivery_suppliedItem :: Maybe SupplyDelivery'SuppliedItem
          -- ^ The item that is being delivered or has been supplied.
        , supplyDelivery_choice15 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The date or time(s) the activity occurred.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , supplyDelivery_supplier :: Maybe Reference
          -- ^ The individual responsible for dispensing the medication, 
          --   supplier or device.
        , supplyDelivery_destination :: Maybe Reference
          -- ^ Identification of the facility/location where the Supply 
          --   was shipped to, as part of the dispense event.
        , supplyDelivery_receiver :: [Reference]
          -- ^ Identifies the person who picked up the Supply.
        }
        deriving (Eq,Show)
instance SchemaType SupplyDelivery where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SupplyDelivery
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "suppliedItem")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "supplier")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "receiver")
    schemaTypeToXML s x@SupplyDelivery{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ supplyDelivery_id x
            , maybe [] (schemaTypeToXML "meta") $ supplyDelivery_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ supplyDelivery_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ supplyDelivery_language x
            , maybe [] (schemaTypeToXML "text") $ supplyDelivery_text x
            , concatMap (schemaTypeToXML "contained") $ supplyDelivery_contained x
            , concatMap (schemaTypeToXML "extension") $ supplyDelivery_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyDelivery_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ supplyDelivery_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ supplyDelivery_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ supplyDelivery_partOf x
            , maybe [] (schemaTypeToXML "status") $ supplyDelivery_status x
            , maybe [] (schemaTypeToXML "patient") $ supplyDelivery_patient x
            , maybe [] (schemaTypeToXML "type") $ supplyDelivery_type x
            , maybe [] (schemaTypeToXML "suppliedItem") $ supplyDelivery_suppliedItem x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ supplyDelivery_choice15 x
            , maybe [] (schemaTypeToXML "supplier") $ supplyDelivery_supplier x
            , maybe [] (schemaTypeToXML "destination") $ supplyDelivery_destination x
            , concatMap (schemaTypeToXML "receiver") $ supplyDelivery_receiver x
            ]
instance Extension SupplyDelivery DomainResource where
    supertype (SupplyDelivery e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SupplyDelivery Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SupplyDelivery -> DomainResource)
              
 
-- | Record of delivery of what is supplied.
data SupplyDelivery'SuppliedItem = SupplyDelivery'SuppliedItem
        { supplyDelivery'SuppliedItem_id :: Maybe String'primitive
        , supplyDelivery'SuppliedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyDelivery'SuppliedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyDelivery'SuppliedItem_quantity :: Maybe Quantity
          -- ^ The amount of supply that has been dispensed. Includes unit 
          --   of measure.
        , supplyDelivery'SuppliedItem_choice3 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Identifies the medication, substance or device being 
          --   dispensed. This is either a link to a resource representing 
          --   the details of the item or a code that identifies the item 
          --   from a known list.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        }
        deriving (Eq,Show)
instance SchemaType SupplyDelivery'SuppliedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyDelivery'SuppliedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                                     ])
    schemaTypeToXML s x@SupplyDelivery'SuppliedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyDelivery'SuppliedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyDelivery'SuppliedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyDelivery'SuppliedItem_modifierExtension x
            , maybe [] (schemaTypeToXML "quantity") $ supplyDelivery'SuppliedItem_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                                    (schemaTypeToXML "itemReference")
                                   ) $ supplyDelivery'SuppliedItem_choice3 x
            ]
instance Extension SupplyDelivery'SuppliedItem BackboneElement where
    supertype (SupplyDelivery'SuppliedItem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyDelivery'SuppliedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyDelivery'SuppliedItem -> BackboneElement)
              
 
data SupplyDeliveryStatus'list
    = SupplyDeliveryStatus'list_In'progress
      -- ^ In Progress
    | SupplyDeliveryStatus'list_Completed
      -- ^ Delivered
    | SupplyDeliveryStatus'list_Abandoned
      -- ^ Abandoned
    | SupplyDeliveryStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType SupplyDeliveryStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SupplyDeliveryStatus'list where
    acceptingParser =  do literal "in-progress"; return SupplyDeliveryStatus'list_In'progress
                      `onFail` do literal "completed"; return SupplyDeliveryStatus'list_Completed
                      `onFail` do literal "abandoned"; return SupplyDeliveryStatus'list_Abandoned
                      `onFail` do literal "entered-in-error"; return SupplyDeliveryStatus'list_Entered'in'error
                      
    simpleTypeText SupplyDeliveryStatus'list_In'progress = "in-progress"
    simpleTypeText SupplyDeliveryStatus'list_Completed = "completed"
    simpleTypeText SupplyDeliveryStatus'list_Abandoned = "abandoned"
    simpleTypeText SupplyDeliveryStatus'list_Entered'in'error = "entered-in-error"
 
data SupplyDeliveryStatus = SupplyDeliveryStatus
        { supplyDeliveryStatus_id :: Maybe String'primitive
        , supplyDeliveryStatus_value :: Maybe SupplyDeliveryStatus'list
        , supplyDeliveryStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SupplyDeliveryStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SupplyDeliveryStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SupplyDeliveryStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyDeliveryStatus_id x
                       , maybe [] (toXMLAttribute "value") $ supplyDeliveryStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyDeliveryStatus_extension x
            ]
instance Extension SupplyDeliveryStatus Element where
    supertype (SupplyDeliveryStatus a0 a1 e0) =
               Element a0 e0
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
elementSupplyRequest :: XMLParser SupplyRequest
elementSupplyRequest = parseSchemaType "SupplyRequest"
elementToXMLSupplyRequest :: SupplyRequest -> [Content ()]
elementToXMLSupplyRequest = schemaTypeToXML "SupplyRequest"
 
data SupplyRequest = SupplyRequest
        { supplyRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , supplyRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , supplyRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , supplyRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , supplyRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , supplyRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , supplyRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequest_identifier :: Maybe Identifier
          -- ^ Unique identifier for this supply request.
        , supplyRequest_status :: Maybe SupplyRequestStatus
          -- ^ Status of the supply request.
        , supplyRequest_category :: Maybe CodeableConcept
          -- ^ Category of supply, e.g. central, non-stock, etc. This is 
          --   used to support work flows associated with the supply 
          --   process.
        , supplyRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly this SupplyRequest should be 
          --   addressed with respect to other requests.
        , supplyRequest_orderedItem :: Maybe SupplyRequest'OrderedItem
          -- ^ The item being requested.
        , supplyRequest_choice13 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ When the request should be fulfilled.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , supplyRequest_authoredOn :: Maybe DateTime
          -- ^ When the request was made.
        , supplyRequest_requester :: Maybe SupplyRequest'Requester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , supplyRequest_supplier :: [Reference]
          -- ^ Who is intended to fulfill the request.
        , supplyRequest_choice17 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Why the supply item was requested.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , supplyRequest_deliverFrom :: Maybe Reference
          -- ^ Where the supply is expected to come from.
        , supplyRequest_deliverTo :: Maybe Reference
          -- ^ Where the supply is destined to go.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SupplyRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "orderedItem")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "supplier")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` optional (parseSchemaType "deliverFrom")
            `apply` optional (parseSchemaType "deliverTo")
    schemaTypeToXML s x@SupplyRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ supplyRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ supplyRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ supplyRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ supplyRequest_language x
            , maybe [] (schemaTypeToXML "text") $ supplyRequest_text x
            , concatMap (schemaTypeToXML "contained") $ supplyRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ supplyRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequest_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ supplyRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ supplyRequest_status x
            , maybe [] (schemaTypeToXML "category") $ supplyRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ supplyRequest_priority x
            , maybe [] (schemaTypeToXML "orderedItem") $ supplyRequest_orderedItem x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ supplyRequest_choice13 x
            , maybe [] (schemaTypeToXML "authoredOn") $ supplyRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ supplyRequest_requester x
            , concatMap (schemaTypeToXML "supplier") $ supplyRequest_supplier x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ supplyRequest_choice17 x
            , maybe [] (schemaTypeToXML "deliverFrom") $ supplyRequest_deliverFrom x
            , maybe [] (schemaTypeToXML "deliverTo") $ supplyRequest_deliverTo x
            ]
instance Extension SupplyRequest DomainResource where
    supertype (SupplyRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SupplyRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SupplyRequest -> DomainResource)
              
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
data SupplyRequest'OrderedItem = SupplyRequest'OrderedItem
        { supplyRequest'OrderedItem_id :: Maybe String'primitive
        , supplyRequest'OrderedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequest'OrderedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequest'OrderedItem_quantity :: Quantity
          -- ^ The amount that is being ordered of the indicated item.
        , supplyRequest'OrderedItem_choice3 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ The item that is requested to be supplied. This is either a 
          --   link to a resource representing the details of the item or 
          --   a code that identifies the item from a known list.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequest'OrderedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyRequest'OrderedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "quantity"
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                                     ])
    schemaTypeToXML s x@SupplyRequest'OrderedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequest'OrderedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequest'OrderedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequest'OrderedItem_modifierExtension x
            , schemaTypeToXML "quantity" $ supplyRequest'OrderedItem_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                                    (schemaTypeToXML "itemReference")
                                   ) $ supplyRequest'OrderedItem_choice3 x
            ]
instance Extension SupplyRequest'OrderedItem BackboneElement where
    supertype (SupplyRequest'OrderedItem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyRequest'OrderedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyRequest'OrderedItem -> BackboneElement)
              
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
data SupplyRequest'Requester = SupplyRequest'Requester
        { supplyRequest'Requester_id :: Maybe String'primitive
        , supplyRequest'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequest'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequest'Requester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , supplyRequest'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequest'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyRequest'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@SupplyRequest'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequest'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequest'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequest'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ supplyRequest'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ supplyRequest'Requester_onBehalfOf x
            ]
instance Extension SupplyRequest'Requester BackboneElement where
    supertype (SupplyRequest'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyRequest'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyRequest'Requester -> BackboneElement)
              
 
data SupplyRequestStatus'list
    = SupplyRequestStatus'list_Draft
      -- ^ Draft
    | SupplyRequestStatus'list_Active
      -- ^ Active
    | SupplyRequestStatus'list_Suspended
      -- ^ Suspended
    | SupplyRequestStatus'list_Cancelled
      -- ^ Cancelled
    | SupplyRequestStatus'list_Completed
      -- ^ Completed
    | SupplyRequestStatus'list_Entered'in'error
      -- ^ Entered in Error
    | SupplyRequestStatus'list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType SupplyRequestStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SupplyRequestStatus'list where
    acceptingParser =  do literal "draft"; return SupplyRequestStatus'list_Draft
                      `onFail` do literal "active"; return SupplyRequestStatus'list_Active
                      `onFail` do literal "suspended"; return SupplyRequestStatus'list_Suspended
                      `onFail` do literal "cancelled"; return SupplyRequestStatus'list_Cancelled
                      `onFail` do literal "completed"; return SupplyRequestStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return SupplyRequestStatus'list_Entered'in'error
                      `onFail` do literal "unknown"; return SupplyRequestStatus'list_Unknown
                      
    simpleTypeText SupplyRequestStatus'list_Draft = "draft"
    simpleTypeText SupplyRequestStatus'list_Active = "active"
    simpleTypeText SupplyRequestStatus'list_Suspended = "suspended"
    simpleTypeText SupplyRequestStatus'list_Cancelled = "cancelled"
    simpleTypeText SupplyRequestStatus'list_Completed = "completed"
    simpleTypeText SupplyRequestStatus'list_Entered'in'error = "entered-in-error"
    simpleTypeText SupplyRequestStatus'list_Unknown = "unknown"
 
data SupplyRequestStatus = SupplyRequestStatus
        { supplyRequestStatus_id :: Maybe String'primitive
        , supplyRequestStatus_value :: Maybe SupplyRequestStatus'list
        , supplyRequestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SupplyRequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SupplyRequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ supplyRequestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequestStatus_extension x
            ]
instance Extension SupplyRequestStatus Element where
    supertype (SupplyRequestStatus a0 a1 e0) =
               Element a0 e0
 
-- | A task to be performed.
elementTask :: XMLParser Task
elementTask = parseSchemaType "Task"
elementToXMLTask :: Task -> [Content ()]
elementToXMLTask = schemaTypeToXML "Task"
 
data Task = Task
        { task_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , task_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , task_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , task_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , task_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , task_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , task_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task_identifier :: [Identifier]
          -- ^ The business identifier for this task.
        , task_choice9 :: (Maybe (OneOf2 Uri Reference))
          -- ^ A reference to a formal or informal definition of the task. 
          --   For example, a protocol, a step within a defined workflow 
          --   definition, etc.
          --   
          --   Choice between:
          --   
          --   (1) definitionUri
          --   
          --   (2) definitionReference
        , task_basedOn :: [Reference]
          -- ^ BasedOn refers to a higher-level authorization that 
          --   triggered the creation of the task. It references a 
          --   &quot;request&quot; resource such as a ProcedureRequest, 
          --   MedicationRequest, ProcedureRequest, CarePlan, etc. which 
          --   is distinct from the &quot;request&quot; resource the task 
          --   is seeking to fulfil. This latter resource is referenced by 
          --   FocusOn. For example, based on a ProcedureRequest (= 
          --   BasedOn), a task is created to fulfil a procedureRequest ( 
          --   = FocusOn ) to collect a specimen from a patient.
        , task_groupIdentifier :: Maybe Identifier
          -- ^ An identifier that links together multiple tasks and other 
          --   requests that were created in the same context.
        , task_partOf :: [Reference]
          -- ^ Task that this particular task is part of.
        , task_status :: TaskStatus
          -- ^ The current status of the task.
        , task_statusReason :: Maybe CodeableConcept
          -- ^ An explanation as to why this task is held, failed, was 
          --   refused, etc.
        , task_businessStatus :: Maybe CodeableConcept
          -- ^ Contains business-specific nuances of the business state.
        , task_intent :: RequestIntent
          -- ^ Indicates the &quot;level&quot; of actionability associated 
          --   with the Task. I.e. Is this a proposed task, a planned 
          --   task, an actionable task, etc.
        , task_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the Task should be addressed with 
          --   respect to other requests.
        , task_code :: Maybe CodeableConcept
          -- ^ A name or code (or both) briefly describing what the task 
          --   involves.
        , task_description :: Maybe Xsd.XsdString
          -- ^ A free-text description of what is to be performed.
        , task_focus :: Maybe Reference
          -- ^ The request being actioned or the resource being 
          --   manipulated by this task.
        , task_for :: Maybe Reference
          -- ^ The entity who benefits from the performance of the service 
          --   specified in the task (e.g., the patient).
        , task_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) during which this task was created.
        , task_executionPeriod :: Maybe Period
          -- ^ Identifies the time action was first taken against the task 
          --   (start) and/or the time final action was taken against the 
          --   task prior to marking it as completed (end).
        , task_authoredOn :: Maybe DateTime
          -- ^ The date and time this task was created.
        , task_lastModified :: Maybe DateTime
          -- ^ The date and time of last modification to this task.
        , task_requester :: Maybe Task'Requester
          -- ^ The creator of the task.
        , task_performerType :: [CodeableConcept]
          -- ^ The type of participant that can execute the task.
        , task_owner :: Maybe Reference
          -- ^ Individual organization or Device currently responsible for 
          --   task execution.
        , task_reason :: Maybe CodeableConcept
          -- ^ A description or code indicating why this task needs to be 
          --   performed.
        , task_note :: [Annotation]
          -- ^ Free-text information captured about the task as it 
          --   progresses.
        , task_relevantHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this Task 
          --   that identify key state transitions or updates that are 
          --   likely to be relevant to a user looking at the current 
          --   version of the task.
        , task_restriction :: Maybe Task'Restriction
          -- ^ If the Task.focus is a request resource and the task is 
          --   seeking fulfillment (i.e is asking for the request to be 
          --   actioned), this element identifies any limitations on what 
          --   parts of the referenced request should be actioned.
        , task_input :: [Task'Input]
          -- ^ Additional information that may be needed in the execution 
          --   of the task.
        , task_output :: [Task'Output]
          -- ^ Outputs produced by the Task.
        }
        deriving (Eq,Show)
instance SchemaType Task where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Task
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "definitionUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "definitionReference"))
                                     ])
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "businessStatus")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "focus")
            `apply` optional (parseSchemaType "for")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "executionPeriod")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "lastModified")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "owner")
            `apply` optional (parseSchemaType "reason")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
            `apply` optional (parseSchemaType "restriction")
            `apply` many (parseSchemaType "input")
            `apply` many (parseSchemaType "output")
    schemaTypeToXML s x@Task{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ task_id x
            , maybe [] (schemaTypeToXML "meta") $ task_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ task_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ task_language x
            , maybe [] (schemaTypeToXML "text") $ task_text x
            , concatMap (schemaTypeToXML "contained") $ task_contained x
            , concatMap (schemaTypeToXML "extension") $ task_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ task_identifier x
            , maybe [] (foldOneOf2  (schemaTypeToXML "definitionUri")
                                    (schemaTypeToXML "definitionReference")
                                   ) $ task_choice9 x
            , concatMap (schemaTypeToXML "basedOn") $ task_basedOn x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ task_groupIdentifier x
            , concatMap (schemaTypeToXML "partOf") $ task_partOf x
            , schemaTypeToXML "status" $ task_status x
            , maybe [] (schemaTypeToXML "statusReason") $ task_statusReason x
            , maybe [] (schemaTypeToXML "businessStatus") $ task_businessStatus x
            , schemaTypeToXML "intent" $ task_intent x
            , maybe [] (schemaTypeToXML "priority") $ task_priority x
            , maybe [] (schemaTypeToXML "code") $ task_code x
            , maybe [] (schemaTypeToXML "description") $ task_description x
            , maybe [] (schemaTypeToXML "focus") $ task_focus x
            , maybe [] (schemaTypeToXML "for") $ task_for x
            , maybe [] (schemaTypeToXML "context") $ task_context x
            , maybe [] (schemaTypeToXML "executionPeriod") $ task_executionPeriod x
            , maybe [] (schemaTypeToXML "authoredOn") $ task_authoredOn x
            , maybe [] (schemaTypeToXML "lastModified") $ task_lastModified x
            , maybe [] (schemaTypeToXML "requester") $ task_requester x
            , concatMap (schemaTypeToXML "performerType") $ task_performerType x
            , maybe [] (schemaTypeToXML "owner") $ task_owner x
            , maybe [] (schemaTypeToXML "reason") $ task_reason x
            , concatMap (schemaTypeToXML "note") $ task_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ task_relevantHistory x
            , maybe [] (schemaTypeToXML "restriction") $ task_restriction x
            , concatMap (schemaTypeToXML "input") $ task_input x
            , concatMap (schemaTypeToXML "output") $ task_output x
            ]
instance Extension Task DomainResource where
    supertype (Task e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Task Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Task -> DomainResource)
              
 
-- | A task to be performed.
data Task'Requester = Task'Requester
        { task'Requester_id :: Maybe String'primitive
        , task'Requester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task'Requester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task'Requester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the task.
        , task'Requester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of when they initiated the task.
        }
        deriving (Eq,Show)
instance SchemaType Task'Requester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Task'Requester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@Task'Requester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ task'Requester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ task'Requester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task'Requester_modifierExtension x
            , schemaTypeToXML "agent" $ task'Requester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ task'Requester_onBehalfOf x
            ]
instance Extension Task'Requester BackboneElement where
    supertype (Task'Requester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Task'Requester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Task'Requester -> BackboneElement)
              
 
-- | A task to be performed.
data Task'Restriction = Task'Restriction
        { task'Restriction_id :: Maybe String'primitive
        , task'Restriction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task'Restriction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task'Restriction_repetitions :: Maybe PositiveInt
          -- ^ Indicates the number of times the requested action should 
          --   occur.
        , task'Restriction_period :: Maybe Period
          -- ^ Over what time-period is fulfillment sought.
        , task'Restriction_recipient :: [Reference]
          -- ^ For requests that are targeted to more than on potential 
          --   recipient/target, for whom is fulfillment sought?
        }
        deriving (Eq,Show)
instance SchemaType Task'Restriction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Task'Restriction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "repetitions")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "recipient")
    schemaTypeToXML s x@Task'Restriction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ task'Restriction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ task'Restriction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task'Restriction_modifierExtension x
            , maybe [] (schemaTypeToXML "repetitions") $ task'Restriction_repetitions x
            , maybe [] (schemaTypeToXML "period") $ task'Restriction_period x
            , concatMap (schemaTypeToXML "recipient") $ task'Restriction_recipient x
            ]
instance Extension Task'Restriction BackboneElement where
    supertype (Task'Restriction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension Task'Restriction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Task'Restriction -> BackboneElement)
              
 
-- | A task to be performed.
data Task'Input = Task'Input
        { task'Input_id :: Maybe String'primitive
        , task'Input_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task'Input_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task'Input_type :: CodeableConcept
          -- ^ A code or description indicating how the input is intended 
          --   to be used as part of the task execution.
        , task'Input_choice3 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The value of the input parameter as a basic type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType Task'Input where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Task'Input a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@Task'Input{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ task'Input_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ task'Input_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task'Input_modifierExtension x
            , schemaTypeToXML "type" $ task'Input_type x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ task'Input_choice3 x
            ]
instance Extension Task'Input BackboneElement where
    supertype (Task'Input a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Task'Input Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Task'Input -> BackboneElement)
              
 
-- | A task to be performed.
data Task'Output = Task'Output
        { task'Output_id :: Maybe String'primitive
        , task'Output_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task'Output_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task'Output_type :: CodeableConcept
          -- ^ The name of the Output parameter.
        , task'Output_choice3 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The value of the Output parameter as a basic type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType Task'Output where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Task'Output a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@Task'Output{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ task'Output_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ task'Output_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task'Output_modifierExtension x
            , schemaTypeToXML "type" $ task'Output_type x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ task'Output_choice3 x
            ]
instance Extension Task'Output BackboneElement where
    supertype (Task'Output a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension Task'Output Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: Task'Output -> BackboneElement)
              
 
data TaskStatus'list
    = TaskStatus'list_Draft
      -- ^ Draft
    | TaskStatus'list_Requested
      -- ^ Requested
    | TaskStatus'list_Received
      -- ^ Received
    | TaskStatus'list_Accepted
      -- ^ Accepted
    | TaskStatus'list_Rejected
      -- ^ Rejected
    | TaskStatus'list_Ready
      -- ^ Ready
    | TaskStatus'list_Cancelled
      -- ^ Cancelled
    | TaskStatus'list_In'progress
      -- ^ In Progress
    | TaskStatus'list_On'hold
      -- ^ On Hold
    | TaskStatus'list_Failed
      -- ^ Failed
    | TaskStatus'list_Completed
      -- ^ Completed
    | TaskStatus'list_Entered'in'error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType TaskStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TaskStatus'list where
    acceptingParser =  do literal "draft"; return TaskStatus'list_Draft
                      `onFail` do literal "requested"; return TaskStatus'list_Requested
                      `onFail` do literal "received"; return TaskStatus'list_Received
                      `onFail` do literal "accepted"; return TaskStatus'list_Accepted
                      `onFail` do literal "rejected"; return TaskStatus'list_Rejected
                      `onFail` do literal "ready"; return TaskStatus'list_Ready
                      `onFail` do literal "cancelled"; return TaskStatus'list_Cancelled
                      `onFail` do literal "in-progress"; return TaskStatus'list_In'progress
                      `onFail` do literal "on-hold"; return TaskStatus'list_On'hold
                      `onFail` do literal "failed"; return TaskStatus'list_Failed
                      `onFail` do literal "completed"; return TaskStatus'list_Completed
                      `onFail` do literal "entered-in-error"; return TaskStatus'list_Entered'in'error
                      
    simpleTypeText TaskStatus'list_Draft = "draft"
    simpleTypeText TaskStatus'list_Requested = "requested"
    simpleTypeText TaskStatus'list_Received = "received"
    simpleTypeText TaskStatus'list_Accepted = "accepted"
    simpleTypeText TaskStatus'list_Rejected = "rejected"
    simpleTypeText TaskStatus'list_Ready = "ready"
    simpleTypeText TaskStatus'list_Cancelled = "cancelled"
    simpleTypeText TaskStatus'list_In'progress = "in-progress"
    simpleTypeText TaskStatus'list_On'hold = "on-hold"
    simpleTypeText TaskStatus'list_Failed = "failed"
    simpleTypeText TaskStatus'list_Completed = "completed"
    simpleTypeText TaskStatus'list_Entered'in'error = "entered-in-error"
 
data TaskStatus = TaskStatus
        { taskStatus_id :: Maybe String'primitive
        , taskStatus_value :: Maybe TaskStatus'list
        , taskStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TaskStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TaskStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TaskStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskStatus_id x
                       , maybe [] (toXMLAttribute "value") $ taskStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskStatus_extension x
            ]
instance Extension TaskStatus Element where
    supertype (TaskStatus a0 a1 e0) =
               Element a0 e0
 
-- | A summary of information based on the results of executing 
--   a TestScript.
elementTestReport :: XMLParser TestReport
elementTestReport = parseSchemaType "TestReport"
elementToXMLTestReport :: TestReport -> [Content ()]
elementToXMLTestReport = schemaTypeToXML "TestReport"
 
data TestReport = TestReport
        { testReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , testReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , testReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , testReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , testReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , testReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , testReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport_identifier :: Maybe Identifier
          -- ^ Identifier for the TestScript assigned for external 
          --   purposes outside the context of FHIR.
        , testReport_name :: Maybe Xsd.XsdString
          -- ^ A free text natural language name identifying the executed 
          --   TestScript.
        , testReport_status :: TestReportStatus
          -- ^ The current state of this test report.
        , testReport_testScript :: Reference
          -- ^ Ideally this is an absolute URL that is used to identify 
          --   the version-specific TestScript that was executed, matching 
          --   the `TestScript.url`.
        , testReport_result :: TestReportResult
          -- ^ The overall result from the execution of the TestScript.
        , testReport_score :: Maybe Decimal
          -- ^ The final score (percentage of tests passed) resulting from 
          --   the execution of the TestScript.
        , testReport_tester :: Maybe Xsd.XsdString
          -- ^ Name of the tester producing this report (Organization or 
          --   individual).
        , testReport_issued :: Maybe DateTime
          -- ^ When the TestScript was executed and this TestReport was 
          --   generated.
        , testReport_participant :: [TestReport'Participant]
          -- ^ A participant in the test execution, either the execution 
          --   engine, a client, or a server.
        , testReport_setup :: Maybe TestReport'Setup
          -- ^ The results of the series of required setup operations 
          --   before the tests were executed.
        , testReport_test :: [TestReport'Test]
          -- ^ A test executed from the test script.
        , testReport_teardown :: Maybe TestReport'Teardown
          -- ^ The results of the series of operations required to clean 
          --   up after the all the tests were executed (successfully or 
          --   otherwise).
        }
        deriving (Eq,Show)
instance SchemaType TestReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return TestReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "testScript"
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "score")
            `apply` optional (parseSchemaType "tester")
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "setup")
            `apply` many (parseSchemaType "test")
            `apply` optional (parseSchemaType "teardown")
    schemaTypeToXML s x@TestReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ testReport_id x
            , maybe [] (schemaTypeToXML "meta") $ testReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ testReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ testReport_language x
            , maybe [] (schemaTypeToXML "text") $ testReport_text x
            , concatMap (schemaTypeToXML "contained") $ testReport_contained x
            , concatMap (schemaTypeToXML "extension") $ testReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ testReport_identifier x
            , maybe [] (schemaTypeToXML "name") $ testReport_name x
            , schemaTypeToXML "status" $ testReport_status x
            , schemaTypeToXML "testScript" $ testReport_testScript x
            , schemaTypeToXML "result" $ testReport_result x
            , maybe [] (schemaTypeToXML "score") $ testReport_score x
            , maybe [] (schemaTypeToXML "tester") $ testReport_tester x
            , maybe [] (schemaTypeToXML "issued") $ testReport_issued x
            , concatMap (schemaTypeToXML "participant") $ testReport_participant x
            , maybe [] (schemaTypeToXML "setup") $ testReport_setup x
            , concatMap (schemaTypeToXML "test") $ testReport_test x
            , maybe [] (schemaTypeToXML "teardown") $ testReport_teardown x
            ]
instance Extension TestReport DomainResource where
    supertype (TestReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension TestReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: TestReport -> DomainResource)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Participant = TestReport'Participant
        { testReport'Participant_id :: Maybe String'primitive
        , testReport'Participant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Participant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Participant_type :: TestReportParticipantType
          -- ^ The type of participant.
        , testReport'Participant_uri :: Uri
          -- ^ The uri of the participant. An absolute URL is preferred.
        , testReport'Participant_display :: Maybe Xsd.XsdString
          -- ^ The display name of the participant.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Participant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Participant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "uri"
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@TestReport'Participant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Participant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Participant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Participant_modifierExtension x
            , schemaTypeToXML "type" $ testReport'Participant_type x
            , schemaTypeToXML "uri" $ testReport'Participant_uri x
            , maybe [] (schemaTypeToXML "display") $ testReport'Participant_display x
            ]
instance Extension TestReport'Participant BackboneElement where
    supertype (TestReport'Participant a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Participant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Participant -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Setup = TestReport'Setup
        { testReport'Setup_id :: Maybe String'primitive
        , testReport'Setup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Setup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Setup_action :: [TestReport'Action]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Setup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Setup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReport'Setup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Setup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Setup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Setup_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testReport'Setup_action x
            ]
instance Extension TestReport'Setup BackboneElement where
    supertype (TestReport'Setup a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Setup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Setup -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Action = TestReport'Action
        { testReport'Action_id :: Maybe String'primitive
        , testReport'Action_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Action_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Action_operation :: Maybe TestReport'Operation
          -- ^ The operation performed.
        , testReport'Action_assert :: Maybe TestReport'Assert
          -- ^ The results of the assertion performed on the previous 
          --   operations.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Action where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Action a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestReport'Action{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Action_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Action_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Action_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testReport'Action_operation x
            , maybe [] (schemaTypeToXML "assert") $ testReport'Action_assert x
            ]
instance Extension TestReport'Action BackboneElement where
    supertype (TestReport'Action a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Action Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Action -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Operation = TestReport'Operation
        { testReport'Operation_id :: Maybe String'primitive
        , testReport'Operation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Operation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Operation_result :: TestReportActionResult
          -- ^ The result of this operation.
        , testReport'Operation_message :: Maybe Markdown
          -- ^ An explanatory message associated with the result.
        , testReport'Operation_detail :: Maybe Uri
          -- ^ A link to further details on the result.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Operation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Operation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "message")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@TestReport'Operation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Operation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Operation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Operation_modifierExtension x
            , schemaTypeToXML "result" $ testReport'Operation_result x
            , maybe [] (schemaTypeToXML "message") $ testReport'Operation_message x
            , maybe [] (schemaTypeToXML "detail") $ testReport'Operation_detail x
            ]
instance Extension TestReport'Operation BackboneElement where
    supertype (TestReport'Operation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Operation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Operation -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Assert = TestReport'Assert
        { testReport'Assert_id :: Maybe String'primitive
        , testReport'Assert_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Assert_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Assert_result :: TestReportActionResult
          -- ^ The result of this assertion.
        , testReport'Assert_message :: Maybe Markdown
          -- ^ An explanatory message associated with the result.
        , testReport'Assert_detail :: Maybe Xsd.XsdString
          -- ^ A link to further details on the result.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Assert where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Assert a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "message")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@TestReport'Assert{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Assert_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Assert_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Assert_modifierExtension x
            , schemaTypeToXML "result" $ testReport'Assert_result x
            , maybe [] (schemaTypeToXML "message") $ testReport'Assert_message x
            , maybe [] (schemaTypeToXML "detail") $ testReport'Assert_detail x
            ]
instance Extension TestReport'Assert BackboneElement where
    supertype (TestReport'Assert a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Assert Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Assert -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Test = TestReport'Test
        { testReport'Test_id :: Maybe String'primitive
        , testReport'Test_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Test_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Test_name :: Maybe Xsd.XsdString
          -- ^ The name of this test used for tracking/logging purposes by 
          --   test engines.
        , testReport'Test_description :: Maybe Xsd.XsdString
          -- ^ A short description of the test used by test engines for 
          --   tracking and reporting purposes.
        , testReport'Test_action :: [TestReport'Action1]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Test where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Test a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReport'Test{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Test_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Test_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Test_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ testReport'Test_name x
            , maybe [] (schemaTypeToXML "description") $ testReport'Test_description x
            , concatMap (schemaTypeToXML "action") $ testReport'Test_action x
            ]
instance Extension TestReport'Test BackboneElement where
    supertype (TestReport'Test a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Test Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Test -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Action1 = TestReport'Action1
        { testReport'Action1_id :: Maybe String'primitive
        , testReport'Action1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Action1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Action1_operation :: Maybe TestReport'Operation
          -- ^ An operation would involve a REST request to a server.
        , testReport'Action1_assert :: Maybe TestReport'Assert
          -- ^ The results of the assertion performed on the previous 
          --   operations.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Action1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Action1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestReport'Action1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Action1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Action1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Action1_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testReport'Action1_operation x
            , maybe [] (schemaTypeToXML "assert") $ testReport'Action1_assert x
            ]
instance Extension TestReport'Action1 BackboneElement where
    supertype (TestReport'Action1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Action1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Action1 -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Teardown = TestReport'Teardown
        { testReport'Teardown_id :: Maybe String'primitive
        , testReport'Teardown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Teardown_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Teardown_action :: [TestReport'Action2]
          -- ^ The teardown action will only contain an operation.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Teardown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Teardown a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReport'Teardown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Teardown_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Teardown_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Teardown_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testReport'Teardown_action x
            ]
instance Extension TestReport'Teardown BackboneElement where
    supertype (TestReport'Teardown a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Teardown Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Teardown -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReport'Action2 = TestReport'Action2
        { testReport'Action2_id :: Maybe String'primitive
        , testReport'Action2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport'Action2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport'Action2_operation :: TestReport'Operation
          -- ^ An operation would involve a REST request to a server.
        }
        deriving (Eq,Show)
instance SchemaType TestReport'Action2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReport'Action2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "operation"
    schemaTypeToXML s x@TestReport'Action2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReport'Action2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReport'Action2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport'Action2_modifierExtension x
            , schemaTypeToXML "operation" $ testReport'Action2_operation x
            ]
instance Extension TestReport'Action2 BackboneElement where
    supertype (TestReport'Action2 a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReport'Action2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReport'Action2 -> BackboneElement)
              
 
data TestReportStatus'list
    = TestReportStatus'list_Completed
      -- ^ Completed
    | TestReportStatus'list_In'progress
      -- ^ In Progress
    | TestReportStatus'list_Waiting
      -- ^ Waiting
    | TestReportStatus'list_Stopped
      -- ^ Stopped
    | TestReportStatus'list_Entered'in'error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType TestReportStatus'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportStatus'list where
    acceptingParser =  do literal "completed"; return TestReportStatus'list_Completed
                      `onFail` do literal "in-progress"; return TestReportStatus'list_In'progress
                      `onFail` do literal "waiting"; return TestReportStatus'list_Waiting
                      `onFail` do literal "stopped"; return TestReportStatus'list_Stopped
                      `onFail` do literal "entered-in-error"; return TestReportStatus'list_Entered'in'error
                      
    simpleTypeText TestReportStatus'list_Completed = "completed"
    simpleTypeText TestReportStatus'list_In'progress = "in-progress"
    simpleTypeText TestReportStatus'list_Waiting = "waiting"
    simpleTypeText TestReportStatus'list_Stopped = "stopped"
    simpleTypeText TestReportStatus'list_Entered'in'error = "entered-in-error"
 
data TestReportStatus = TestReportStatus
        { testReportStatus_id :: Maybe String'primitive
        , testReportStatus_value :: Maybe TestReportStatus'list
        , testReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ testReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportStatus_extension x
            ]
instance Extension TestReportStatus Element where
    supertype (TestReportStatus a0 a1 e0) =
               Element a0 e0
 
data TestReportActionResult'list
    = TestReportActionResult'list_Pass
      -- ^ Pass
    | TestReportActionResult'list_Skip
      -- ^ Skip
    | TestReportActionResult'list_Fail
      -- ^ Fail
    | TestReportActionResult'list_Warning
      -- ^ Warning
    | TestReportActionResult'list_Error
      -- ^ Error
    deriving (Eq,Show,Enum)
instance SchemaType TestReportActionResult'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportActionResult'list where
    acceptingParser =  do literal "pass"; return TestReportActionResult'list_Pass
                      `onFail` do literal "skip"; return TestReportActionResult'list_Skip
                      `onFail` do literal "fail"; return TestReportActionResult'list_Fail
                      `onFail` do literal "warning"; return TestReportActionResult'list_Warning
                      `onFail` do literal "error"; return TestReportActionResult'list_Error
                      
    simpleTypeText TestReportActionResult'list_Pass = "pass"
    simpleTypeText TestReportActionResult'list_Skip = "skip"
    simpleTypeText TestReportActionResult'list_Fail = "fail"
    simpleTypeText TestReportActionResult'list_Warning = "warning"
    simpleTypeText TestReportActionResult'list_Error = "error"
 
data TestReportActionResult = TestReportActionResult
        { testReportActionResult_id :: Maybe String'primitive
        , testReportActionResult_value :: Maybe TestReportActionResult'list
        , testReportActionResult_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportActionResult where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportActionResult a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportActionResult{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportActionResult_id x
                       , maybe [] (toXMLAttribute "value") $ testReportActionResult_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportActionResult_extension x
            ]
instance Extension TestReportActionResult Element where
    supertype (TestReportActionResult a0 a1 e0) =
               Element a0 e0
 
data TestReportParticipantType'list
    = TestReportParticipantType'list_Test'engine
      -- ^ Test Engine
    | TestReportParticipantType'list_Client
      -- ^ Client
    | TestReportParticipantType'list_Server
      -- ^ Server
    deriving (Eq,Show,Enum)
instance SchemaType TestReportParticipantType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportParticipantType'list where
    acceptingParser =  do literal "test-engine"; return TestReportParticipantType'list_Test'engine
                      `onFail` do literal "client"; return TestReportParticipantType'list_Client
                      `onFail` do literal "server"; return TestReportParticipantType'list_Server
                      
    simpleTypeText TestReportParticipantType'list_Test'engine = "test-engine"
    simpleTypeText TestReportParticipantType'list_Client = "client"
    simpleTypeText TestReportParticipantType'list_Server = "server"
 
data TestReportParticipantType = TestReportParticipantType
        { testReportParticipantType_id :: Maybe String'primitive
        , testReportParticipantType_value :: Maybe TestReportParticipantType'list
        , testReportParticipantType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportParticipantType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportParticipantType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportParticipantType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportParticipantType_id x
                       , maybe [] (toXMLAttribute "value") $ testReportParticipantType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportParticipantType_extension x
            ]
instance Extension TestReportParticipantType Element where
    supertype (TestReportParticipantType a0 a1 e0) =
               Element a0 e0
 
data TestReportResult'list
    = TestReportResult'list_Pass
      -- ^ Pass
    | TestReportResult'list_Fail
      -- ^ Fail
    | TestReportResult'list_Pending
      -- ^ Pending
    deriving (Eq,Show,Enum)
instance SchemaType TestReportResult'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportResult'list where
    acceptingParser =  do literal "pass"; return TestReportResult'list_Pass
                      `onFail` do literal "fail"; return TestReportResult'list_Fail
                      `onFail` do literal "pending"; return TestReportResult'list_Pending
                      
    simpleTypeText TestReportResult'list_Pass = "pass"
    simpleTypeText TestReportResult'list_Fail = "fail"
    simpleTypeText TestReportResult'list_Pending = "pending"
 
data TestReportResult = TestReportResult
        { testReportResult_id :: Maybe String'primitive
        , testReportResult_value :: Maybe TestReportResult'list
        , testReportResult_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportResult where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportResult a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportResult{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportResult_id x
                       , maybe [] (toXMLAttribute "value") $ testReportResult_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportResult_extension x
            ]
instance Extension TestReportResult Element where
    supertype (TestReportResult a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
elementTestScript :: XMLParser TestScript
elementTestScript = parseSchemaType "TestScript"
elementToXMLTestScript :: TestScript -> [Content ()]
elementToXMLTestScript = schemaTypeToXML "TestScript"
 
data TestScript = TestScript
        { testScript_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , testScript_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , testScript_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , testScript_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , testScript_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , testScript_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , testScript_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript_url :: Uri
          -- ^ An absolute URI that is used to identify this test script 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this test script 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the test script. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , testScript_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this test 
          --   script when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , testScript_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   test script when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the test script author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , testScript_name :: Xsd.XsdString
          -- ^ A natural language name identifying the test script. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , testScript_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the test 
          --   script.
        , testScript_status :: PublicationStatus
          -- ^ The status of this test script. Enables tracking the 
          --   life-cycle of the content.
        , testScript_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this test script is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , testScript_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the test script was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the test script changes.
        , testScript_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the test script.
        , testScript_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , testScript_description :: Maybe Markdown
          -- ^ A free text natural language description of the test script 
          --   from a consumer's perspective.
        , testScript_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   test script instances.
        , testScript_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the test script is 
          --   intended to be used.
        , testScript_purpose :: Maybe Markdown
          -- ^ Explaination of why this test script is needed and why it 
          --   has been designed as it has.
        , testScript_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the test script and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the test script.
        , testScript_origin :: [TestScript'Origin]
          -- ^ An abstract server used in operations within this test 
          --   script in the origin element.
        , testScript_destination :: [TestScript'Destination]
          -- ^ An abstract server used in operations within this test 
          --   script in the destination element.
        , testScript_metadata :: Maybe TestScript'Metadata
          -- ^ The required capability must exist and are assumed to 
          --   function correctly on the FHIR server being tested.
        , testScript_fixture :: [TestScript'Fixture]
          -- ^ Fixture in the test script - by reference (uri). All 
          --   fixtures are required for the test script to execute.
        , testScript_profile :: [Reference]
          -- ^ Reference to the profile to be used for validation.
        , testScript_variable :: [TestScript'Variable]
          -- ^ Variable is set based either on element value in response 
          --   body or on header field value in the response headers.
        , testScript_rule :: [TestScript'Rule]
          -- ^ Assert rule to be used in one or more asserts within the 
          --   test script.
        , testScript_ruleset :: [TestScript'Ruleset]
          -- ^ Contains one or more rules. Offers a way to group rules so 
          --   assertions could reference the group of rules and have them 
          --   all applied.
        , testScript_setup :: Maybe TestScript'Setup
          -- ^ A series of required setup operations before tests are 
          --   executed.
        , testScript_test :: [TestScript'Test]
          -- ^ A test in this script.
        , testScript_teardown :: Maybe TestScript'Teardown
          -- ^ A series of operations required to clean up after the all 
          --   the tests are executed (successfully or otherwise).
        }
        deriving (Eq,Show)
instance SchemaType TestScript where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return TestScript
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "origin")
            `apply` many (parseSchemaType "destination")
            `apply` optional (parseSchemaType "metadata")
            `apply` many (parseSchemaType "fixture")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "variable")
            `apply` many (parseSchemaType "rule")
            `apply` many (parseSchemaType "ruleset")
            `apply` optional (parseSchemaType "setup")
            `apply` many (parseSchemaType "test")
            `apply` optional (parseSchemaType "teardown")
    schemaTypeToXML s x@TestScript{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ testScript_id x
            , maybe [] (schemaTypeToXML "meta") $ testScript_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ testScript_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ testScript_language x
            , maybe [] (schemaTypeToXML "text") $ testScript_text x
            , concatMap (schemaTypeToXML "contained") $ testScript_contained x
            , concatMap (schemaTypeToXML "extension") $ testScript_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript_modifierExtension x
            , schemaTypeToXML "url" $ testScript_url x
            , maybe [] (schemaTypeToXML "identifier") $ testScript_identifier x
            , maybe [] (schemaTypeToXML "version") $ testScript_version x
            , schemaTypeToXML "name" $ testScript_name x
            , maybe [] (schemaTypeToXML "title") $ testScript_title x
            , schemaTypeToXML "status" $ testScript_status x
            , maybe [] (schemaTypeToXML "experimental") $ testScript_experimental x
            , maybe [] (schemaTypeToXML "date") $ testScript_date x
            , maybe [] (schemaTypeToXML "publisher") $ testScript_publisher x
            , concatMap (schemaTypeToXML "contact") $ testScript_contact x
            , maybe [] (schemaTypeToXML "description") $ testScript_description x
            , concatMap (schemaTypeToXML "useContext") $ testScript_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ testScript_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ testScript_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ testScript_copyright x
            , concatMap (schemaTypeToXML "origin") $ testScript_origin x
            , concatMap (schemaTypeToXML "destination") $ testScript_destination x
            , maybe [] (schemaTypeToXML "metadata") $ testScript_metadata x
            , concatMap (schemaTypeToXML "fixture") $ testScript_fixture x
            , concatMap (schemaTypeToXML "profile") $ testScript_profile x
            , concatMap (schemaTypeToXML "variable") $ testScript_variable x
            , concatMap (schemaTypeToXML "rule") $ testScript_rule x
            , concatMap (schemaTypeToXML "ruleset") $ testScript_ruleset x
            , maybe [] (schemaTypeToXML "setup") $ testScript_setup x
            , concatMap (schemaTypeToXML "test") $ testScript_test x
            , maybe [] (schemaTypeToXML "teardown") $ testScript_teardown x
            ]
instance Extension TestScript DomainResource where
    supertype (TestScript e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension TestScript Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: TestScript -> DomainResource)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Origin = TestScript'Origin
        { testScript'Origin_id :: Maybe String'primitive
        , testScript'Origin_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Origin_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Origin_index :: Integer
          -- ^ Abstract name given to an origin server in this test 
          --   script. The name is provided as a number starting at 1.
        , testScript'Origin_profile :: Coding
          -- ^ The type of origin profile the test system supports.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Origin where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Origin a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "index"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@TestScript'Origin{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Origin_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Origin_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Origin_modifierExtension x
            , schemaTypeToXML "index" $ testScript'Origin_index x
            , schemaTypeToXML "profile" $ testScript'Origin_profile x
            ]
instance Extension TestScript'Origin BackboneElement where
    supertype (TestScript'Origin a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Origin Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Origin -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Destination = TestScript'Destination
        { testScript'Destination_id :: Maybe String'primitive
        , testScript'Destination_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Destination_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Destination_index :: Integer
          -- ^ Abstract name given to a destination server in this test 
          --   script. The name is provided as a number starting at 1.
        , testScript'Destination_profile :: Coding
          -- ^ The type of destination profile the test system supports.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Destination where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Destination a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "index"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@TestScript'Destination{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Destination_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Destination_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Destination_modifierExtension x
            , schemaTypeToXML "index" $ testScript'Destination_index x
            , schemaTypeToXML "profile" $ testScript'Destination_profile x
            ]
instance Extension TestScript'Destination BackboneElement where
    supertype (TestScript'Destination a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Destination Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Destination -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Metadata = TestScript'Metadata
        { testScript'Metadata_id :: Maybe String'primitive
        , testScript'Metadata_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Metadata_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Metadata_link :: [TestScript'Link]
          -- ^ A link to the FHIR specification that this test is 
          --   covering.
        , testScript'Metadata_capability :: [TestScript'Capability]
          -- ^ Capabilities that must exist and are assumed to function 
          --   correctly on the FHIR server being tested.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Metadata where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Metadata a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "link")
            `apply` many1 (parseSchemaType "capability")
    schemaTypeToXML s x@TestScript'Metadata{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Metadata_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Metadata_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Metadata_modifierExtension x
            , concatMap (schemaTypeToXML "link") $ testScript'Metadata_link x
            , concatMap (schemaTypeToXML "capability") $ testScript'Metadata_capability x
            ]
instance Extension TestScript'Metadata BackboneElement where
    supertype (TestScript'Metadata a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Metadata Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Metadata -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Link = TestScript'Link
        { testScript'Link_id :: Maybe String'primitive
        , testScript'Link_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Link_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Link_url :: Uri
          -- ^ URL to a particular requirement or feature within the FHIR 
          --   specification.
        , testScript'Link_description :: Maybe Xsd.XsdString
          -- ^ Short description of the link.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Link where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Link a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@TestScript'Link{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Link_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Link_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Link_modifierExtension x
            , schemaTypeToXML "url" $ testScript'Link_url x
            , maybe [] (schemaTypeToXML "description") $ testScript'Link_description x
            ]
instance Extension TestScript'Link BackboneElement where
    supertype (TestScript'Link a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Link Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Link -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Capability = TestScript'Capability
        { testScript'Capability_id :: Maybe String'primitive
        , testScript'Capability_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Capability_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Capability_required :: Maybe Boolean
          -- ^ Whether or not the test execution will require the given 
          --   capabilities of the server in order for this test script to 
          --   execute.
        , testScript'Capability_validated :: Maybe Boolean
          -- ^ Whether or not the test execution will validate the given 
          --   capabilities of the server in order for this test script to 
          --   execute.
        , testScript'Capability_description :: Maybe Xsd.XsdString
          -- ^ Description of the capabilities that this test script is 
          --   requiring the server to support.
        , testScript'Capability_origin :: [Integer]
          -- ^ Which origin server these requirements apply to.
        , testScript'Capability_destination :: Maybe Integer
          -- ^ Which server these requirements apply to.
        , testScript'Capability_link :: [Uri]
          -- ^ Links to the FHIR specification that describes this 
          --   interaction and the resources involved in more detail.
        , testScript'Capability_capabilities :: Reference
          -- ^ Minimum capabilities required of server for test script to 
          --   execute successfully. If server does not meet at a minimum 
          --   the referenced capability statement, then all tests in this 
          --   script are skipped.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Capability where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Capability a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "required")
            `apply` optional (parseSchemaType "validated")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "origin")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "link")
            `apply` parseSchemaType "capabilities"
    schemaTypeToXML s x@TestScript'Capability{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Capability_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Capability_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Capability_modifierExtension x
            , maybe [] (schemaTypeToXML "required") $ testScript'Capability_required x
            , maybe [] (schemaTypeToXML "validated") $ testScript'Capability_validated x
            , maybe [] (schemaTypeToXML "description") $ testScript'Capability_description x
            , concatMap (schemaTypeToXML "origin") $ testScript'Capability_origin x
            , maybe [] (schemaTypeToXML "destination") $ testScript'Capability_destination x
            , concatMap (schemaTypeToXML "link") $ testScript'Capability_link x
            , schemaTypeToXML "capabilities" $ testScript'Capability_capabilities x
            ]
instance Extension TestScript'Capability BackboneElement where
    supertype (TestScript'Capability a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Capability Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Capability -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Fixture = TestScript'Fixture
        { testScript'Fixture_id :: Maybe String'primitive
        , testScript'Fixture_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Fixture_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Fixture_autocreate :: Maybe Boolean
          -- ^ Whether or not to implicitly create the fixture during 
          --   setup. If true, the fixture is automatically created on 
          --   each server being tested during setup, therefore no create 
          --   operation is required for this fixture in the 
          --   TestScript.setup section.
        , testScript'Fixture_autodelete :: Maybe Boolean
          -- ^ Whether or not to implicitly delete the fixture during 
          --   teardown. If true, the fixture is automatically deleted on 
          --   each server being tested during teardown, therefore no 
          --   delete operation is required for this fixture in the 
          --   TestScript.teardown section.
        , testScript'Fixture_resource :: Maybe Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   resource needed for operations).
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Fixture where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Fixture a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "autocreate")
            `apply` optional (parseSchemaType "autodelete")
            `apply` optional (parseSchemaType "resource")
    schemaTypeToXML s x@TestScript'Fixture{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Fixture_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Fixture_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Fixture_modifierExtension x
            , maybe [] (schemaTypeToXML "autocreate") $ testScript'Fixture_autocreate x
            , maybe [] (schemaTypeToXML "autodelete") $ testScript'Fixture_autodelete x
            , maybe [] (schemaTypeToXML "resource") $ testScript'Fixture_resource x
            ]
instance Extension TestScript'Fixture BackboneElement where
    supertype (TestScript'Fixture a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Fixture Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Fixture -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Variable = TestScript'Variable
        { testScript'Variable_id :: Maybe String'primitive
        , testScript'Variable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Variable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Variable_name :: Xsd.XsdString
          -- ^ Descriptive name for this variable.
        , testScript'Variable_defaultValue :: Maybe Xsd.XsdString
          -- ^ A default, hard-coded, or user-defined value for this 
          --   variable.
        , testScript'Variable_description :: Maybe Xsd.XsdString
          -- ^ A free text natural language description of the variable 
          --   and its purpose.
        , testScript'Variable_expression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to evaluate against the fixture 
          --   body. When variables are defined, only one of either 
          --   expression, headerField or path must be specified.
        , testScript'Variable_headerField :: Maybe Xsd.XsdString
          -- ^ Will be used to grab the HTTP header field value from the 
          --   headers that sourceId is pointing to.
        , testScript'Variable_hint :: Maybe Xsd.XsdString
          -- ^ Displayable text string with hint help information to the 
          --   user when entering a default value.
        , testScript'Variable_path :: Maybe Xsd.XsdString
          -- ^ XPath or JSONPath to evaluate against the fixture body. 
          --   When variables are defined, only one of either expression, 
          --   headerField or path must be specified.
        , testScript'Variable_sourceId :: Maybe Id
          -- ^ Fixture to evaluate the XPath/JSONPath expression or the 
          --   headerField against within this variable.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Variable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Variable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "defaultValue")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "headerField")
            `apply` optional (parseSchemaType "hint")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "sourceId")
    schemaTypeToXML s x@TestScript'Variable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Variable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Variable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Variable_modifierExtension x
            , schemaTypeToXML "name" $ testScript'Variable_name x
            , maybe [] (schemaTypeToXML "defaultValue") $ testScript'Variable_defaultValue x
            , maybe [] (schemaTypeToXML "description") $ testScript'Variable_description x
            , maybe [] (schemaTypeToXML "expression") $ testScript'Variable_expression x
            , maybe [] (schemaTypeToXML "headerField") $ testScript'Variable_headerField x
            , maybe [] (schemaTypeToXML "hint") $ testScript'Variable_hint x
            , maybe [] (schemaTypeToXML "path") $ testScript'Variable_path x
            , maybe [] (schemaTypeToXML "sourceId") $ testScript'Variable_sourceId x
            ]
instance Extension TestScript'Variable BackboneElement where
    supertype (TestScript'Variable a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Variable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Variable -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Rule = TestScript'Rule
        { testScript'Rule_id :: Maybe String'primitive
        , testScript'Rule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Rule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Rule_resource :: Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   rule needed for assertions).
        , testScript'Rule_param :: [TestScript'Param]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Rule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Rule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "resource"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScript'Rule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Rule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Rule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Rule_modifierExtension x
            , schemaTypeToXML "resource" $ testScript'Rule_resource x
            , concatMap (schemaTypeToXML "param") $ testScript'Rule_param x
            ]
instance Extension TestScript'Rule BackboneElement where
    supertype (TestScript'Rule a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Rule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Rule -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Param = TestScript'Param
        { testScript'Param_id :: Maybe String'primitive
        , testScript'Param_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Param_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Param_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert rule parameter name.
        , testScript'Param_value :: Maybe Xsd.XsdString
          -- ^ The explicit or dynamic value for the parameter that will 
          --   be passed on to the external rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Param where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Param a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@TestScript'Param{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Param_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Param_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Param_modifierExtension x
            , schemaTypeToXML "name" $ testScript'Param_name x
            , maybe [] (schemaTypeToXML "value") $ testScript'Param_value x
            ]
instance Extension TestScript'Param BackboneElement where
    supertype (TestScript'Param a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Param Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Param -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Ruleset = TestScript'Ruleset
        { testScript'Ruleset_id :: Maybe String'primitive
        , testScript'Ruleset_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Ruleset_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Ruleset_resource :: Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   ruleset needed for assertions).
        , testScript'Ruleset_rule :: [TestScript'Rule1]
          -- ^ The referenced rule within the external ruleset template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Ruleset where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Ruleset a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "resource"
            `apply` many1 (parseSchemaType "rule")
    schemaTypeToXML s x@TestScript'Ruleset{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Ruleset_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Ruleset_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Ruleset_modifierExtension x
            , schemaTypeToXML "resource" $ testScript'Ruleset_resource x
            , concatMap (schemaTypeToXML "rule") $ testScript'Ruleset_rule x
            ]
instance Extension TestScript'Ruleset BackboneElement where
    supertype (TestScript'Ruleset a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Ruleset Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Ruleset -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Rule1 = TestScript'Rule1
        { testScript'Rule1_id :: Maybe String'primitive
        , testScript'Rule1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Rule1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Rule1_ruleId :: Id
          -- ^ Id of the referenced rule within the external ruleset 
          --   template.
        , testScript'Rule1_param :: [TestScript'Param1]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Rule1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Rule1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScript'Rule1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Rule1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Rule1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Rule1_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScript'Rule1_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScript'Rule1_param x
            ]
instance Extension TestScript'Rule1 BackboneElement where
    supertype (TestScript'Rule1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Rule1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Rule1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Param1 = TestScript'Param1
        { testScript'Param1_id :: Maybe String'primitive
        , testScript'Param1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Param1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Param1_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert ruleset rule parameter name.
        , testScript'Param1_value :: Maybe Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external ruleset rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Param1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Param1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@TestScript'Param1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Param1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Param1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Param1_modifierExtension x
            , schemaTypeToXML "name" $ testScript'Param1_name x
            , maybe [] (schemaTypeToXML "value") $ testScript'Param1_value x
            ]
instance Extension TestScript'Param1 BackboneElement where
    supertype (TestScript'Param1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Param1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Param1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Setup = TestScript'Setup
        { testScript'Setup_id :: Maybe String'primitive
        , testScript'Setup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Setup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Setup_action :: [TestScript'Action]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Setup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Setup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScript'Setup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Setup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Setup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Setup_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testScript'Setup_action x
            ]
instance Extension TestScript'Setup BackboneElement where
    supertype (TestScript'Setup a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Setup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Setup -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Action = TestScript'Action
        { testScript'Action_id :: Maybe String'primitive
        , testScript'Action_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Action_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Action_operation :: Maybe TestScript'Operation
          -- ^ The operation to perform.
        , testScript'Action_assert :: Maybe TestScript'Assert
          -- ^ Evaluates the results of previous operations to determine 
          --   if the server under test behaves appropriately.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Action where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Action a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestScript'Action{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Action_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Action_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Action_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testScript'Action_operation x
            , maybe [] (schemaTypeToXML "assert") $ testScript'Action_assert x
            ]
instance Extension TestScript'Action BackboneElement where
    supertype (TestScript'Action a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Action Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Action -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Operation = TestScript'Operation
        { testScript'Operation_id :: Maybe String'primitive
        , testScript'Operation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Operation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Operation_type :: Maybe Coding
          -- ^ Server interaction or operation type.
        , testScript'Operation_resource :: Maybe FHIRDefinedType
          -- ^ The type of the resource. See 
          --   http://hl7.org/fhir/resourcelist.html.
        , testScript'Operation_label :: Maybe Xsd.XsdString
          -- ^ The label would be used for tracking/logging purposes by 
          --   test engines.
        , testScript'Operation_description :: Maybe Xsd.XsdString
          -- ^ The description would be used by test engines for tracking 
          --   and reporting purposes.
        , testScript'Operation_accept :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Accept' header.
        , testScript'Operation_contentType :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Content-Type' header.
        , testScript'Operation_destination :: Maybe Integer
          -- ^ The server where the request message is destined for. Must 
          --   be one of the server numbers listed in 
          --   TestScript.destination section.
        , testScript'Operation_encodeRequestUrl :: Maybe Boolean
          -- ^ Whether or not to implicitly send the request url in 
          --   encoded format. The default is true to match the standard 
          --   RESTful client behavior. Set to false when communicating 
          --   with a server that does not support encoded url paths.
        , testScript'Operation_origin :: Maybe Integer
          -- ^ The server where the request message originates from. Must 
          --   be one of the server numbers listed in TestScript.origin 
          --   section.
        , testScript'Operation_params :: Maybe Xsd.XsdString
          -- ^ Path plus parameters after [type]. Used to set parts of the 
          --   request URL explicitly.
        , testScript'Operation_requestHeader :: [TestScript'RequestHeader]
          -- ^ Header elements would be used to set HTTP headers.
        , testScript'Operation_requestId :: Maybe Id
          -- ^ The fixture id (maybe new) to map to the request.
        , testScript'Operation_responseId :: Maybe Id
          -- ^ The fixture id (maybe new) to map to the response.
        , testScript'Operation_sourceId :: Maybe Id
          -- ^ The id of the fixture used as the body of a PUT or POST 
          --   request.
        , testScript'Operation_targetId :: Maybe Id
          -- ^ Id of fixture used for extracting the [id], [type], and 
          --   [vid] for GET requests.
        , testScript'Operation_url :: Maybe Xsd.XsdString
          -- ^ Complete request URL.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Operation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Operation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "accept")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "destination")
            `apply` optional (parseSchemaType "encodeRequestUrl")
            `apply` optional (parseSchemaType "origin")
            `apply` optional (parseSchemaType "params")
            `apply` many (parseSchemaType "requestHeader")
            `apply` optional (parseSchemaType "requestId")
            `apply` optional (parseSchemaType "responseId")
            `apply` optional (parseSchemaType "sourceId")
            `apply` optional (parseSchemaType "targetId")
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@TestScript'Operation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Operation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Operation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Operation_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ testScript'Operation_type x
            , maybe [] (schemaTypeToXML "resource") $ testScript'Operation_resource x
            , maybe [] (schemaTypeToXML "label") $ testScript'Operation_label x
            , maybe [] (schemaTypeToXML "description") $ testScript'Operation_description x
            , maybe [] (schemaTypeToXML "accept") $ testScript'Operation_accept x
            , maybe [] (schemaTypeToXML "contentType") $ testScript'Operation_contentType x
            , maybe [] (schemaTypeToXML "destination") $ testScript'Operation_destination x
            , maybe [] (schemaTypeToXML "encodeRequestUrl") $ testScript'Operation_encodeRequestUrl x
            , maybe [] (schemaTypeToXML "origin") $ testScript'Operation_origin x
            , maybe [] (schemaTypeToXML "params") $ testScript'Operation_params x
            , concatMap (schemaTypeToXML "requestHeader") $ testScript'Operation_requestHeader x
            , maybe [] (schemaTypeToXML "requestId") $ testScript'Operation_requestId x
            , maybe [] (schemaTypeToXML "responseId") $ testScript'Operation_responseId x
            , maybe [] (schemaTypeToXML "sourceId") $ testScript'Operation_sourceId x
            , maybe [] (schemaTypeToXML "targetId") $ testScript'Operation_targetId x
            , maybe [] (schemaTypeToXML "url") $ testScript'Operation_url x
            ]
instance Extension TestScript'Operation BackboneElement where
    supertype (TestScript'Operation a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Operation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Operation -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'RequestHeader = TestScript'RequestHeader
        { testScript'RequestHeader_id :: Maybe String'primitive
        , testScript'RequestHeader_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'RequestHeader_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'RequestHeader_field :: Xsd.XsdString
          -- ^ The HTTP header field e.g. &quot;Accept&quot;.
        , testScript'RequestHeader_value :: Xsd.XsdString
          -- ^ The value of the header e.g. 
          --   &quot;application/fhir+xml&quot;.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'RequestHeader where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'RequestHeader a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "field"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScript'RequestHeader{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'RequestHeader_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'RequestHeader_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'RequestHeader_modifierExtension x
            , schemaTypeToXML "field" $ testScript'RequestHeader_field x
            , schemaTypeToXML "value" $ testScript'RequestHeader_value x
            ]
instance Extension TestScript'RequestHeader BackboneElement where
    supertype (TestScript'RequestHeader a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'RequestHeader Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'RequestHeader -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Assert = TestScript'Assert
        { testScript'Assert_id :: Maybe String'primitive
        , testScript'Assert_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Assert_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Assert_label :: Maybe Xsd.XsdString
          -- ^ The label would be used for tracking/logging purposes by 
          --   test engines.
        , testScript'Assert_description :: Maybe Xsd.XsdString
          -- ^ The description would be used by test engines for tracking 
          --   and reporting purposes.
        , testScript'Assert_direction :: Maybe AssertionDirectionType
          -- ^ The direction to use for the assertion.
        , testScript'Assert_compareToSourceId :: Maybe Xsd.XsdString
          -- ^ Id of the source fixture used as the contents to be 
          --   evaluated by either the &quot;source/expression&quot; or 
          --   &quot;sourceId/path&quot; definition.
        , testScript'Assert_compareToSourceExpression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to evaluate against the source 
          --   fixture. When compareToSourceId is defined, either 
          --   compareToSourceExpression or compareToSourcePath must be 
          --   defined, but not both.
        , testScript'Assert_compareToSourcePath :: Maybe Xsd.XsdString
          -- ^ XPath or JSONPath expression to evaluate against the source 
          --   fixture. When compareToSourceId is defined, either 
          --   compareToSourceExpression or compareToSourcePath must be 
          --   defined, but not both.
        , testScript'Assert_contentType :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Content-Type' header.
        , testScript'Assert_expression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to be evaluated against the 
          --   request or response message contents - HTTP headers and 
          --   payload.
        , testScript'Assert_headerField :: Maybe Xsd.XsdString
          -- ^ The HTTP header field name e.g. 'Location'.
        , testScript'Assert_minimumId :: Maybe Xsd.XsdString
          -- ^ The ID of a fixture. Asserts that the response contains at 
          --   a minimum the fixture specified by minimumId.
        , testScript'Assert_navigationLinks :: Maybe Boolean
          -- ^ Whether or not the test execution performs validation on 
          --   the bundle navigation links.
        , testScript'Assert_operator :: Maybe AssertionOperatorType
          -- ^ The operator type defines the conditional behavior of the 
          --   assert. If not defined, the default is equals.
        , testScript'Assert_path :: Maybe Xsd.XsdString
          -- ^ The XPath or JSONPath expression to be evaluated against 
          --   the fixture representing the response received from server.
        , testScript'Assert_requestMethod :: Maybe TestScriptRequestMethodCode
          -- ^ The request method or HTTP operation code to compare 
          --   against that used by the client system under test.
        , testScript'Assert_requestURL :: Maybe Xsd.XsdString
          -- ^ The value to use in a comparison against the request URL 
          --   path string.
        , testScript'Assert_resource :: Maybe FHIRDefinedType
          -- ^ The type of the resource. See 
          --   http://hl7.org/fhir/resourcelist.html.
        , testScript'Assert_response :: Maybe AssertionResponseTypes
          -- ^ okay | created | noContent | notModified | bad | forbidden 
          --   | notFound | methodNotAllowed | conflict | gone | 
          --   preconditionFailed | unprocessable.
        , testScript'Assert_responseCode :: Maybe Xsd.XsdString
          -- ^ The value of the HTTP response code to be tested.
        , testScript'Assert_rule :: Maybe TestScript'Rule2
          -- ^ The TestScript.rule this assert will evaluate.
        , testScript'Assert_ruleset :: Maybe TestScript'Ruleset1
          -- ^ The TestScript.ruleset this assert will evaluate.
        , testScript'Assert_sourceId :: Maybe Id
          -- ^ Fixture to evaluate the XPath/JSONPath expression or the 
          --   headerField against.
        , testScript'Assert_validateProfileId :: Maybe Id
          -- ^ The ID of the Profile to validate against.
        , testScript'Assert_value :: Maybe Xsd.XsdString
          -- ^ The value to compare to.
        , testScript'Assert_warningOnly :: Maybe Boolean
          -- ^ Whether or not the test execution will produce a warning 
          --   only on error for this assert.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Assert where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Assert a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "direction")
            `apply` optional (parseSchemaType "compareToSourceId")
            `apply` optional (parseSchemaType "compareToSourceExpression")
            `apply` optional (parseSchemaType "compareToSourcePath")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "headerField")
            `apply` optional (parseSchemaType "minimumId")
            `apply` optional (parseSchemaType "navigationLinks")
            `apply` optional (parseSchemaType "operator")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "requestMethod")
            `apply` optional (parseSchemaType "requestURL")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "responseCode")
            `apply` optional (parseSchemaType "rule")
            `apply` optional (parseSchemaType "ruleset")
            `apply` optional (parseSchemaType "sourceId")
            `apply` optional (parseSchemaType "validateProfileId")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "warningOnly")
    schemaTypeToXML s x@TestScript'Assert{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Assert_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Assert_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Assert_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ testScript'Assert_label x
            , maybe [] (schemaTypeToXML "description") $ testScript'Assert_description x
            , maybe [] (schemaTypeToXML "direction") $ testScript'Assert_direction x
            , maybe [] (schemaTypeToXML "compareToSourceId") $ testScript'Assert_compareToSourceId x
            , maybe [] (schemaTypeToXML "compareToSourceExpression") $ testScript'Assert_compareToSourceExpression x
            , maybe [] (schemaTypeToXML "compareToSourcePath") $ testScript'Assert_compareToSourcePath x
            , maybe [] (schemaTypeToXML "contentType") $ testScript'Assert_contentType x
            , maybe [] (schemaTypeToXML "expression") $ testScript'Assert_expression x
            , maybe [] (schemaTypeToXML "headerField") $ testScript'Assert_headerField x
            , maybe [] (schemaTypeToXML "minimumId") $ testScript'Assert_minimumId x
            , maybe [] (schemaTypeToXML "navigationLinks") $ testScript'Assert_navigationLinks x
            , maybe [] (schemaTypeToXML "operator") $ testScript'Assert_operator x
            , maybe [] (schemaTypeToXML "path") $ testScript'Assert_path x
            , maybe [] (schemaTypeToXML "requestMethod") $ testScript'Assert_requestMethod x
            , maybe [] (schemaTypeToXML "requestURL") $ testScript'Assert_requestURL x
            , maybe [] (schemaTypeToXML "resource") $ testScript'Assert_resource x
            , maybe [] (schemaTypeToXML "response") $ testScript'Assert_response x
            , maybe [] (schemaTypeToXML "responseCode") $ testScript'Assert_responseCode x
            , maybe [] (schemaTypeToXML "rule") $ testScript'Assert_rule x
            , maybe [] (schemaTypeToXML "ruleset") $ testScript'Assert_ruleset x
            , maybe [] (schemaTypeToXML "sourceId") $ testScript'Assert_sourceId x
            , maybe [] (schemaTypeToXML "validateProfileId") $ testScript'Assert_validateProfileId x
            , maybe [] (schemaTypeToXML "value") $ testScript'Assert_value x
            , maybe [] (schemaTypeToXML "warningOnly") $ testScript'Assert_warningOnly x
            ]
instance Extension TestScript'Assert BackboneElement where
    supertype (TestScript'Assert a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Assert Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Assert -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Rule2 = TestScript'Rule2
        { testScript'Rule2_id :: Maybe String'primitive
        , testScript'Rule2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Rule2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Rule2_ruleId :: Id
          -- ^ The TestScript.rule id value this assert will evaluate.
        , testScript'Rule2_param :: [TestScript'Param2]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Rule2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Rule2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScript'Rule2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Rule2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Rule2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Rule2_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScript'Rule2_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScript'Rule2_param x
            ]
instance Extension TestScript'Rule2 BackboneElement where
    supertype (TestScript'Rule2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Rule2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Rule2 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Param2 = TestScript'Param2
        { testScript'Param2_id :: Maybe String'primitive
        , testScript'Param2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Param2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Param2_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert rule parameter name.
        , testScript'Param2_value :: Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Param2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Param2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScript'Param2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Param2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Param2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Param2_modifierExtension x
            , schemaTypeToXML "name" $ testScript'Param2_name x
            , schemaTypeToXML "value" $ testScript'Param2_value x
            ]
instance Extension TestScript'Param2 BackboneElement where
    supertype (TestScript'Param2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Param2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Param2 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Ruleset1 = TestScript'Ruleset1
        { testScript'Ruleset1_id :: Maybe String'primitive
        , testScript'Ruleset1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Ruleset1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Ruleset1_rulesetId :: Id
          -- ^ The TestScript.ruleset id value this assert will evaluate.
        , testScript'Ruleset1_rule :: [TestScript'Rule3]
          -- ^ The referenced rule within the external ruleset template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Ruleset1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Ruleset1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "rulesetId"
            `apply` many (parseSchemaType "rule")
    schemaTypeToXML s x@TestScript'Ruleset1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Ruleset1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Ruleset1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Ruleset1_modifierExtension x
            , schemaTypeToXML "rulesetId" $ testScript'Ruleset1_rulesetId x
            , concatMap (schemaTypeToXML "rule") $ testScript'Ruleset1_rule x
            ]
instance Extension TestScript'Ruleset1 BackboneElement where
    supertype (TestScript'Ruleset1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Ruleset1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Ruleset1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Rule3 = TestScript'Rule3
        { testScript'Rule3_id :: Maybe String'primitive
        , testScript'Rule3_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Rule3_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Rule3_ruleId :: Id
          -- ^ Id of the referenced rule within the external ruleset 
          --   template.
        , testScript'Rule3_param :: [TestScript'Param3]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Rule3 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Rule3 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScript'Rule3{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Rule3_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Rule3_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Rule3_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScript'Rule3_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScript'Rule3_param x
            ]
instance Extension TestScript'Rule3 BackboneElement where
    supertype (TestScript'Rule3 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Rule3 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Rule3 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Param3 = TestScript'Param3
        { testScript'Param3_id :: Maybe String'primitive
        , testScript'Param3_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Param3_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Param3_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert ruleset rule parameter name.
        , testScript'Param3_value :: Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external ruleset rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Param3 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Param3 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScript'Param3{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Param3_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Param3_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Param3_modifierExtension x
            , schemaTypeToXML "name" $ testScript'Param3_name x
            , schemaTypeToXML "value" $ testScript'Param3_value x
            ]
instance Extension TestScript'Param3 BackboneElement where
    supertype (TestScript'Param3 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Param3 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Param3 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Test = TestScript'Test
        { testScript'Test_id :: Maybe String'primitive
        , testScript'Test_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Test_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Test_name :: Maybe Xsd.XsdString
          -- ^ The name of this test used for tracking/logging purposes by 
          --   test engines.
        , testScript'Test_description :: Maybe Xsd.XsdString
          -- ^ A short description of the test used by test engines for 
          --   tracking and reporting purposes.
        , testScript'Test_action :: [TestScript'Action1]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Test where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Test a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScript'Test{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Test_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Test_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Test_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ testScript'Test_name x
            , maybe [] (schemaTypeToXML "description") $ testScript'Test_description x
            , concatMap (schemaTypeToXML "action") $ testScript'Test_action x
            ]
instance Extension TestScript'Test BackboneElement where
    supertype (TestScript'Test a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Test Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Test -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Action1 = TestScript'Action1
        { testScript'Action1_id :: Maybe String'primitive
        , testScript'Action1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Action1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Action1_operation :: Maybe TestScript'Operation
          -- ^ An operation would involve a REST request to a server.
        , testScript'Action1_assert :: Maybe TestScript'Assert
          -- ^ Evaluates the results of previous operations to determine 
          --   if the server under test behaves appropriately.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Action1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Action1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestScript'Action1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Action1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Action1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Action1_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testScript'Action1_operation x
            , maybe [] (schemaTypeToXML "assert") $ testScript'Action1_assert x
            ]
instance Extension TestScript'Action1 BackboneElement where
    supertype (TestScript'Action1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Action1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Action1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Teardown = TestScript'Teardown
        { testScript'Teardown_id :: Maybe String'primitive
        , testScript'Teardown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Teardown_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Teardown_action :: [TestScript'Action2]
          -- ^ The teardown action will only contain an operation.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Teardown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Teardown a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScript'Teardown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Teardown_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Teardown_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Teardown_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testScript'Teardown_action x
            ]
instance Extension TestScript'Teardown BackboneElement where
    supertype (TestScript'Teardown a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Teardown Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Teardown -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScript'Action2 = TestScript'Action2
        { testScript'Action2_id :: Maybe String'primitive
        , testScript'Action2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript'Action2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript'Action2_operation :: TestScript'Operation
          -- ^ An operation would involve a REST request to a server.
        }
        deriving (Eq,Show)
instance SchemaType TestScript'Action2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScript'Action2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "operation"
    schemaTypeToXML s x@TestScript'Action2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScript'Action2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScript'Action2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript'Action2_modifierExtension x
            , schemaTypeToXML "operation" $ testScript'Action2_operation x
            ]
instance Extension TestScript'Action2 BackboneElement where
    supertype (TestScript'Action2 a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScript'Action2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScript'Action2 -> BackboneElement)
              
 
data FHIRDefinedType'list
    = FHIRDefinedType'list_Address
      -- ^ Address
    | FHIRDefinedType'list_Age
      -- ^ Age
    | FHIRDefinedType'list_Annotation
      -- ^ Annotation
    | FHIRDefinedType'list_Attachment
      -- ^ Attachment
    | FHIRDefinedType'list_BackboneElement
      -- ^ BackboneElement
    | FHIRDefinedType'list_CodeableConcept
      -- ^ CodeableConcept
    | FHIRDefinedType'list_Coding
      -- ^ Coding
    | FHIRDefinedType'list_ContactDetail
      -- ^ ContactDetail
    | FHIRDefinedType'list_ContactPoint
      -- ^ ContactPoint
    | FHIRDefinedType'list_Contributor
      -- ^ Contributor
    | FHIRDefinedType'list_Count
      -- ^ Count
    | FHIRDefinedType'list_DataRequirement
      -- ^ DataRequirement
    | FHIRDefinedType'list_Distance
      -- ^ Distance
    | FHIRDefinedType'list_Dosage
      -- ^ Dosage
    | FHIRDefinedType'list_Duration
      -- ^ Duration
    | FHIRDefinedType'list_Element
      -- ^ Element
    | FHIRDefinedType'list_ElementDefinition
      -- ^ ElementDefinition
    | FHIRDefinedType'list_Extension
      -- ^ Extension
    | FHIRDefinedType'list_HumanName
      -- ^ HumanName
    | FHIRDefinedType'list_Identifier
      -- ^ Identifier
    | FHIRDefinedType'list_Meta
      -- ^ Meta
    | FHIRDefinedType'list_Money
      -- ^ Money
    | FHIRDefinedType'list_Narrative
      -- ^ Narrative
    | FHIRDefinedType'list_ParameterDefinition
      -- ^ ParameterDefinition
    | FHIRDefinedType'list_Period
      -- ^ Period
    | FHIRDefinedType'list_Quantity
      -- ^ Quantity
    | FHIRDefinedType'list_Range
      -- ^ Range
    | FHIRDefinedType'list_Ratio
      -- ^ Ratio
    | FHIRDefinedType'list_Reference
      -- ^ Reference
    | FHIRDefinedType'list_RelatedArtifact
      -- ^ RelatedArtifact
    | FHIRDefinedType'list_SampledData
      -- ^ SampledData
    | FHIRDefinedType'list_Signature
      -- ^ Signature
    | FHIRDefinedType'list_SimpleQuantity
      -- ^ SimpleQuantity
    | FHIRDefinedType'list_Timing
      -- ^ Timing
    | FHIRDefinedType'list_TriggerDefinition
      -- ^ TriggerDefinition
    | FHIRDefinedType'list_UsageContext
      -- ^ UsageContext
    | FHIRDefinedType'list_Base64Binary
      -- ^ base64Binary
    | FHIRDefinedType'list_Boolean
      -- ^ boolean
    | FHIRDefinedType'list_Code
      -- ^ code
    | FHIRDefinedType'list_Date
      -- ^ date
    | FHIRDefinedType'list_DateTime
      -- ^ dateTime
    | FHIRDefinedType'list_Decimal
      -- ^ decimal
    | FHIRDefinedType'list_Id
      -- ^ id
    | FHIRDefinedType'list_Instant
      -- ^ instant
    | FHIRDefinedType'list_Integer
      -- ^ integer
    | FHIRDefinedType'list_Markdown
      -- ^ markdown
    | FHIRDefinedType'list_Oid
      -- ^ oid
    | FHIRDefinedType'list_PositiveInt
      -- ^ positiveInt
    | FHIRDefinedType'list_Xsd.XsdString
      -- ^ string
    | FHIRDefinedType'list_Time
      -- ^ time
    | FHIRDefinedType'list_UnsignedInt
      -- ^ unsignedInt
    | FHIRDefinedType'list_Uri
      -- ^ uri
    | FHIRDefinedType'list_Uuid
      -- ^ uuid
    | FHIRDefinedType'list_Xhtml
      -- ^ XHTML
    | FHIRDefinedType'list_Account
      -- ^ Account
    | FHIRDefinedType'list_ActivityDefinition
      -- ^ ActivityDefinition
    | FHIRDefinedType'list_AdverseEvent
      -- ^ AdverseEvent
    | FHIRDefinedType'list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | FHIRDefinedType'list_Appointment
      -- ^ Appointment
    | FHIRDefinedType'list_AppointmentResponse
      -- ^ AppointmentResponse
    | FHIRDefinedType'list_AuditEvent
      -- ^ AuditEvent
    | FHIRDefinedType'list_Basic
      -- ^ Basic
    | FHIRDefinedType'list_Binary
      -- ^ Binary
    | FHIRDefinedType'list_BodySite
      -- ^ BodySite
    | FHIRDefinedType'list_Bundle
      -- ^ Bundle
    | FHIRDefinedType'list_CapabilityStatement
      -- ^ CapabilityStatement
    | FHIRDefinedType'list_CarePlan
      -- ^ CarePlan
    | FHIRDefinedType'list_CareTeam
      -- ^ CareTeam
    | FHIRDefinedType'list_ChargeItem
      -- ^ ChargeItem
    | FHIRDefinedType'list_Claim
      -- ^ Claim
    | FHIRDefinedType'list_ClaimResponse
      -- ^ ClaimResponse
    | FHIRDefinedType'list_ClinicalImpression
      -- ^ ClinicalImpression
    | FHIRDefinedType'list_CodeSystem
      -- ^ CodeSystem
    | FHIRDefinedType'list_Communication
      -- ^ Communication
    | FHIRDefinedType'list_CommunicationRequest
      -- ^ CommunicationRequest
    | FHIRDefinedType'list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | FHIRDefinedType'list_Composition
      -- ^ Composition
    | FHIRDefinedType'list_ConceptMap
      -- ^ ConceptMap
    | FHIRDefinedType'list_Condition
      -- ^ Condition
    | FHIRDefinedType'list_Consent
      -- ^ Consent
    | FHIRDefinedType'list_Contract
      -- ^ Contract
    | FHIRDefinedType'list_Coverage
      -- ^ Coverage
    | FHIRDefinedType'list_DataElement
      -- ^ DataElement
    | FHIRDefinedType'list_DetectedIssue
      -- ^ DetectedIssue
    | FHIRDefinedType'list_Device
      -- ^ Device
    | FHIRDefinedType'list_DeviceComponent
      -- ^ DeviceComponent
    | FHIRDefinedType'list_DeviceMetric
      -- ^ DeviceMetric
    | FHIRDefinedType'list_DeviceRequest
      -- ^ DeviceRequest
    | FHIRDefinedType'list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | FHIRDefinedType'list_DiagnosticReport
      -- ^ DiagnosticReport
    | FHIRDefinedType'list_DocumentManifest
      -- ^ DocumentManifest
    | FHIRDefinedType'list_DocumentReference
      -- ^ DocumentReference
    | FHIRDefinedType'list_DomainResource
      -- ^ DomainResource
    | FHIRDefinedType'list_EligibilityRequest
      -- ^ EligibilityRequest
    | FHIRDefinedType'list_EligibilityResponse
      -- ^ EligibilityResponse
    | FHIRDefinedType'list_Encounter
      -- ^ Encounter
    | FHIRDefinedType'list_Endpoint
      -- ^ Endpoint
    | FHIRDefinedType'list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | FHIRDefinedType'list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | FHIRDefinedType'list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | FHIRDefinedType'list_ExpansionProfile
      -- ^ ExpansionProfile
    | FHIRDefinedType'list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | FHIRDefinedType'list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | FHIRDefinedType'list_Flag
      -- ^ Flag
    | FHIRDefinedType'list_Goal
      -- ^ Goal
    | FHIRDefinedType'list_GraphDefinition
      -- ^ GraphDefinition
    | FHIRDefinedType'list_Group
      -- ^ Group
    | FHIRDefinedType'list_GuidanceResponse
      -- ^ GuidanceResponse
    | FHIRDefinedType'list_HealthcareService
      -- ^ HealthcareService
    | FHIRDefinedType'list_ImagingManifest
      -- ^ ImagingManifest
    | FHIRDefinedType'list_ImagingStudy
      -- ^ ImagingStudy
    | FHIRDefinedType'list_Immunization
      -- ^ Immunization
    | FHIRDefinedType'list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | FHIRDefinedType'list_ImplementationGuide
      -- ^ ImplementationGuide
    | FHIRDefinedType'list_Library
      -- ^ Library
    | FHIRDefinedType'list_Linkage
      -- ^ Linkage
    | FHIRDefinedType'list_List
      -- ^ List
    | FHIRDefinedType'list_Location
      -- ^ Location
    | FHIRDefinedType'list_Measure
      -- ^ Measure
    | FHIRDefinedType'list_MeasureReport
      -- ^ MeasureReport
    | FHIRDefinedType'list_Media
      -- ^ Media
    | FHIRDefinedType'list_Medication
      -- ^ Medication
    | FHIRDefinedType'list_MedicationAdministration
      -- ^ MedicationAdministration
    | FHIRDefinedType'list_MedicationDispense
      -- ^ MedicationDispense
    | FHIRDefinedType'list_MedicationRequest
      -- ^ MedicationRequest
    | FHIRDefinedType'list_MedicationStatement
      -- ^ MedicationStatement
    | FHIRDefinedType'list_MessageDefinition
      -- ^ MessageDefinition
    | FHIRDefinedType'list_MessageHeader
      -- ^ MessageHeader
    | FHIRDefinedType'list_NamingSystem
      -- ^ NamingSystem
    | FHIRDefinedType'list_NutritionOrder
      -- ^ NutritionOrder
    | FHIRDefinedType'list_Observation
      -- ^ Observation
    | FHIRDefinedType'list_OperationDefinition
      -- ^ OperationDefinition
    | FHIRDefinedType'list_OperationOutcome
      -- ^ OperationOutcome
    | FHIRDefinedType'list_Organization
      -- ^ Organization
    | FHIRDefinedType'list_Parameters
      -- ^ Parameters
    | FHIRDefinedType'list_Patient
      -- ^ Patient
    | FHIRDefinedType'list_PaymentNotice
      -- ^ PaymentNotice
    | FHIRDefinedType'list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | FHIRDefinedType'list_Person
      -- ^ Person
    | FHIRDefinedType'list_PlanDefinition
      -- ^ PlanDefinition
    | FHIRDefinedType'list_Practitioner
      -- ^ Practitioner
    | FHIRDefinedType'list_PractitionerRole
      -- ^ PractitionerRole
    | FHIRDefinedType'list_Procedure
      -- ^ Procedure
    | FHIRDefinedType'list_ProcedureRequest
      -- ^ ProcedureRequest
    | FHIRDefinedType'list_ProcessRequest
      -- ^ ProcessRequest
    | FHIRDefinedType'list_ProcessResponse
      -- ^ ProcessResponse
    | FHIRDefinedType'list_Provenance
      -- ^ Provenance
    | FHIRDefinedType'list_Questionnaire
      -- ^ Questionnaire
    | FHIRDefinedType'list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | FHIRDefinedType'list_ReferralRequest
      -- ^ ReferralRequest
    | FHIRDefinedType'list_RelatedPerson
      -- ^ RelatedPerson
    | FHIRDefinedType'list_RequestGroup
      -- ^ RequestGroup
    | FHIRDefinedType'list_ResearchStudy
      -- ^ ResearchStudy
    | FHIRDefinedType'list_ResearchSubject
      -- ^ ResearchSubject
    | FHIRDefinedType'list_Resource
      -- ^ Resource
    | FHIRDefinedType'list_RiskAssessment
      -- ^ RiskAssessment
    | FHIRDefinedType'list_Schedule
      -- ^ Schedule
    | FHIRDefinedType'list_SearchParameter
      -- ^ SearchParameter
    | FHIRDefinedType'list_Sequence
      -- ^ Sequence
    | FHIRDefinedType'list_ServiceDefinition
      -- ^ ServiceDefinition
    | FHIRDefinedType'list_Slot
      -- ^ Slot
    | FHIRDefinedType'list_Specimen
      -- ^ Specimen
    | FHIRDefinedType'list_StructureDefinition
      -- ^ StructureDefinition
    | FHIRDefinedType'list_StructureMap
      -- ^ StructureMap
    | FHIRDefinedType'list_Subscription
      -- ^ Subscription
    | FHIRDefinedType'list_Substance
      -- ^ Substance
    | FHIRDefinedType'list_SupplyDelivery
      -- ^ SupplyDelivery
    | FHIRDefinedType'list_SupplyRequest
      -- ^ SupplyRequest
    | FHIRDefinedType'list_Task
      -- ^ Task
    | FHIRDefinedType'list_TestReport
      -- ^ TestReport
    | FHIRDefinedType'list_TestScript
      -- ^ TestScript
    | FHIRDefinedType'list_ValueSet
      -- ^ ValueSet
    | FHIRDefinedType'list_VisionPrescription
      -- ^ VisionPrescription
    deriving (Eq,Show,Enum)
instance SchemaType FHIRDefinedType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRDefinedType'list where
    acceptingParser =  do literal "Address"; return FHIRDefinedType'list_Address
                      `onFail` do literal "Age"; return FHIRDefinedType'list_Age
                      `onFail` do literal "Annotation"; return FHIRDefinedType'list_Annotation
                      `onFail` do literal "Attachment"; return FHIRDefinedType'list_Attachment
                      `onFail` do literal "BackboneElement"; return FHIRDefinedType'list_BackboneElement
                      `onFail` do literal "CodeableConcept"; return FHIRDefinedType'list_CodeableConcept
                      `onFail` do literal "Coding"; return FHIRDefinedType'list_Coding
                      `onFail` do literal "ContactDetail"; return FHIRDefinedType'list_ContactDetail
                      `onFail` do literal "ContactPoint"; return FHIRDefinedType'list_ContactPoint
                      `onFail` do literal "Contributor"; return FHIRDefinedType'list_Contributor
                      `onFail` do literal "Count"; return FHIRDefinedType'list_Count
                      `onFail` do literal "DataRequirement"; return FHIRDefinedType'list_DataRequirement
                      `onFail` do literal "Distance"; return FHIRDefinedType'list_Distance
                      `onFail` do literal "Dosage"; return FHIRDefinedType'list_Dosage
                      `onFail` do literal "Duration"; return FHIRDefinedType'list_Duration
                      `onFail` do literal "Element"; return FHIRDefinedType'list_Element
                      `onFail` do literal "ElementDefinition"; return FHIRDefinedType'list_ElementDefinition
                      `onFail` do literal "Extension"; return FHIRDefinedType'list_Extension
                      `onFail` do literal "HumanName"; return FHIRDefinedType'list_HumanName
                      `onFail` do literal "Identifier"; return FHIRDefinedType'list_Identifier
                      `onFail` do literal "Meta"; return FHIRDefinedType'list_Meta
                      `onFail` do literal "Money"; return FHIRDefinedType'list_Money
                      `onFail` do literal "Narrative"; return FHIRDefinedType'list_Narrative
                      `onFail` do literal "ParameterDefinition"; return FHIRDefinedType'list_ParameterDefinition
                      `onFail` do literal "Period"; return FHIRDefinedType'list_Period
                      `onFail` do literal "Quantity"; return FHIRDefinedType'list_Quantity
                      `onFail` do literal "Range"; return FHIRDefinedType'list_Range
                      `onFail` do literal "Ratio"; return FHIRDefinedType'list_Ratio
                      `onFail` do literal "Reference"; return FHIRDefinedType'list_Reference
                      `onFail` do literal "RelatedArtifact"; return FHIRDefinedType'list_RelatedArtifact
                      `onFail` do literal "SampledData"; return FHIRDefinedType'list_SampledData
                      `onFail` do literal "Signature"; return FHIRDefinedType'list_Signature
                      `onFail` do literal "SimpleQuantity"; return FHIRDefinedType'list_SimpleQuantity
                      `onFail` do literal "Timing"; return FHIRDefinedType'list_Timing
                      `onFail` do literal "TriggerDefinition"; return FHIRDefinedType'list_TriggerDefinition
                      `onFail` do literal "UsageContext"; return FHIRDefinedType'list_UsageContext
                      `onFail` do literal "base64Binary"; return FHIRDefinedType'list_Base64Binary
                      `onFail` do literal "boolean"; return FHIRDefinedType'list_Boolean
                      `onFail` do literal "code"; return FHIRDefinedType'list_Code
                      `onFail` do literal "date"; return FHIRDefinedType'list_Date
                      `onFail` do literal "dateTime"; return FHIRDefinedType'list_DateTime
                      `onFail` do literal "decimal"; return FHIRDefinedType'list_Decimal
                      `onFail` do literal "id"; return FHIRDefinedType'list_Id
                      `onFail` do literal "instant"; return FHIRDefinedType'list_Instant
                      `onFail` do literal "integer"; return FHIRDefinedType'list_Integer
                      `onFail` do literal "markdown"; return FHIRDefinedType'list_Markdown
                      `onFail` do literal "oid"; return FHIRDefinedType'list_Oid
                      `onFail` do literal "positiveInt"; return FHIRDefinedType'list_PositiveInt
                      `onFail` do literal "string"; return FHIRDefinedType'list_Xsd.XsdString
                      `onFail` do literal "time"; return FHIRDefinedType'list_Time
                      `onFail` do literal "unsignedInt"; return FHIRDefinedType'list_UnsignedInt
                      `onFail` do literal "uri"; return FHIRDefinedType'list_Uri
                      `onFail` do literal "uuid"; return FHIRDefinedType'list_Uuid
                      `onFail` do literal "xhtml"; return FHIRDefinedType'list_Xhtml
                      `onFail` do literal "Account"; return FHIRDefinedType'list_Account
                      `onFail` do literal "ActivityDefinition"; return FHIRDefinedType'list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return FHIRDefinedType'list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return FHIRDefinedType'list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return FHIRDefinedType'list_Appointment
                      `onFail` do literal "AppointmentResponse"; return FHIRDefinedType'list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return FHIRDefinedType'list_AuditEvent
                      `onFail` do literal "Basic"; return FHIRDefinedType'list_Basic
                      `onFail` do literal "Binary"; return FHIRDefinedType'list_Binary
                      `onFail` do literal "BodySite"; return FHIRDefinedType'list_BodySite
                      `onFail` do literal "Bundle"; return FHIRDefinedType'list_Bundle
                      `onFail` do literal "CapabilityStatement"; return FHIRDefinedType'list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return FHIRDefinedType'list_CarePlan
                      `onFail` do literal "CareTeam"; return FHIRDefinedType'list_CareTeam
                      `onFail` do literal "ChargeItem"; return FHIRDefinedType'list_ChargeItem
                      `onFail` do literal "Claim"; return FHIRDefinedType'list_Claim
                      `onFail` do literal "ClaimResponse"; return FHIRDefinedType'list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return FHIRDefinedType'list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return FHIRDefinedType'list_CodeSystem
                      `onFail` do literal "Communication"; return FHIRDefinedType'list_Communication
                      `onFail` do literal "CommunicationRequest"; return FHIRDefinedType'list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return FHIRDefinedType'list_CompartmentDefinition
                      `onFail` do literal "Composition"; return FHIRDefinedType'list_Composition
                      `onFail` do literal "ConceptMap"; return FHIRDefinedType'list_ConceptMap
                      `onFail` do literal "Condition"; return FHIRDefinedType'list_Condition
                      `onFail` do literal "Consent"; return FHIRDefinedType'list_Consent
                      `onFail` do literal "Contract"; return FHIRDefinedType'list_Contract
                      `onFail` do literal "Coverage"; return FHIRDefinedType'list_Coverage
                      `onFail` do literal "DataElement"; return FHIRDefinedType'list_DataElement
                      `onFail` do literal "DetectedIssue"; return FHIRDefinedType'list_DetectedIssue
                      `onFail` do literal "Device"; return FHIRDefinedType'list_Device
                      `onFail` do literal "DeviceComponent"; return FHIRDefinedType'list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return FHIRDefinedType'list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return FHIRDefinedType'list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return FHIRDefinedType'list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return FHIRDefinedType'list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return FHIRDefinedType'list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return FHIRDefinedType'list_DocumentReference
                      `onFail` do literal "DomainResource"; return FHIRDefinedType'list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return FHIRDefinedType'list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return FHIRDefinedType'list_EligibilityResponse
                      `onFail` do literal "Encounter"; return FHIRDefinedType'list_Encounter
                      `onFail` do literal "Endpoint"; return FHIRDefinedType'list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return FHIRDefinedType'list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return FHIRDefinedType'list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return FHIRDefinedType'list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return FHIRDefinedType'list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return FHIRDefinedType'list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return FHIRDefinedType'list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return FHIRDefinedType'list_Flag
                      `onFail` do literal "Goal"; return FHIRDefinedType'list_Goal
                      `onFail` do literal "GraphDefinition"; return FHIRDefinedType'list_GraphDefinition
                      `onFail` do literal "Group"; return FHIRDefinedType'list_Group
                      `onFail` do literal "GuidanceResponse"; return FHIRDefinedType'list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return FHIRDefinedType'list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return FHIRDefinedType'list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return FHIRDefinedType'list_ImagingStudy
                      `onFail` do literal "Immunization"; return FHIRDefinedType'list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return FHIRDefinedType'list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return FHIRDefinedType'list_ImplementationGuide
                      `onFail` do literal "Library"; return FHIRDefinedType'list_Library
                      `onFail` do literal "Linkage"; return FHIRDefinedType'list_Linkage
                      `onFail` do literal "List"; return FHIRDefinedType'list_List
                      `onFail` do literal "Location"; return FHIRDefinedType'list_Location
                      `onFail` do literal "Measure"; return FHIRDefinedType'list_Measure
                      `onFail` do literal "MeasureReport"; return FHIRDefinedType'list_MeasureReport
                      `onFail` do literal "Media"; return FHIRDefinedType'list_Media
                      `onFail` do literal "Medication"; return FHIRDefinedType'list_Medication
                      `onFail` do literal "MedicationAdministration"; return FHIRDefinedType'list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return FHIRDefinedType'list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return FHIRDefinedType'list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return FHIRDefinedType'list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return FHIRDefinedType'list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return FHIRDefinedType'list_MessageHeader
                      `onFail` do literal "NamingSystem"; return FHIRDefinedType'list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return FHIRDefinedType'list_NutritionOrder
                      `onFail` do literal "Observation"; return FHIRDefinedType'list_Observation
                      `onFail` do literal "OperationDefinition"; return FHIRDefinedType'list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return FHIRDefinedType'list_OperationOutcome
                      `onFail` do literal "Organization"; return FHIRDefinedType'list_Organization
                      `onFail` do literal "Parameters"; return FHIRDefinedType'list_Parameters
                      `onFail` do literal "Patient"; return FHIRDefinedType'list_Patient
                      `onFail` do literal "PaymentNotice"; return FHIRDefinedType'list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return FHIRDefinedType'list_PaymentReconciliation
                      `onFail` do literal "Person"; return FHIRDefinedType'list_Person
                      `onFail` do literal "PlanDefinition"; return FHIRDefinedType'list_PlanDefinition
                      `onFail` do literal "Practitioner"; return FHIRDefinedType'list_Practitioner
                      `onFail` do literal "PractitionerRole"; return FHIRDefinedType'list_PractitionerRole
                      `onFail` do literal "Procedure"; return FHIRDefinedType'list_Procedure
                      `onFail` do literal "ProcedureRequest"; return FHIRDefinedType'list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return FHIRDefinedType'list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return FHIRDefinedType'list_ProcessResponse
                      `onFail` do literal "Provenance"; return FHIRDefinedType'list_Provenance
                      `onFail` do literal "Questionnaire"; return FHIRDefinedType'list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return FHIRDefinedType'list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return FHIRDefinedType'list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return FHIRDefinedType'list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return FHIRDefinedType'list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return FHIRDefinedType'list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return FHIRDefinedType'list_ResearchSubject
                      `onFail` do literal "Resource"; return FHIRDefinedType'list_Resource
                      `onFail` do literal "RiskAssessment"; return FHIRDefinedType'list_RiskAssessment
                      `onFail` do literal "Schedule"; return FHIRDefinedType'list_Schedule
                      `onFail` do literal "SearchParameter"; return FHIRDefinedType'list_SearchParameter
                      `onFail` do literal "Sequence"; return FHIRDefinedType'list_Sequence
                      `onFail` do literal "ServiceDefinition"; return FHIRDefinedType'list_ServiceDefinition
                      `onFail` do literal "Slot"; return FHIRDefinedType'list_Slot
                      `onFail` do literal "Specimen"; return FHIRDefinedType'list_Specimen
                      `onFail` do literal "StructureDefinition"; return FHIRDefinedType'list_StructureDefinition
                      `onFail` do literal "StructureMap"; return FHIRDefinedType'list_StructureMap
                      `onFail` do literal "Subscription"; return FHIRDefinedType'list_Subscription
                      `onFail` do literal "Substance"; return FHIRDefinedType'list_Substance
                      `onFail` do literal "SupplyDelivery"; return FHIRDefinedType'list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return FHIRDefinedType'list_SupplyRequest
                      `onFail` do literal "Task"; return FHIRDefinedType'list_Task
                      `onFail` do literal "TestReport"; return FHIRDefinedType'list_TestReport
                      `onFail` do literal "TestScript"; return FHIRDefinedType'list_TestScript
                      `onFail` do literal "ValueSet"; return FHIRDefinedType'list_ValueSet
                      `onFail` do literal "VisionPrescription"; return FHIRDefinedType'list_VisionPrescription
                      
    simpleTypeText FHIRDefinedType'list_Address = "Address"
    simpleTypeText FHIRDefinedType'list_Age = "Age"
    simpleTypeText FHIRDefinedType'list_Annotation = "Annotation"
    simpleTypeText FHIRDefinedType'list_Attachment = "Attachment"
    simpleTypeText FHIRDefinedType'list_BackboneElement = "BackboneElement"
    simpleTypeText FHIRDefinedType'list_CodeableConcept = "CodeableConcept"
    simpleTypeText FHIRDefinedType'list_Coding = "Coding"
    simpleTypeText FHIRDefinedType'list_ContactDetail = "ContactDetail"
    simpleTypeText FHIRDefinedType'list_ContactPoint = "ContactPoint"
    simpleTypeText FHIRDefinedType'list_Contributor = "Contributor"
    simpleTypeText FHIRDefinedType'list_Count = "Count"
    simpleTypeText FHIRDefinedType'list_DataRequirement = "DataRequirement"
    simpleTypeText FHIRDefinedType'list_Distance = "Distance"
    simpleTypeText FHIRDefinedType'list_Dosage = "Dosage"
    simpleTypeText FHIRDefinedType'list_Duration = "Duration"
    simpleTypeText FHIRDefinedType'list_Element = "Element"
    simpleTypeText FHIRDefinedType'list_ElementDefinition = "ElementDefinition"
    simpleTypeText FHIRDefinedType'list_Extension = "Extension"
    simpleTypeText FHIRDefinedType'list_HumanName = "HumanName"
    simpleTypeText FHIRDefinedType'list_Identifier = "Identifier"
    simpleTypeText FHIRDefinedType'list_Meta = "Meta"
    simpleTypeText FHIRDefinedType'list_Money = "Money"
    simpleTypeText FHIRDefinedType'list_Narrative = "Narrative"
    simpleTypeText FHIRDefinedType'list_ParameterDefinition = "ParameterDefinition"
    simpleTypeText FHIRDefinedType'list_Period = "Period"
    simpleTypeText FHIRDefinedType'list_Quantity = "Quantity"
    simpleTypeText FHIRDefinedType'list_Range = "Range"
    simpleTypeText FHIRDefinedType'list_Ratio = "Ratio"
    simpleTypeText FHIRDefinedType'list_Reference = "Reference"
    simpleTypeText FHIRDefinedType'list_RelatedArtifact = "RelatedArtifact"
    simpleTypeText FHIRDefinedType'list_SampledData = "SampledData"
    simpleTypeText FHIRDefinedType'list_Signature = "Signature"
    simpleTypeText FHIRDefinedType'list_SimpleQuantity = "SimpleQuantity"
    simpleTypeText FHIRDefinedType'list_Timing = "Timing"
    simpleTypeText FHIRDefinedType'list_TriggerDefinition = "TriggerDefinition"
    simpleTypeText FHIRDefinedType'list_UsageContext = "UsageContext"
    simpleTypeText FHIRDefinedType'list_Base64Binary = "base64Binary"
    simpleTypeText FHIRDefinedType'list_Boolean = "boolean"
    simpleTypeText FHIRDefinedType'list_Code = "code"
    simpleTypeText FHIRDefinedType'list_Date = "date"
    simpleTypeText FHIRDefinedType'list_DateTime = "dateTime"
    simpleTypeText FHIRDefinedType'list_Decimal = "decimal"
    simpleTypeText FHIRDefinedType'list_Id = "id"
    simpleTypeText FHIRDefinedType'list_Instant = "instant"
    simpleTypeText FHIRDefinedType'list_Integer = "integer"
    simpleTypeText FHIRDefinedType'list_Markdown = "markdown"
    simpleTypeText FHIRDefinedType'list_Oid = "oid"
    simpleTypeText FHIRDefinedType'list_PositiveInt = "positiveInt"
    simpleTypeText FHIRDefinedType'list_Xsd.XsdString = "string"
    simpleTypeText FHIRDefinedType'list_Time = "time"
    simpleTypeText FHIRDefinedType'list_UnsignedInt = "unsignedInt"
    simpleTypeText FHIRDefinedType'list_Uri = "uri"
    simpleTypeText FHIRDefinedType'list_Uuid = "uuid"
    simpleTypeText FHIRDefinedType'list_Xhtml = "xhtml"
    simpleTypeText FHIRDefinedType'list_Account = "Account"
    simpleTypeText FHIRDefinedType'list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText FHIRDefinedType'list_AdverseEvent = "AdverseEvent"
    simpleTypeText FHIRDefinedType'list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText FHIRDefinedType'list_Appointment = "Appointment"
    simpleTypeText FHIRDefinedType'list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText FHIRDefinedType'list_AuditEvent = "AuditEvent"
    simpleTypeText FHIRDefinedType'list_Basic = "Basic"
    simpleTypeText FHIRDefinedType'list_Binary = "Binary"
    simpleTypeText FHIRDefinedType'list_BodySite = "BodySite"
    simpleTypeText FHIRDefinedType'list_Bundle = "Bundle"
    simpleTypeText FHIRDefinedType'list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText FHIRDefinedType'list_CarePlan = "CarePlan"
    simpleTypeText FHIRDefinedType'list_CareTeam = "CareTeam"
    simpleTypeText FHIRDefinedType'list_ChargeItem = "ChargeItem"
    simpleTypeText FHIRDefinedType'list_Claim = "Claim"
    simpleTypeText FHIRDefinedType'list_ClaimResponse = "ClaimResponse"
    simpleTypeText FHIRDefinedType'list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText FHIRDefinedType'list_CodeSystem = "CodeSystem"
    simpleTypeText FHIRDefinedType'list_Communication = "Communication"
    simpleTypeText FHIRDefinedType'list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText FHIRDefinedType'list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText FHIRDefinedType'list_Composition = "Composition"
    simpleTypeText FHIRDefinedType'list_ConceptMap = "ConceptMap"
    simpleTypeText FHIRDefinedType'list_Condition = "Condition"
    simpleTypeText FHIRDefinedType'list_Consent = "Consent"
    simpleTypeText FHIRDefinedType'list_Contract = "Contract"
    simpleTypeText FHIRDefinedType'list_Coverage = "Coverage"
    simpleTypeText FHIRDefinedType'list_DataElement = "DataElement"
    simpleTypeText FHIRDefinedType'list_DetectedIssue = "DetectedIssue"
    simpleTypeText FHIRDefinedType'list_Device = "Device"
    simpleTypeText FHIRDefinedType'list_DeviceComponent = "DeviceComponent"
    simpleTypeText FHIRDefinedType'list_DeviceMetric = "DeviceMetric"
    simpleTypeText FHIRDefinedType'list_DeviceRequest = "DeviceRequest"
    simpleTypeText FHIRDefinedType'list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText FHIRDefinedType'list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText FHIRDefinedType'list_DocumentManifest = "DocumentManifest"
    simpleTypeText FHIRDefinedType'list_DocumentReference = "DocumentReference"
    simpleTypeText FHIRDefinedType'list_DomainResource = "DomainResource"
    simpleTypeText FHIRDefinedType'list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText FHIRDefinedType'list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText FHIRDefinedType'list_Encounter = "Encounter"
    simpleTypeText FHIRDefinedType'list_Endpoint = "Endpoint"
    simpleTypeText FHIRDefinedType'list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText FHIRDefinedType'list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText FHIRDefinedType'list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText FHIRDefinedType'list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText FHIRDefinedType'list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText FHIRDefinedType'list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText FHIRDefinedType'list_Flag = "Flag"
    simpleTypeText FHIRDefinedType'list_Goal = "Goal"
    simpleTypeText FHIRDefinedType'list_GraphDefinition = "GraphDefinition"
    simpleTypeText FHIRDefinedType'list_Group = "Group"
    simpleTypeText FHIRDefinedType'list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText FHIRDefinedType'list_HealthcareService = "HealthcareService"
    simpleTypeText FHIRDefinedType'list_ImagingManifest = "ImagingManifest"
    simpleTypeText FHIRDefinedType'list_ImagingStudy = "ImagingStudy"
    simpleTypeText FHIRDefinedType'list_Immunization = "Immunization"
    simpleTypeText FHIRDefinedType'list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText FHIRDefinedType'list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText FHIRDefinedType'list_Library = "Library"
    simpleTypeText FHIRDefinedType'list_Linkage = "Linkage"
    simpleTypeText FHIRDefinedType'list_List = "List"
    simpleTypeText FHIRDefinedType'list_Location = "Location"
    simpleTypeText FHIRDefinedType'list_Measure = "Measure"
    simpleTypeText FHIRDefinedType'list_MeasureReport = "MeasureReport"
    simpleTypeText FHIRDefinedType'list_Media = "Media"
    simpleTypeText FHIRDefinedType'list_Medication = "Medication"
    simpleTypeText FHIRDefinedType'list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText FHIRDefinedType'list_MedicationDispense = "MedicationDispense"
    simpleTypeText FHIRDefinedType'list_MedicationRequest = "MedicationRequest"
    simpleTypeText FHIRDefinedType'list_MedicationStatement = "MedicationStatement"
    simpleTypeText FHIRDefinedType'list_MessageDefinition = "MessageDefinition"
    simpleTypeText FHIRDefinedType'list_MessageHeader = "MessageHeader"
    simpleTypeText FHIRDefinedType'list_NamingSystem = "NamingSystem"
    simpleTypeText FHIRDefinedType'list_NutritionOrder = "NutritionOrder"
    simpleTypeText FHIRDefinedType'list_Observation = "Observation"
    simpleTypeText FHIRDefinedType'list_OperationDefinition = "OperationDefinition"
    simpleTypeText FHIRDefinedType'list_OperationOutcome = "OperationOutcome"
    simpleTypeText FHIRDefinedType'list_Organization = "Organization"
    simpleTypeText FHIRDefinedType'list_Parameters = "Parameters"
    simpleTypeText FHIRDefinedType'list_Patient = "Patient"
    simpleTypeText FHIRDefinedType'list_PaymentNotice = "PaymentNotice"
    simpleTypeText FHIRDefinedType'list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText FHIRDefinedType'list_Person = "Person"
    simpleTypeText FHIRDefinedType'list_PlanDefinition = "PlanDefinition"
    simpleTypeText FHIRDefinedType'list_Practitioner = "Practitioner"
    simpleTypeText FHIRDefinedType'list_PractitionerRole = "PractitionerRole"
    simpleTypeText FHIRDefinedType'list_Procedure = "Procedure"
    simpleTypeText FHIRDefinedType'list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText FHIRDefinedType'list_ProcessRequest = "ProcessRequest"
    simpleTypeText FHIRDefinedType'list_ProcessResponse = "ProcessResponse"
    simpleTypeText FHIRDefinedType'list_Provenance = "Provenance"
    simpleTypeText FHIRDefinedType'list_Questionnaire = "Questionnaire"
    simpleTypeText FHIRDefinedType'list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText FHIRDefinedType'list_ReferralRequest = "ReferralRequest"
    simpleTypeText FHIRDefinedType'list_RelatedPerson = "RelatedPerson"
    simpleTypeText FHIRDefinedType'list_RequestGroup = "RequestGroup"
    simpleTypeText FHIRDefinedType'list_ResearchStudy = "ResearchStudy"
    simpleTypeText FHIRDefinedType'list_ResearchSubject = "ResearchSubject"
    simpleTypeText FHIRDefinedType'list_Resource = "Resource"
    simpleTypeText FHIRDefinedType'list_RiskAssessment = "RiskAssessment"
    simpleTypeText FHIRDefinedType'list_Schedule = "Schedule"
    simpleTypeText FHIRDefinedType'list_SearchParameter = "SearchParameter"
    simpleTypeText FHIRDefinedType'list_Sequence = "Sequence"
    simpleTypeText FHIRDefinedType'list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText FHIRDefinedType'list_Slot = "Slot"
    simpleTypeText FHIRDefinedType'list_Specimen = "Specimen"
    simpleTypeText FHIRDefinedType'list_StructureDefinition = "StructureDefinition"
    simpleTypeText FHIRDefinedType'list_StructureMap = "StructureMap"
    simpleTypeText FHIRDefinedType'list_Subscription = "Subscription"
    simpleTypeText FHIRDefinedType'list_Substance = "Substance"
    simpleTypeText FHIRDefinedType'list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText FHIRDefinedType'list_SupplyRequest = "SupplyRequest"
    simpleTypeText FHIRDefinedType'list_Task = "Task"
    simpleTypeText FHIRDefinedType'list_TestReport = "TestReport"
    simpleTypeText FHIRDefinedType'list_TestScript = "TestScript"
    simpleTypeText FHIRDefinedType'list_ValueSet = "ValueSet"
    simpleTypeText FHIRDefinedType'list_VisionPrescription = "VisionPrescription"
 
data FHIRDefinedType = FHIRDefinedType
        { fHIRDefinedType_id :: Maybe String'primitive
        , fHIRDefinedType_value :: Maybe FHIRDefinedType'list
        , fHIRDefinedType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRDefinedType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRDefinedType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRDefinedType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRDefinedType_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRDefinedType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRDefinedType_extension x
            ]
instance Extension FHIRDefinedType Element where
    supertype (FHIRDefinedType a0 a1 e0) =
               Element a0 e0
 
data ContentType'list
    = ContentType'list_Xml
      -- ^ xml
    | ContentType'list_Json
      -- ^ json
    | ContentType'list_Ttl
      -- ^ ttl
    | ContentType'list_None
      -- ^ none
    deriving (Eq,Show,Enum)
instance SchemaType ContentType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContentType'list where
    acceptingParser =  do literal "xml"; return ContentType'list_Xml
                      `onFail` do literal "json"; return ContentType'list_Json
                      `onFail` do literal "ttl"; return ContentType'list_Ttl
                      `onFail` do literal "none"; return ContentType'list_None
                      
    simpleTypeText ContentType'list_Xml = "xml"
    simpleTypeText ContentType'list_Json = "json"
    simpleTypeText ContentType'list_Ttl = "ttl"
    simpleTypeText ContentType'list_None = "none"
 
data ContentType = ContentType
        { contentType_id :: Maybe String'primitive
        , contentType_value :: Maybe ContentType'list
        , contentType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContentType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContentType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContentType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contentType_id x
                       , maybe [] (toXMLAttribute "value") $ contentType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contentType_extension x
            ]
instance Extension ContentType Element where
    supertype (ContentType a0 a1 e0) =
               Element a0 e0
 
data AssertionDirectionType'list
    = AssertionDirectionType'list_Response
      -- ^ response
    | AssertionDirectionType'list_Request
      -- ^ request
    deriving (Eq,Show,Enum)
instance SchemaType AssertionDirectionType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionDirectionType'list where
    acceptingParser =  do literal "response"; return AssertionDirectionType'list_Response
                      `onFail` do literal "request"; return AssertionDirectionType'list_Request
                      
    simpleTypeText AssertionDirectionType'list_Response = "response"
    simpleTypeText AssertionDirectionType'list_Request = "request"
 
data AssertionDirectionType = AssertionDirectionType
        { assertionDirectionType_id :: Maybe String'primitive
        , assertionDirectionType_value :: Maybe AssertionDirectionType'list
        , assertionDirectionType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionDirectionType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionDirectionType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionDirectionType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionDirectionType_id x
                       , maybe [] (toXMLAttribute "value") $ assertionDirectionType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionDirectionType_extension x
            ]
instance Extension AssertionDirectionType Element where
    supertype (AssertionDirectionType a0 a1 e0) =
               Element a0 e0
 
data AssertionOperatorType'list
    = AssertionOperatorType'list_Equals
      -- ^ equals
    | AssertionOperatorType'list_NotEquals
      -- ^ notEquals
    | AssertionOperatorType'list_In
      -- ^ in
    | AssertionOperatorType'list_NotIn
      -- ^ notIn
    | AssertionOperatorType'list_GreaterThan
      -- ^ greaterThan
    | AssertionOperatorType'list_LessThan
      -- ^ lessThan
    | AssertionOperatorType'list_Empty
      -- ^ empty
    | AssertionOperatorType'list_NotEmpty
      -- ^ notEmpty
    | AssertionOperatorType'list_Contains
      -- ^ contains
    | AssertionOperatorType'list_NotContains
      -- ^ notContains
    | AssertionOperatorType'list_Eval
      -- ^ evaluate
    deriving (Eq,Show,Enum)
instance SchemaType AssertionOperatorType'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionOperatorType'list where
    acceptingParser =  do literal "equals"; return AssertionOperatorType'list_Equals
                      `onFail` do literal "notEquals"; return AssertionOperatorType'list_NotEquals
                      `onFail` do literal "in"; return AssertionOperatorType'list_In
                      `onFail` do literal "notIn"; return AssertionOperatorType'list_NotIn
                      `onFail` do literal "greaterThan"; return AssertionOperatorType'list_GreaterThan
                      `onFail` do literal "lessThan"; return AssertionOperatorType'list_LessThan
                      `onFail` do literal "empty"; return AssertionOperatorType'list_Empty
                      `onFail` do literal "notEmpty"; return AssertionOperatorType'list_NotEmpty
                      `onFail` do literal "contains"; return AssertionOperatorType'list_Contains
                      `onFail` do literal "notContains"; return AssertionOperatorType'list_NotContains
                      `onFail` do literal "eval"; return AssertionOperatorType'list_Eval
                      
    simpleTypeText AssertionOperatorType'list_Equals = "equals"
    simpleTypeText AssertionOperatorType'list_NotEquals = "notEquals"
    simpleTypeText AssertionOperatorType'list_In = "in"
    simpleTypeText AssertionOperatorType'list_NotIn = "notIn"
    simpleTypeText AssertionOperatorType'list_GreaterThan = "greaterThan"
    simpleTypeText AssertionOperatorType'list_LessThan = "lessThan"
    simpleTypeText AssertionOperatorType'list_Empty = "empty"
    simpleTypeText AssertionOperatorType'list_NotEmpty = "notEmpty"
    simpleTypeText AssertionOperatorType'list_Contains = "contains"
    simpleTypeText AssertionOperatorType'list_NotContains = "notContains"
    simpleTypeText AssertionOperatorType'list_Eval = "eval"
 
data AssertionOperatorType = AssertionOperatorType
        { assertionOperatorType_id :: Maybe String'primitive
        , assertionOperatorType_value :: Maybe AssertionOperatorType'list
        , assertionOperatorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionOperatorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionOperatorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionOperatorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionOperatorType_id x
                       , maybe [] (toXMLAttribute "value") $ assertionOperatorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionOperatorType_extension x
            ]
instance Extension AssertionOperatorType Element where
    supertype (AssertionOperatorType a0 a1 e0) =
               Element a0 e0
 
data AssertionResponseTypes'list
    = AssertionResponseTypes'list_Okay
      -- ^ okay
    | AssertionResponseTypes'list_Created
      -- ^ created
    | AssertionResponseTypes'list_NoContent
      -- ^ noContent
    | AssertionResponseTypes'list_NotModified
      -- ^ notModified
    | AssertionResponseTypes'list_Bad
      -- ^ bad
    | AssertionResponseTypes'list_Forbidden
      -- ^ forbidden
    | AssertionResponseTypes'list_NotFound
      -- ^ notFound
    | AssertionResponseTypes'list_MethodNotAllowed
      -- ^ methodNotAllowed
    | AssertionResponseTypes'list_Conflict
      -- ^ conflict
    | AssertionResponseTypes'list_Gone
      -- ^ gone
    | AssertionResponseTypes'list_PreconditionFailed
      -- ^ preconditionFailed
    | AssertionResponseTypes'list_Unprocessable
      -- ^ unprocessable
    deriving (Eq,Show,Enum)
instance SchemaType AssertionResponseTypes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionResponseTypes'list where
    acceptingParser =  do literal "okay"; return AssertionResponseTypes'list_Okay
                      `onFail` do literal "created"; return AssertionResponseTypes'list_Created
                      `onFail` do literal "noContent"; return AssertionResponseTypes'list_NoContent
                      `onFail` do literal "notModified"; return AssertionResponseTypes'list_NotModified
                      `onFail` do literal "bad"; return AssertionResponseTypes'list_Bad
                      `onFail` do literal "forbidden"; return AssertionResponseTypes'list_Forbidden
                      `onFail` do literal "notFound"; return AssertionResponseTypes'list_NotFound
                      `onFail` do literal "methodNotAllowed"; return AssertionResponseTypes'list_MethodNotAllowed
                      `onFail` do literal "conflict"; return AssertionResponseTypes'list_Conflict
                      `onFail` do literal "gone"; return AssertionResponseTypes'list_Gone
                      `onFail` do literal "preconditionFailed"; return AssertionResponseTypes'list_PreconditionFailed
                      `onFail` do literal "unprocessable"; return AssertionResponseTypes'list_Unprocessable
                      
    simpleTypeText AssertionResponseTypes'list_Okay = "okay"
    simpleTypeText AssertionResponseTypes'list_Created = "created"
    simpleTypeText AssertionResponseTypes'list_NoContent = "noContent"
    simpleTypeText AssertionResponseTypes'list_NotModified = "notModified"
    simpleTypeText AssertionResponseTypes'list_Bad = "bad"
    simpleTypeText AssertionResponseTypes'list_Forbidden = "forbidden"
    simpleTypeText AssertionResponseTypes'list_NotFound = "notFound"
    simpleTypeText AssertionResponseTypes'list_MethodNotAllowed = "methodNotAllowed"
    simpleTypeText AssertionResponseTypes'list_Conflict = "conflict"
    simpleTypeText AssertionResponseTypes'list_Gone = "gone"
    simpleTypeText AssertionResponseTypes'list_PreconditionFailed = "preconditionFailed"
    simpleTypeText AssertionResponseTypes'list_Unprocessable = "unprocessable"
 
data AssertionResponseTypes = AssertionResponseTypes
        { assertionResponseTypes_id :: Maybe String'primitive
        , assertionResponseTypes_value :: Maybe AssertionResponseTypes'list
        , assertionResponseTypes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionResponseTypes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionResponseTypes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionResponseTypes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionResponseTypes_id x
                       , maybe [] (toXMLAttribute "value") $ assertionResponseTypes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionResponseTypes_extension x
            ]
instance Extension AssertionResponseTypes Element where
    supertype (AssertionResponseTypes a0 a1 e0) =
               Element a0 e0
 
data TestScriptRequestMethodCode'list
    = TestScriptRequestMethodCode'list_Delete
      -- ^ DELETE
    | TestScriptRequestMethodCode'list_Get
      -- ^ GET
    | TestScriptRequestMethodCode'list_Options
      -- ^ OPTIONS
    | TestScriptRequestMethodCode'list_Patch
      -- ^ PATCH
    | TestScriptRequestMethodCode'list_Post
      -- ^ POST
    | TestScriptRequestMethodCode'list_Put
      -- ^ PUT
    deriving (Eq,Show,Enum)
instance SchemaType TestScriptRequestMethodCode'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestScriptRequestMethodCode'list where
    acceptingParser =  do literal "delete"; return TestScriptRequestMethodCode'list_Delete
                      `onFail` do literal "get"; return TestScriptRequestMethodCode'list_Get
                      `onFail` do literal "options"; return TestScriptRequestMethodCode'list_Options
                      `onFail` do literal "patch"; return TestScriptRequestMethodCode'list_Patch
                      `onFail` do literal "post"; return TestScriptRequestMethodCode'list_Post
                      `onFail` do literal "put"; return TestScriptRequestMethodCode'list_Put
                      
    simpleTypeText TestScriptRequestMethodCode'list_Delete = "delete"
    simpleTypeText TestScriptRequestMethodCode'list_Get = "get"
    simpleTypeText TestScriptRequestMethodCode'list_Options = "options"
    simpleTypeText TestScriptRequestMethodCode'list_Patch = "patch"
    simpleTypeText TestScriptRequestMethodCode'list_Post = "post"
    simpleTypeText TestScriptRequestMethodCode'list_Put = "put"
 
data TestScriptRequestMethodCode = TestScriptRequestMethodCode
        { testScriptRequestMethodCode_id :: Maybe String'primitive
        , testScriptRequestMethodCode_value :: Maybe TestScriptRequestMethodCode'list
        , testScriptRequestMethodCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRequestMethodCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestScriptRequestMethodCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestScriptRequestMethodCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRequestMethodCode_id x
                       , maybe [] (toXMLAttribute "value") $ testScriptRequestMethodCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRequestMethodCode_extension x
            ]
instance Extension TestScriptRequestMethodCode Element where
    supertype (TestScriptRequestMethodCode a0 a1 e0) =
               Element a0 e0
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
elementValueSet :: XMLParser ValueSet
elementValueSet = parseSchemaType "ValueSet"
elementToXMLValueSet :: ValueSet -> [Content ()]
elementToXMLValueSet = schemaTypeToXML "ValueSet"
 
data ValueSet = ValueSet
        { valueSet_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , valueSet_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , valueSet_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , valueSet_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , valueSet_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , valueSet_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , valueSet_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this value set 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this value set is 
          --   (or will be) published. The URL SHOULD include the major 
          --   version of the value set. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , valueSet_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this value set 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , valueSet_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   value set when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the value set author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , valueSet_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the value set. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , valueSet_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the value 
          --   set.
        , valueSet_status :: PublicationStatus
          -- ^ The status of this value set. Enables tracking the 
          --   life-cycle of the content.
        , valueSet_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this value set is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , valueSet_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the value set was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the value set changes. (e.g. the 'content 
          --   logical definition').
        , valueSet_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the value set.
        , valueSet_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , valueSet_description :: Maybe Markdown
          -- ^ A free text natural language description of the value set 
          --   from a consumer's perspective.
        , valueSet_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   value set instances.
        , valueSet_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the value set is 
          --   intended to be used.
        , valueSet_immutable :: Maybe Boolean
          -- ^ If this is set to 'true', then no new versions of the 
          --   content logical definition can be created. Note: Other 
          --   metadata might still change.
        , valueSet_purpose :: Maybe Markdown
          -- ^ Explaination of why this value set is needed and why it has 
          --   been designed as it has.
        , valueSet_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the value set and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the value set.
        , valueSet_extensible :: Maybe Boolean
          -- ^ Whether this is intended to be used with an extensible 
          --   binding or not.
        , valueSet_compose :: Maybe ValueSet'Compose
          -- ^ A set of criteria that define the content logical 
          --   definition of the value set by including or excluding codes 
          --   from outside this value set. This I also known as the 
          --   &quot;Content Logical Definition&quot; (CLD).
        , valueSet_expansion :: Maybe ValueSet'Expansion
          -- ^ A value set can also be &quot;expanded&quot;, where the 
          --   value set is turned into a simple collection of enumerated 
          --   codes. This element holds the expansion, if it has been 
          --   performed.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ValueSet
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "immutable")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "extensible")
            `apply` optional (parseSchemaType "compose")
            `apply` optional (parseSchemaType "expansion")
    schemaTypeToXML s x@ValueSet{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ valueSet_id x
            , maybe [] (schemaTypeToXML "meta") $ valueSet_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ valueSet_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ valueSet_language x
            , maybe [] (schemaTypeToXML "text") $ valueSet_text x
            , concatMap (schemaTypeToXML "contained") $ valueSet_contained x
            , concatMap (schemaTypeToXML "extension") $ valueSet_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ valueSet_url x
            , concatMap (schemaTypeToXML "identifier") $ valueSet_identifier x
            , maybe [] (schemaTypeToXML "version") $ valueSet_version x
            , maybe [] (schemaTypeToXML "name") $ valueSet_name x
            , maybe [] (schemaTypeToXML "title") $ valueSet_title x
            , schemaTypeToXML "status" $ valueSet_status x
            , maybe [] (schemaTypeToXML "experimental") $ valueSet_experimental x
            , maybe [] (schemaTypeToXML "date") $ valueSet_date x
            , maybe [] (schemaTypeToXML "publisher") $ valueSet_publisher x
            , concatMap (schemaTypeToXML "contact") $ valueSet_contact x
            , maybe [] (schemaTypeToXML "description") $ valueSet_description x
            , concatMap (schemaTypeToXML "useContext") $ valueSet_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ valueSet_jurisdiction x
            , maybe [] (schemaTypeToXML "immutable") $ valueSet_immutable x
            , maybe [] (schemaTypeToXML "purpose") $ valueSet_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ valueSet_copyright x
            , maybe [] (schemaTypeToXML "extensible") $ valueSet_extensible x
            , maybe [] (schemaTypeToXML "compose") $ valueSet_compose x
            , maybe [] (schemaTypeToXML "expansion") $ valueSet_expansion x
            ]
instance Extension ValueSet DomainResource where
    supertype (ValueSet e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ValueSet Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ValueSet -> DomainResource)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Compose = ValueSet'Compose
        { valueSet'Compose_id :: Maybe String'primitive
        , valueSet'Compose_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Compose_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Compose_lockedDate :: Maybe Date
          -- ^ If a locked date is defined, then the Content Logical 
          --   Definition must be evaluated using the current version as 
          --   of the locked date for referenced code system(s) and value 
          --   set instances where ValueSet.compose.include.version is not 
          --   defined.
        , valueSet'Compose_inactive :: Maybe Boolean
          -- ^ Whether inactive codes - codes that are not approved for 
          --   current use - are in the value set. If inactive = true, 
          --   inactive codes are to be included in the expansion, if 
          --   inactive = false, the inactive codes will not be included 
          --   in the expansion. If absent, the behavior is determined by 
          --   the implementation, or by the applicable ExpansionProfile 
          --   (but generally, inactive codes would be expected to be 
          --   included).
        , valueSet'Compose_include :: [ValueSet'Include]
          -- ^ Include one or more codes from a code system or other value 
          --   set(s).
        , valueSet'Compose_exclude :: [ValueSet'Include]
          -- ^ Exclude one or more codes from the value set based on code 
          --   system filters and/or other value sets.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Compose where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Compose a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "lockedDate")
            `apply` optional (parseSchemaType "inactive")
            `apply` many1 (parseSchemaType "include")
            `apply` many (parseSchemaType "exclude")
    schemaTypeToXML s x@ValueSet'Compose{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Compose_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Compose_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Compose_modifierExtension x
            , maybe [] (schemaTypeToXML "lockedDate") $ valueSet'Compose_lockedDate x
            , maybe [] (schemaTypeToXML "inactive") $ valueSet'Compose_inactive x
            , concatMap (schemaTypeToXML "include") $ valueSet'Compose_include x
            , concatMap (schemaTypeToXML "exclude") $ valueSet'Compose_exclude x
            ]
instance Extension ValueSet'Compose BackboneElement where
    supertype (ValueSet'Compose a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Compose Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Compose -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Include = ValueSet'Include
        { valueSet'Include_id :: Maybe String'primitive
        , valueSet'Include_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Include_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Include_system :: Maybe Uri
          -- ^ An absolute URI which is the code system from which the 
          --   selected codes come from.
        , valueSet'Include_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system that the codes are selected 
          --   from.
        , valueSet'Include_concept :: [ValueSet'Concept]
          -- ^ Specifies a concept to be included or excluded.
        , valueSet'Include_filter :: [ValueSet'Filter]
          -- ^ Select concepts by specify a matching criteria based on the 
          --   properties (including relationships) defined by the system. 
          --   If multiple filters are specified, they SHALL all be true.
        , valueSet'Include_valueSet :: [Uri]
          -- ^ Selects concepts found in this value set. This is an 
          --   absolute URI that is a reference to ValueSet.url.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Include where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Include a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "version")
            `apply` many (parseSchemaType "concept")
            `apply` many (parseSchemaType "filter")
            `apply` many (parseSchemaType "valueSet")
    schemaTypeToXML s x@ValueSet'Include{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Include_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Include_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Include_modifierExtension x
            , maybe [] (schemaTypeToXML "system") $ valueSet'Include_system x
            , maybe [] (schemaTypeToXML "version") $ valueSet'Include_version x
            , concatMap (schemaTypeToXML "concept") $ valueSet'Include_concept x
            , concatMap (schemaTypeToXML "filter") $ valueSet'Include_filter x
            , concatMap (schemaTypeToXML "valueSet") $ valueSet'Include_valueSet x
            ]
instance Extension ValueSet'Include BackboneElement where
    supertype (ValueSet'Include a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Include Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Include -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Concept = ValueSet'Concept
        { valueSet'Concept_id :: Maybe String'primitive
        , valueSet'Concept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Concept_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Concept_code :: Code
          -- ^ Specifies a code for the concept to be included or 
          --   excluded.
        , valueSet'Concept_display :: Maybe Xsd.XsdString
          -- ^ The text to display to the user for this concept in the 
          --   context of this valueset. If no display is provided, then 
          --   applications using the value set use the display specified 
          --   for the code by the system.
        , valueSet'Concept_designation :: [ValueSet'Designation]
          -- ^ Additional representations for this concept when used in 
          --   this value set - other languages, aliases, specialized 
          --   purposes, used for particular purposes, etc.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Concept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Concept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ValueSet'Concept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Concept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Concept_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Concept_modifierExtension x
            , schemaTypeToXML "code" $ valueSet'Concept_code x
            , maybe [] (schemaTypeToXML "display") $ valueSet'Concept_display x
            , concatMap (schemaTypeToXML "designation") $ valueSet'Concept_designation x
            ]
instance Extension ValueSet'Concept BackboneElement where
    supertype (ValueSet'Concept a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Concept Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Concept -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Designation = ValueSet'Designation
        { valueSet'Designation_id :: Maybe String'primitive
        , valueSet'Designation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Designation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Designation_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , valueSet'Designation_use :: Maybe Coding
          -- ^ A code that details how this designation would be used.
        , valueSet'Designation_value :: Xsd.XsdString
          -- ^ The text value for this designation.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Designation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Designation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ValueSet'Designation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Designation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Designation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Designation_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ valueSet'Designation_language x
            , maybe [] (schemaTypeToXML "use") $ valueSet'Designation_use x
            , schemaTypeToXML "value" $ valueSet'Designation_value x
            ]
instance Extension ValueSet'Designation BackboneElement where
    supertype (ValueSet'Designation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Designation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Designation -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Filter = ValueSet'Filter
        { valueSet'Filter_id :: Maybe String'primitive
        , valueSet'Filter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Filter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Filter_property :: Code
          -- ^ A code that identifies a property defined in the code 
          --   system.
        , valueSet'Filter_op :: FilterOperator
          -- ^ The kind of operation to perform as a part of the filter 
          --   criteria.
        , valueSet'Filter_value :: Code
          -- ^ The match value may be either a code defined by the system, 
          --   or a string value, which is a regex match on the literal 
          --   string of the property value when the operation is 'regex', 
          --   or one of the values (true and false), when the operation 
          --   is 'exists'.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Filter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Filter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "property"
            `apply` parseSchemaType "op"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ValueSet'Filter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Filter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Filter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Filter_modifierExtension x
            , schemaTypeToXML "property" $ valueSet'Filter_property x
            , schemaTypeToXML "op" $ valueSet'Filter_op x
            , schemaTypeToXML "value" $ valueSet'Filter_value x
            ]
instance Extension ValueSet'Filter BackboneElement where
    supertype (ValueSet'Filter a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Filter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Filter -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Expansion = ValueSet'Expansion
        { valueSet'Expansion_id :: Maybe String'primitive
        , valueSet'Expansion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Expansion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Expansion_identifier :: Uri
          -- ^ An identifier that uniquely identifies this expansion of 
          --   the valueset. Systems may re-use the same identifier as 
          --   long as the expansion and the definition remain the same, 
          --   but are not required to do so.
        , valueSet'Expansion_timestamp :: DateTime
          -- ^ The time at which the expansion was produced by the 
          --   expanding system.
        , valueSet'Expansion_total :: Maybe Integer
          -- ^ The total number of concepts in the expansion. If the 
          --   number of concept nodes in this resource is less than the 
          --   stated number, then the server can return more using the 
          --   offset parameter.
        , valueSet'Expansion_offset :: Maybe Integer
          -- ^ If paging is being used, the offset at which this resource 
          --   starts. I.e. this resource is a partial view into the 
          --   expansion. If paging is not being used, this element SHALL 
          --   not be present.
        , valueSet'Expansion_parameter :: [ValueSet'Parameter]
          -- ^ A parameter that controlled the expansion process. These 
          --   parameters may be used by users of expanded value sets to 
          --   check whether the expansion is suitable for a particular 
          --   purpose, or to pick the correct expansion.
        , valueSet'Expansion_contains :: [ValueSet'Contains]
          -- ^ The codes that are contained in the value set expansion.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Expansion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Expansion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "timestamp"
            `apply` optional (parseSchemaType "total")
            `apply` optional (parseSchemaType "offset")
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "contains")
    schemaTypeToXML s x@ValueSet'Expansion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Expansion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Expansion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Expansion_modifierExtension x
            , schemaTypeToXML "identifier" $ valueSet'Expansion_identifier x
            , schemaTypeToXML "timestamp" $ valueSet'Expansion_timestamp x
            , maybe [] (schemaTypeToXML "total") $ valueSet'Expansion_total x
            , maybe [] (schemaTypeToXML "offset") $ valueSet'Expansion_offset x
            , concatMap (schemaTypeToXML "parameter") $ valueSet'Expansion_parameter x
            , concatMap (schemaTypeToXML "contains") $ valueSet'Expansion_contains x
            ]
instance Extension ValueSet'Expansion BackboneElement where
    supertype (ValueSet'Expansion a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Expansion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Expansion -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Parameter = ValueSet'Parameter
        { valueSet'Parameter_id :: Maybe String'primitive
        , valueSet'Parameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Parameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Parameter_name :: Xsd.XsdString
          -- ^ The name of the parameter.
        , valueSet'Parameter_choice3 :: (Maybe (OneOf6 Xsd.XsdString Boolean Integer Decimal Uri Code))
          -- ^ The value of the parameter.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueInteger
          --   
          --   (4) valueDecimal
          --   
          --   (5) valueUri
          --   
          --   (6) valueCode
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Parameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Parameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf6 (parseSchemaType "valueString"))
                                     , ("Boolean", fmap TwoOf6 (parseSchemaType "valueBoolean"))
                                     , ("Integer", fmap ThreeOf6 (parseSchemaType "valueInteger"))
                                     , ("Decimal", fmap FourOf6 (parseSchemaType "valueDecimal"))
                                     , ("Uri", fmap FiveOf6 (parseSchemaType "valueUri"))
                                     , ("Code", fmap SixOf6 (parseSchemaType "valueCode"))
                                     ])
    schemaTypeToXML s x@ValueSet'Parameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Parameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Parameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Parameter_modifierExtension x
            , schemaTypeToXML "name" $ valueSet'Parameter_name x
            , maybe [] (foldOneOf6  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueBoolean")
                                    (schemaTypeToXML "valueInteger")
                                    (schemaTypeToXML "valueDecimal")
                                    (schemaTypeToXML "valueUri")
                                    (schemaTypeToXML "valueCode")
                                   ) $ valueSet'Parameter_choice3 x
            ]
instance Extension ValueSet'Parameter BackboneElement where
    supertype (ValueSet'Parameter a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Parameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Parameter -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSet'Contains = ValueSet'Contains
        { valueSet'Contains_id :: Maybe String'primitive
        , valueSet'Contains_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet'Contains_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet'Contains_system :: Maybe Uri
          -- ^ An absolute URI which is the code system in which the code 
          --   for this item in the expansion is defined.
        , valueSet'Contains_abstract :: Maybe Boolean
          -- ^ If true, this entry is included in the expansion for 
          --   navigational purposes, and the user cannot select the code 
          --   directly as a proper value.
        , valueSet'Contains_inactive :: Maybe Boolean
          -- ^ If the concept is inactive in the code system that defines 
          --   it. Inactive codes are those that are no longer to be used, 
          --   but are maintained by the code system for understanding 
          --   legacy data.
        , valueSet'Contains_version :: Maybe Xsd.XsdString
          -- ^ The version of this code system that defined this code 
          --   and/or display. This should only be used with code systems 
          --   that do not enforce concept permanence.
        , valueSet'Contains_code :: Maybe Code
          -- ^ The code for this item in the expansion hierarchy. If this 
          --   code is missing the entry in the hierarchy is a place 
          --   holder (abstract) and does not represent a valid code in 
          --   the value set.
        , valueSet'Contains_display :: Maybe Xsd.XsdString
          -- ^ The recommended display for this item in the expansion.
        , valueSet'Contains_designation :: [ValueSet'Designation]
          -- ^ Additional representations for this item - other languages, 
          --   aliases, specialized purposes, used for particular 
          --   purposes, etc. These are relevant when the conditions of 
          --   the expansion do not fix to a single correct 
          --   representation.
        , valueSet'Contains_contains :: [ValueSet'Contains]
          -- ^ Other codes and entries contained under this entry in the 
          --   hierarchy.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet'Contains where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSet'Contains a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "abstract")
            `apply` optional (parseSchemaType "inactive")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "designation")
            `apply` many (parseSchemaType "contains")
    schemaTypeToXML s x@ValueSet'Contains{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSet'Contains_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSet'Contains_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet'Contains_modifierExtension x
            , maybe [] (schemaTypeToXML "system") $ valueSet'Contains_system x
            , maybe [] (schemaTypeToXML "abstract") $ valueSet'Contains_abstract x
            , maybe [] (schemaTypeToXML "inactive") $ valueSet'Contains_inactive x
            , maybe [] (schemaTypeToXML "version") $ valueSet'Contains_version x
            , maybe [] (schemaTypeToXML "code") $ valueSet'Contains_code x
            , maybe [] (schemaTypeToXML "display") $ valueSet'Contains_display x
            , concatMap (schemaTypeToXML "designation") $ valueSet'Contains_designation x
            , concatMap (schemaTypeToXML "contains") $ valueSet'Contains_contains x
            ]
instance Extension ValueSet'Contains BackboneElement where
    supertype (ValueSet'Contains a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension ValueSet'Contains Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSet'Contains -> BackboneElement)
              
 
-- | An authorization for the supply of glasses and/or contact 
--   lenses to a patient.
elementVisionPrescription :: XMLParser VisionPrescription
elementVisionPrescription = parseSchemaType "VisionPrescription"
elementToXMLVisionPrescription :: VisionPrescription -> [Content ()]
elementToXMLVisionPrescription = schemaTypeToXML "VisionPrescription"
 
data VisionPrescription = VisionPrescription
        { visionPrescription_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , visionPrescription_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , visionPrescription_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , visionPrescription_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , visionPrescription_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , visionPrescription_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , visionPrescription_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , visionPrescription_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , visionPrescription_identifier :: [Identifier]
          -- ^ Business identifier which may be used by other parties to 
          --   reference or identify the prescription.
        , visionPrescription_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , visionPrescription_patient :: Maybe Reference
          -- ^ A link to a resource representing the person to whom the 
          --   vision products will be supplied.
        , visionPrescription_encounter :: Maybe Reference
          -- ^ A link to a resource that identifies the particular 
          --   occurrence of contact between patient and health care 
          --   provider.
        , visionPrescription_dateWritten :: Maybe DateTime
          -- ^ The date (and perhaps time) when the prescription was 
          --   written.
        , visionPrescription_prescriber :: Maybe Reference
          -- ^ The healthcare professional responsible for authorizing the 
          --   prescription.
        , visionPrescription_choice14 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Can be the reason or the indication for writing the 
          --   prescription.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , visionPrescription_dispense :: [VisionPrescription'Dispense]
          -- ^ Deals with details of the dispense part of the supply 
          --   specification.
        }
        deriving (Eq,Show)
instance SchemaType VisionPrescription where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return VisionPrescription
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "dateWritten")
            `apply` optional (parseSchemaType "prescriber")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "dispense")
    schemaTypeToXML s x@VisionPrescription{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ visionPrescription_id x
            , maybe [] (schemaTypeToXML "meta") $ visionPrescription_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ visionPrescription_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ visionPrescription_language x
            , maybe [] (schemaTypeToXML "text") $ visionPrescription_text x
            , concatMap (schemaTypeToXML "contained") $ visionPrescription_contained x
            , concatMap (schemaTypeToXML "extension") $ visionPrescription_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ visionPrescription_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ visionPrescription_identifier x
            , maybe [] (schemaTypeToXML "status") $ visionPrescription_status x
            , maybe [] (schemaTypeToXML "patient") $ visionPrescription_patient x
            , maybe [] (schemaTypeToXML "encounter") $ visionPrescription_encounter x
            , maybe [] (schemaTypeToXML "dateWritten") $ visionPrescription_dateWritten x
            , maybe [] (schemaTypeToXML "prescriber") $ visionPrescription_prescriber x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ visionPrescription_choice14 x
            , concatMap (schemaTypeToXML "dispense") $ visionPrescription_dispense x
            ]
instance Extension VisionPrescription DomainResource where
    supertype (VisionPrescription e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension VisionPrescription Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: VisionPrescription -> DomainResource)
              
 
-- | An authorization for the supply of glasses and/or contact 
--   lenses to a patient.
data VisionPrescription'Dispense = VisionPrescription'Dispense
        { visionPrescription'Dispense_id :: Maybe String'primitive
        , visionPrescription'Dispense_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , visionPrescription'Dispense_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , visionPrescription'Dispense_product :: Maybe CodeableConcept
          -- ^ Identifies the type of vision correction product which is 
          --   required for the patient.
        , visionPrescription'Dispense_eye :: Maybe VisionEyes
          -- ^ The eye for which the lens applies.
        , visionPrescription'Dispense_sphere :: Maybe Decimal
          -- ^ Lens power measured in diopters (0.25 units).
        , visionPrescription'Dispense_cylinder :: Maybe Decimal
          -- ^ Power adjustment for astigmatism measured in diopters (0.25 
          --   units).
        , visionPrescription'Dispense_axis :: Maybe Integer
          -- ^ Adjustment for astigmatism measured in integer degrees.
        , visionPrescription'Dispense_prism :: Maybe Decimal
          -- ^ Amount of prism to compensate for eye alignment in 
          --   fractional units.
        , visionPrescription'Dispense_base :: Maybe VisionBase
          -- ^ The relative base, or reference lens edge, for the prism.
        , visionPrescription'Dispense_add :: Maybe Decimal
          -- ^ Power adjustment for multifocal lenses measured in diopters 
          --   (0.25 units).
        , visionPrescription'Dispense_power :: Maybe Decimal
          -- ^ Contact lens power measured in diopters (0.25 units).
        , visionPrescription'Dispense_backCurve :: Maybe Decimal
          -- ^ Back curvature measured in millimeters.
        , visionPrescription'Dispense_diameter :: Maybe Decimal
          -- ^ Contact lens diameter measured in millimeters.
        , visionPrescription'Dispense_duration :: Maybe Quantity
          -- ^ The recommended maximum wear period for the lens.
        , visionPrescription'Dispense_color :: Maybe Xsd.XsdString
          -- ^ Special color or pattern.
        , visionPrescription'Dispense_brand :: Maybe Xsd.XsdString
          -- ^ Brand recommendations or restrictions.
        , visionPrescription'Dispense_note :: [Annotation]
          -- ^ Notes for special requirements such as coatings and lens 
          --   materials.
        }
        deriving (Eq,Show)
instance SchemaType VisionPrescription'Dispense where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (VisionPrescription'Dispense a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "product")
            `apply` optional (parseSchemaType "eye")
            `apply` optional (parseSchemaType "sphere")
            `apply` optional (parseSchemaType "cylinder")
            `apply` optional (parseSchemaType "axis")
            `apply` optional (parseSchemaType "prism")
            `apply` optional (parseSchemaType "base")
            `apply` optional (parseSchemaType "add")
            `apply` optional (parseSchemaType "power")
            `apply` optional (parseSchemaType "backCurve")
            `apply` optional (parseSchemaType "diameter")
            `apply` optional (parseSchemaType "duration")
            `apply` optional (parseSchemaType "color")
            `apply` optional (parseSchemaType "brand")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@VisionPrescription'Dispense{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionPrescription'Dispense_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionPrescription'Dispense_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ visionPrescription'Dispense_modifierExtension x
            , maybe [] (schemaTypeToXML "product") $ visionPrescription'Dispense_product x
            , maybe [] (schemaTypeToXML "eye") $ visionPrescription'Dispense_eye x
            , maybe [] (schemaTypeToXML "sphere") $ visionPrescription'Dispense_sphere x
            , maybe [] (schemaTypeToXML "cylinder") $ visionPrescription'Dispense_cylinder x
            , maybe [] (schemaTypeToXML "axis") $ visionPrescription'Dispense_axis x
            , maybe [] (schemaTypeToXML "prism") $ visionPrescription'Dispense_prism x
            , maybe [] (schemaTypeToXML "base") $ visionPrescription'Dispense_base x
            , maybe [] (schemaTypeToXML "add") $ visionPrescription'Dispense_add x
            , maybe [] (schemaTypeToXML "power") $ visionPrescription'Dispense_power x
            , maybe [] (schemaTypeToXML "backCurve") $ visionPrescription'Dispense_backCurve x
            , maybe [] (schemaTypeToXML "diameter") $ visionPrescription'Dispense_diameter x
            , maybe [] (schemaTypeToXML "duration") $ visionPrescription'Dispense_duration x
            , maybe [] (schemaTypeToXML "color") $ visionPrescription'Dispense_color x
            , maybe [] (schemaTypeToXML "brand") $ visionPrescription'Dispense_brand x
            , concatMap (schemaTypeToXML "note") $ visionPrescription'Dispense_note x
            ]
instance Extension VisionPrescription'Dispense BackboneElement where
    supertype (VisionPrescription'Dispense a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension VisionPrescription'Dispense Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: VisionPrescription'Dispense -> BackboneElement)
              
 
data VisionBase'list
    = VisionBase'list_Up
      -- ^ Up
    | VisionBase'list_Down
      -- ^ Down
    | VisionBase'list_In
      -- ^ In
    | VisionBase'list_Out
      -- ^ Out
    deriving (Eq,Show,Enum)
instance SchemaType VisionBase'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType VisionBase'list where
    acceptingParser =  do literal "up"; return VisionBase'list_Up
                      `onFail` do literal "down"; return VisionBase'list_Down
                      `onFail` do literal "in"; return VisionBase'list_In
                      `onFail` do literal "out"; return VisionBase'list_Out
                      
    simpleTypeText VisionBase'list_Up = "up"
    simpleTypeText VisionBase'list_Down = "down"
    simpleTypeText VisionBase'list_In = "in"
    simpleTypeText VisionBase'list_Out = "out"
 
data VisionBase = VisionBase
        { visionBase_id :: Maybe String'primitive
        , visionBase_value :: Maybe VisionBase'list
        , visionBase_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType VisionBase where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (VisionBase a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@VisionBase{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionBase_id x
                       , maybe [] (toXMLAttribute "value") $ visionBase_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionBase_extension x
            ]
instance Extension VisionBase Element where
    supertype (VisionBase a0 a1 e0) =
               Element a0 e0
 
data VisionEyes'list
    = VisionEyes'list_Right
      -- ^ Right Eye
    | VisionEyes'list_Left
      -- ^ Left Eye
    deriving (Eq,Show,Enum)
instance SchemaType VisionEyes'list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType VisionEyes'list where
    acceptingParser =  do literal "right"; return VisionEyes'list_Right
                      `onFail` do literal "left"; return VisionEyes'list_Left
                      
    simpleTypeText VisionEyes'list_Right = "right"
    simpleTypeText VisionEyes'list_Left = "left"
 
data VisionEyes = VisionEyes
        { visionEyes_id :: Maybe String'primitive
        , visionEyes_value :: Maybe VisionEyes'list
        , visionEyes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType VisionEyes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (VisionEyes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@VisionEyes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionEyes_id x
                       , maybe [] (toXMLAttribute "value") $ visionEyes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionEyes_extension x
            ]
instance Extension VisionEyes Element where
    supertype (VisionEyes a0 a1 e0) =
               Element a0 e0
