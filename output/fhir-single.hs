{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}
{-# OPTIONS_GHC -fno-warn-duplicate-exports #-}
module Xsd_fhir_singlexsd
  ( module Xsd_fhir_singlexsd
  ) where
 
import Text.XML.HaXml.Schema.Schema (SchemaType(..),SimpleType(..),Extension(..),Restricts(..))
import Text.XML.HaXml.Schema.Schema as Schema
import Text.XML.HaXml.OneOfN
import qualified Text.XML.HaXml.Schema.PrimitiveTypes as Xs
import Xmlxsd as Xml
import Fhir_xhtmlxsd as Xhtml
 
-- Some hs-boot imports are required, for fwd-declaring types.
 
newtype Date_primitive = Date_primitive UnknownSimple deriving (Eq,Show)
instance Restricts Date_primitive UnknownSimple where
    restricts (Date_primitive x) = x
instance SchemaType Date_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Date_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Date_primitive where
    acceptingParser = fmap Date_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1]))?)?)
    simpleTypeText (Date_primitive x) = simpleTypeText x
 
data Date = Date
        { date_id :: Maybe String_primitive
        , date_value :: Maybe Date_primitive
        , date_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Date where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Date a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Date{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ date_id x
                       , maybe [] (toXMLAttribute "value") $ date_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ date_extension x
            ]
instance Extension Date Element where
    supertype (Date a0 a1 e0) =
               Element a0 e0
 
newtype DateTime_primitive = DateTime_primitive UnknownSimple deriving (Eq,Show)
instance Restricts DateTime_primitive UnknownSimple where
    restricts (DateTime_primitive x) = x
instance SchemaType DateTime_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (DateTime_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DateTime_primitive where
    acceptingParser = fmap DateTime_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)?)?)?)
    simpleTypeText (DateTime_primitive x) = simpleTypeText x
 
data DateTime = DateTime
        { dateTime_id :: Maybe String_primitive
        , dateTime_value :: Maybe DateTime_primitive
        , dateTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DateTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DateTime a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DateTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dateTime_id x
                       , maybe [] (toXMLAttribute "value") $ dateTime_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dateTime_extension x
            ]
instance Extension DateTime Element where
    supertype (DateTime a0 a1 e0) =
               Element a0 e0
 
newtype Code_primitive = Code_primitive Xs.Token deriving (Eq,Show)
instance Restricts Code_primitive Xs.Token where
    restricts (Code_primitive x) = x
instance SchemaType Code_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Code_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Code_primitive where
    acceptingParser = fmap Code_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [^\s]+([\s]?[^\s]+)*)
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Code_primitive x) = simpleTypeText x
 
data Code = Code
        { code_id :: Maybe String_primitive
        , code_value :: Maybe Code_primitive
        , code_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Code where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Code a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Code{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ code_id x
                       , maybe [] (toXMLAttribute "value") $ code_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ code_extension x
            ]
instance Extension Code Element where
    supertype (Code a0 a1 e0) =
               Element a0 e0
 
newtype String_primitive = String_primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts String_primitive Xsd.XsdString where
    restricts (String_primitive x) = x
instance SchemaType String_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (String_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType String_primitive where
    acceptingParser = fmap String_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (String_primitive x) = simpleTypeText x
 
data Xsd.XsdString = Xsd.XsdString
        { string_id :: Maybe String_primitive
        , string_value :: Maybe String_primitive
        , string_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Xsd.XsdString where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Xsd.XsdString a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Xsd.XsdString{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ string_id x
                       , maybe [] (toXMLAttribute "value") $ string_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ string_extension x
            ]
instance Extension Xsd.XsdString Element where
    supertype (Xsd.XsdString a0 a1 e0) =
               Element a0 e0
 
newtype Integer_primitive = Integer_primitive Xs.Int deriving (Eq,Show)
instance Restricts Integer_primitive Xs.Int where
    restricts (Integer_primitive x) = x
instance SchemaType Integer_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Integer_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Integer_primitive where
    acceptingParser = fmap Integer_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?([0]|([1-9][0-9]*)))
    simpleTypeText (Integer_primitive x) = simpleTypeText x
 
data Integer = Integer
        { integer_id :: Maybe String_primitive
        , integer_value :: Maybe Integer_primitive
        , integer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Integer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Integer a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Integer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ integer_id x
                       , maybe [] (toXMLAttribute "value") $ integer_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ integer_extension x
            ]
instance Extension Integer Element where
    supertype (Integer a0 a1 e0) =
               Element a0 e0
 
newtype Oid_primitive = Oid_primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Oid_primitive Xs.AnyURI where
    restricts (Oid_primitive x) = x
instance SchemaType Oid_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Oid_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Oid_primitive where
    acceptingParser = fmap Oid_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern urn:oid:(0|[1-9][0-9]*)(\.(0|[1-9][0-9]*))*)
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Oid_primitive x) = simpleTypeText x
 
data Oid = Oid
        { oid_id :: Maybe String_primitive
        , oid_value :: Maybe Oid_primitive
        , oid_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Oid where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Oid a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Oid{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ oid_id x
                       , maybe [] (toXMLAttribute "value") $ oid_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ oid_extension x
            ]
instance Extension Oid Element where
    supertype (Oid a0 a1 e0) =
               Element a0 e0
 
newtype Uri_primitive = Uri_primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Uri_primitive Xs.AnyURI where
    restricts (Uri_primitive x) = x
instance SchemaType Uri_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Uri_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Uri_primitive where
    acceptingParser = fmap Uri_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Uri_primitive x) = simpleTypeText x
 
data Uri = Uri
        { uri_id :: Maybe String_primitive
        , uri_value :: Maybe Uri_primitive
        , uri_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Uri where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Uri a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Uri{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uri_id x
                       , maybe [] (toXMLAttribute "value") $ uri_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uri_extension x
            ]
instance Extension Uri Element where
    supertype (Uri a0 a1 e0) =
               Element a0 e0
 
newtype Uuid_primitive = Uuid_primitive Xs.AnyURI deriving (Eq,Show)
instance Restricts Uuid_primitive Xs.AnyURI where
    restricts (Uuid_primitive x) = x
instance SchemaType Uuid_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Uuid_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Uuid_primitive where
    acceptingParser = fmap Uuid_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Uuid_primitive x) = simpleTypeText x
 
data Uuid = Uuid
        { uuid_id :: Maybe String_primitive
        , uuid_value :: Maybe Uuid_primitive
        , uuid_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Uuid where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Uuid a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Uuid{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uuid_id x
                       , maybe [] (toXMLAttribute "value") $ uuid_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uuid_extension x
            ]
instance Extension Uuid Element where
    supertype (Uuid a0 a1 e0) =
               Element a0 e0
 
newtype Instant_primitive = Instant_primitive Xs.DateTime deriving (Eq,Show)
instance Restricts Instant_primitive Xs.DateTime where
    restricts (Instant_primitive x) = x
instance SchemaType Instant_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Instant_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Instant_primitive where
    acceptingParser = fmap Instant_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Instant_primitive x) = simpleTypeText x
 
data Instant = Instant
        { instant_id :: Maybe String_primitive
        , instant_value :: Maybe Instant_primitive
        , instant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Instant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Instant a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Instant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ instant_id x
                       , maybe [] (toXMLAttribute "value") $ instant_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ instant_extension x
            ]
instance Extension Instant Element where
    supertype (Instant a0 a1 e0) =
               Element a0 e0
 
newtype Boolean_primitive = Boolean_primitive Xsd.Boolean deriving (Eq,Show)
instance Restricts Boolean_primitive Xsd.Boolean where
    restricts (Boolean_primitive x) = x
instance SchemaType Boolean_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Boolean_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Boolean_primitive where
    acceptingParser = fmap Boolean_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Boolean_primitive x) = simpleTypeText x
 
data Boolean = Boolean
        { boolean_id :: Maybe String_primitive
        , boolean_value :: Maybe Boolean_primitive
        , boolean_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Boolean where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Boolean a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Boolean{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ boolean_id x
                       , maybe [] (toXMLAttribute "value") $ boolean_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ boolean_extension x
            ]
instance Extension Boolean Element where
    supertype (Boolean a0 a1 e0) =
               Element a0 e0
 
newtype Base64Binary_primitive = Base64Binary_primitive Xs.Base64Binary deriving (Eq,Show)
instance Restricts Base64Binary_primitive Xs.Base64Binary where
    restricts (Base64Binary_primitive x) = x
instance SchemaType Base64Binary_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Base64Binary_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Base64Binary_primitive where
    acceptingParser = fmap Base64Binary_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    simpleTypeText (Base64Binary_primitive x) = simpleTypeText x
 
data Base64Binary = Base64Binary
        { base64Binary_id :: Maybe String_primitive
        , base64Binary_value :: Maybe Base64Binary_primitive
        , base64Binary_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Base64Binary where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Base64Binary a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Base64Binary{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ base64Binary_id x
                       , maybe [] (toXMLAttribute "value") $ base64Binary_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ base64Binary_extension x
            ]
instance Extension Base64Binary Element where
    supertype (Base64Binary a0 a1 e0) =
               Element a0 e0
 
newtype UnsignedInt_primitive = UnsignedInt_primitive Xs.NonNegativeInteger deriving (Eq,Show)
instance Restricts UnsignedInt_primitive Xs.NonNegativeInteger where
    restricts (UnsignedInt_primitive x) = x
instance SchemaType UnsignedInt_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (UnsignedInt_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnsignedInt_primitive where
    acceptingParser = fmap UnsignedInt_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [0]|([1-9][0-9]*))
    simpleTypeText (UnsignedInt_primitive x) = simpleTypeText x
 
data UnsignedInt = UnsignedInt
        { unsignedInt_id :: Maybe String_primitive
        , unsignedInt_value :: Maybe UnsignedInt_primitive
        , unsignedInt_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnsignedInt where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnsignedInt a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnsignedInt{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unsignedInt_id x
                       , maybe [] (toXMLAttribute "value") $ unsignedInt_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unsignedInt_extension x
            ]
instance Extension UnsignedInt Element where
    supertype (UnsignedInt a0 a1 e0) =
               Element a0 e0
 
newtype Markdown_primitive = Markdown_primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts Markdown_primitive Xsd.XsdString where
    restricts (Markdown_primitive x) = x
instance SchemaType Markdown_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Markdown_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Markdown_primitive where
    acceptingParser = fmap Markdown_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (StrLength (Occurs (Just 1) Nothing))
    simpleTypeText (Markdown_primitive x) = simpleTypeText x
 
data Markdown = Markdown
        { markdown_id :: Maybe String_primitive
        , markdown_value :: Maybe Markdown_primitive
        , markdown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Markdown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Markdown a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Markdown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ markdown_id x
                       , maybe [] (toXMLAttribute "value") $ markdown_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ markdown_extension x
            ]
instance Extension Markdown Element where
    supertype (Markdown a0 a1 e0) =
               Element a0 e0
 
newtype Time_primitive = Time_primitive Xs.Time deriving (Eq,Show)
instance Restricts Time_primitive Xs.Time where
    restricts (Time_primitive x) = x
instance SchemaType Time_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Time_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Time_primitive where
    acceptingParser = fmap Time_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern ([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?)
    simpleTypeText (Time_primitive x) = simpleTypeText x
 
data Time = Time
        { time_id :: Maybe String_primitive
        , time_value :: Maybe Time_primitive
        , time_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Time where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Time a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Time{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ time_id x
                       , maybe [] (toXMLAttribute "value") $ time_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ time_extension x
            ]
instance Extension Time Element where
    supertype (Time a0 a1 e0) =
               Element a0 e0
 
newtype Id_primitive = Id_primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts Id_primitive Xsd.XsdString where
    restricts (Id_primitive x) = x
instance SchemaType Id_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Id_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Id_primitive where
    acceptingParser = fmap Id_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [A-Za-z0-9\-\.]{1,64})
    --      (StrLength (Occurs (Just 1) (Just 64)))
    simpleTypeText (Id_primitive x) = simpleTypeText x
 
data Id = Id
        { id_id :: Maybe String_primitive
        , id_value :: Maybe Id_primitive
        , id_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Id where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Id a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Id{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ id_id x
                       , maybe [] (toXMLAttribute "value") $ id_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ id_extension x
            ]
instance Extension Id Element where
    supertype (Id a0 a1 e0) =
               Element a0 e0
 
newtype PositiveInt_primitive = PositiveInt_primitive Xs.PositiveInteger deriving (Eq,Show)
instance Restricts PositiveInt_primitive Xs.PositiveInteger where
    restricts (PositiveInt_primitive x) = x
instance SchemaType PositiveInt_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (PositiveInt_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PositiveInt_primitive where
    acceptingParser = fmap PositiveInt_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern [1-9][0-9]*)
    simpleTypeText (PositiveInt_primitive x) = simpleTypeText x
 
data PositiveInt = PositiveInt
        { positiveInt_id :: Maybe String_primitive
        , positiveInt_value :: Maybe PositiveInt_primitive
        , positiveInt_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PositiveInt where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PositiveInt a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PositiveInt{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ positiveInt_id x
                       , maybe [] (toXMLAttribute "value") $ positiveInt_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ positiveInt_extension x
            ]
instance Extension PositiveInt Element where
    supertype (PositiveInt a0 a1 e0) =
               Element a0 e0
 
newtype Decimal_primitive = Decimal_primitive Xsd.Decimal deriving (Eq,Show)
instance Restricts Decimal_primitive Xsd.Decimal where
    restricts (Decimal_primitive x) = x
instance SchemaType Decimal_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (Decimal_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Decimal_primitive where
    acceptingParser = fmap Decimal_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern -?([0]|([1-9][0-9]*))(\.[0-9]+)?)
    simpleTypeText (Decimal_primitive x) = simpleTypeText x
 
data Decimal = Decimal
        { decimal_id :: Maybe String_primitive
        , decimal_value :: Maybe Decimal_primitive
        , decimal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Decimal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Decimal a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Decimal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ decimal_id x
                       , maybe [] (toXMLAttribute "value") $ decimal_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ decimal_extension x
            ]
instance Extension Decimal Element where
    supertype (Decimal a0 a1 e0) =
               Element a0 e0
 
data ResourceContainer = ResourceContainer
        { resourceContainer_choice0 :: OneOf117 Account ActivityDefinition AdverseEvent AllergyIntolerance Appointment AppointmentResponse AuditEvent Basic Binary BodySite Bundle CapabilityStatement CarePlan CareTeam ChargeItem Claim ClaimResponse ClinicalImpression CodeSystem Communication CommunicationRequest CompartmentDefinition Composition ConceptMap Condition Consent Contract Coverage DataElement DetectedIssue Device DeviceComponent DeviceMetric DeviceRequest DeviceUseStatement DiagnosticReport DocumentManifest DocumentReference EligibilityRequest EligibilityResponse Encounter Endpoint EnrollmentRequest EnrollmentResponse EpisodeOfCare ExpansionProfile ExplanationOfBenefit FamilyMemberHistory Flag Goal GraphDefinition Group GuidanceResponse HealthcareService ImagingManifest ImagingStudy Immunization ImmunizationRecommendation ImplementationGuide Library Linkage List Location Measure MeasureReport Media Medication MedicationAdministration MedicationDispense MedicationRequest MedicationStatement MessageDefinition MessageHeader NamingSystem NutritionOrder Observation OperationDefinition OperationOutcome Organization Patient PaymentNotice PaymentReconciliation Person PlanDefinition Practitioner PractitionerRole Procedure ProcedureRequest ProcessRequest ProcessResponse Provenance Questionnaire QuestionnaireResponse ReferralRequest RelatedPerson RequestGroup ResearchStudy ResearchSubject RiskAssessment Schedule SearchParameter Sequence ServiceDefinition Slot Specimen StructureDefinition StructureMap Subscription Substance SupplyDelivery SupplyRequest Task TestReport TestScript ValueSet VisionPrescription Parameters
          -- ^ Choice between:
          --   
          --   (1) A financial tool for tracking value accrued for a 
          --   particular purpose. In the healthcare field, used to 
          --   track charges for a patient, cost centers, etc.
          --   
          --   (2) This resource allows for the definition of some 
          --   activity to be performed, independent of a particular 
          --   patient, practitioner, or other performance context.
          --   
          --   (3) Actual or potential/avoided event causing unintended 
          --   physical injury resulting from or contributed to by 
          --   medical care, a research study or other healthcare 
          --   setting factors that requires additional monitoring, 
          --   treatment, or hospitalization, or that results in 
          --   death.
          --   
          --   (4) Risk of harmful or undesirable, physiological response 
          --   which is unique to an individual and associated with 
          --   exposure to a substance.
          --   
          --   (5) A booking of a healthcare event among patient(s), 
          --   practitioner(s), related person(s) and/or device(s) for 
          --   a specific date/time. This may result in one or more 
          --   Encounter(s).
          --   
          --   (6) A reply to an appointment request for a patient and/or 
          --   practitioner(s), such as a confirmation or rejection.
          --   
          --   (7) A record of an event made for purposes of maintaining a 
          --   security log. Typical uses include detection of 
          --   intrusion attempts and monitoring for inappropriate 
          --   usage.
          --   
          --   (8) Basic is used for handling concepts not yet defined in 
          --   FHIR, narrative-only resources that don't map to an 
          --   existing resource, and custom resources not appropriate 
          --   for inclusion in the FHIR specification.
          --   
          --   (9) A binary resource can contain any content, whether 
          --   text, image, pdf, zip archive, etc.
          --   
          --   (10) Record details about the anatomical location of a 
          --   specimen or body part. This resource may be used when a 
          --   coded concept does not provide the necessary detail 
          --   needed for the use case.
          --   
          --   (11) A container for a collection of resources.
          --   
          --   (12) A Capability Statement documents a set of capabilities 
          --   (behaviors) of a FHIR Server that may be used as a 
          --   statement of actual server functionality or a statement 
          --   of required or desired server implementation.
          --   
          --   (13) Describes the intention of how one or more 
          --   practitioners intend to deliver care for a particular 
          --   patient, group or community for a period of time, 
          --   possibly limited to care for a specific condition or 
          --   set of conditions.
          --   
          --   (14) The Care Team includes all the people and organizations 
          --   who plan to participate in the coordination and 
          --   delivery of care for a patient.
          --   
          --   (15) The resource ChargeItem describes the provision of 
          --   healthcare provider products for a certain patient, 
          --   therefore referring not only to the product, but 
          --   containing in addition details of the provision, like 
          --   date, time, amounts and participating organizations and 
          --   persons. Main Usage of the ChargeItem is to enable the 
          --   billing process and internal cost allocation.
          --   
          --   (16) A provider issued list of services and products 
          --   provided, or to be provided, to a patient which is 
          --   provided to an insurer for payment recovery.
          --   
          --   (17) This resource provides the adjudication details from 
          --   the processing of a Claim resource.
          --   
          --   (18) A record of a clinical assessment performed to 
          --   determine what problem(s) may affect the patient and 
          --   before planning the treatments or management strategies 
          --   that are best to manage a patient's condition. 
          --   Assessments are often 1:1 with a clinical consultation 
          --   / encounter, but this varies greatly depending on the 
          --   clinical workflow. This resource is called 
          --   &quot;ClinicalImpression&quot; rather than 
          --   &quot;ClinicalAssessment&quot; to avoid confusion with 
          --   the recording of assessment tools such as Apgar score.
          --   
          --   (19) A code system resource specifies a set of codes drawn 
          --   from one or more code systems.
          --   
          --   (20) An occurrence of information being transmitted; e.g. an 
          --   alert that was sent to a responsible provider, a public 
          --   health agency was notified about a reportable 
          --   condition.
          --   
          --   (21) A request to convey information; e.g. the CDS system 
          --   proposes that an alert be sent to a responsible 
          --   provider, the CDS system proposes that the public 
          --   health agency be notified about a reportable condition.
          --   
          --   (22) A compartment definition that defines how resources are 
          --   accessed on a server.
          --   
          --   (23) A set of healthcare-related information that is 
          --   assembled together into a single logical document that 
          --   provides a single coherent statement of meaning, 
          --   establishes its own context and that has clinical 
          --   attestation with regard to who is making the statement. 
          --   While a Composition defines the structure, it does not 
          --   actually contain the content: rather the full content 
          --   of a document is contained in a Bundle, of which the 
          --   Composition is the first resource contained.
          --   
          --   (24) A statement of relationships from one set of concepts 
          --   to one or more other concepts - either code systems or 
          --   data elements, or classes in class models.
          --   
          --   (25) A clinical condition, problem, diagnosis, or other 
          --   event, situation, issue, or clinical concept that has 
          --   risen to a level of concern.
          --   
          --   (26) A record of a healthcare consumerâ€™s policy choices, 
          --   which permits or denies identified recipient(s) or 
          --   recipient role(s) to perform one or more actions within 
          --   a given policy context, for specific purposes and 
          --   periods of time.
          --   
          --   (27) A formal agreement between parties regarding the 
          --   conduct of business, exchange of information or other 
          --   matters.
          --   
          --   (28) Financial instrument which may be used to reimburse or 
          --   pay for health care products and services.
          --   
          --   (29) The formal description of a single piece of information 
          --   that can be gathered and reported.
          --   
          --   (30) Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions 
          --   for a patient; e.g. Drug-drug interaction, Ineffective 
          --   treatment frequency, Procedure-condition conflict, etc.
          --   
          --   (31) This resource identifies an instance or a type of a 
          --   manufactured item that is used in the provision of 
          --   healthcare without being substantially changed through 
          --   that activity. The device may be a medical or 
          --   non-medical device. Medical devices include durable 
          --   (reusable) medical equipment, implantable devices, as 
          --   well as disposable equipment used for diagnostic, 
          --   treatment, and research for healthcare and public 
          --   health. Non-medical devices may include items such as a 
          --   machine, cellphone, computer, application, etc.
          --   
          --   (32) The characteristics, operational status and 
          --   capabilities of a medical-related component of a 
          --   medical device.
          --   
          --   (33) Describes a measurement, calculation or setting 
          --   capability of a medical device.
          --   
          --   (34) Represents a request for a patient to employ a medical 
          --   device. The device may be an implantable device, or an 
          --   external assistive device, such as a walker.
          --   
          --   (35) A record of a device being used by a patient where the 
          --   record is the result of a report from the patient or 
          --   another clinician.
          --   
          --   (36) The findings and interpretation of diagnostic tests 
          --   performed on patients, groups of patients, devices, and 
          --   locations, and/or specimens derived from these. The 
          --   report includes clinical context such as requesting and 
          --   provider information, and some mix of atomic results, 
          --   images, textual and coded interpretations, and 
          --   formatted representation of diagnostic reports.
          --   
          --   (37) A collection of documents compiled for a purpose 
          --   together with metadata that applies to the collection.
          --   
          --   (38) A reference to a document.
          --   
          --   (39) The EligibilityRequest provides patient and insurance 
          --   coverage information to an insurer for them to respond, 
          --   in the form of an EligibilityResponse, with information 
          --   regarding whether the stated coverage is valid and 
          --   in-force and optionally to provide the insurance 
          --   details of the policy.
          --   
          --   (40) This resource provides eligibility and plan details 
          --   from the processing of an Eligibility resource.
          --   
          --   (41) An interaction between a patient and healthcare 
          --   provider(s) for the purpose of providing healthcare 
          --   service(s) or assessing the health status of a patient.
          --   
          --   (42) The technical details of an endpoint that can be used 
          --   for electronic services, such as for web services 
          --   providing XDS.b or a REST endpoint for another FHIR 
          --   server. This may include any security context 
          --   information.
          --   
          --   (43) This resource provides the insurance enrollment details 
          --   to the insurer regarding a specified coverage.
          --   
          --   (44) This resource provides enrollment and plan details from 
          --   the processing of an Enrollment resource.
          --   
          --   (45) An association between a patient and an organization / 
          --   healthcare provider(s) during which time encounters may 
          --   occur. The managing organization assumes a level of 
          --   responsibility for the patient during this time.
          --   
          --   (46) Resource to define constraints on the Expansion of a 
          --   FHIR ValueSet.
          --   
          --   (47) This resource provides: the claim details; adjudication 
          --   details from the processing of a Claim; and optionally 
          --   account balance information, for informing the 
          --   subscriber of the benefits provided.
          --   
          --   (48) Significant health events and conditions for a person 
          --   related to the patient relevant in the context of care 
          --   for the patient.
          --   
          --   (49) Prospective warnings of potential issues when providing 
          --   care to the patient.
          --   
          --   (50) Describes the intended objective(s) for a patient, 
          --   group or organization care, for example, weight loss, 
          --   restoring an activity of daily living, obtaining herd 
          --   immunity via immunization, meeting a process 
          --   improvement objective, etc.
          --   
          --   (51) A formal computable definition of a graph of resources 
          --   - that is, a coherent set of resources that form a 
          --   graph by following references. The Graph Definition 
          --   resource defines a set and makes rules about the set.
          --   
          --   (52) Represents a defined collection of entities that may be 
          --   discussed or acted upon collectively but which are not 
          --   expected to act collectively and are not formally or 
          --   legally recognized; i.e. a collection of entities that 
          --   isn't an Organization.
          --   
          --   (53) A guidance response is the formal response to a 
          --   guidance request, including any output parameters 
          --   returned by the evaluation, as well as the description 
          --   of any proposed actions to be taken.
          --   
          --   (54) The details of a healthcare service available at a 
          --   location.
          --   
          --   (55) A text description of the DICOM SOP instances selected 
          --   in the ImagingManifest; or the reason for, or 
          --   significance of, the selection.
          --   
          --   (56) Representation of the content produced in a DICOM 
          --   imaging study. A study comprises a set of series, each 
          --   of which includes a set of Service-Object Pair 
          --   Instances (SOP Instances - images or other data) 
          --   acquired or produced in a common context. A series is 
          --   of only one modality (e.g. X-ray, CT, MR, ultrasound), 
          --   but a study may have multiple series of different 
          --   modalities.
          --   
          --   (57) Describes the event of a patient being administered a 
          --   vaccination or a record of a vaccination as reported by 
          --   a patient, a clinician or another party and may include 
          --   vaccine reaction information and what vaccination 
          --   protocol was followed.
          --   
          --   (58) A patient's point-in-time immunization and 
          --   recommendation (i.e. forecasting a patient's 
          --   immunization eligibility according to a published 
          --   schedule) with optional supporting justification.
          --   
          --   (59) A set of rules of how FHIR is used to solve a 
          --   particular problem. This resource is used to gather all 
          --   the parts of an implementation guide into a logical 
          --   whole and to publish a computable definition of all the 
          --   parts.
          --   
          --   (60) The Library resource is a general-purpose container for 
          --   knowledge asset definitions. It can be used to describe 
          --   and expose existing knowledge assets such as logic 
          --   libraries and information model descriptions, as well 
          --   as to describe a collection of knowledge assets.
          --   
          --   (61) Identifies two or more records (resource instances) 
          --   that are referring to the same real-world 
          --   &quot;occurrence&quot;.
          --   
          --   (62) A set of information summarized from a list of other 
          --   resources.
          --   
          --   (63) Details and position information for a physical place 
          --   where services are provided and resources and 
          --   participants may be stored, found, contained or 
          --   accommodated.
          --   
          --   (64) The Measure resource provides the definition of a 
          --   quality measure.
          --   
          --   (65) The MeasureReport resource contains the results of 
          --   evaluating a measure.
          --   
          --   (66) A photo, video, or audio recording acquired or used in 
          --   healthcare. The actual content may be inline or 
          --   provided by direct reference.
          --   
          --   (67) This resource is primarily used for the identification 
          --   and definition of a medication. It covers the 
          --   ingredients and the packaging for a medication.
          --   
          --   (68) Describes the event of a patient consuming or otherwise 
          --   being administered a medication. This may be as simple 
          --   as swallowing a tablet or it may be a long running 
          --   infusion. Related resources tie this event to the 
          --   authorizing prescription, and the specific encounter 
          --   between patient and health care practitioner.
          --   
          --   (69) Indicates that a medication product is to be or has 
          --   been dispensed for a named person/patient. This 
          --   includes a description of the medication product 
          --   (supply) provided and the instructions for 
          --   administering the medication. The medication dispense 
          --   is the result of a pharmacy system responding to a 
          --   medication order.
          --   
          --   (70) An order or request for both supply of the medication 
          --   and the instructions for administration of the 
          --   medication to a patient. The resource is called 
          --   &quot;MedicationRequest&quot; rather than 
          --   &quot;MedicationPrescription&quot; or 
          --   &quot;MedicationOrder&quot; to generalize the use 
          --   across inpatient and outpatient settings, including 
          --   care plans, etc., and to harmonize with workflow 
          --   patterns.
          --   
          --   (71) A record of a medication that is being consumed by a 
          --   patient. A MedicationStatement may indicate that the 
          --   patient may be taking the medication now, or has taken 
          --   the medication in the past or will be taking the 
          --   medication in the future. The source of this 
          --   information can be the patient, significant other (such 
          --   as a family member or spouse), or a clinician. A common 
          --   scenario where this information is captured is during 
          --   the history taking process during a patient visit or 
          --   stay. The medication information may come from sources 
          --   such as the patient's memory, from a prescription 
          --   bottle, or from a list of medications the patient, 
          --   clinician or other party maintains The primary 
          --   difference between a medication statement and a 
          --   medication administration is that the medication 
          --   administration has complete administration information 
          --   and is based on actual administration information from 
          --   the person who administered the medication. A 
          --   medication statement is often, if not always, less 
          --   specific. There is no required date/time when the 
          --   medication was administered, in fact we only know that 
          --   a source has reported the patient is taking this 
          --   medication, where details such as time, quantity, or 
          --   rate or even medication product may be incomplete or 
          --   missing or less precise. As stated earlier, the 
          --   medication statement information may come from the 
          --   patient's memory, from a prescription bottle or from a 
          --   list of medications the patient, clinician or other 
          --   party maintains. Medication administration is more 
          --   formal and is not missing detailed information.
          --   
          --   (72) Defines the characteristics of a message that can be 
          --   shared between systems, including the type of event 
          --   that initiates the message, the content to be 
          --   transmitted and what response(s), if any, are 
          --   permitted.
          --   
          --   (73) The header for a message exchange that is either 
          --   requesting or responding to an action. The reference(s) 
          --   that are the subject of the action as well as other 
          --   information related to the action are typically 
          --   transmitted in a bundle in which the MessageHeader 
          --   resource instance is the first resource in the bundle.
          --   
          --   (74) A curated namespace that issues unique symbols within 
          --   that namespace for the identification of concepts, 
          --   people, devices, etc. Represents a &quot;System&quot; 
          --   used within the Identifier and Coding data types.
          --   
          --   (75) A request to supply a diet, formula feeding (enteral) 
          --   or oral nutritional supplement to a patient/resident.
          --   
          --   (76) Measurements and simple assertions made about a 
          --   patient, device or other subject.
          --   
          --   (77) A formal computable definition of an operation (on the 
          --   RESTful interface) or a named query (using the search 
          --   interaction).
          --   
          --   (78) A collection of error, warning or information messages 
          --   that result from a system action.
          --   
          --   (79) A formally or informally recognized grouping of people 
          --   or organizations formed for the purpose of achieving 
          --   some form of collective action. Includes companies, 
          --   institutions, corporations, departments, community 
          --   groups, healthcare practice groups, etc.
          --   
          --   (80) Demographics and other administrative information about 
          --   an individual or animal receiving care or other 
          --   health-related services.
          --   
          --   (81) This resource provides the status of the payment for 
          --   goods and services rendered, and the request and 
          --   response resource references.
          --   
          --   (82) This resource provides payment details and claim 
          --   references supporting a bulk payment.
          --   
          --   (83) Demographics and administrative information about a 
          --   person independent of a specific health-related 
          --   context.
          --   
          --   (84) This resource allows for the definition of various 
          --   types of plans as a sharable, consumable, and 
          --   executable artifact. The resource is general enough to 
          --   support the description of a broad range of clinical 
          --   artifacts such as clinical decision support rules, 
          --   order sets and protocols.
          --   
          --   (85) A person who is directly or indirectly involved in the 
          --   provisioning of healthcare.
          --   
          --   (86) A specific set of Roles/Locations/specialties/services 
          --   that a practitioner may perform at an organization for 
          --   a period of time.
          --   
          --   (87) An action that is or was performed on a patient. This 
          --   can be a physical intervention like an operation, or 
          --   less invasive like counseling or hypnotherapy.
          --   
          --   (88) A record of a request for diagnostic investigations, 
          --   treatments, or operations to be performed.
          --   
          --   (89) This resource provides the target, request and 
          --   response, and action details for an action to be 
          --   performed by the target on or about existing resources.
          --   
          --   (90) This resource provides processing status, errors and 
          --   notes from the processing of a resource.
          --   
          --   (91) Provenance of a resource is a record that describes 
          --   entities and processes involved in producing and 
          --   delivering or otherwise influencing that resource. 
          --   Provenance provides a critical foundation for assessing 
          --   authenticity, enabling trust, and allowing 
          --   reproducibility. Provenance assertions are a form of 
          --   contextual metadata and can themselves become important 
          --   records with their own provenance. Provenance statement 
          --   indicates clinical significance in terms of confidence 
          --   in authenticity, reliability, and trustworthiness, 
          --   integrity, and stage in lifecycle (e.g. Document 
          --   Completion - has the artifact been legally 
          --   authenticated), all of which may impact security, 
          --   privacy, and trust policies.
          --   
          --   (92) A structured set of questions intended to guide the 
          --   collection of answers from end-users. Questionnaires 
          --   provide detailed control over order, presentation, 
          --   phraseology and grouping to allow coherent, consistent 
          --   data collection.
          --   
          --   (93) A structured set of questions and their answers. The 
          --   questions are ordered and grouped into coherent 
          --   subsets, corresponding to the structure of the grouping 
          --   of the questionnaire being responded to.
          --   
          --   (94) Used to record and send details about a request for 
          --   referral service or transfer of a patient to the care 
          --   of another provider or provider organization.
          --   
          --   (95) Information about a person that is involved in the care 
          --   for a patient, but who is not the target of healthcare, 
          --   nor has a formal responsibility in the care process.
          --   
          --   (96) A group of related requests that can be used to capture 
          --   intended activities that have inter-dependencies such 
          --   as &quot;give this medication after that one&quot;.
          --   
          --   (97) A process where a researcher or organization plans and 
          --   then executes a series of steps intended to increase 
          --   the field of healthcare-related knowledge. This 
          --   includes studies of safety, efficacy, comparative 
          --   effectiveness and other information about medications, 
          --   devices, therapies and other interventional and 
          --   investigative techniques. A ResearchStudy involves the 
          --   gathering of information about human or animal 
          --   subjects.
          --   
          --   (98) A process where a researcher or organization plans and 
          --   then executes a series of steps intended to increase 
          --   the field of healthcare-related knowledge. This 
          --   includes studies of safety, efficacy, comparative 
          --   effectiveness and other information about medications, 
          --   devices, therapies and other interventional and 
          --   investigative techniques. A ResearchStudy involves the 
          --   gathering of information about human or animal 
          --   subjects.
          --   
          --   (99) An assessment of the likely outcome(s) for a patient or 
          --   other subject as well as the likelihood of each 
          --   outcome.
          --   
          --   (100) A container for slots of time that may be available for 
          --   booking appointments.
          --   
          --   (101) A search parameter that defines a named search item 
          --   that can be used to search/filter on a resource.
          --   
          --   (102) Raw data describing a biological sequence.
          --   
          --   (103) The ServiceDefinition describes a unit of decision 
          --   support functionality that is made available as a 
          --   service, such as immunization modules or drug-drug 
          --   interaction checking.
          --   
          --   (104) A slot of time on a schedule that may be available for 
          --   booking appointments.
          --   
          --   (105) A sample to be used for analysis.
          --   
          --   (106) A definition of a FHIR structure. This resource is used 
          --   to describe the underlying resources, data types 
          --   defined in FHIR, and also for describing extensions and 
          --   constraints on resources and data types.
          --   
          --   (107) A Map of relationships between 2 structures that can be 
          --   used to transform data.
          --   
          --   (108) The subscription resource is used to define a push 
          --   based subscription from a server to another system. 
          --   Once a subscription is registered with the server, the 
          --   server checks every resource that is created or 
          --   updated, and if the resource matches the given 
          --   criteria, it sends a message on the defined 
          --   &quot;channel&quot; so that another system is able to 
          --   take an appropriate action.
          --   
          --   (109) A homogeneous material with a definite composition.
          --   
          --   (110) Record of delivery of what is supplied.
          --   
          --   (111) A record of a request for a medication, substance or 
          --   device used in the healthcare setting.
          --   
          --   (112) A task to be performed.
          --   
          --   (113) A summary of information based on the results of 
          --   executing a TestScript.
          --   
          --   (114) A structured set of tests against a FHIR server 
          --   implementation to determine compliance against the FHIR 
          --   specification.
          --   
          --   (115) A value set specifies a set of codes drawn from one or 
          --   more code systems.
          --   
          --   (116) An authorization for the supply of glasses and/or 
          --   contact lenses to a patient.
          --   
          --   (117) This special resource type is used to represent an 
          --   operation request and response (operations.html). It 
          --   has no other use, and there is no RESTful endpoint 
          --   associated with it.
        }
        deriving (Eq,Show)
instance SchemaType ResourceContainer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResourceContainer
            `apply` oneOf' [ ("Account", fmap OneOf117 (elementAccount))
                           , ("ActivityDefinition", fmap TwoOf117 (elementActivityDefinition))
                           , ("AdverseEvent", fmap ThreeOf117 (elementAdverseEvent))
                           , ("AllergyIntolerance", fmap FourOf117 (elementAllergyIntolerance))
                           , ("Appointment", fmap FiveOf117 (elementAppointment))
                           , ("AppointmentResponse", fmap SixOf117 (elementAppointmentResponse))
                           , ("AuditEvent", fmap SevenOf117 (elementAuditEvent))
                           , ("Basic", fmap EightOf117 (elementBasic))
                           , ("Binary", fmap NineOf117 (elementBinary))
                           , ("BodySite", fmap TenOf117 (elementBodySite))
                           , ("Bundle", fmap ElevenOf117 (elementBundle))
                           , ("CapabilityStatement", fmap TwelveOf117 (elementCapabilityStatement))
                           , ("CarePlan", fmap ThirteenOf117 (elementCarePlan))
                           , ("CareTeam", fmap FourteenOf117 (elementCareTeam))
                           , ("ChargeItem", fmap FifteenOf117 (elementChargeItem))
                           , ("Claim", fmap SixteenOf117 (elementClaim))
                           , ("ClaimResponse", fmap SeventeenOf117 (elementClaimResponse))
                           , ("ClinicalImpression", fmap EighteenOf117 (elementClinicalImpression))
                           , ("CodeSystem", fmap NineteenOf117 (elementCodeSystem))
                           , ("Communication", fmap TwentyOf117 (elementCommunication))
                           , ("CommunicationRequest", fmap Choice21Of117 (elementCommunicationRequest))
                           , ("CompartmentDefinition", fmap Choice22Of117 (elementCompartmentDefinition))
                           , ("Composition", fmap Choice23Of117 (elementComposition))
                           , ("ConceptMap", fmap Choice24Of117 (elementConceptMap))
                           , ("Condition", fmap Choice25Of117 (elementCondition))
                           , ("Consent", fmap Choice26Of117 (elementConsent))
                           , ("Contract", fmap Choice27Of117 (elementContract))
                           , ("Coverage", fmap Choice28Of117 (elementCoverage))
                           , ("DataElement", fmap Choice29Of117 (elementDataElement))
                           , ("DetectedIssue", fmap Choice30Of117 (elementDetectedIssue))
                           , ("Device", fmap Choice31Of117 (elementDevice))
                           , ("DeviceComponent", fmap Choice32Of117 (elementDeviceComponent))
                           , ("DeviceMetric", fmap Choice33Of117 (elementDeviceMetric))
                           , ("DeviceRequest", fmap Choice34Of117 (elementDeviceRequest))
                           , ("DeviceUseStatement", fmap Choice35Of117 (elementDeviceUseStatement))
                           , ("DiagnosticReport", fmap Choice36Of117 (elementDiagnosticReport))
                           , ("DocumentManifest", fmap Choice37Of117 (elementDocumentManifest))
                           , ("DocumentReference", fmap Choice38Of117 (elementDocumentReference))
                           , ("EligibilityRequest", fmap Choice39Of117 (elementEligibilityRequest))
                           , ("EligibilityResponse", fmap Choice40Of117 (elementEligibilityResponse))
                           , ("Encounter", fmap Choice41Of117 (elementEncounter))
                           , ("Endpoint", fmap Choice42Of117 (elementEndpoint))
                           , ("EnrollmentRequest", fmap Choice43Of117 (elementEnrollmentRequest))
                           , ("EnrollmentResponse", fmap Choice44Of117 (elementEnrollmentResponse))
                           , ("EpisodeOfCare", fmap Choice45Of117 (elementEpisodeOfCare))
                           , ("ExpansionProfile", fmap Choice46Of117 (elementExpansionProfile))
                           , ("ExplanationOfBenefit", fmap Choice47Of117 (elementExplanationOfBenefit))
                           , ("FamilyMemberHistory", fmap Choice48Of117 (elementFamilyMemberHistory))
                           , ("Flag", fmap Choice49Of117 (elementFlag))
                           , ("Goal", fmap Choice50Of117 (elementGoal))
                           , ("GraphDefinition", fmap Choice51Of117 (elementGraphDefinition))
                           , ("Group", fmap Choice52Of117 (elementGroup))
                           , ("GuidanceResponse", fmap Choice53Of117 (elementGuidanceResponse))
                           , ("HealthcareService", fmap Choice54Of117 (elementHealthcareService))
                           , ("ImagingManifest", fmap Choice55Of117 (elementImagingManifest))
                           , ("ImagingStudy", fmap Choice56Of117 (elementImagingStudy))
                           , ("Immunization", fmap Choice57Of117 (elementImmunization))
                           , ("ImmunizationRecommendation", fmap Choice58Of117 (elementImmunizationRecommendation))
                           , ("ImplementationGuide", fmap Choice59Of117 (elementImplementationGuide))
                           , ("Library", fmap Choice60Of117 (elementLibrary))
                           , ("Linkage", fmap Choice61Of117 (elementLinkage))
                           , ("List", fmap Choice62Of117 (elementList))
                           , ("Location", fmap Choice63Of117 (elementLocation))
                           , ("Measure", fmap Choice64Of117 (elementMeasure))
                           , ("MeasureReport", fmap Choice65Of117 (elementMeasureReport))
                           , ("Media", fmap Choice66Of117 (elementMedia))
                           , ("Medication", fmap Choice67Of117 (elementMedication))
                           , ("MedicationAdministration", fmap Choice68Of117 (elementMedicationAdministration))
                           , ("MedicationDispense", fmap Choice69Of117 (elementMedicationDispense))
                           , ("MedicationRequest", fmap Choice70Of117 (elementMedicationRequest))
                           , ("MedicationStatement", fmap Choice71Of117 (elementMedicationStatement))
                           , ("MessageDefinition", fmap Choice72Of117 (elementMessageDefinition))
                           , ("MessageHeader", fmap Choice73Of117 (elementMessageHeader))
                           , ("NamingSystem", fmap Choice74Of117 (elementNamingSystem))
                           , ("NutritionOrder", fmap Choice75Of117 (elementNutritionOrder))
                           , ("Observation", fmap Choice76Of117 (elementObservation))
                           , ("OperationDefinition", fmap Choice77Of117 (elementOperationDefinition))
                           , ("OperationOutcome", fmap Choice78Of117 (elementOperationOutcome))
                           , ("Organization", fmap Choice79Of117 (elementOrganization))
                           , ("Patient", fmap Choice80Of117 (elementPatient))
                           , ("PaymentNotice", fmap Choice81Of117 (elementPaymentNotice))
                           , ("PaymentReconciliation", fmap Choice82Of117 (elementPaymentReconciliation))
                           , ("Person", fmap Choice83Of117 (elementPerson))
                           , ("PlanDefinition", fmap Choice84Of117 (elementPlanDefinition))
                           , ("Practitioner", fmap Choice85Of117 (elementPractitioner))
                           , ("PractitionerRole", fmap Choice86Of117 (elementPractitionerRole))
                           , ("Procedure", fmap Choice87Of117 (elementProcedure))
                           , ("ProcedureRequest", fmap Choice88Of117 (elementProcedureRequest))
                           , ("ProcessRequest", fmap Choice89Of117 (elementProcessRequest))
                           , ("ProcessResponse", fmap Choice90Of117 (elementProcessResponse))
                           , ("Provenance", fmap Choice91Of117 (elementProvenance))
                           , ("Questionnaire", fmap Choice92Of117 (elementQuestionnaire))
                           , ("QuestionnaireResponse", fmap Choice93Of117 (elementQuestionnaireResponse))
                           , ("ReferralRequest", fmap Choice94Of117 (elementReferralRequest))
                           , ("RelatedPerson", fmap Choice95Of117 (elementRelatedPerson))
                           , ("RequestGroup", fmap Choice96Of117 (elementRequestGroup))
                           , ("ResearchStudy", fmap Choice97Of117 (elementResearchStudy))
                           , ("ResearchSubject", fmap Choice98Of117 (elementResearchSubject))
                           , ("RiskAssessment", fmap Choice99Of117 (elementRiskAssessment))
                           , ("Schedule", fmap Choice100Of117 (elementSchedule))
                           , ("SearchParameter", fmap Choice101Of117 (elementSearchParameter))
                           , ("Sequence", fmap Choice102Of117 (elementSequence))
                           , ("ServiceDefinition", fmap Choice103Of117 (elementServiceDefinition))
                           , ("Slot", fmap Choice104Of117 (elementSlot))
                           , ("Specimen", fmap Choice105Of117 (elementSpecimen))
                           , ("StructureDefinition", fmap Choice106Of117 (elementStructureDefinition))
                           , ("StructureMap", fmap Choice107Of117 (elementStructureMap))
                           , ("Subscription", fmap Choice108Of117 (elementSubscription))
                           , ("Substance", fmap Choice109Of117 (elementSubstance))
                           , ("SupplyDelivery", fmap Choice110Of117 (elementSupplyDelivery))
                           , ("SupplyRequest", fmap Choice111Of117 (elementSupplyRequest))
                           , ("Task", fmap Choice112Of117 (elementTask))
                           , ("TestReport", fmap Choice113Of117 (elementTestReport))
                           , ("TestScript", fmap Choice114Of117 (elementTestScript))
                           , ("ValueSet", fmap Choice115Of117 (elementValueSet))
                           , ("VisionPrescription", fmap Choice116Of117 (elementVisionPrescription))
                           , ("Parameters", fmap Choice117Of117 (elementParameters))
                           ]
    schemaTypeToXML s x@ResourceContainer{} =
        toXMLElement s []
            [ foldOneOf117  (elementToXMLAccount)
                            (elementToXMLActivityDefinition)
                            (elementToXMLAdverseEvent)
                            (elementToXMLAllergyIntolerance)
                            (elementToXMLAppointment)
                            (elementToXMLAppointmentResponse)
                            (elementToXMLAuditEvent)
                            (elementToXMLBasic)
                            (elementToXMLBinary)
                            (elementToXMLBodySite)
                            (elementToXMLBundle)
                            (elementToXMLCapabilityStatement)
                            (elementToXMLCarePlan)
                            (elementToXMLCareTeam)
                            (elementToXMLChargeItem)
                            (elementToXMLClaim)
                            (elementToXMLClaimResponse)
                            (elementToXMLClinicalImpression)
                            (elementToXMLCodeSystem)
                            (elementToXMLCommunication)
                            (elementToXMLCommunicationRequest)
                            (elementToXMLCompartmentDefinition)
                            (elementToXMLComposition)
                            (elementToXMLConceptMap)
                            (elementToXMLCondition)
                            (elementToXMLConsent)
                            (elementToXMLContract)
                            (elementToXMLCoverage)
                            (elementToXMLDataElement)
                            (elementToXMLDetectedIssue)
                            (elementToXMLDevice)
                            (elementToXMLDeviceComponent)
                            (elementToXMLDeviceMetric)
                            (elementToXMLDeviceRequest)
                            (elementToXMLDeviceUseStatement)
                            (elementToXMLDiagnosticReport)
                            (elementToXMLDocumentManifest)
                            (elementToXMLDocumentReference)
                            (elementToXMLEligibilityRequest)
                            (elementToXMLEligibilityResponse)
                            (elementToXMLEncounter)
                            (elementToXMLEndpoint)
                            (elementToXMLEnrollmentRequest)
                            (elementToXMLEnrollmentResponse)
                            (elementToXMLEpisodeOfCare)
                            (elementToXMLExpansionProfile)
                            (elementToXMLExplanationOfBenefit)
                            (elementToXMLFamilyMemberHistory)
                            (elementToXMLFlag)
                            (elementToXMLGoal)
                            (elementToXMLGraphDefinition)
                            (elementToXMLGroup)
                            (elementToXMLGuidanceResponse)
                            (elementToXMLHealthcareService)
                            (elementToXMLImagingManifest)
                            (elementToXMLImagingStudy)
                            (elementToXMLImmunization)
                            (elementToXMLImmunizationRecommendation)
                            (elementToXMLImplementationGuide)
                            (elementToXMLLibrary)
                            (elementToXMLLinkage)
                            (elementToXMLList)
                            (elementToXMLLocation)
                            (elementToXMLMeasure)
                            (elementToXMLMeasureReport)
                            (elementToXMLMedia)
                            (elementToXMLMedication)
                            (elementToXMLMedicationAdministration)
                            (elementToXMLMedicationDispense)
                            (elementToXMLMedicationRequest)
                            (elementToXMLMedicationStatement)
                            (elementToXMLMessageDefinition)
                            (elementToXMLMessageHeader)
                            (elementToXMLNamingSystem)
                            (elementToXMLNutritionOrder)
                            (elementToXMLObservation)
                            (elementToXMLOperationDefinition)
                            (elementToXMLOperationOutcome)
                            (elementToXMLOrganization)
                            (elementToXMLPatient)
                            (elementToXMLPaymentNotice)
                            (elementToXMLPaymentReconciliation)
                            (elementToXMLPerson)
                            (elementToXMLPlanDefinition)
                            (elementToXMLPractitioner)
                            (elementToXMLPractitionerRole)
                            (elementToXMLProcedure)
                            (elementToXMLProcedureRequest)
                            (elementToXMLProcessRequest)
                            (elementToXMLProcessResponse)
                            (elementToXMLProvenance)
                            (elementToXMLQuestionnaire)
                            (elementToXMLQuestionnaireResponse)
                            (elementToXMLReferralRequest)
                            (elementToXMLRelatedPerson)
                            (elementToXMLRequestGroup)
                            (elementToXMLResearchStudy)
                            (elementToXMLResearchSubject)
                            (elementToXMLRiskAssessment)
                            (elementToXMLSchedule)
                            (elementToXMLSearchParameter)
                            (elementToXMLSequence)
                            (elementToXMLServiceDefinition)
                            (elementToXMLSlot)
                            (elementToXMLSpecimen)
                            (elementToXMLStructureDefinition)
                            (elementToXMLStructureMap)
                            (elementToXMLSubscription)
                            (elementToXMLSubstance)
                            (elementToXMLSupplyDelivery)
                            (elementToXMLSupplyRequest)
                            (elementToXMLTask)
                            (elementToXMLTestReport)
                            (elementToXMLTestScript)
                            (elementToXMLValueSet)
                            (elementToXMLVisionPrescription)
                            (elementToXMLParameters)
                            $ resourceContainer_choice0 x
            ]
 
data Extension = Extension
        { extension_id :: Maybe String_primitive
        , extension_url :: Uri_primitive
        , extension_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , extension_choice1 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Value of extension - may be a resource or one of a 
          --   constrained set of the data types (see Extensibility in the 
          --   spec for list).
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType Extension where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- getAttribute "url" e pos
        commit $ interior e $ return (Extension a0 a1)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                                     ])
    schemaTypeToXML s x@Extension{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ extension_id x
                       , toXMLAttribute "url" $ extension_url x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ extension_extension x
            , maybe [] (foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueCode")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueId")
                                     (schemaTypeToXML "valueInstant")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueMarkdown")
                                     (schemaTypeToXML "valueOid")
                                     (schemaTypeToXML "valuePositiveInt")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueUnsignedInt")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAddress")
                                     (schemaTypeToXML "valueAge")
                                     (schemaTypeToXML "valueAnnotation")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueContactPoint")
                                     (schemaTypeToXML "valueCount")
                                     (schemaTypeToXML "valueDistance")
                                     (schemaTypeToXML "valueDuration")
                                     (schemaTypeToXML "valueHumanName")
                                     (schemaTypeToXML "valueIdentifier")
                                     (schemaTypeToXML "valueMoney")
                                     (schemaTypeToXML "valuePeriod")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueReference")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueSignature")
                                     (schemaTypeToXML "valueTiming")
                                     (schemaTypeToXML "valueMeta")
                                    ) $ extension_choice1 x
            ]
instance Extension Extension Element where
    supertype (Extension a0 a1 e0 e1) =
               Element a0 e0
 
data BackboneElement = BackboneElement
        { backboneElement_id :: Maybe String_primitive
        , backboneElement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , backboneElement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        }
        deriving (Eq,Show)
instance SchemaType BackboneElement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BackboneElement a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
    schemaTypeToXML s x@BackboneElement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ backboneElement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ backboneElement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ backboneElement_modifierExtension x
            ]
instance Extension BackboneElement Element where
    supertype (BackboneElement a0 e0 e1) =
               Element a0 e0
 
data Narrative = Narrative
        { narrative_id :: Maybe String_primitive
        , narrative_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , narrative_status :: NarrativeStatus
          -- ^ The status of the narrative - whether it's entirely 
          --   generated (from just the defined data or the extensions 
          --   too), or whether a human authored it and it may contain 
          --   additional data.
        , narrative_Xhtml.div :: Xhtml.Div
        }
        deriving (Eq,Show)
instance SchemaType Narrative where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Narrative a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "status"
            `apply` elementDiv
    schemaTypeToXML s x@Narrative{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ narrative_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ narrative_extension x
            , schemaTypeToXML "status" $ narrative_status x
            , elementToXMLDiv $ narrative_Xhtml.div x
            ]
instance Extension Narrative Element where
    supertype (Narrative a0 e0 e1 e2) =
               Element a0 e0
 
data NarrativeStatus_list
    = NarrativeStatus_list_Generated
      -- ^ Generated
    | NarrativeStatus_list_Extensions
      -- ^ Extensions
    | NarrativeStatus_list_Additional
      -- ^ Additional
    | NarrativeStatus_list_Empty
      -- ^ Empty
    deriving (Eq,Show,Enum)
instance SchemaType NarrativeStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NarrativeStatus_list where
    acceptingParser =  do literal "generated"; return NarrativeStatus_list_Generated
                      `onFail` do literal "extensions"; return NarrativeStatus_list_Extensions
                      `onFail` do literal "additional"; return NarrativeStatus_list_Additional
                      `onFail` do literal "empty"; return NarrativeStatus_list_Empty
                      
    simpleTypeText NarrativeStatus_list_Generated = "generated"
    simpleTypeText NarrativeStatus_list_Extensions = "extensions"
    simpleTypeText NarrativeStatus_list_Additional = "additional"
    simpleTypeText NarrativeStatus_list_Empty = "empty"
 
data NarrativeStatus = NarrativeStatus
        { narrativeStatus_id :: Maybe String_primitive
        , narrativeStatus_value :: Maybe NarrativeStatus_list
        , narrativeStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NarrativeStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NarrativeStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NarrativeStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ narrativeStatus_id x
                       , maybe [] (toXMLAttribute "value") $ narrativeStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ narrativeStatus_extension x
            ]
instance Extension NarrativeStatus Element where
    supertype (NarrativeStatus a0 a1 e0) =
               Element a0 e0
 
data Element = Element
        { element_id :: Maybe String_primitive
        , element_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Element where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Element a0)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Element{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ element_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ element_extension x
            ]
 
data Reference = Reference
        { reference_id :: Maybe String_primitive
        , reference_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , reference_reference :: Maybe Xsd.XsdString
          -- ^ A reference to a location at which the other resource is 
          --   found. The reference may be a relative reference, in which 
          --   case it is relative to the service base URL, or an absolute 
          --   URL that resolves to the location where the resource is 
          --   found. The reference may be version specific or not. If the 
          --   reference is not to a FHIR RESTful server, then it should 
          --   be assumed to be version specific. Internal fragment 
          --   references (start with '#') refer to contained resources.
        , reference_identifier :: Maybe Identifier
          -- ^ An identifier for the other resource. This is used when 
          --   there is no way to reference the other resource directly, 
          --   either because the entity is not available through a FHIR 
          --   server, or because there is no way for the author of the 
          --   resource to convert a known identifier to an actual 
          --   location. There is no requirement that a 
          --   Reference.identifier point to something that is actually 
          --   exposed as a FHIR instance, but it SHALL point to a 
          --   business concept that would be expected to be exposed as a 
          --   FHIR instance, and that instance would need to be of a FHIR 
          --   resource type allowed by the reference.
        , reference_display :: Maybe Xsd.XsdString
          -- ^ Plain text narrative that identifies the resource in 
          --   addition to the resource reference.
        }
        deriving (Eq,Show)
instance SchemaType Reference where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Reference a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@Reference{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ reference_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ reference_extension x
            , maybe [] (schemaTypeToXML "reference") $ reference_reference x
            , maybe [] (schemaTypeToXML "identifier") $ reference_identifier x
            , maybe [] (schemaTypeToXML "display") $ reference_display x
            ]
instance Extension Reference Element where
    supertype (Reference a0 e0 e1 e2 e3) =
               Element a0 e0
 
data Quantity = Quantity
        { quantity_id :: Maybe String_primitive
        , quantity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , quantity_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , quantity_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , quantity_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , quantity_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , quantity_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Quantity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Quantity a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Quantity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ quantity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ quantity_extension x
            , maybe [] (schemaTypeToXML "value") $ quantity_value x
            , maybe [] (schemaTypeToXML "comparator") $ quantity_comparator x
            , maybe [] (schemaTypeToXML "unit") $ quantity_unit x
            , maybe [] (schemaTypeToXML "system") $ quantity_system x
            , maybe [] (schemaTypeToXML "code") $ quantity_code x
            ]
instance Extension Quantity Element where
    supertype (Quantity a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data QuantityComparator_list
    = QuantityComparator_list_Lt
      -- ^ Less than
    | QuantityComparator_list_LtEq
      -- ^ Less or Equal to
    | QuantityComparator_list_GtEq
      -- ^ Greater or Equal to
    | QuantityComparator_list_Gt
      -- ^ Greater than
    deriving (Eq,Show,Enum)
instance SchemaType QuantityComparator_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuantityComparator_list where
    acceptingParser =  do literal "&lt;"; return QuantityComparator_list_Lt
                      `onFail` do literal "&lt;="; return QuantityComparator_list_LtEq
                      `onFail` do literal "&gt;="; return QuantityComparator_list_GtEq
                      `onFail` do literal "&gt;"; return QuantityComparator_list_Gt
                      
    simpleTypeText QuantityComparator_list_Lt = "&lt;"
    simpleTypeText QuantityComparator_list_LtEq = "&lt;="
    simpleTypeText QuantityComparator_list_GtEq = "&gt;="
    simpleTypeText QuantityComparator_list_Gt = "&gt;"
 
data QuantityComparator = QuantityComparator
        { quantityComparator_id :: Maybe String_primitive
        , quantityComparator_value :: Maybe QuantityComparator_list
        , quantityComparator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuantityComparator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuantityComparator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuantityComparator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ quantityComparator_id x
                       , maybe [] (toXMLAttribute "value") $ quantityComparator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ quantityComparator_extension x
            ]
instance Extension QuantityComparator Element where
    supertype (QuantityComparator a0 a1 e0) =
               Element a0 e0
 
data Period = Period
        { period_id :: Maybe String_primitive
        , period_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , period_start :: Maybe DateTime
          -- ^ The start of the period. The boundary is inclusive.
        , period_end :: Maybe DateTime
          -- ^ The end of the period. If the end of the period is missing, 
          --   it means that the period is ongoing. The start may be in 
          --   the past, and the end date in the future, which means that 
          --   period is expected/planned to end at that time.
        }
        deriving (Eq,Show)
instance SchemaType Period where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Period a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
    schemaTypeToXML s x@Period{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ period_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ period_extension x
            , maybe [] (schemaTypeToXML "start") $ period_start x
            , maybe [] (schemaTypeToXML "end") $ period_end x
            ]
instance Extension Period Element where
    supertype (Period a0 e0 e1 e2) =
               Element a0 e0
 
data Attachment = Attachment
        { attachment_id :: Maybe String_primitive
        , attachment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , attachment_contentType :: Maybe Code
          -- ^ Identifies the type of the data in the attachment and 
          --   allows a method to be chosen to interpret or render the 
          --   data. Includes mime type parameters such as charset where 
          --   appropriate.
        , attachment_language :: Maybe Code
          -- ^ The human language of the content. The value can be any 
          --   valid value according to BCP 47.
        , attachment_data :: Maybe Base64Binary
          -- ^ The actual data of the attachment - a sequence of bytes. In 
          --   XML, represented using base64.
        , attachment_url :: Maybe Uri
          -- ^ An alternative location where the data can be accessed.
        , attachment_size :: Maybe UnsignedInt
          -- ^ The number of bytes of data that make up this attachment 
          --   (before base64 encoding, if that is done).
        , attachment_hash :: Maybe Base64Binary
          -- ^ The calculated hash of the data using SHA-1. Represented 
          --   using base64.
        , attachment_title :: Maybe Xsd.XsdString
          -- ^ A label or set of text to display in place of the data.
        , attachment_creation :: Maybe DateTime
          -- ^ The date that the attachment was first created.
        }
        deriving (Eq,Show)
instance SchemaType Attachment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Attachment a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "data")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "size")
            `apply` optional (parseSchemaType "hash")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "creation")
    schemaTypeToXML s x@Attachment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ attachment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ attachment_extension x
            , maybe [] (schemaTypeToXML "contentType") $ attachment_contentType x
            , maybe [] (schemaTypeToXML "language") $ attachment_language x
            , maybe [] (schemaTypeToXML "data") $ attachment_data x
            , maybe [] (schemaTypeToXML "url") $ attachment_url x
            , maybe [] (schemaTypeToXML "size") $ attachment_size x
            , maybe [] (schemaTypeToXML "hash") $ attachment_hash x
            , maybe [] (schemaTypeToXML "title") $ attachment_title x
            , maybe [] (schemaTypeToXML "creation") $ attachment_creation x
            ]
instance Extension Attachment Element where
    supertype (Attachment a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               Element a0 e0
 
data Duration = Duration
        { duration_id :: Maybe String_primitive
        , duration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , duration_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , duration_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , duration_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , duration_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , duration_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Duration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Duration a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Duration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ duration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ duration_extension x
            , maybe [] (schemaTypeToXML "value") $ duration_value x
            , maybe [] (schemaTypeToXML "comparator") $ duration_comparator x
            , maybe [] (schemaTypeToXML "unit") $ duration_unit x
            , maybe [] (schemaTypeToXML "system") $ duration_system x
            , maybe [] (schemaTypeToXML "code") $ duration_code x
            ]
instance Extension Duration Quantity where
    supertype (Duration a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Duration Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Duration -> Quantity)
              
 
data Count = Count
        { count_id :: Maybe String_primitive
        , count_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , count_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , count_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , count_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , count_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , count_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Count where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Count a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Count{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ count_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ count_extension x
            , maybe [] (schemaTypeToXML "value") $ count_value x
            , maybe [] (schemaTypeToXML "comparator") $ count_comparator x
            , maybe [] (schemaTypeToXML "unit") $ count_unit x
            , maybe [] (schemaTypeToXML "system") $ count_system x
            , maybe [] (schemaTypeToXML "code") $ count_code x
            ]
instance Extension Count Quantity where
    supertype (Count a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Count Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Count -> Quantity)
              
 
data Range = Range
        { range_id :: Maybe String_primitive
        , range_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , range_low :: Maybe Quantity
          -- ^ The low limit. The boundary is inclusive.
        , range_high :: Maybe Quantity
          -- ^ The high limit. The boundary is inclusive.
        }
        deriving (Eq,Show)
instance SchemaType Range where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Range a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "low")
            `apply` optional (parseSchemaType "high")
    schemaTypeToXML s x@Range{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ range_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ range_extension x
            , maybe [] (schemaTypeToXML "low") $ range_low x
            , maybe [] (schemaTypeToXML "high") $ range_high x
            ]
instance Extension Range Element where
    supertype (Range a0 e0 e1 e2) =
               Element a0 e0
 
data Annotation = Annotation
        { annotation_id :: Maybe String_primitive
        , annotation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , annotation_choice1 :: (Maybe (OneOf2 [Reference] [Xsd.XsdString]))
          -- ^ The individual responsible for making the annotation.
          --   
          --   Choice between:
          --   
          --   (1) authorReference
          --   
          --   (2) authorString
        , annotation_time :: Maybe DateTime
          -- ^ Indicates when this particular annotation was made.
        , annotation_text :: Xsd.XsdString
          -- ^ The text of the annotation.
        }
        deriving (Eq,Show)
instance SchemaType Annotation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Annotation a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("[Reference]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "authorReference")))
                                     , ("[Xsd.XsdString]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "authorString")))
                                     ])
            `apply` optional (parseSchemaType "time")
            `apply` parseSchemaType "text"
    schemaTypeToXML s x@Annotation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ annotation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ annotation_extension x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "authorReference"))
                                    (concatMap (schemaTypeToXML "authorString"))
                                   ) $ annotation_choice1 x
            , maybe [] (schemaTypeToXML "time") $ annotation_time x
            , schemaTypeToXML "text" $ annotation_text x
            ]
instance Extension Annotation Element where
    supertype (Annotation a0 e0 e1 e2 e3) =
               Element a0 e0
 
data Money = Money
        { money_id :: Maybe String_primitive
        , money_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , money_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , money_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , money_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , money_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , money_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Money where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Money a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Money{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ money_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ money_extension x
            , maybe [] (schemaTypeToXML "value") $ money_value x
            , maybe [] (schemaTypeToXML "comparator") $ money_comparator x
            , maybe [] (schemaTypeToXML "unit") $ money_unit x
            , maybe [] (schemaTypeToXML "system") $ money_system x
            , maybe [] (schemaTypeToXML "code") $ money_code x
            ]
instance Extension Money Quantity where
    supertype (Money a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Money Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Money -> Quantity)
              
 
data Identifier = Identifier
        { identifier_id :: Maybe String_primitive
        , identifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , identifier_use :: Maybe IdentifierUse
          -- ^ The purpose of this identifier.
        , identifier_type :: Maybe CodeableConcept
          -- ^ A coded type for the identifier that can be used to 
          --   determine which identifier to use for a specific purpose.
        , identifier_system :: Maybe Uri
          -- ^ Establishes the namespace for the value - that is, a URL 
          --   that describes a set values that are unique.
        , identifier_value :: Maybe Xsd.XsdString
          -- ^ The portion of the identifier typically relevant to the 
          --   user and which is unique within the context of the system.
        , identifier_period :: Maybe Period
          -- ^ Time period during which identifier is/was valid for use.
        , identifier_assigner :: Maybe Reference
          -- ^ Organization that issued/manages the identifier.
        }
        deriving (Eq,Show)
instance SchemaType Identifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Identifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "assigner")
    schemaTypeToXML s x@Identifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identifier_extension x
            , maybe [] (schemaTypeToXML "use") $ identifier_use x
            , maybe [] (schemaTypeToXML "type") $ identifier_type x
            , maybe [] (schemaTypeToXML "system") $ identifier_system x
            , maybe [] (schemaTypeToXML "value") $ identifier_value x
            , maybe [] (schemaTypeToXML "period") $ identifier_period x
            , maybe [] (schemaTypeToXML "assigner") $ identifier_assigner x
            ]
instance Extension Identifier Element where
    supertype (Identifier a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data IdentifierUse_list
    = IdentifierUse_list_Usual
      -- ^ Usual
    | IdentifierUse_list_Official
      -- ^ Official
    | IdentifierUse_list_Temp
      -- ^ Temp
    | IdentifierUse_list_Secondary
      -- ^ Secondary
    deriving (Eq,Show,Enum)
instance SchemaType IdentifierUse_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IdentifierUse_list where
    acceptingParser =  do literal "usual"; return IdentifierUse_list_Usual
                      `onFail` do literal "official"; return IdentifierUse_list_Official
                      `onFail` do literal "temp"; return IdentifierUse_list_Temp
                      `onFail` do literal "secondary"; return IdentifierUse_list_Secondary
                      
    simpleTypeText IdentifierUse_list_Usual = "usual"
    simpleTypeText IdentifierUse_list_Official = "official"
    simpleTypeText IdentifierUse_list_Temp = "temp"
    simpleTypeText IdentifierUse_list_Secondary = "secondary"
 
data IdentifierUse = IdentifierUse
        { identifierUse_id :: Maybe String_primitive
        , identifierUse_value :: Maybe IdentifierUse_list
        , identifierUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IdentifierUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IdentifierUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IdentifierUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identifierUse_id x
                       , maybe [] (toXMLAttribute "value") $ identifierUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identifierUse_extension x
            ]
instance Extension IdentifierUse Element where
    supertype (IdentifierUse a0 a1 e0) =
               Element a0 e0
 
data Coding = Coding
        { coding_id :: Maybe String_primitive
        , coding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coding_system :: Maybe Uri
          -- ^ The identification of the code system that defines the 
          --   meaning of the symbol in the code.
        , coding_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system which was used when choosing 
          --   this code. Note that a well-maintained code system does not 
          --   need the version reported, because the meaning of codes is 
          --   consistent across versions. However this cannot 
          --   consistently be assured. and when the meaning is not 
          --   guaranteed to be consistent, the version SHOULD be 
          --   exchanged.
        , coding_code :: Maybe Code
          -- ^ A symbol in syntax defined by the system. The symbol may be 
          --   a predefined code or an expression in a syntax defined by 
          --   the coding system (e.g. post-coordination).
        , coding_display :: Maybe Xsd.XsdString
          -- ^ A representation of the meaning of the code in the system, 
          --   following the rules of the system.
        , coding_userSelected :: Maybe Boolean
          -- ^ Indicates that this coding was chosen by a user directly - 
          --   i.e. off a pick list of available items (codes or 
          --   displays).
        }
        deriving (Eq,Show)
instance SchemaType Coding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Coding a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "userSelected")
    schemaTypeToXML s x@Coding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ coding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ coding_extension x
            , maybe [] (schemaTypeToXML "system") $ coding_system x
            , maybe [] (schemaTypeToXML "version") $ coding_version x
            , maybe [] (schemaTypeToXML "code") $ coding_code x
            , maybe [] (schemaTypeToXML "display") $ coding_display x
            , maybe [] (schemaTypeToXML "userSelected") $ coding_userSelected x
            ]
instance Extension Coding Element where
    supertype (Coding a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data Signature = Signature
        { signature_id :: Maybe String_primitive
        , signature_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , signature_type :: [Coding]
          -- ^ An indication of the reason that the entity signed this 
          --   document. This may be explicitly included as part of the 
          --   signature information and can be used when determining 
          --   accountability for various actions concerning the document.
        , signature_when :: Instant
          -- ^ When the digital signature was signed.
        , signature_choice3 :: OneOf2 [Uri] [Reference]
          -- ^ A reference to an application-usable description of the 
          --   identity that signed (e.g. the signature used their private 
          --   key).
          --   
          --   Choice between:
          --   
          --   (1) whoUri
          --   
          --   (2) whoReference
        , signature_choice4 :: (Maybe (OneOf2 [Uri] [Reference]))
          -- ^ A reference to an application-usable description of the 
          --   identity that is represented by the signature.
          --   
          --   Choice between:
          --   
          --   (1) onBehalfOfUri
          --   
          --   (2) onBehalfOfReference
        , signature_contentType :: Maybe Code
          -- ^ A mime type that indicates the technical format of the 
          --   signature. Important mime types are 
          --   application/signature+xml for X ML DigSig, application/jwt 
          --   for JWT, and image/* for a graphical image of a signature, 
          --   etc.
        , signature_blob :: Maybe Base64Binary
          -- ^ The base64 encoding of the Signature content. When 
          --   signature is not recorded electronically this element would 
          --   be empty.
        }
        deriving (Eq,Show)
instance SchemaType Signature where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Signature a0)
            `apply` many (parseSchemaType "extension")
            `apply` many1 (parseSchemaType "type")
            `apply` parseSchemaType "when"
            `apply` oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                            (parseSchemaType "whoUri")))
                           , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                  (parseSchemaType "whoReference")))
                           ]
            `apply` optional (oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                      (parseSchemaType "onBehalfOfUri")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "onBehalfOfReference")))
                                     ])
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "blob")
    schemaTypeToXML s x@Signature{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ signature_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ signature_extension x
            , concatMap (schemaTypeToXML "type") $ signature_type x
            , schemaTypeToXML "when" $ signature_when x
            , foldOneOf2  (concatMap (schemaTypeToXML "whoUri"))
                          (concatMap (schemaTypeToXML "whoReference"))
                          $ signature_choice3 x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "onBehalfOfUri"))
                                    (concatMap (schemaTypeToXML "onBehalfOfReference"))
                                   ) $ signature_choice4 x
            , maybe [] (schemaTypeToXML "contentType") $ signature_contentType x
            , maybe [] (schemaTypeToXML "blob") $ signature_blob x
            ]
instance Extension Signature Element where
    supertype (Signature a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data SampledData = SampledData
        { sampledData_id :: Maybe String_primitive
        , sampledData_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sampledData_origin :: Quantity
          -- ^ The base quantity that a measured value of zero represents. 
          --   In addition, this provides the units of the entire 
          --   measurement series.
        , sampledData_period :: Decimal
          -- ^ The length of time between sampling times, measured in 
          --   milliseconds.
        , sampledData_factor :: Maybe Decimal
          -- ^ A correction factor that is applied to the sampled data 
          --   points before they are added to the origin.
        , sampledData_lowerLimit :: Maybe Decimal
          -- ^ The lower limit of detection of the measured points. This 
          --   is needed if any of the data points have the value 
          --   &quot;L&quot; (lower than detection limit).
        , sampledData_upperLimit :: Maybe Decimal
          -- ^ The upper limit of detection of the measured points. This 
          --   is needed if any of the data points have the value 
          --   &quot;U&quot; (higher than detection limit).
        , sampledData_dimensions :: PositiveInt
          -- ^ The number of sample points at each time point. If this 
          --   value is greater than one, then the dimensions will be 
          --   interlaced - all the sample points for a point in time will 
          --   be recorded at once.
        , sampledData_data :: SampledDataDataType
          -- ^ A series of data points which are decimal values separated 
          --   by a single space (character u20). The special values 
          --   &quot;E&quot; (error), &quot;L&quot; (below detection 
          --   limit) and &quot;U&quot; (above detection limit) can also 
          --   be used in place of a decimal value.
        }
        deriving (Eq,Show)
instance SchemaType SampledData where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SampledData a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "origin"
            `apply` parseSchemaType "period"
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "lowerLimit")
            `apply` optional (parseSchemaType "upperLimit")
            `apply` parseSchemaType "dimensions"
            `apply` parseSchemaType "data"
    schemaTypeToXML s x@SampledData{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sampledData_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sampledData_extension x
            , schemaTypeToXML "origin" $ sampledData_origin x
            , schemaTypeToXML "period" $ sampledData_period x
            , maybe [] (schemaTypeToXML "factor") $ sampledData_factor x
            , maybe [] (schemaTypeToXML "lowerLimit") $ sampledData_lowerLimit x
            , maybe [] (schemaTypeToXML "upperLimit") $ sampledData_upperLimit x
            , schemaTypeToXML "dimensions" $ sampledData_dimensions x
            , schemaTypeToXML "data" $ sampledData_data x
            ]
instance Extension SampledData Element where
    supertype (SampledData a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
newtype SampledDataDataType_primitive = SampledDataDataType_primitive Xsd.XsdString deriving (Eq,Show)
instance Restricts SampledDataDataType_primitive Xsd.XsdString where
    restricts (SampledDataDataType_primitive x) = x
instance SchemaType SampledDataDataType_primitive where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s (SampledDataDataType_primitive x) = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SampledDataDataType_primitive where
    acceptingParser = fmap SampledDataDataType_primitive acceptingParser
    -- XXX should enforce the restrictions somehow?
    -- The restrictions are:
    --      (Pattern ((-{0,1}\d*\.{0,1}\d+)|[EUL])( ((-{0,1}\d*\.{0,1}\d+)|[EUL]))*)
    simpleTypeText (SampledDataDataType_primitive x) = simpleTypeText x
 
data SampledDataDataType = SampledDataDataType
        { sampledDataDataType_id :: Maybe String_primitive
        , sampledDataDataType_value :: Maybe SampledDataDataType_primitive
        , sampledDataDataType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SampledDataDataType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SampledDataDataType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SampledDataDataType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sampledDataDataType_id x
                       , maybe [] (toXMLAttribute "value") $ sampledDataDataType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sampledDataDataType_extension x
            ]
instance Extension SampledDataDataType Element where
    supertype (SampledDataDataType a0 a1 e0) =
               Element a0 e0
 
data Ratio = Ratio
        { ratio_id :: Maybe String_primitive
        , ratio_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , ratio_numerator :: Maybe Quantity
          -- ^ The value of the numerator.
        , ratio_denominator :: Maybe Quantity
          -- ^ The value of the denominator.
        }
        deriving (Eq,Show)
instance SchemaType Ratio where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Ratio a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "numerator")
            `apply` optional (parseSchemaType "denominator")
    schemaTypeToXML s x@Ratio{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ ratio_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ ratio_extension x
            , maybe [] (schemaTypeToXML "numerator") $ ratio_numerator x
            , maybe [] (schemaTypeToXML "denominator") $ ratio_denominator x
            ]
instance Extension Ratio Element where
    supertype (Ratio a0 e0 e1 e2) =
               Element a0 e0
 
data Distance = Distance
        { distance_id :: Maybe String_primitive
        , distance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , distance_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , distance_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , distance_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , distance_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , distance_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Distance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Distance a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Distance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ distance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ distance_extension x
            , maybe [] (schemaTypeToXML "value") $ distance_value x
            , maybe [] (schemaTypeToXML "comparator") $ distance_comparator x
            , maybe [] (schemaTypeToXML "unit") $ distance_unit x
            , maybe [] (schemaTypeToXML "system") $ distance_system x
            , maybe [] (schemaTypeToXML "code") $ distance_code x
            ]
instance Extension Distance Quantity where
    supertype (Distance a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Distance Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Distance -> Quantity)
              
 
data Age = Age
        { age_id :: Maybe String_primitive
        , age_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , age_value :: Maybe Decimal
          -- ^ The value of the measured amount. The value includes an 
          --   implicit precision in the presentation of the value.
        , age_comparator :: Maybe QuantityComparator
          -- ^ How the value should be understood and represented - 
          --   whether the actual value is greater or less than the stated 
          --   value due to measurement issues; e.g. if the comparator is 
          --   &quot;&lt;&quot; , then the real value is &lt; stated 
          --   value.
        , age_unit :: Maybe Xsd.XsdString
          -- ^ A human-readable form of the unit.
        , age_system :: Maybe Uri
          -- ^ The identification of the system that provides the coded 
          --   form of the unit.
        , age_code :: Maybe Code
          -- ^ A computer processable form of the unit in some unit 
          --   representation system.
        }
        deriving (Eq,Show)
instance SchemaType Age where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Age a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "comparator")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Age{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ age_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ age_extension x
            , maybe [] (schemaTypeToXML "value") $ age_value x
            , maybe [] (schemaTypeToXML "comparator") $ age_comparator x
            , maybe [] (schemaTypeToXML "unit") $ age_unit x
            , maybe [] (schemaTypeToXML "system") $ age_system x
            , maybe [] (schemaTypeToXML "code") $ age_code x
            ]
instance Extension Age Quantity where
    supertype (Age a0 e0 e1 e2 e3 e4 e5) =
               Quantity a0 e0 e1 e2 e3 e4 e5
instance Extension Age Element where
    supertype = (supertype :: Quantity -> Element)
              . (supertype :: Age -> Quantity)
              
 
data CodeableConcept = CodeableConcept
        { codeableConcept_id :: Maybe String_primitive
        , codeableConcept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeableConcept_coding :: [Coding]
          -- ^ A reference to a code defined by a terminology system.
        , codeableConcept_text :: Maybe Xsd.XsdString
          -- ^ A human language representation of the concept as 
          --   seen/selected/uttered by the user who entered the data 
          --   and/or which represents the intended meaning of the user.
        }
        deriving (Eq,Show)
instance SchemaType CodeableConcept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeableConcept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "coding")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@CodeableConcept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeableConcept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeableConcept_extension x
            , concatMap (schemaTypeToXML "coding") $ codeableConcept_coding x
            , maybe [] (schemaTypeToXML "text") $ codeableConcept_text x
            ]
instance Extension CodeableConcept Element where
    supertype (CodeableConcept a0 e0 e1 e2) =
               Element a0 e0
 
data Meta = Meta
        { meta_id :: Maybe String_primitive
        , meta_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , meta_versionId :: Maybe Id
          -- ^ The version specific identifier, as it appears in the 
          --   version portion of the URL. This values changes when the 
          --   resource is created, updated, or deleted.
        , meta_lastUpdated :: Maybe Instant
          -- ^ When the resource last changed - e.g. when the version 
          --   changed.
        , meta_profile :: [Uri]
          -- ^ A list of profiles (references to [[[StructureDefinition]]] 
          --   resources) that this resource claims to conform to. The URL 
          --   is a reference to [[[StructureDefinition.url]]].
        , meta_security :: [Coding]
          -- ^ Security labels applied to this resource. These tags 
          --   connect specific resources to the overall security policy 
          --   and infrastructure.
        , meta_tag :: [Coding]
          -- ^ Tags applied to this resource. Tags are intended to be used 
          --   to identify and relate resources to process and workflow, 
          --   and applications are not required to consider the tags when 
          --   interpreting the meaning of a resource.
        }
        deriving (Eq,Show)
instance SchemaType Meta where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Meta a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "versionId")
            `apply` optional (parseSchemaType "lastUpdated")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "security")
            `apply` many (parseSchemaType "tag")
    schemaTypeToXML s x@Meta{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ meta_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ meta_extension x
            , maybe [] (schemaTypeToXML "versionId") $ meta_versionId x
            , maybe [] (schemaTypeToXML "lastUpdated") $ meta_lastUpdated x
            , concatMap (schemaTypeToXML "profile") $ meta_profile x
            , concatMap (schemaTypeToXML "security") $ meta_security x
            , concatMap (schemaTypeToXML "tag") $ meta_tag x
            ]
instance Extension Meta Element where
    supertype (Meta a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data Address = Address
        { address_id :: Maybe String_primitive
        , address_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , address_use :: Maybe AddressUse
          -- ^ The purpose of this address.
        , address_type :: Maybe AddressType
          -- ^ Distinguishes between physical addresses (those you can 
          --   visit) and mailing addresses (e.g. PO Boxes and care-of 
          --   addresses). Most addresses are both.
        , address_text :: Maybe Xsd.XsdString
          -- ^ A full text representation of the address.
        , address_line :: [Xsd.XsdString]
          -- ^ This component contains the house number, apartment number, 
          --   street name, street direction, P.O. Box number, delivery 
          --   hints, and similar address information.
        , address_city :: Maybe Xsd.XsdString
          -- ^ The name of the city, town, village or other community or 
          --   delivery center.
        , address_district :: Maybe Xsd.XsdString
          -- ^ The name of the administrative area (county).
        , address_state :: Maybe Xsd.XsdString
          -- ^ Sub-unit of a country with limited sovereignty in a 
          --   federally organized country. A code may be used if codes 
          --   are in common use (i.e. US 2 letter state codes).
        , address_postalCode :: Maybe Xsd.XsdString
          -- ^ A postal code designating a region defined by the postal 
          --   service.
        , address_country :: Maybe Xsd.XsdString
          -- ^ Country - a nation as commonly understood or generally 
          --   accepted.
        , address_period :: Maybe Period
          -- ^ Time period when address was/is in use.
        }
        deriving (Eq,Show)
instance SchemaType Address where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Address a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "line")
            `apply` optional (parseSchemaType "city")
            `apply` optional (parseSchemaType "district")
            `apply` optional (parseSchemaType "state")
            `apply` optional (parseSchemaType "postalCode")
            `apply` optional (parseSchemaType "country")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@Address{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ address_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ address_extension x
            , maybe [] (schemaTypeToXML "use") $ address_use x
            , maybe [] (schemaTypeToXML "type") $ address_type x
            , maybe [] (schemaTypeToXML "text") $ address_text x
            , concatMap (schemaTypeToXML "line") $ address_line x
            , maybe [] (schemaTypeToXML "city") $ address_city x
            , maybe [] (schemaTypeToXML "district") $ address_district x
            , maybe [] (schemaTypeToXML "state") $ address_state x
            , maybe [] (schemaTypeToXML "postalCode") $ address_postalCode x
            , maybe [] (schemaTypeToXML "country") $ address_country x
            , maybe [] (schemaTypeToXML "period") $ address_period x
            ]
instance Extension Address Element where
    supertype (Address a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               Element a0 e0
 
data AddressUse_list
    = AddressUse_list_Home
      -- ^ Home
    | AddressUse_list_Work
      -- ^ Work
    | AddressUse_list_Temp
      -- ^ Temporary
    | AddressUse_list_Old
      -- ^ Old / Incorrect
    deriving (Eq,Show,Enum)
instance SchemaType AddressUse_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AddressUse_list where
    acceptingParser =  do literal "home"; return AddressUse_list_Home
                      `onFail` do literal "work"; return AddressUse_list_Work
                      `onFail` do literal "temp"; return AddressUse_list_Temp
                      `onFail` do literal "old"; return AddressUse_list_Old
                      
    simpleTypeText AddressUse_list_Home = "home"
    simpleTypeText AddressUse_list_Work = "work"
    simpleTypeText AddressUse_list_Temp = "temp"
    simpleTypeText AddressUse_list_Old = "old"
 
data AddressUse = AddressUse
        { addressUse_id :: Maybe String_primitive
        , addressUse_value :: Maybe AddressUse_list
        , addressUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AddressUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AddressUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AddressUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ addressUse_id x
                       , maybe [] (toXMLAttribute "value") $ addressUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ addressUse_extension x
            ]
instance Extension AddressUse Element where
    supertype (AddressUse a0 a1 e0) =
               Element a0 e0
 
data AddressType_list
    = AddressType_list_Postal
      -- ^ Postal
    | AddressType_list_Physical
      -- ^ Physical
    | AddressType_list_Both
      -- ^ Postal &amp; Physical
    deriving (Eq,Show,Enum)
instance SchemaType AddressType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AddressType_list where
    acceptingParser =  do literal "postal"; return AddressType_list_Postal
                      `onFail` do literal "physical"; return AddressType_list_Physical
                      `onFail` do literal "both"; return AddressType_list_Both
                      
    simpleTypeText AddressType_list_Postal = "postal"
    simpleTypeText AddressType_list_Physical = "physical"
    simpleTypeText AddressType_list_Both = "both"
 
data AddressType = AddressType
        { addressType_id :: Maybe String_primitive
        , addressType_value :: Maybe AddressType_list
        , addressType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AddressType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AddressType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AddressType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ addressType_id x
                       , maybe [] (toXMLAttribute "value") $ addressType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ addressType_extension x
            ]
instance Extension AddressType Element where
    supertype (AddressType a0 a1 e0) =
               Element a0 e0
 
data TriggerDefinition = TriggerDefinition
        { triggerDefinition_id :: Maybe String_primitive
        , triggerDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , triggerDefinition_type :: TriggerType
          -- ^ The type of triggering event.
        , triggerDefinition_eventName :: Maybe Xsd.XsdString
          -- ^ The name of the event (if this is a named-event trigger).
        , triggerDefinition_choice3 :: (Maybe (OneOf4 [Timing] [Reference] [Date] [DateTime]))
          -- ^ The timing of the event (if this is a period trigger).
          --   
          --   Choice between:
          --   
          --   (1) eventTimingTiming
          --   
          --   (2) eventTimingReference
          --   
          --   (3) eventTimingDate
          --   
          --   (4) eventTimingDateTime
        , triggerDefinition_eventData :: Maybe DataRequirement
          -- ^ The triggering data of the event (if this is a data 
          --   trigger).
        }
        deriving (Eq,Show)
instance SchemaType TriggerDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TriggerDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "eventName")
            `apply` optional (oneOf' [ ("[Timing]", fmap OneOf4 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "eventTimingTiming")))
                                     , ("[Reference]", fmap TwoOf4 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "eventTimingReference")))
                                     , ("[Date]", fmap ThreeOf4 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "eventTimingDate")))
                                     , ("[DateTime]", fmap FourOf4 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "eventTimingDateTime")))
                                     ])
            `apply` optional (parseSchemaType "eventData")
    schemaTypeToXML s x@TriggerDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ triggerDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ triggerDefinition_extension x
            , schemaTypeToXML "type" $ triggerDefinition_type x
            , maybe [] (schemaTypeToXML "eventName") $ triggerDefinition_eventName x
            , maybe [] (foldOneOf4  (concatMap (schemaTypeToXML "eventTimingTiming"))
                                    (concatMap (schemaTypeToXML "eventTimingReference"))
                                    (concatMap (schemaTypeToXML "eventTimingDate"))
                                    (concatMap (schemaTypeToXML "eventTimingDateTime"))
                                   ) $ triggerDefinition_choice3 x
            , maybe [] (schemaTypeToXML "eventData") $ triggerDefinition_eventData x
            ]
instance Extension TriggerDefinition Element where
    supertype (TriggerDefinition a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data TriggerType_list
    = TriggerType_list_Named_event
      -- ^ Named Event
    | TriggerType_list_Periodic
      -- ^ Periodic
    | TriggerType_list_Data_added
      -- ^ Data Added
    | TriggerType_list_Data_modified
      -- ^ Data Modified
    | TriggerType_list_Data_removed
      -- ^ Data Removed
    | TriggerType_list_Data_accessed
      -- ^ Data Accessed
    | TriggerType_list_Data_access_ended
      -- ^ Data Access Ended
    deriving (Eq,Show,Enum)
instance SchemaType TriggerType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TriggerType_list where
    acceptingParser =  do literal "named-event"; return TriggerType_list_Named_event
                      `onFail` do literal "periodic"; return TriggerType_list_Periodic
                      `onFail` do literal "data-added"; return TriggerType_list_Data_added
                      `onFail` do literal "data-modified"; return TriggerType_list_Data_modified
                      `onFail` do literal "data-removed"; return TriggerType_list_Data_removed
                      `onFail` do literal "data-accessed"; return TriggerType_list_Data_accessed
                      `onFail` do literal "data-access-ended"; return TriggerType_list_Data_access_ended
                      
    simpleTypeText TriggerType_list_Named_event = "named-event"
    simpleTypeText TriggerType_list_Periodic = "periodic"
    simpleTypeText TriggerType_list_Data_added = "data-added"
    simpleTypeText TriggerType_list_Data_modified = "data-modified"
    simpleTypeText TriggerType_list_Data_removed = "data-removed"
    simpleTypeText TriggerType_list_Data_accessed = "data-accessed"
    simpleTypeText TriggerType_list_Data_access_ended = "data-access-ended"
 
data TriggerType = TriggerType
        { triggerType_id :: Maybe String_primitive
        , triggerType_value :: Maybe TriggerType_list
        , triggerType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TriggerType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TriggerType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TriggerType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ triggerType_id x
                       , maybe [] (toXMLAttribute "value") $ triggerType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ triggerType_extension x
            ]
instance Extension TriggerType Element where
    supertype (TriggerType a0 a1 e0) =
               Element a0 e0
 
data Contributor = Contributor
        { contributor_id :: Maybe String_primitive
        , contributor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contributor_type :: ContributorType
          -- ^ The type of contributor.
        , contributor_name :: Xsd.XsdString
          -- ^ The name of the individual or organization responsible for 
          --   the contribution.
        , contributor_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the contributor.
        }
        deriving (Eq,Show)
instance SchemaType Contributor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Contributor a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "name"
            `apply` many (parseSchemaType "contact")
    schemaTypeToXML s x@Contributor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contributor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contributor_extension x
            , schemaTypeToXML "type" $ contributor_type x
            , schemaTypeToXML "name" $ contributor_name x
            , concatMap (schemaTypeToXML "contact") $ contributor_contact x
            ]
instance Extension Contributor Element where
    supertype (Contributor a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ContributorType_list
    = ContributorType_list_Author
      -- ^ Author
    | ContributorType_list_Editor
      -- ^ Editor
    | ContributorType_list_Reviewer
      -- ^ Reviewer
    | ContributorType_list_Endorser
      -- ^ Endorser
    deriving (Eq,Show,Enum)
instance SchemaType ContributorType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContributorType_list where
    acceptingParser =  do literal "author"; return ContributorType_list_Author
                      `onFail` do literal "editor"; return ContributorType_list_Editor
                      `onFail` do literal "reviewer"; return ContributorType_list_Reviewer
                      `onFail` do literal "endorser"; return ContributorType_list_Endorser
                      
    simpleTypeText ContributorType_list_Author = "author"
    simpleTypeText ContributorType_list_Editor = "editor"
    simpleTypeText ContributorType_list_Reviewer = "reviewer"
    simpleTypeText ContributorType_list_Endorser = "endorser"
 
data ContributorType = ContributorType
        { contributorType_id :: Maybe String_primitive
        , contributorType_value :: Maybe ContributorType_list
        , contributorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContributorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContributorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContributorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contributorType_id x
                       , maybe [] (toXMLAttribute "value") $ contributorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contributorType_extension x
            ]
instance Extension ContributorType Element where
    supertype (ContributorType a0 a1 e0) =
               Element a0 e0
 
data DataRequirement = DataRequirement
        { dataRequirement_id :: Maybe String_primitive
        , dataRequirement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirement_type :: Code
          -- ^ The type of the required data, specified as the type name 
          --   of a resource. For profiles, this value is set to the type 
          --   of the base resource of the profile.
        , dataRequirement_profile :: [Uri]
          -- ^ The profile of the required data, specified as the uri of 
          --   the profile definition.
        , dataRequirement_mustSupport :: [Xsd.XsdString]
          -- ^ Indicates that specific elements of the type are referenced 
          --   by the knowledge module and must be supported by the 
          --   consumer in order to obtain an effective evaluation. This 
          --   does not mean that a value is required for this element, 
          --   only that the consuming system must understand the element 
          --   and be able to provide values for it if they are available. 
          --   Note that the value for this element can be a path to allow 
          --   references to nested elements. In that case, all the 
          --   elements along the path must be supported.
        , dataRequirement_codeFilter :: [DataRequirementCodeFilter]
          -- ^ Code filters specify additional constraints on the data, 
          --   specifying the value set of interest for a particular 
          --   element of the data.
        , dataRequirement_dateFilter :: [DataRequirementDateFilter]
          -- ^ Date filters specify additional constraints on the data in 
          --   terms of the applicable date range for specific elements.
        }
        deriving (Eq,Show)
instance SchemaType DataRequirement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirement a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "mustSupport")
            `apply` many (parseSchemaType "codeFilter")
            `apply` many (parseSchemaType "dateFilter")
    schemaTypeToXML s x@DataRequirement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirement_extension x
            , schemaTypeToXML "type" $ dataRequirement_type x
            , concatMap (schemaTypeToXML "profile") $ dataRequirement_profile x
            , concatMap (schemaTypeToXML "mustSupport") $ dataRequirement_mustSupport x
            , concatMap (schemaTypeToXML "codeFilter") $ dataRequirement_codeFilter x
            , concatMap (schemaTypeToXML "dateFilter") $ dataRequirement_dateFilter x
            ]
instance Extension DataRequirement Element where
    supertype (DataRequirement a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data DataRequirementCodeFilter = DataRequirementCodeFilter
        { dataRequirementCodeFilter_id :: Maybe String_primitive
        , dataRequirementCodeFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirementCodeFilter_path :: Xsd.XsdString
          -- ^ The code-valued attribute of the filter. The specified path 
          --   must be resolvable from the type of the required data. The 
          --   path is allowed to contain qualifiers (.) to traverse 
          --   sub-elements, as well as indexers ([x]) to traverse 
          --   multiple-cardinality sub-elements. Note that the index must 
          --   be an integer constant. The path must resolve to an element 
          --   of type code, Coding, or CodeableConcept.
        , dataRequirementCodeFilter_choice2 :: (Maybe (OneOf2 [Xsd.XsdString] [Reference]))
          -- ^ The valueset for the code filter. The valueSet and value 
          --   elements are exclusive. If valueSet is specified, the 
          --   filter will return only those data items for which the 
          --   value of the code-valued element specified in the path is a 
          --   member of the specified valueset.
          --   
          --   Choice between:
          --   
          --   (1) valueSetString
          --   
          --   (2) valueSetReference
        , dataRequirementCodeFilter_valueCode :: [Code]
          -- ^ The codes for the code filter. Only one of valueSet, 
          --   valueCode, valueCoding, or valueCodeableConcept may be 
          --   specified. If values are given, the filter will return only 
          --   those data items for which the code-valued attribute 
          --   specified by the path has a value that is one of the 
          --   specified codes.
        , dataRequirementCodeFilter_valueCoding :: [Coding]
          -- ^ The Codings for the code filter. Only one of valueSet, 
          --   valueCode, valueConding, or valueCodeableConcept may be 
          --   specified. If values are given, the filter will return only 
          --   those data items for which the code-valued attribute 
          --   specified by the path has a value that is one of the 
          --   specified Codings.
        , dataRequirementCodeFilter_valueCodeableConcept :: [CodeableConcept]
          -- ^ The CodeableConcepts for the code filter. Only one of 
          --   valueSet, valueCode, valueConding, or valueCodeableConcept 
          --   may be specified. If values are given, the filter will 
          --   return only those data items for which the code-valued 
          --   attribute specified by the path has a value that is one of 
          --   the specified CodeableConcepts.
        }
        deriving (Eq,Show)
instance SchemaType DataRequirementCodeFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirementCodeFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` optional (oneOf' [ ("[Xsd.XsdString]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "valueSetString")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "valueSetReference")))
                                     ])
            `apply` many (parseSchemaType "valueCode")
            `apply` many (parseSchemaType "valueCoding")
            `apply` many (parseSchemaType "valueCodeableConcept")
    schemaTypeToXML s x@DataRequirementCodeFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirementCodeFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirementCodeFilter_extension x
            , schemaTypeToXML "path" $ dataRequirementCodeFilter_path x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "valueSetString"))
                                    (concatMap (schemaTypeToXML "valueSetReference"))
                                   ) $ dataRequirementCodeFilter_choice2 x
            , concatMap (schemaTypeToXML "valueCode") $ dataRequirementCodeFilter_valueCode x
            , concatMap (schemaTypeToXML "valueCoding") $ dataRequirementCodeFilter_valueCoding x
            , concatMap (schemaTypeToXML "valueCodeableConcept") $ dataRequirementCodeFilter_valueCodeableConcept x
            ]
instance Extension DataRequirementCodeFilter Element where
    supertype (DataRequirementCodeFilter a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data DataRequirementDateFilter = DataRequirementDateFilter
        { dataRequirementDateFilter_id :: Maybe String_primitive
        , dataRequirementDateFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataRequirementDateFilter_path :: Xsd.XsdString
          -- ^ The date-valued attribute of the filter. The specified path 
          --   must be resolvable from the type of the required data. The 
          --   path is allowed to contain qualifiers (.) to traverse 
          --   sub-elements, as well as indexers ([x]) to traverse 
          --   multiple-cardinality sub-elements. Note that the index must 
          --   be an integer constant. The path must resolve to an element 
          --   of type dateTime, Period, Schedule, or Timing.
        , dataRequirementDateFilter_choice2 :: (Maybe (OneOf3 [DateTime] [Period] [Duration]))
          -- ^ The value of the filter. If period is specified, the filter 
          --   will return only those data items that fall within the 
          --   bounds determined by the Period, inclusive of the period 
          --   boundaries. If dateTime is specified, the filter will 
          --   return only those data items that are equal to the 
          --   specified dateTime. If a Duration is specified, the filter 
          --   will return only those data items that fall within Duration 
          --   from now.
          --   
          --   Choice between:
          --   
          --   (1) valueDateTime
          --   
          --   (2) valuePeriod
          --   
          --   (3) valueDuration
        }
        deriving (Eq,Show)
instance SchemaType DataRequirementDateFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataRequirementDateFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` optional (oneOf' [ ("[DateTime]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "valueDateTime")))
                                     , ("[Period]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                         (parseSchemaType "valuePeriod")))
                                     , ("[Duration]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                             (parseSchemaType "valueDuration")))
                                     ])
    schemaTypeToXML s x@DataRequirementDateFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataRequirementDateFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataRequirementDateFilter_extension x
            , schemaTypeToXML "path" $ dataRequirementDateFilter_path x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "valueDateTime"))
                                    (concatMap (schemaTypeToXML "valuePeriod"))
                                    (concatMap (schemaTypeToXML "valueDuration"))
                                   ) $ dataRequirementDateFilter_choice2 x
            ]
instance Extension DataRequirementDateFilter Element where
    supertype (DataRequirementDateFilter a0 e0 e1 e2) =
               Element a0 e0
 
data Dosage = Dosage
        { dosage_id :: Maybe String_primitive
        , dosage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dosage_sequence :: Maybe Integer
          -- ^ Indicates the order in which the dosage instructions should 
          --   be applied or interpreted.
        , dosage_text :: Maybe Xsd.XsdString
          -- ^ Free text dosage instructions e.g. SIG.
        , dosage_additionalInstruction :: [CodeableConcept]
          -- ^ Supplemental instruction - e.g. &quot;with meals&quot;.
        , dosage_patientInstruction :: Maybe Xsd.XsdString
          -- ^ Instructions in terms that are understood by the patient or 
          --   consumer.
        , dosage_timing :: Maybe Timing
          -- ^ When medication should be administered.
        , dosage_choice6 :: (Maybe (OneOf2 [Boolean] [CodeableConcept]))
          -- ^ Indicates whether the Medication is only taken when needed 
          --   within a specific dosing schedule (Boolean option), or it 
          --   indicates the precondition for taking the Medication 
          --   (CodeableConcept).
          --   
          --   Choice between:
          --   
          --   (1) asNeededBoolean
          --   
          --   (2) asNeededCodeableConcept
        , dosage_site :: Maybe CodeableConcept
          -- ^ Body site to administer to.
        , dosage_route :: Maybe CodeableConcept
          -- ^ How drug should enter body.
        , dosage_method :: Maybe CodeableConcept
          -- ^ Technique for administering medication.
        , dosage_choice10 :: (Maybe (OneOf2 [Range] [Quantity]))
          -- ^ Amount of medication per dose.
          --   
          --   Choice between:
          --   
          --   (1) doseRange
          --   
          --   (2) doseQuantity
        , dosage_maxDosePerPeriod :: Maybe Ratio
          -- ^ Upper limit on medication per unit of time.
        , dosage_maxDosePerAdministration :: Maybe Quantity
          -- ^ Upper limit on medication per administration.
        , dosage_maxDosePerLifetime :: Maybe Quantity
          -- ^ Upper limit on medication per lifetime of the patient.
        , dosage_choice14 :: (Maybe (OneOf3 [Ratio] [Range] [Quantity]))
          -- ^ Amount of medication per unit of time.
          --   
          --   Choice between:
          --   
          --   (1) rateRatio
          --   
          --   (2) rateRange
          --   
          --   (3) rateQuantity
        }
        deriving (Eq,Show)
instance SchemaType Dosage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Dosage a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "sequence")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "additionalInstruction")
            `apply` optional (parseSchemaType "patientInstruction")
            `apply` optional (parseSchemaType "timing")
            `apply` optional (oneOf' [ ("[Boolean]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "asNeededBoolean")))
                                     , ("[CodeableConcept]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                                  (parseSchemaType "asNeededCodeableConcept")))
                                     ])
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "method")
            `apply` optional (oneOf' [ ("[Range]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "doseRange")))
                                     , ("[Quantity]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "doseQuantity")))
                                     ])
            `apply` optional (parseSchemaType "maxDosePerPeriod")
            `apply` optional (parseSchemaType "maxDosePerAdministration")
            `apply` optional (parseSchemaType "maxDosePerLifetime")
            `apply` optional (oneOf' [ ("[Ratio]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "rateRatio")))
                                     , ("[Range]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "rateRange")))
                                     , ("[Quantity]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                             (parseSchemaType "rateQuantity")))
                                     ])
    schemaTypeToXML s x@Dosage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dosage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dosage_extension x
            , maybe [] (schemaTypeToXML "sequence") $ dosage_sequence x
            , maybe [] (schemaTypeToXML "text") $ dosage_text x
            , concatMap (schemaTypeToXML "additionalInstruction") $ dosage_additionalInstruction x
            , maybe [] (schemaTypeToXML "patientInstruction") $ dosage_patientInstruction x
            , maybe [] (schemaTypeToXML "timing") $ dosage_timing x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "asNeededBoolean"))
                                    (concatMap (schemaTypeToXML "asNeededCodeableConcept"))
                                   ) $ dosage_choice6 x
            , maybe [] (schemaTypeToXML "site") $ dosage_site x
            , maybe [] (schemaTypeToXML "route") $ dosage_route x
            , maybe [] (schemaTypeToXML "method") $ dosage_method x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "doseRange"))
                                    (concatMap (schemaTypeToXML "doseQuantity"))
                                   ) $ dosage_choice10 x
            , maybe [] (schemaTypeToXML "maxDosePerPeriod") $ dosage_maxDosePerPeriod x
            , maybe [] (schemaTypeToXML "maxDosePerAdministration") $ dosage_maxDosePerAdministration x
            , maybe [] (schemaTypeToXML "maxDosePerLifetime") $ dosage_maxDosePerLifetime x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "rateRatio"))
                                    (concatMap (schemaTypeToXML "rateRange"))
                                    (concatMap (schemaTypeToXML "rateQuantity"))
                                   ) $ dosage_choice14 x
            ]
instance Extension Dosage Element where
    supertype (Dosage a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               Element a0 e0
 
data RelatedArtifact = RelatedArtifact
        { relatedArtifact_id :: Maybe String_primitive
        , relatedArtifact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , relatedArtifact_type :: RelatedArtifactType
          -- ^ The type of relationship to the related artifact.
        , relatedArtifact_display :: Maybe Xsd.XsdString
          -- ^ A brief description of the document or knowledge resource 
          --   being referenced, suitable for display to a consumer.
        , relatedArtifact_citation :: Maybe Xsd.XsdString
          -- ^ A bibliographic citation for the related artifact. This 
          --   text SHOULD be formatted according to an accepted citation 
          --   format.
        , relatedArtifact_url :: Maybe Uri
          -- ^ A url for the artifact that can be followed to access the 
          --   actual content.
        , relatedArtifact_document :: Maybe Attachment
          -- ^ The document being referenced, represented as an 
          --   attachment. This is exclusive with the resource element.
        , relatedArtifact_resource :: Maybe Reference
          -- ^ The related resource, such as a library, value set, 
          --   profile, or other knowledge resource.
        }
        deriving (Eq,Show)
instance SchemaType RelatedArtifact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RelatedArtifact a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "citation")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "document")
            `apply` optional (parseSchemaType "resource")
    schemaTypeToXML s x@RelatedArtifact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ relatedArtifact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ relatedArtifact_extension x
            , schemaTypeToXML "type" $ relatedArtifact_type x
            , maybe [] (schemaTypeToXML "display") $ relatedArtifact_display x
            , maybe [] (schemaTypeToXML "citation") $ relatedArtifact_citation x
            , maybe [] (schemaTypeToXML "url") $ relatedArtifact_url x
            , maybe [] (schemaTypeToXML "document") $ relatedArtifact_document x
            , maybe [] (schemaTypeToXML "resource") $ relatedArtifact_resource x
            ]
instance Extension RelatedArtifact Element where
    supertype (RelatedArtifact a0 e0 e1 e2 e3 e4 e5 e6) =
               Element a0 e0
 
data RelatedArtifactType_list
    = RelatedArtifactType_list_Documentation
      -- ^ Documentation
    | RelatedArtifactType_list_Justification
      -- ^ Justification
    | RelatedArtifactType_list_Citation
      -- ^ Citation
    | RelatedArtifactType_list_Predecessor
      -- ^ Predecessor
    | RelatedArtifactType_list_Successor
      -- ^ Successor
    | RelatedArtifactType_list_Derived_from
      -- ^ Derived From
    | RelatedArtifactType_list_Depends_on
      -- ^ Depends On
    | RelatedArtifactType_list_Composed_of
      -- ^ Composed Of
    deriving (Eq,Show,Enum)
instance SchemaType RelatedArtifactType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RelatedArtifactType_list where
    acceptingParser =  do literal "documentation"; return RelatedArtifactType_list_Documentation
                      `onFail` do literal "justification"; return RelatedArtifactType_list_Justification
                      `onFail` do literal "citation"; return RelatedArtifactType_list_Citation
                      `onFail` do literal "predecessor"; return RelatedArtifactType_list_Predecessor
                      `onFail` do literal "successor"; return RelatedArtifactType_list_Successor
                      `onFail` do literal "derived-from"; return RelatedArtifactType_list_Derived_from
                      `onFail` do literal "depends-on"; return RelatedArtifactType_list_Depends_on
                      `onFail` do literal "composed-of"; return RelatedArtifactType_list_Composed_of
                      
    simpleTypeText RelatedArtifactType_list_Documentation = "documentation"
    simpleTypeText RelatedArtifactType_list_Justification = "justification"
    simpleTypeText RelatedArtifactType_list_Citation = "citation"
    simpleTypeText RelatedArtifactType_list_Predecessor = "predecessor"
    simpleTypeText RelatedArtifactType_list_Successor = "successor"
    simpleTypeText RelatedArtifactType_list_Derived_from = "derived-from"
    simpleTypeText RelatedArtifactType_list_Depends_on = "depends-on"
    simpleTypeText RelatedArtifactType_list_Composed_of = "composed-of"
 
data RelatedArtifactType = RelatedArtifactType
        { relatedArtifactType_id :: Maybe String_primitive
        , relatedArtifactType_value :: Maybe RelatedArtifactType_list
        , relatedArtifactType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RelatedArtifactType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RelatedArtifactType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RelatedArtifactType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ relatedArtifactType_id x
                       , maybe [] (toXMLAttribute "value") $ relatedArtifactType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ relatedArtifactType_extension x
            ]
instance Extension RelatedArtifactType Element where
    supertype (RelatedArtifactType a0 a1 e0) =
               Element a0 e0
 
data ContactDetail = ContactDetail
        { contactDetail_id :: Maybe String_primitive
        , contactDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contactDetail_name :: Maybe Xsd.XsdString
          -- ^ The name of an individual to contact.
        , contactDetail_telecom :: [ContactPoint]
          -- ^ The contact details for the individual (if a name was 
          --   provided) or the organization.
        }
        deriving (Eq,Show)
instance SchemaType ContactDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContactDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
    schemaTypeToXML s x@ContactDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactDetail_extension x
            , maybe [] (schemaTypeToXML "name") $ contactDetail_name x
            , concatMap (schemaTypeToXML "telecom") $ contactDetail_telecom x
            ]
instance Extension ContactDetail Element where
    supertype (ContactDetail a0 e0 e1 e2) =
               Element a0 e0
 
data HumanName = HumanName
        { humanName_id :: Maybe String_primitive
        , humanName_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , humanName_use :: Maybe NameUse
          -- ^ Identifies the purpose for this name.
        , humanName_text :: Maybe Xsd.XsdString
          -- ^ A full text representation of the name.
        , humanName_family :: Maybe Xsd.XsdString
          -- ^ The part of a name that links to the genealogy. In some 
          --   cultures (e.g. Eritrea) the family name of a son is the 
          --   first name of his father.
        , humanName_given :: [Xsd.XsdString]
          -- ^ Given name.
        , humanName_prefix :: [Xsd.XsdString]
          -- ^ Part of the name that is acquired as a title due to 
          --   academic, legal, employment or nobility status, etc. and 
          --   that appears at the start of the name.
        , humanName_suffix :: [Xsd.XsdString]
          -- ^ Part of the name that is acquired as a title due to 
          --   academic, legal, employment or nobility status, etc. and 
          --   that appears at the end of the name.
        , humanName_period :: Maybe Period
          -- ^ Indicates the period of time when this name was valid for 
          --   the named person.
        }
        deriving (Eq,Show)
instance SchemaType HumanName where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HumanName a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "family")
            `apply` many (parseSchemaType "given")
            `apply` many (parseSchemaType "prefix")
            `apply` many (parseSchemaType "suffix")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@HumanName{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ humanName_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ humanName_extension x
            , maybe [] (schemaTypeToXML "use") $ humanName_use x
            , maybe [] (schemaTypeToXML "text") $ humanName_text x
            , maybe [] (schemaTypeToXML "family") $ humanName_family x
            , concatMap (schemaTypeToXML "given") $ humanName_given x
            , concatMap (schemaTypeToXML "prefix") $ humanName_prefix x
            , concatMap (schemaTypeToXML "suffix") $ humanName_suffix x
            , maybe [] (schemaTypeToXML "period") $ humanName_period x
            ]
instance Extension HumanName Element where
    supertype (HumanName a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
data NameUse_list
    = NameUse_list_Usual
      -- ^ Usual
    | NameUse_list_Official
      -- ^ Official
    | NameUse_list_Temp
      -- ^ Temp
    | NameUse_list_Nickname
      -- ^ Nickname
    | NameUse_list_Anonymous
      -- ^ Anonymous
    | NameUse_list_Old
      -- ^ Old
    | NameUse_list_Maiden
      -- ^ Name changed for Marriage
    deriving (Eq,Show,Enum)
instance SchemaType NameUse_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NameUse_list where
    acceptingParser =  do literal "usual"; return NameUse_list_Usual
                      `onFail` do literal "official"; return NameUse_list_Official
                      `onFail` do literal "temp"; return NameUse_list_Temp
                      `onFail` do literal "nickname"; return NameUse_list_Nickname
                      `onFail` do literal "anonymous"; return NameUse_list_Anonymous
                      `onFail` do literal "old"; return NameUse_list_Old
                      `onFail` do literal "maiden"; return NameUse_list_Maiden
                      
    simpleTypeText NameUse_list_Usual = "usual"
    simpleTypeText NameUse_list_Official = "official"
    simpleTypeText NameUse_list_Temp = "temp"
    simpleTypeText NameUse_list_Nickname = "nickname"
    simpleTypeText NameUse_list_Anonymous = "anonymous"
    simpleTypeText NameUse_list_Old = "old"
    simpleTypeText NameUse_list_Maiden = "maiden"
 
data NameUse = NameUse
        { nameUse_id :: Maybe String_primitive
        , nameUse_value :: Maybe NameUse_list
        , nameUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NameUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NameUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NameUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nameUse_id x
                       , maybe [] (toXMLAttribute "value") $ nameUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nameUse_extension x
            ]
instance Extension NameUse Element where
    supertype (NameUse a0 a1 e0) =
               Element a0 e0
 
data ContactPoint = ContactPoint
        { contactPoint_id :: Maybe String_primitive
        , contactPoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contactPoint_system :: Maybe ContactPointSystem
          -- ^ Telecommunications form for contact point - what 
          --   communications system is required to make use of the 
          --   contact.
        , contactPoint_value :: Maybe Xsd.XsdString
          -- ^ The actual contact point details, in a form that is 
          --   meaningful to the designated communication system (i.e. 
          --   phone number or email address).
        , contactPoint_use :: Maybe ContactPointUse
          -- ^ Identifies the purpose for the contact point.
        , contactPoint_rank :: Maybe PositiveInt
          -- ^ Specifies a preferred order in which to use a set of 
          --   contacts. Contacts are ranked with lower values coming 
          --   before higher values.
        , contactPoint_period :: Maybe Period
          -- ^ Time period when the contact point was/is in use.
        }
        deriving (Eq,Show)
instance SchemaType ContactPoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContactPoint a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "rank")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@ContactPoint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPoint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPoint_extension x
            , maybe [] (schemaTypeToXML "system") $ contactPoint_system x
            , maybe [] (schemaTypeToXML "value") $ contactPoint_value x
            , maybe [] (schemaTypeToXML "use") $ contactPoint_use x
            , maybe [] (schemaTypeToXML "rank") $ contactPoint_rank x
            , maybe [] (schemaTypeToXML "period") $ contactPoint_period x
            ]
instance Extension ContactPoint Element where
    supertype (ContactPoint a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data ContactPointSystem_list
    = ContactPointSystem_list_Phone
      -- ^ Phone
    | ContactPointSystem_list_Fax
      -- ^ Fax
    | ContactPointSystem_list_Email
      -- ^ Email
    | ContactPointSystem_list_Pager
      -- ^ Pager
    | ContactPointSystem_list_Url
      -- ^ URL
    | ContactPointSystem_list_Sms
      -- ^ SMS
    | ContactPointSystem_list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType ContactPointSystem_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContactPointSystem_list where
    acceptingParser =  do literal "phone"; return ContactPointSystem_list_Phone
                      `onFail` do literal "fax"; return ContactPointSystem_list_Fax
                      `onFail` do literal "email"; return ContactPointSystem_list_Email
                      `onFail` do literal "pager"; return ContactPointSystem_list_Pager
                      `onFail` do literal "url"; return ContactPointSystem_list_Url
                      `onFail` do literal "sms"; return ContactPointSystem_list_Sms
                      `onFail` do literal "other"; return ContactPointSystem_list_Other
                      
    simpleTypeText ContactPointSystem_list_Phone = "phone"
    simpleTypeText ContactPointSystem_list_Fax = "fax"
    simpleTypeText ContactPointSystem_list_Email = "email"
    simpleTypeText ContactPointSystem_list_Pager = "pager"
    simpleTypeText ContactPointSystem_list_Url = "url"
    simpleTypeText ContactPointSystem_list_Sms = "sms"
    simpleTypeText ContactPointSystem_list_Other = "other"
 
data ContactPointSystem = ContactPointSystem
        { contactPointSystem_id :: Maybe String_primitive
        , contactPointSystem_value :: Maybe ContactPointSystem_list
        , contactPointSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContactPointSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContactPointSystem a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContactPointSystem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPointSystem_id x
                       , maybe [] (toXMLAttribute "value") $ contactPointSystem_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPointSystem_extension x
            ]
instance Extension ContactPointSystem Element where
    supertype (ContactPointSystem a0 a1 e0) =
               Element a0 e0
 
data ContactPointUse_list
    = ContactPointUse_list_Home
      -- ^ Home
    | ContactPointUse_list_Work
      -- ^ Work
    | ContactPointUse_list_Temp
      -- ^ Temp
    | ContactPointUse_list_Old
      -- ^ Old
    | ContactPointUse_list_Mobile
      -- ^ Mobile
    deriving (Eq,Show,Enum)
instance SchemaType ContactPointUse_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContactPointUse_list where
    acceptingParser =  do literal "home"; return ContactPointUse_list_Home
                      `onFail` do literal "work"; return ContactPointUse_list_Work
                      `onFail` do literal "temp"; return ContactPointUse_list_Temp
                      `onFail` do literal "old"; return ContactPointUse_list_Old
                      `onFail` do literal "mobile"; return ContactPointUse_list_Mobile
                      
    simpleTypeText ContactPointUse_list_Home = "home"
    simpleTypeText ContactPointUse_list_Work = "work"
    simpleTypeText ContactPointUse_list_Temp = "temp"
    simpleTypeText ContactPointUse_list_Old = "old"
    simpleTypeText ContactPointUse_list_Mobile = "mobile"
 
data ContactPointUse = ContactPointUse
        { contactPointUse_id :: Maybe String_primitive
        , contactPointUse_value :: Maybe ContactPointUse_list
        , contactPointUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContactPointUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContactPointUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContactPointUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contactPointUse_id x
                       , maybe [] (toXMLAttribute "value") $ contactPointUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contactPointUse_extension x
            ]
instance Extension ContactPointUse Element where
    supertype (ContactPointUse a0 a1 e0) =
               Element a0 e0
 
data UsageContext = UsageContext
        { usageContext_id :: Maybe String_primitive
        , usageContext_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , usageContext_code :: Coding
          -- ^ A code that identifies the type of context being specified 
          --   by this usage context.
        , usageContext_choice2 :: OneOf3 [CodeableConcept] [Quantity] [Range]
          -- ^ A value that defines the context specified in this context 
          --   of use. The interpretation of the value is defined by the 
          --   code.
          --   
          --   Choice between:
          --   
          --   (1) valueCodeableConcept
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueRange
        }
        deriving (Eq,Show)
instance SchemaType UsageContext where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (UsageContext a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("[CodeableConcept]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "valueCodeableConcept")))
                           , ("[Quantity]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                 (parseSchemaType "valueQuantity")))
                           , ("[Range]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                (parseSchemaType "valueRange")))
                           ]
    schemaTypeToXML s x@UsageContext{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ usageContext_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ usageContext_extension x
            , schemaTypeToXML "code" $ usageContext_code x
            , foldOneOf3  (concatMap (schemaTypeToXML "valueCodeableConcept"))
                          (concatMap (schemaTypeToXML "valueQuantity"))
                          (concatMap (schemaTypeToXML "valueRange"))
                          $ usageContext_choice2 x
            ]
instance Extension UsageContext Element where
    supertype (UsageContext a0 e0 e1 e2) =
               Element a0 e0
 
data Timing = Timing
        { timing_id :: Maybe String_primitive
        , timing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , timing_event :: [DateTime]
          -- ^ Identifies specific times when the event occurs.
        , timing_repeat :: Maybe TimingRepeat
          -- ^ A set of rules that describe when the event is scheduled.
        , timing_code :: Maybe CodeableConcept
          -- ^ A code for the timing schedule. Some codes such as BID are 
          --   ubiquitous, but many institutions define their own 
          --   additional codes. If a code is provided, the code is 
          --   understood to be a complete statement of whatever is 
          --   specified in the structured timing data, and either the 
          --   code or the data may be used to interpret the Timing, with 
          --   the exception that .repeat.bounds still applies over the 
          --   code (and is not contained in the code).
        }
        deriving (Eq,Show)
instance SchemaType Timing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (Timing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "event")
            `apply` optional (parseSchemaType "repeat")
            `apply` optional (parseSchemaType "code")
    schemaTypeToXML s x@Timing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ timing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ timing_extension x
            , concatMap (schemaTypeToXML "event") $ timing_event x
            , maybe [] (schemaTypeToXML "repeat") $ timing_repeat x
            , maybe [] (schemaTypeToXML "code") $ timing_code x
            ]
instance Extension Timing Element where
    supertype (Timing a0 e0 e1 e2 e3) =
               Element a0 e0
 
data TimingRepeat = TimingRepeat
        { timingRepeat_id :: Maybe String_primitive
        , timingRepeat_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , timingRepeat_choice1 :: (Maybe (OneOf3 [Duration] [Range] [Period]))
          -- ^ Either a duration for the length of the timing schedule, a 
          --   range of possible length, or outer bounds for start and/or 
          --   end limits of the timing schedule.
          --   
          --   Choice between:
          --   
          --   (1) boundsDuration
          --   
          --   (2) boundsRange
          --   
          --   (3) boundsPeriod
        , timingRepeat_count :: Maybe Integer
          -- ^ A total count of the desired number of repetitions.
        , timingRepeat_countMax :: Maybe Integer
          -- ^ A maximum value for the count of the desired repetitions 
          --   (e.g. do something 6-8 times).
        , timingRepeat_duration :: Maybe Decimal
          -- ^ How long this thing happens for when it happens.
        , timingRepeat_durationMax :: Maybe Decimal
          -- ^ The upper limit of how long this thing happens for when it 
          --   happens.
        , timingRepeat_durationUnit :: Maybe UnitsOfTime
          -- ^ The units of time for the duration, in UCUM units.
        , timingRepeat_frequency :: Maybe Integer
          -- ^ The number of times to repeat the action within the 
          --   specified period / period range (i.e. both period and 
          --   periodMax provided).
        , timingRepeat_frequencyMax :: Maybe Integer
          -- ^ If present, indicates that the frequency is a range - so to 
          --   repeat between [frequency] and [frequencyMax] times within 
          --   the period or period range.
        , timingRepeat_period :: Maybe Decimal
          -- ^ Indicates the duration of time over which repetitions are 
          --   to occur; e.g. to express &quot;3 times per day&quot;, 3 
          --   would be the frequency and &quot;1 day&quot; would be the 
          --   period.
        , timingRepeat_periodMax :: Maybe Decimal
          -- ^ If present, indicates that the period is a range from 
          --   [period] to [periodMax], allowing expressing concepts such 
          --   as &quot;do this once every 3-5 days.
        , timingRepeat_periodUnit :: Maybe UnitsOfTime
          -- ^ The units of time for the period in UCUM units.
        , timingRepeat_dayOfWeek :: [Code]
          -- ^ If one or more days of week is provided, then the action 
          --   happens only on the specified day(s).
        , timingRepeat_timeOfDay :: [Time]
          -- ^ Specified time of day for action to take place.
        , timingRepeat_when :: [EventTiming]
          -- ^ Real world events that the occurrence of the event should 
          --   be tied to.
        , timingRepeat_offset :: Maybe UnsignedInt
          -- ^ The number of minutes from the event. If the event code 
          --   does not indicate whether the minutes is before or after 
          --   the event, then the offset is assumed to be after the 
          --   event.
        }
        deriving (Eq,Show)
instance SchemaType TimingRepeat where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TimingRepeat a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (oneOf' [ ("[Duration]", fmap OneOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "boundsDuration")))
                                     , ("[Range]", fmap TwoOf3 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "boundsRange")))
                                     , ("[Period]", fmap ThreeOf3 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "boundsPeriod")))
                                     ])
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "countMax")
            `apply` optional (parseSchemaType "duration")
            `apply` optional (parseSchemaType "durationMax")
            `apply` optional (parseSchemaType "durationUnit")
            `apply` optional (parseSchemaType "frequency")
            `apply` optional (parseSchemaType "frequencyMax")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "periodMax")
            `apply` optional (parseSchemaType "periodUnit")
            `apply` many (parseSchemaType "dayOfWeek")
            `apply` many (parseSchemaType "timeOfDay")
            `apply` many (parseSchemaType "when")
            `apply` optional (parseSchemaType "offset")
    schemaTypeToXML s x@TimingRepeat{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ timingRepeat_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ timingRepeat_extension x
            , maybe [] (foldOneOf3  (concatMap (schemaTypeToXML "boundsDuration"))
                                    (concatMap (schemaTypeToXML "boundsRange"))
                                    (concatMap (schemaTypeToXML "boundsPeriod"))
                                   ) $ timingRepeat_choice1 x
            , maybe [] (schemaTypeToXML "count") $ timingRepeat_count x
            , maybe [] (schemaTypeToXML "countMax") $ timingRepeat_countMax x
            , maybe [] (schemaTypeToXML "duration") $ timingRepeat_duration x
            , maybe [] (schemaTypeToXML "durationMax") $ timingRepeat_durationMax x
            , maybe [] (schemaTypeToXML "durationUnit") $ timingRepeat_durationUnit x
            , maybe [] (schemaTypeToXML "frequency") $ timingRepeat_frequency x
            , maybe [] (schemaTypeToXML "frequencyMax") $ timingRepeat_frequencyMax x
            , maybe [] (schemaTypeToXML "period") $ timingRepeat_period x
            , maybe [] (schemaTypeToXML "periodMax") $ timingRepeat_periodMax x
            , maybe [] (schemaTypeToXML "periodUnit") $ timingRepeat_periodUnit x
            , concatMap (schemaTypeToXML "dayOfWeek") $ timingRepeat_dayOfWeek x
            , concatMap (schemaTypeToXML "timeOfDay") $ timingRepeat_timeOfDay x
            , concatMap (schemaTypeToXML "when") $ timingRepeat_when x
            , maybe [] (schemaTypeToXML "offset") $ timingRepeat_offset x
            ]
instance Extension TimingRepeat Element where
    supertype (TimingRepeat a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               Element a0 e0
 
data UnitsOfTime_list
    = UnitsOfTime_list_S
      -- ^ ç§’
    | UnitsOfTime_list_Min
      -- ^ åˆ†é’Ÿ
    | UnitsOfTime_list_H
      -- ^ å°æ—¶
    | UnitsOfTime_list_D
      -- ^ å¤©
    | UnitsOfTime_list_Wk
      -- ^ æ˜ŸæœŸ
    | UnitsOfTime_list_Mo
      -- ^ æœˆ
    | UnitsOfTime_list_A
      -- ^ å¹´
    deriving (Eq,Show,Enum)
instance SchemaType UnitsOfTime_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnitsOfTime_list where
    acceptingParser =  do literal "s"; return UnitsOfTime_list_S
                      `onFail` do literal "min"; return UnitsOfTime_list_Min
                      `onFail` do literal "h"; return UnitsOfTime_list_H
                      `onFail` do literal "d"; return UnitsOfTime_list_D
                      `onFail` do literal "wk"; return UnitsOfTime_list_Wk
                      `onFail` do literal "mo"; return UnitsOfTime_list_Mo
                      `onFail` do literal "a"; return UnitsOfTime_list_A
                      
    simpleTypeText UnitsOfTime_list_S = "s"
    simpleTypeText UnitsOfTime_list_Min = "min"
    simpleTypeText UnitsOfTime_list_H = "h"
    simpleTypeText UnitsOfTime_list_D = "d"
    simpleTypeText UnitsOfTime_list_Wk = "wk"
    simpleTypeText UnitsOfTime_list_Mo = "mo"
    simpleTypeText UnitsOfTime_list_A = "a"
 
data UnitsOfTime = UnitsOfTime
        { unitsOfTime_id :: Maybe String_primitive
        , unitsOfTime_value :: Maybe UnitsOfTime_list
        , unitsOfTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnitsOfTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnitsOfTime a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnitsOfTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unitsOfTime_id x
                       , maybe [] (toXMLAttribute "value") $ unitsOfTime_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unitsOfTime_extension x
            ]
instance Extension UnitsOfTime Element where
    supertype (UnitsOfTime a0 a1 e0) =
               Element a0 e0
 
data EventTiming_list
    = EventTiming_list_MORN
      -- ^ Morning
    | EventTiming_list_AFT
      -- ^ Afternoon
    | EventTiming_list_EVE
      -- ^ Evening
    | EventTiming_list_NIGHT
      -- ^ Night
    | EventTiming_list_PHS
      -- ^ After Sleep
    | EventTiming_list_HS
      -- ^ HS
    | EventTiming_list_WAKE
      -- ^ WAKE
    | EventTiming_list_C
      -- ^ C
    | EventTiming_list_CM
      -- ^ CM
    | EventTiming_list_CD
      -- ^ CD
    | EventTiming_list_CV
      -- ^ CV
    | EventTiming_list_AC
      -- ^ AC
    | EventTiming_list_ACM
      -- ^ ACM
    | EventTiming_list_ACD
      -- ^ ACD
    | EventTiming_list_ACV
      -- ^ ACV
    | EventTiming_list_PC
      -- ^ PC
    | EventTiming_list_PCM
      -- ^ PCM
    | EventTiming_list_PCD
      -- ^ PCD
    | EventTiming_list_PCV
      -- ^ PCV
    deriving (Eq,Show,Enum)
instance SchemaType EventTiming_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventTiming_list where
    acceptingParser =  do literal "MORN"; return EventTiming_list_MORN
                      `onFail` do literal "AFT"; return EventTiming_list_AFT
                      `onFail` do literal "EVE"; return EventTiming_list_EVE
                      `onFail` do literal "NIGHT"; return EventTiming_list_NIGHT
                      `onFail` do literal "PHS"; return EventTiming_list_PHS
                      `onFail` do literal "HS"; return EventTiming_list_HS
                      `onFail` do literal "WAKE"; return EventTiming_list_WAKE
                      `onFail` do literal "C"; return EventTiming_list_C
                      `onFail` do literal "CM"; return EventTiming_list_CM
                      `onFail` do literal "CD"; return EventTiming_list_CD
                      `onFail` do literal "CV"; return EventTiming_list_CV
                      `onFail` do literal "AC"; return EventTiming_list_AC
                      `onFail` do literal "ACM"; return EventTiming_list_ACM
                      `onFail` do literal "ACD"; return EventTiming_list_ACD
                      `onFail` do literal "ACV"; return EventTiming_list_ACV
                      `onFail` do literal "PC"; return EventTiming_list_PC
                      `onFail` do literal "PCM"; return EventTiming_list_PCM
                      `onFail` do literal "PCD"; return EventTiming_list_PCD
                      `onFail` do literal "PCV"; return EventTiming_list_PCV
                      
    simpleTypeText EventTiming_list_MORN = "MORN"
    simpleTypeText EventTiming_list_AFT = "AFT"
    simpleTypeText EventTiming_list_EVE = "EVE"
    simpleTypeText EventTiming_list_NIGHT = "NIGHT"
    simpleTypeText EventTiming_list_PHS = "PHS"
    simpleTypeText EventTiming_list_HS = "HS"
    simpleTypeText EventTiming_list_WAKE = "WAKE"
    simpleTypeText EventTiming_list_C = "C"
    simpleTypeText EventTiming_list_CM = "CM"
    simpleTypeText EventTiming_list_CD = "CD"
    simpleTypeText EventTiming_list_CV = "CV"
    simpleTypeText EventTiming_list_AC = "AC"
    simpleTypeText EventTiming_list_ACM = "ACM"
    simpleTypeText EventTiming_list_ACD = "ACD"
    simpleTypeText EventTiming_list_ACV = "ACV"
    simpleTypeText EventTiming_list_PC = "PC"
    simpleTypeText EventTiming_list_PCM = "PCM"
    simpleTypeText EventTiming_list_PCD = "PCD"
    simpleTypeText EventTiming_list_PCV = "PCV"
 
data EventTiming = EventTiming
        { eventTiming_id :: Maybe String_primitive
        , eventTiming_value :: Maybe EventTiming_list
        , eventTiming_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventTiming where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventTiming a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventTiming{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventTiming_id x
                       , maybe [] (toXMLAttribute "value") $ eventTiming_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventTiming_extension x
            ]
instance Extension EventTiming Element where
    supertype (EventTiming a0 a1 e0) =
               Element a0 e0
 
data ElementDefinition = ElementDefinition
        { elementDefinition_id :: Maybe String_primitive
        , elementDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinition_path :: Xsd.XsdString
          -- ^ The path identifies the element and is expressed as a 
          --   &quot;.&quot;-separated list of ancestor elements, 
          --   beginning with the name of the resource or extension.
        , elementDefinition_representation :: [PropertyRepresentation]
          -- ^ Codes that define how this element is represented in 
          --   instances, when the deviation varies from the normal case.
        , elementDefinition_sliceName :: Maybe Xsd.XsdString
          -- ^ The name of this element definition slice, when slicing is 
          --   working. The name must be a token with no dots or spaces. 
          --   This is a unique name referring to a specific set of 
          --   constraints applied to this element, used to provide a name 
          --   to different slices of the same element.
        , elementDefinition_label :: Maybe Xsd.XsdString
          -- ^ A single preferred label which is the text to display 
          --   beside the element indicating its meaning or to use to 
          --   prompt for the element in a user display or form.
        , elementDefinition_code :: [Coding]
          -- ^ A code that has the same meaning as the element in a 
          --   particular terminology.
        , elementDefinition_slicing :: Maybe ElementDefinitionSlicing
          -- ^ Indicates that the element is sliced into a set of 
          --   alternative definitions (i.e. in a structure definition, 
          --   there are multiple different constraints on a single 
          --   element in the base resource). Slicing can be used in any 
          --   resource that has cardinality ..* on the base resource, or 
          --   any resource with a choice of types. The set of slices is 
          --   any elements that come after this in the element sequence 
          --   that have the same path, until a shorter path occurs (the 
          --   shorter path terminates the set).
        , elementDefinition_short :: Maybe Xsd.XsdString
          -- ^ A concise description of what this element means (e.g. for 
          --   use in autogenerated summaries).
        , elementDefinition_definition :: Maybe Markdown
          -- ^ Provides a complete explanation of the meaning of the data 
          --   element for human readability. For the case of elements 
          --   derived from existing elements (e.g. constraints), the 
          --   definition SHALL be consistent with the base definition, 
          --   but convey the meaning of the element in the particular 
          --   context of use of the resource.
        , elementDefinition_comment :: Maybe Markdown
          -- ^ Explanatory notes and implementation guidance about the 
          --   data element, including notes about how to use the data 
          --   properly, exceptions to proper use, etc.
        , elementDefinition_requirements :: Maybe Markdown
          -- ^ This element is for traceability of why the element was 
          --   created and why the constraints exist as they do. This may 
          --   be used to point to source materials or specifications that 
          --   drove the structure of this element.
        , elementDefinition_alias :: [Xsd.XsdString]
          -- ^ Identifies additional names by which this element might 
          --   also be known.
        , elementDefinition_min :: Maybe UnsignedInt
          -- ^ The minimum number of times this element SHALL appear in 
          --   the instance.
        , elementDefinition_max :: Maybe Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the instance.
        , elementDefinition_base :: Maybe ElementDefinitionBase
          -- ^ Information about the base definition of the element, 
          --   provided to make it unnecessary for tools to trace the 
          --   deviation of the element through the derived and related 
          --   profiles. This information is provided when the element 
          --   definition is not the original definition of an element - 
          --   i.g. either in a constraint on another type, or for 
          --   elements from a super type in a snap shot.
        , elementDefinition_contentReference :: Maybe Uri
          -- ^ Identifies the identity of an element defined elsewhere in 
          --   the profile whose content rules should be applied to the 
          --   current element.
        , elementDefinition_type :: [ElementDefinitionType]
          -- ^ The data type or resource that the value of this element is 
          --   permitted to be.
        , elementDefinition_choice17 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ The value that should be used if there is no value stated 
          --   in the instance (e.g. 'if not otherwise specified, the 
          --   abstract is false').
          --   
          --   Choice between:
          --   
          --   (1) defaultValueBase64Binary
          --   
          --   (2) defaultValueBoolean
          --   
          --   (3) defaultValueCode
          --   
          --   (4) defaultValueDate
          --   
          --   (5) defaultValueDateTime
          --   
          --   (6) defaultValueDecimal
          --   
          --   (7) defaultValueId
          --   
          --   (8) defaultValueInstant
          --   
          --   (9) defaultValueInteger
          --   
          --   (10) defaultValueMarkdown
          --   
          --   (11) defaultValueOid
          --   
          --   (12) defaultValuePositiveInt
          --   
          --   (13) defaultValueString
          --   
          --   (14) defaultValueTime
          --   
          --   (15) defaultValueUnsignedInt
          --   
          --   (16) defaultValueUri
          --   
          --   (17) defaultValueAddress
          --   
          --   (18) defaultValueAge
          --   
          --   (19) defaultValueAnnotation
          --   
          --   (20) defaultValueAttachment
          --   
          --   (21) defaultValueCodeableConcept
          --   
          --   (22) defaultValueCoding
          --   
          --   (23) defaultValueContactPoint
          --   
          --   (24) defaultValueCount
          --   
          --   (25) defaultValueDistance
          --   
          --   (26) defaultValueDuration
          --   
          --   (27) defaultValueHumanName
          --   
          --   (28) defaultValueIdentifier
          --   
          --   (29) defaultValueMoney
          --   
          --   (30) defaultValuePeriod
          --   
          --   (31) defaultValueQuantity
          --   
          --   (32) defaultValueRange
          --   
          --   (33) defaultValueRatio
          --   
          --   (34) defaultValueReference
          --   
          --   (35) defaultValueSampledData
          --   
          --   (36) defaultValueSignature
          --   
          --   (37) defaultValueTiming
          --   
          --   (38) defaultValueMeta
        , elementDefinition_meaningWhenMissing :: Maybe Markdown
          -- ^ The Implicit meaning that is to be understood when this 
          --   element is missing (e.g. 'when this element is missing, the 
          --   period is ongoing'.
        , elementDefinition_orderMeaning :: Maybe Xsd.XsdString
          -- ^ If present, indicates that the order of the repeating 
          --   element has meaning and describes what that meaning is. If 
          --   absent, it means that the order of the element has no 
          --   meaning.
        , elementDefinition_choice20 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Specifies a value that SHALL be exactly the value for this 
          --   element in the instance. For purposes of comparison, 
          --   non-significant whitespace is ignored, and all values must 
          --   be an exact match (case and accent sensitive). Missing 
          --   elements/attributes must also be missing.
          --   
          --   Choice between:
          --   
          --   (1) fixedBase64Binary
          --   
          --   (2) fixedBoolean
          --   
          --   (3) fixedCode
          --   
          --   (4) fixedDate
          --   
          --   (5) fixedDateTime
          --   
          --   (6) fixedDecimal
          --   
          --   (7) fixedId
          --   
          --   (8) fixedInstant
          --   
          --   (9) fixedInteger
          --   
          --   (10) fixedMarkdown
          --   
          --   (11) fixedOid
          --   
          --   (12) fixedPositiveInt
          --   
          --   (13) fixedString
          --   
          --   (14) fixedTime
          --   
          --   (15) fixedUnsignedInt
          --   
          --   (16) fixedUri
          --   
          --   (17) fixedAddress
          --   
          --   (18) fixedAge
          --   
          --   (19) fixedAnnotation
          --   
          --   (20) fixedAttachment
          --   
          --   (21) fixedCodeableConcept
          --   
          --   (22) fixedCoding
          --   
          --   (23) fixedContactPoint
          --   
          --   (24) fixedCount
          --   
          --   (25) fixedDistance
          --   
          --   (26) fixedDuration
          --   
          --   (27) fixedHumanName
          --   
          --   (28) fixedIdentifier
          --   
          --   (29) fixedMoney
          --   
          --   (30) fixedPeriod
          --   
          --   (31) fixedQuantity
          --   
          --   (32) fixedRange
          --   
          --   (33) fixedRatio
          --   
          --   (34) fixedReference
          --   
          --   (35) fixedSampledData
          --   
          --   (36) fixedSignature
          --   
          --   (37) fixedTiming
          --   
          --   (38) fixedMeta
        , elementDefinition_choice21 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ Specifies a value that the value in the instance SHALL 
          --   follow - that is, any value in the pattern must be found in 
          --   the instance. Other additional values may be found too. 
          --   This is effectively constraint by example. The values of 
          --   elements present in the pattern must match exactly 
          --   (case-sensitive, accent-sensitive, etc.).
          --   
          --   Choice between:
          --   
          --   (1) patternBase64Binary
          --   
          --   (2) patternBoolean
          --   
          --   (3) patternCode
          --   
          --   (4) patternDate
          --   
          --   (5) patternDateTime
          --   
          --   (6) patternDecimal
          --   
          --   (7) patternId
          --   
          --   (8) patternInstant
          --   
          --   (9) patternInteger
          --   
          --   (10) patternMarkdown
          --   
          --   (11) patternOid
          --   
          --   (12) patternPositiveInt
          --   
          --   (13) patternString
          --   
          --   (14) patternTime
          --   
          --   (15) patternUnsignedInt
          --   
          --   (16) patternUri
          --   
          --   (17) patternAddress
          --   
          --   (18) patternAge
          --   
          --   (19) patternAnnotation
          --   
          --   (20) patternAttachment
          --   
          --   (21) patternCodeableConcept
          --   
          --   (22) patternCoding
          --   
          --   (23) patternContactPoint
          --   
          --   (24) patternCount
          --   
          --   (25) patternDistance
          --   
          --   (26) patternDuration
          --   
          --   (27) patternHumanName
          --   
          --   (28) patternIdentifier
          --   
          --   (29) patternMoney
          --   
          --   (30) patternPeriod
          --   
          --   (31) patternQuantity
          --   
          --   (32) patternRange
          --   
          --   (33) patternRatio
          --   
          --   (34) patternReference
          --   
          --   (35) patternSampledData
          --   
          --   (36) patternSignature
          --   
          --   (37) patternTiming
          --   
          --   (38) patternMeta
        , elementDefinition_example :: [ElementDefinitionExample]
          -- ^ A sample value for this element demonstrating the type of 
          --   information that would typically be found in the element.
        , elementDefinition_choice23 :: (Maybe (OneOf9 [Date] [DateTime] [Instant] [Time] [Decimal] [Integer] [PositiveInt] [UnsignedInt] [Quantity]))
          -- ^ The minimum allowed value for the element. The value is 
          --   inclusive. This is allowed for the types date, dateTime, 
          --   instant, time, decimal, integer, and Quantity.
          --   
          --   Choice between:
          --   
          --   (1) minValueDate
          --   
          --   (2) minValueDateTime
          --   
          --   (3) minValueInstant
          --   
          --   (4) minValueTime
          --   
          --   (5) minValueDecimal
          --   
          --   (6) minValueInteger
          --   
          --   (7) minValuePositiveInt
          --   
          --   (8) minValueUnsignedInt
          --   
          --   (9) minValueQuantity
        , elementDefinition_choice24 :: (Maybe (OneOf9 [Date] [DateTime] [Instant] [Time] [Decimal] [Integer] [PositiveInt] [UnsignedInt] [Quantity]))
          -- ^ The maximum allowed value for the element. The value is 
          --   inclusive. This is allowed for the types date, dateTime, 
          --   instant, time, decimal, integer, and Quantity.
          --   
          --   Choice between:
          --   
          --   (1) maxValueDate
          --   
          --   (2) maxValueDateTime
          --   
          --   (3) maxValueInstant
          --   
          --   (4) maxValueTime
          --   
          --   (5) maxValueDecimal
          --   
          --   (6) maxValueInteger
          --   
          --   (7) maxValuePositiveInt
          --   
          --   (8) maxValueUnsignedInt
          --   
          --   (9) maxValueQuantity
        , elementDefinition_maxLength :: Maybe Integer
          -- ^ Indicates the maximum length in characters that is 
          --   permitted to be present in conformant instances and which 
          --   is expected to be supported by conformant consumers that 
          --   support the element.
        , elementDefinition_condition :: [Id]
          -- ^ A reference to an invariant that may make additional 
          --   statements about the cardinality or value in the instance.
        , elementDefinition_constraint :: [ElementDefinitionConstraint]
          -- ^ Formal constraints such as co-occurrence and other 
          --   constraints that can be computationally evaluated within 
          --   the context of the instance.
        , elementDefinition_mustSupport :: Maybe Boolean
          -- ^ If true, implementations that produce or consume resources 
          --   SHALL provide &quot;support&quot; for the element in some 
          --   meaningful way. If false, the element may be ignored and 
          --   not supported.
        , elementDefinition_isModifier :: Maybe Boolean
          -- ^ If true, the value of this element affects the 
          --   interpretation of the element or resource that contains it, 
          --   and the value of the element cannot be ignored. Typically, 
          --   this is used for status, negation and qualification codes. 
          --   The effect of this is that the element cannot be ignored by 
          --   systems: they SHALL either recognize the element and 
          --   process it, and/or a pre-determination has been made that 
          --   it is not relevant to their particular system.
        , elementDefinition_isSummary :: Maybe Boolean
          -- ^ Whether the element should be included if a client requests 
          --   a search with the parameter _summary=true.
        , elementDefinition_binding :: Maybe ElementDefinitionBinding
          -- ^ Binds to a value set if this element is coded (code, 
          --   Coding, CodeableConcept, Quantity), or the data types 
          --   (string, uri).
        , elementDefinition_mapping :: [ElementDefinitionMapping]
          -- ^ Identifies a concept from an external specification that 
          --   roughly corresponds to this element.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` many (parseSchemaType "representation")
            `apply` optional (parseSchemaType "sliceName")
            `apply` optional (parseSchemaType "label")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "slicing")
            `apply` optional (parseSchemaType "short")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "requirements")
            `apply` many (parseSchemaType "alias")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "base")
            `apply` optional (parseSchemaType "contentReference")
            `apply` many (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "defaultValueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "defaultValueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "defaultValueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "defaultValueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "defaultValueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "defaultValueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "defaultValueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "defaultValueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "defaultValueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "defaultValueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "defaultValueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "defaultValuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "defaultValueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "defaultValueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "defaultValueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "defaultValueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "defaultValueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "defaultValueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "defaultValueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "defaultValueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "defaultValueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "defaultValueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "defaultValueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "defaultValueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "defaultValueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "defaultValueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "defaultValueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "defaultValueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "defaultValueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "defaultValuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "defaultValueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "defaultValueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "defaultValueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "defaultValueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "defaultValueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "defaultValueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "defaultValueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "defaultValueMeta"))
                                     ])
            `apply` optional (parseSchemaType "meaningWhenMissing")
            `apply` optional (parseSchemaType "orderMeaning")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "fixedBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "fixedBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "fixedCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "fixedDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "fixedDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "fixedDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "fixedId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "fixedInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "fixedInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "fixedMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "fixedOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "fixedPositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "fixedString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "fixedTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "fixedUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "fixedUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "fixedAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "fixedAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "fixedAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "fixedAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "fixedCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "fixedCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "fixedContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "fixedCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "fixedDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "fixedDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "fixedHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "fixedIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "fixedMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "fixedPeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "fixedQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "fixedRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "fixedRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "fixedReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "fixedSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "fixedSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "fixedTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "fixedMeta"))
                                     ])
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "patternBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "patternBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "patternCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "patternDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "patternDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "patternDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "patternId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "patternInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "patternInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "patternMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "patternOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "patternPositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "patternString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "patternTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "patternUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "patternUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "patternAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "patternAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "patternAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "patternAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "patternCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "patternCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "patternContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "patternCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "patternDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "patternDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "patternHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "patternIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "patternMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "patternPeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "patternQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "patternRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "patternRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "patternReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "patternSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "patternSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "patternTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "patternMeta"))
                                     ])
            `apply` many (parseSchemaType "example")
            `apply` optional (oneOf' [ ("[Date]", fmap OneOf9 (between (Occurs Nothing (Just 1))
                                                                       (parseSchemaType "minValueDate")))
                                     , ("[DateTime]", fmap TwoOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "minValueDateTime")))
                                     , ("[Instant]", fmap ThreeOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "minValueInstant")))
                                     , ("[Time]", fmap FourOf9 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "minValueTime")))
                                     , ("[Decimal]", fmap FiveOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "minValueDecimal")))
                                     , ("[Integer]", fmap SixOf9 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "minValueInteger")))
                                     , ("[PositiveInt]", fmap SevenOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "minValuePositiveInt")))
                                     , ("[UnsignedInt]", fmap EightOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "minValueUnsignedInt")))
                                     , ("[Quantity]", fmap NineOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "minValueQuantity")))
                                     ])
            `apply` optional (oneOf' [ ("[Date]", fmap OneOf9 (between (Occurs Nothing (Just 1))
                                                                       (parseSchemaType "maxValueDate")))
                                     , ("[DateTime]", fmap TwoOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "maxValueDateTime")))
                                     , ("[Instant]", fmap ThreeOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "maxValueInstant")))
                                     , ("[Time]", fmap FourOf9 (between (Occurs Nothing (Just 1))
                                                                        (parseSchemaType "maxValueTime")))
                                     , ("[Decimal]", fmap FiveOf9 (between (Occurs Nothing (Just 1))
                                                                           (parseSchemaType "maxValueDecimal")))
                                     , ("[Integer]", fmap SixOf9 (between (Occurs Nothing (Just 1))
                                                                          (parseSchemaType "maxValueInteger")))
                                     , ("[PositiveInt]", fmap SevenOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "maxValuePositiveInt")))
                                     , ("[UnsignedInt]", fmap EightOf9 (between (Occurs Nothing (Just 1))
                                                                                (parseSchemaType "maxValueUnsignedInt")))
                                     , ("[Quantity]", fmap NineOf9 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "maxValueQuantity")))
                                     ])
            `apply` optional (parseSchemaType "maxLength")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "constraint")
            `apply` optional (parseSchemaType "mustSupport")
            `apply` optional (parseSchemaType "isModifier")
            `apply` optional (parseSchemaType "isSummary")
            `apply` optional (parseSchemaType "binding")
            `apply` many (parseSchemaType "mapping")
    schemaTypeToXML s x@ElementDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinition_extension x
            , schemaTypeToXML "path" $ elementDefinition_path x
            , concatMap (schemaTypeToXML "representation") $ elementDefinition_representation x
            , maybe [] (schemaTypeToXML "sliceName") $ elementDefinition_sliceName x
            , maybe [] (schemaTypeToXML "label") $ elementDefinition_label x
            , concatMap (schemaTypeToXML "code") $ elementDefinition_code x
            , maybe [] (schemaTypeToXML "slicing") $ elementDefinition_slicing x
            , maybe [] (schemaTypeToXML "short") $ elementDefinition_short x
            , maybe [] (schemaTypeToXML "definition") $ elementDefinition_definition x
            , maybe [] (schemaTypeToXML "comment") $ elementDefinition_comment x
            , maybe [] (schemaTypeToXML "requirements") $ elementDefinition_requirements x
            , concatMap (schemaTypeToXML "alias") $ elementDefinition_alias x
            , maybe [] (schemaTypeToXML "min") $ elementDefinition_min x
            , maybe [] (schemaTypeToXML "max") $ elementDefinition_max x
            , maybe [] (schemaTypeToXML "base") $ elementDefinition_base x
            , maybe [] (schemaTypeToXML "contentReference") $ elementDefinition_contentReference x
            , concatMap (schemaTypeToXML "type") $ elementDefinition_type x
            , maybe [] (foldOneOf38  (schemaTypeToXML "defaultValueBase64Binary")
                                     (schemaTypeToXML "defaultValueBoolean")
                                     (schemaTypeToXML "defaultValueCode")
                                     (schemaTypeToXML "defaultValueDate")
                                     (schemaTypeToXML "defaultValueDateTime")
                                     (schemaTypeToXML "defaultValueDecimal")
                                     (schemaTypeToXML "defaultValueId")
                                     (schemaTypeToXML "defaultValueInstant")
                                     (schemaTypeToXML "defaultValueInteger")
                                     (schemaTypeToXML "defaultValueMarkdown")
                                     (schemaTypeToXML "defaultValueOid")
                                     (schemaTypeToXML "defaultValuePositiveInt")
                                     (schemaTypeToXML "defaultValueString")
                                     (schemaTypeToXML "defaultValueTime")
                                     (schemaTypeToXML "defaultValueUnsignedInt")
                                     (schemaTypeToXML "defaultValueUri")
                                     (schemaTypeToXML "defaultValueAddress")
                                     (schemaTypeToXML "defaultValueAge")
                                     (schemaTypeToXML "defaultValueAnnotation")
                                     (schemaTypeToXML "defaultValueAttachment")
                                     (schemaTypeToXML "defaultValueCodeableConcept")
                                     (schemaTypeToXML "defaultValueCoding")
                                     (schemaTypeToXML "defaultValueContactPoint")
                                     (schemaTypeToXML "defaultValueCount")
                                     (schemaTypeToXML "defaultValueDistance")
                                     (schemaTypeToXML "defaultValueDuration")
                                     (schemaTypeToXML "defaultValueHumanName")
                                     (schemaTypeToXML "defaultValueIdentifier")
                                     (schemaTypeToXML "defaultValueMoney")
                                     (schemaTypeToXML "defaultValuePeriod")
                                     (schemaTypeToXML "defaultValueQuantity")
                                     (schemaTypeToXML "defaultValueRange")
                                     (schemaTypeToXML "defaultValueRatio")
                                     (schemaTypeToXML "defaultValueReference")
                                     (schemaTypeToXML "defaultValueSampledData")
                                     (schemaTypeToXML "defaultValueSignature")
                                     (schemaTypeToXML "defaultValueTiming")
                                     (schemaTypeToXML "defaultValueMeta")
                                    ) $ elementDefinition_choice17 x
            , maybe [] (schemaTypeToXML "meaningWhenMissing") $ elementDefinition_meaningWhenMissing x
            , maybe [] (schemaTypeToXML "orderMeaning") $ elementDefinition_orderMeaning x
            , maybe [] (foldOneOf38  (schemaTypeToXML "fixedBase64Binary")
                                     (schemaTypeToXML "fixedBoolean")
                                     (schemaTypeToXML "fixedCode")
                                     (schemaTypeToXML "fixedDate")
                                     (schemaTypeToXML "fixedDateTime")
                                     (schemaTypeToXML "fixedDecimal")
                                     (schemaTypeToXML "fixedId")
                                     (schemaTypeToXML "fixedInstant")
                                     (schemaTypeToXML "fixedInteger")
                                     (schemaTypeToXML "fixedMarkdown")
                                     (schemaTypeToXML "fixedOid")
                                     (schemaTypeToXML "fixedPositiveInt")
                                     (schemaTypeToXML "fixedString")
                                     (schemaTypeToXML "fixedTime")
                                     (schemaTypeToXML "fixedUnsignedInt")
                                     (schemaTypeToXML "fixedUri")
                                     (schemaTypeToXML "fixedAddress")
                                     (schemaTypeToXML "fixedAge")
                                     (schemaTypeToXML "fixedAnnotation")
                                     (schemaTypeToXML "fixedAttachment")
                                     (schemaTypeToXML "fixedCodeableConcept")
                                     (schemaTypeToXML "fixedCoding")
                                     (schemaTypeToXML "fixedContactPoint")
                                     (schemaTypeToXML "fixedCount")
                                     (schemaTypeToXML "fixedDistance")
                                     (schemaTypeToXML "fixedDuration")
                                     (schemaTypeToXML "fixedHumanName")
                                     (schemaTypeToXML "fixedIdentifier")
                                     (schemaTypeToXML "fixedMoney")
                                     (schemaTypeToXML "fixedPeriod")
                                     (schemaTypeToXML "fixedQuantity")
                                     (schemaTypeToXML "fixedRange")
                                     (schemaTypeToXML "fixedRatio")
                                     (schemaTypeToXML "fixedReference")
                                     (schemaTypeToXML "fixedSampledData")
                                     (schemaTypeToXML "fixedSignature")
                                     (schemaTypeToXML "fixedTiming")
                                     (schemaTypeToXML "fixedMeta")
                                    ) $ elementDefinition_choice20 x
            , maybe [] (foldOneOf38  (schemaTypeToXML "patternBase64Binary")
                                     (schemaTypeToXML "patternBoolean")
                                     (schemaTypeToXML "patternCode")
                                     (schemaTypeToXML "patternDate")
                                     (schemaTypeToXML "patternDateTime")
                                     (schemaTypeToXML "patternDecimal")
                                     (schemaTypeToXML "patternId")
                                     (schemaTypeToXML "patternInstant")
                                     (schemaTypeToXML "patternInteger")
                                     (schemaTypeToXML "patternMarkdown")
                                     (schemaTypeToXML "patternOid")
                                     (schemaTypeToXML "patternPositiveInt")
                                     (schemaTypeToXML "patternString")
                                     (schemaTypeToXML "patternTime")
                                     (schemaTypeToXML "patternUnsignedInt")
                                     (schemaTypeToXML "patternUri")
                                     (schemaTypeToXML "patternAddress")
                                     (schemaTypeToXML "patternAge")
                                     (schemaTypeToXML "patternAnnotation")
                                     (schemaTypeToXML "patternAttachment")
                                     (schemaTypeToXML "patternCodeableConcept")
                                     (schemaTypeToXML "patternCoding")
                                     (schemaTypeToXML "patternContactPoint")
                                     (schemaTypeToXML "patternCount")
                                     (schemaTypeToXML "patternDistance")
                                     (schemaTypeToXML "patternDuration")
                                     (schemaTypeToXML "patternHumanName")
                                     (schemaTypeToXML "patternIdentifier")
                                     (schemaTypeToXML "patternMoney")
                                     (schemaTypeToXML "patternPeriod")
                                     (schemaTypeToXML "patternQuantity")
                                     (schemaTypeToXML "patternRange")
                                     (schemaTypeToXML "patternRatio")
                                     (schemaTypeToXML "patternReference")
                                     (schemaTypeToXML "patternSampledData")
                                     (schemaTypeToXML "patternSignature")
                                     (schemaTypeToXML "patternTiming")
                                     (schemaTypeToXML "patternMeta")
                                    ) $ elementDefinition_choice21 x
            , concatMap (schemaTypeToXML "example") $ elementDefinition_example x
            , maybe [] (foldOneOf9  (concatMap (schemaTypeToXML "minValueDate"))
                                    (concatMap (schemaTypeToXML "minValueDateTime"))
                                    (concatMap (schemaTypeToXML "minValueInstant"))
                                    (concatMap (schemaTypeToXML "minValueTime"))
                                    (concatMap (schemaTypeToXML "minValueDecimal"))
                                    (concatMap (schemaTypeToXML "minValueInteger"))
                                    (concatMap (schemaTypeToXML "minValuePositiveInt"))
                                    (concatMap (schemaTypeToXML "minValueUnsignedInt"))
                                    (concatMap (schemaTypeToXML "minValueQuantity"))
                                   ) $ elementDefinition_choice23 x
            , maybe [] (foldOneOf9  (concatMap (schemaTypeToXML "maxValueDate"))
                                    (concatMap (schemaTypeToXML "maxValueDateTime"))
                                    (concatMap (schemaTypeToXML "maxValueInstant"))
                                    (concatMap (schemaTypeToXML "maxValueTime"))
                                    (concatMap (schemaTypeToXML "maxValueDecimal"))
                                    (concatMap (schemaTypeToXML "maxValueInteger"))
                                    (concatMap (schemaTypeToXML "maxValuePositiveInt"))
                                    (concatMap (schemaTypeToXML "maxValueUnsignedInt"))
                                    (concatMap (schemaTypeToXML "maxValueQuantity"))
                                   ) $ elementDefinition_choice24 x
            , maybe [] (schemaTypeToXML "maxLength") $ elementDefinition_maxLength x
            , concatMap (schemaTypeToXML "condition") $ elementDefinition_condition x
            , concatMap (schemaTypeToXML "constraint") $ elementDefinition_constraint x
            , maybe [] (schemaTypeToXML "mustSupport") $ elementDefinition_mustSupport x
            , maybe [] (schemaTypeToXML "isModifier") $ elementDefinition_isModifier x
            , maybe [] (schemaTypeToXML "isSummary") $ elementDefinition_isSummary x
            , maybe [] (schemaTypeToXML "binding") $ elementDefinition_binding x
            , concatMap (schemaTypeToXML "mapping") $ elementDefinition_mapping x
            ]
instance Extension ElementDefinition Element where
    supertype (ElementDefinition a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               Element a0 e0
 
data ElementDefinitionConstraint = ElementDefinitionConstraint
        { elementDefinitionConstraint_id :: Maybe String_primitive
        , elementDefinitionConstraint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionConstraint_key :: Id
          -- ^ Allows identification of which elements have their 
          --   cardinalities impacted by the constraint. Will not be 
          --   referenced for constraints that do not affect cardinality.
        , elementDefinitionConstraint_requirements :: Maybe Xsd.XsdString
          -- ^ Description of why this constraint is necessary or 
          --   appropriate.
        , elementDefinitionConstraint_severity :: ConstraintSeverity
          -- ^ Identifies the impact constraint violation has on the 
          --   conformance of the instance.
        , elementDefinitionConstraint_human :: Xsd.XsdString
          -- ^ Text that can be used to describe the constraint in 
          --   messages identifying that the constraint has been violated.
        , elementDefinitionConstraint_expression :: Xsd.XsdString
          -- ^ A [FHIRPath](http://hl7.org/fluentpath) expression of 
          --   constraint that can be executed to see if this constraint 
          --   is met.
        , elementDefinitionConstraint_xpath :: Maybe Xsd.XsdString
          -- ^ An XPath expression of constraint that can be executed to 
          --   see if this constraint is met.
        , elementDefinitionConstraint_source :: Maybe Uri
          -- ^ A reference to the original source of the constraint, for 
          --   traceability purposes.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionConstraint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionConstraint a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "key"
            `apply` optional (parseSchemaType "requirements")
            `apply` parseSchemaType "severity"
            `apply` parseSchemaType "human"
            `apply` parseSchemaType "expression"
            `apply` optional (parseSchemaType "xpath")
            `apply` optional (parseSchemaType "source")
    schemaTypeToXML s x@ElementDefinitionConstraint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionConstraint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionConstraint_extension x
            , schemaTypeToXML "key" $ elementDefinitionConstraint_key x
            , maybe [] (schemaTypeToXML "requirements") $ elementDefinitionConstraint_requirements x
            , schemaTypeToXML "severity" $ elementDefinitionConstraint_severity x
            , schemaTypeToXML "human" $ elementDefinitionConstraint_human x
            , schemaTypeToXML "expression" $ elementDefinitionConstraint_expression x
            , maybe [] (schemaTypeToXML "xpath") $ elementDefinitionConstraint_xpath x
            , maybe [] (schemaTypeToXML "source") $ elementDefinitionConstraint_source x
            ]
instance Extension ElementDefinitionConstraint Element where
    supertype (ElementDefinitionConstraint a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
data ElementDefinitionMapping = ElementDefinitionMapping
        { elementDefinitionMapping_id :: Maybe String_primitive
        , elementDefinitionMapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionMapping_identity :: Id
          -- ^ An internal reference to the definition of a mapping.
        , elementDefinitionMapping_language :: Maybe Code
          -- ^ Identifies the computable language in which mapping.map is 
          --   expressed.
        , elementDefinitionMapping_map :: Xsd.XsdString
          -- ^ Expresses what part of the target specification corresponds 
          --   to this element.
        , elementDefinitionMapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments that provide information about the mapping or its 
          --   use.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionMapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionMapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "language")
            `apply` parseSchemaType "map"
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@ElementDefinitionMapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionMapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionMapping_extension x
            , schemaTypeToXML "identity" $ elementDefinitionMapping_identity x
            , maybe [] (schemaTypeToXML "language") $ elementDefinitionMapping_language x
            , schemaTypeToXML "map" $ elementDefinitionMapping_map x
            , maybe [] (schemaTypeToXML "comment") $ elementDefinitionMapping_comment x
            ]
instance Extension ElementDefinitionMapping Element where
    supertype (ElementDefinitionMapping a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data ElementDefinitionBase = ElementDefinitionBase
        { elementDefinitionBase_id :: Maybe String_primitive
        , elementDefinitionBase_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionBase_path :: Xsd.XsdString
          -- ^ The Path that identifies the base element - this matches 
          --   the ElementDefinition.path for that element. Across FHIR, 
          --   there is only one base definition of any element - that is, 
          --   an element definition on a [[[StructureDefinition]]] 
          --   without a StructureDefinition.base.
        , elementDefinitionBase_min :: UnsignedInt
          -- ^ Minimum cardinality of the base element identified by the 
          --   path.
        , elementDefinitionBase_max :: Xsd.XsdString
          -- ^ Maximum cardinality of the base element identified by the 
          --   path.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionBase where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionBase a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "path"
            `apply` parseSchemaType "min"
            `apply` parseSchemaType "max"
    schemaTypeToXML s x@ElementDefinitionBase{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionBase_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionBase_extension x
            , schemaTypeToXML "path" $ elementDefinitionBase_path x
            , schemaTypeToXML "min" $ elementDefinitionBase_min x
            , schemaTypeToXML "max" $ elementDefinitionBase_max x
            ]
instance Extension ElementDefinitionBase Element where
    supertype (ElementDefinitionBase a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ElementDefinitionType = ElementDefinitionType
        { elementDefinitionType_id :: Maybe String_primitive
        , elementDefinitionType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionType_code :: Uri
          -- ^ URL of Data type or Resource that is a(or the) type used 
          --   for this element. References are URLs that are relative to 
          --   http://hl7.org/fhir/StructureDefinition e.g. 
          --   &quot;string&quot; is a reference to 
          --   http://hl7.org/fhir/StructureDefinition/string. Absolute 
          --   URLs are only allowed in logical models.
        , elementDefinitionType_profile :: Maybe Uri
          -- ^ Identifies a profile structure or implementation Guide that 
          --   SHALL hold for the datatype this element refers to. Can be 
          --   a local reference - to a contained StructureDefinition, or 
          --   a reference to another StructureDefinition or 
          --   Implementation Guide by a canonical URL. When an 
          --   implementation guide is specified, the resource SHALL 
          --   conform to at least one profile defined in the 
          --   implementation guide.
        , elementDefinitionType_targetProfile :: Maybe Uri
          -- ^ Identifies a profile structure or implementation Guide that 
          --   SHALL hold for the target of the reference this element 
          --   refers to. Can be a local reference - to a contained 
          --   StructureDefinition, or a reference to another 
          --   StructureDefinition or Implementation Guide by a canonical 
          --   URL. When an implementation guide is specified, the 
          --   resource SHALL conform to at least one profile defined in 
          --   the implementation guide.
        , elementDefinitionType_aggregation :: [AggregationMode]
          -- ^ If the type is a reference to another resource, how the 
          --   resource is or can be aggregated - is it a contained 
          --   resource, or a reference, and if the context is a bundle, 
          --   is it included in the bundle.
        , elementDefinitionType_versioning :: Maybe ReferenceVersionRules
          -- ^ Whether this reference needs to be version specific or 
          --   version independent, or whether either can be used.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionType a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "targetProfile")
            `apply` many (parseSchemaType "aggregation")
            `apply` optional (parseSchemaType "versioning")
    schemaTypeToXML s x@ElementDefinitionType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionType_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionType_extension x
            , schemaTypeToXML "code" $ elementDefinitionType_code x
            , maybe [] (schemaTypeToXML "profile") $ elementDefinitionType_profile x
            , maybe [] (schemaTypeToXML "targetProfile") $ elementDefinitionType_targetProfile x
            , concatMap (schemaTypeToXML "aggregation") $ elementDefinitionType_aggregation x
            , maybe [] (schemaTypeToXML "versioning") $ elementDefinitionType_versioning x
            ]
instance Extension ElementDefinitionType Element where
    supertype (ElementDefinitionType a0 e0 e1 e2 e3 e4 e5) =
               Element a0 e0
 
data ElementDefinitionExample = ElementDefinitionExample
        { elementDefinitionExample_id :: Maybe String_primitive
        , elementDefinitionExample_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionExample_label :: Xsd.XsdString
          -- ^ Describes the purpose of this example amoung the set of 
          --   examples.
        , elementDefinitionExample_choice2 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The actual value for the element, which must be one of the 
          --   types allowed for this element.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionExample where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionExample a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "label"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@ElementDefinitionExample{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionExample_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionExample_extension x
            , schemaTypeToXML "label" $ elementDefinitionExample_label x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ elementDefinitionExample_choice2 x
            ]
instance Extension ElementDefinitionExample Element where
    supertype (ElementDefinitionExample a0 e0 e1 e2) =
               Element a0 e0
 
data ElementDefinitionSlicing = ElementDefinitionSlicing
        { elementDefinitionSlicing_id :: Maybe String_primitive
        , elementDefinitionSlicing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionSlicing_discriminator :: [ElementDefinitionDiscriminator]
          -- ^ Designates which child elements are used to discriminate 
          --   between the slices when processing an instance. If one or 
          --   more discriminators are provided, the value of the child 
          --   elements in the instance data SHALL completely distinguish 
          --   which slice the element in the resource matches based on 
          --   the allowed values for those elements in each of the 
          --   slices.
        , elementDefinitionSlicing_description :: Maybe Xsd.XsdString
          -- ^ A human-readable text description of how the slicing works. 
          --   If there is no discriminator, this is required to be 
          --   present to provide whatever information is possible about 
          --   how the slices can be differentiated.
        , elementDefinitionSlicing_ordered :: Maybe Boolean
          -- ^ If the matching elements have to occur in the same order as 
          --   defined in the profile.
        , elementDefinitionSlicing_rules :: SlicingRules
          -- ^ Whether additional slices are allowed or not. When the 
          --   slices are ordered, profile authors can also say that 
          --   additional slices are only allowed at the end.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionSlicing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionSlicing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "discriminator")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "ordered")
            `apply` parseSchemaType "rules"
    schemaTypeToXML s x@ElementDefinitionSlicing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionSlicing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionSlicing_extension x
            , concatMap (schemaTypeToXML "discriminator") $ elementDefinitionSlicing_discriminator x
            , maybe [] (schemaTypeToXML "description") $ elementDefinitionSlicing_description x
            , maybe [] (schemaTypeToXML "ordered") $ elementDefinitionSlicing_ordered x
            , schemaTypeToXML "rules" $ elementDefinitionSlicing_rules x
            ]
instance Extension ElementDefinitionSlicing Element where
    supertype (ElementDefinitionSlicing a0 e0 e1 e2 e3 e4) =
               Element a0 e0
 
data ElementDefinitionBinding = ElementDefinitionBinding
        { elementDefinitionBinding_id :: Maybe String_primitive
        , elementDefinitionBinding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionBinding_strength :: BindingStrength
          -- ^ Indicates the degree of conformance expectations associated 
          --   with this binding - that is, the degree to which the 
          --   provided value set must be adhered to in the instances.
        , elementDefinitionBinding_description :: Maybe Xsd.XsdString
          -- ^ Describes the intended use of this particular set of codes.
        , elementDefinitionBinding_choice3 :: (Maybe (OneOf2 [Uri] [Reference]))
          -- ^ Points to the value set or external definition (e.g. 
          --   implicit value set) that identifies the set of codes to be 
          --   used. If the binding refers to an explicit value set - the 
          --   normal case - then use a Reference(ValueSet) preferably 
          --   containing the canonical URL for the value set. If the 
          --   reference is to an implicit value set - usually, an IETF 
          --   RFC that defines a grammar, such as mime types - then use a 
          --   uri.
          --   
          --   Choice between:
          --   
          --   (1) valueSetUri
          --   
          --   (2) valueSetReference
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionBinding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionBinding a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "strength"
            `apply` optional (parseSchemaType "description")
            `apply` optional (oneOf' [ ("[Uri]", fmap OneOf2 (between (Occurs Nothing (Just 1))
                                                                      (parseSchemaType "valueSetUri")))
                                     , ("[Reference]", fmap TwoOf2 (between (Occurs Nothing (Just 1))
                                                                            (parseSchemaType "valueSetReference")))
                                     ])
    schemaTypeToXML s x@ElementDefinitionBinding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionBinding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionBinding_extension x
            , schemaTypeToXML "strength" $ elementDefinitionBinding_strength x
            , maybe [] (schemaTypeToXML "description") $ elementDefinitionBinding_description x
            , maybe [] (foldOneOf2  (concatMap (schemaTypeToXML "valueSetUri"))
                                    (concatMap (schemaTypeToXML "valueSetReference"))
                                   ) $ elementDefinitionBinding_choice3 x
            ]
instance Extension ElementDefinitionBinding Element where
    supertype (ElementDefinitionBinding a0 e0 e1 e2 e3) =
               Element a0 e0
 
data ElementDefinitionDiscriminator = ElementDefinitionDiscriminator
        { elementDefinitionDiscriminator_id :: Maybe String_primitive
        , elementDefinitionDiscriminator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , elementDefinitionDiscriminator_type :: DiscriminatorType
          -- ^ How the element value is interpreted when discrimination is 
          --   evaluated.
        , elementDefinitionDiscriminator_path :: Xsd.XsdString
          -- ^ A FHIRPath expression, using a restricted subset of 
          --   FHIRPath, that is used to identify the element on which 
          --   discrimination is based.
        }
        deriving (Eq,Show)
instance SchemaType ElementDefinitionDiscriminator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ElementDefinitionDiscriminator a0)
            `apply` many (parseSchemaType "extension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "path"
    schemaTypeToXML s x@ElementDefinitionDiscriminator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ elementDefinitionDiscriminator_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ elementDefinitionDiscriminator_extension x
            , schemaTypeToXML "type" $ elementDefinitionDiscriminator_type x
            , schemaTypeToXML "path" $ elementDefinitionDiscriminator_path x
            ]
instance Extension ElementDefinitionDiscriminator Element where
    supertype (ElementDefinitionDiscriminator a0 e0 e1 e2) =
               Element a0 e0
 
data PropertyRepresentation_list
    = PropertyRepresentation_list_XmlAttr
      -- ^ XML Attribute
    | PropertyRepresentation_list_XmlText
      -- ^ XML Text
    | PropertyRepresentation_list_TypeAttr
      -- ^ Type Attribute
    | PropertyRepresentation_list_CdaText
      -- ^ CDA Text Format
    | PropertyRepresentation_list_Xhtml
      -- ^ XHTML
    deriving (Eq,Show,Enum)
instance SchemaType PropertyRepresentation_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PropertyRepresentation_list where
    acceptingParser =  do literal "xmlAttr"; return PropertyRepresentation_list_XmlAttr
                      `onFail` do literal "xmlText"; return PropertyRepresentation_list_XmlText
                      `onFail` do literal "typeAttr"; return PropertyRepresentation_list_TypeAttr
                      `onFail` do literal "cdaText"; return PropertyRepresentation_list_CdaText
                      `onFail` do literal "xhtml"; return PropertyRepresentation_list_Xhtml
                      
    simpleTypeText PropertyRepresentation_list_XmlAttr = "xmlAttr"
    simpleTypeText PropertyRepresentation_list_XmlText = "xmlText"
    simpleTypeText PropertyRepresentation_list_TypeAttr = "typeAttr"
    simpleTypeText PropertyRepresentation_list_CdaText = "cdaText"
    simpleTypeText PropertyRepresentation_list_Xhtml = "xhtml"
 
data PropertyRepresentation = PropertyRepresentation
        { propertyRepresentation_id :: Maybe String_primitive
        , propertyRepresentation_value :: Maybe PropertyRepresentation_list
        , propertyRepresentation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PropertyRepresentation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PropertyRepresentation a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PropertyRepresentation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ propertyRepresentation_id x
                       , maybe [] (toXMLAttribute "value") $ propertyRepresentation_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ propertyRepresentation_extension x
            ]
instance Extension PropertyRepresentation Element where
    supertype (PropertyRepresentation a0 a1 e0) =
               Element a0 e0
 
data ConstraintSeverity_list
    = ConstraintSeverity_list_Error
      -- ^ Error
    | ConstraintSeverity_list_Warning
      -- ^ Warning
    deriving (Eq,Show,Enum)
instance SchemaType ConstraintSeverity_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConstraintSeverity_list where
    acceptingParser =  do literal "error"; return ConstraintSeverity_list_Error
                      `onFail` do literal "warning"; return ConstraintSeverity_list_Warning
                      
    simpleTypeText ConstraintSeverity_list_Error = "error"
    simpleTypeText ConstraintSeverity_list_Warning = "warning"
 
data ConstraintSeverity = ConstraintSeverity
        { constraintSeverity_id :: Maybe String_primitive
        , constraintSeverity_value :: Maybe ConstraintSeverity_list
        , constraintSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConstraintSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConstraintSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConstraintSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ constraintSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ constraintSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ constraintSeverity_extension x
            ]
instance Extension ConstraintSeverity Element where
    supertype (ConstraintSeverity a0 a1 e0) =
               Element a0 e0
 
data AggregationMode_list
    = AggregationMode_list_Contained
      -- ^ Contained
    | AggregationMode_list_Referenced
      -- ^ Referenced
    | AggregationMode_list_Bundled
      -- ^ Bundled
    deriving (Eq,Show,Enum)
instance SchemaType AggregationMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AggregationMode_list where
    acceptingParser =  do literal "contained"; return AggregationMode_list_Contained
                      `onFail` do literal "referenced"; return AggregationMode_list_Referenced
                      `onFail` do literal "bundled"; return AggregationMode_list_Bundled
                      
    simpleTypeText AggregationMode_list_Contained = "contained"
    simpleTypeText AggregationMode_list_Referenced = "referenced"
    simpleTypeText AggregationMode_list_Bundled = "bundled"
 
data AggregationMode = AggregationMode
        { aggregationMode_id :: Maybe String_primitive
        , aggregationMode_value :: Maybe AggregationMode_list
        , aggregationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AggregationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AggregationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AggregationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ aggregationMode_id x
                       , maybe [] (toXMLAttribute "value") $ aggregationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ aggregationMode_extension x
            ]
instance Extension AggregationMode Element where
    supertype (AggregationMode a0 a1 e0) =
               Element a0 e0
 
data ReferenceVersionRules_list
    = ReferenceVersionRules_list_Either
      -- ^ Either Specific or independent
    | ReferenceVersionRules_list_Independent
      -- ^ Version independent
    | ReferenceVersionRules_list_Specific
      -- ^ Version Specific
    deriving (Eq,Show,Enum)
instance SchemaType ReferenceVersionRules_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ReferenceVersionRules_list where
    acceptingParser =  do literal "either"; return ReferenceVersionRules_list_Either
                      `onFail` do literal "independent"; return ReferenceVersionRules_list_Independent
                      `onFail` do literal "specific"; return ReferenceVersionRules_list_Specific
                      
    simpleTypeText ReferenceVersionRules_list_Either = "either"
    simpleTypeText ReferenceVersionRules_list_Independent = "independent"
    simpleTypeText ReferenceVersionRules_list_Specific = "specific"
 
data ReferenceVersionRules = ReferenceVersionRules
        { referenceVersionRules_id :: Maybe String_primitive
        , referenceVersionRules_value :: Maybe ReferenceVersionRules_list
        , referenceVersionRules_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ReferenceVersionRules where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ReferenceVersionRules a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ReferenceVersionRules{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referenceVersionRules_id x
                       , maybe [] (toXMLAttribute "value") $ referenceVersionRules_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referenceVersionRules_extension x
            ]
instance Extension ReferenceVersionRules Element where
    supertype (ReferenceVersionRules a0 a1 e0) =
               Element a0 e0
 
data SlicingRules_list
    = SlicingRules_list_Closed
      -- ^ Closed
    | SlicingRules_list_Open
      -- ^ Open
    | SlicingRules_list_OpenAtEnd
      -- ^ Open at End
    deriving (Eq,Show,Enum)
instance SchemaType SlicingRules_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SlicingRules_list where
    acceptingParser =  do literal "closed"; return SlicingRules_list_Closed
                      `onFail` do literal "open"; return SlicingRules_list_Open
                      `onFail` do literal "openAtEnd"; return SlicingRules_list_OpenAtEnd
                      
    simpleTypeText SlicingRules_list_Closed = "closed"
    simpleTypeText SlicingRules_list_Open = "open"
    simpleTypeText SlicingRules_list_OpenAtEnd = "openAtEnd"
 
data SlicingRules = SlicingRules
        { slicingRules_id :: Maybe String_primitive
        , slicingRules_value :: Maybe SlicingRules_list
        , slicingRules_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SlicingRules where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SlicingRules a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SlicingRules{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ slicingRules_id x
                       , maybe [] (toXMLAttribute "value") $ slicingRules_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ slicingRules_extension x
            ]
instance Extension SlicingRules Element where
    supertype (SlicingRules a0 a1 e0) =
               Element a0 e0
 
data BindingStrength_list
    = BindingStrength_list_Required
      -- ^ Required
    | BindingStrength_list_Extensible
      -- ^ Extensible
    | BindingStrength_list_Preferred
      -- ^ Preferred
    | BindingStrength_list_Example
      -- ^ Example
    deriving (Eq,Show,Enum)
instance SchemaType BindingStrength_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType BindingStrength_list where
    acceptingParser =  do literal "required"; return BindingStrength_list_Required
                      `onFail` do literal "extensible"; return BindingStrength_list_Extensible
                      `onFail` do literal "preferred"; return BindingStrength_list_Preferred
                      `onFail` do literal "example"; return BindingStrength_list_Example
                      
    simpleTypeText BindingStrength_list_Required = "required"
    simpleTypeText BindingStrength_list_Extensible = "extensible"
    simpleTypeText BindingStrength_list_Preferred = "preferred"
    simpleTypeText BindingStrength_list_Example = "example"
 
data BindingStrength = BindingStrength
        { bindingStrength_id :: Maybe String_primitive
        , bindingStrength_value :: Maybe BindingStrength_list
        , bindingStrength_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType BindingStrength where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (BindingStrength a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@BindingStrength{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bindingStrength_id x
                       , maybe [] (toXMLAttribute "value") $ bindingStrength_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bindingStrength_extension x
            ]
instance Extension BindingStrength Element where
    supertype (BindingStrength a0 a1 e0) =
               Element a0 e0
 
data DiscriminatorType_list
    = DiscriminatorType_list_Value
      -- ^ Value
    | DiscriminatorType_list_Exists
      -- ^ Exists
    | DiscriminatorType_list_Pattern
      -- ^ Pattern
    | DiscriminatorType_list_Type
      -- ^ Type
    | DiscriminatorType_list_Profile
      -- ^ Profile
    deriving (Eq,Show,Enum)
instance SchemaType DiscriminatorType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DiscriminatorType_list where
    acceptingParser =  do literal "value"; return DiscriminatorType_list_Value
                      `onFail` do literal "exists"; return DiscriminatorType_list_Exists
                      `onFail` do literal "pattern"; return DiscriminatorType_list_Pattern
                      `onFail` do literal "type"; return DiscriminatorType_list_Type
                      `onFail` do literal "profile"; return DiscriminatorType_list_Profile
                      
    simpleTypeText DiscriminatorType_list_Value = "value"
    simpleTypeText DiscriminatorType_list_Exists = "exists"
    simpleTypeText DiscriminatorType_list_Pattern = "pattern"
    simpleTypeText DiscriminatorType_list_Type = "type"
    simpleTypeText DiscriminatorType_list_Profile = "profile"
 
data DiscriminatorType = DiscriminatorType
        { discriminatorType_id :: Maybe String_primitive
        , discriminatorType_value :: Maybe DiscriminatorType_list
        , discriminatorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DiscriminatorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DiscriminatorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DiscriminatorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ discriminatorType_id x
                       , maybe [] (toXMLAttribute "value") $ discriminatorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ discriminatorType_extension x
            ]
instance Extension DiscriminatorType Element where
    supertype (DiscriminatorType a0 a1 e0) =
               Element a0 e0
 
data ParameterDefinition = ParameterDefinition
        { parameterDefinition_id :: Maybe String_primitive
        , parameterDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , parameterDefinition_name :: Maybe Code
          -- ^ The name of the parameter used to allow access to the value 
          --   of the parameter in evaluation contexts.
        , parameterDefinition_use :: Code
          -- ^ Whether the parameter is input or output for the module.
        , parameterDefinition_min :: Maybe Integer
          -- ^ The minimum number of times this parameter SHALL appear in 
          --   the request or response.
        , parameterDefinition_max :: Maybe Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the request or response.
        , parameterDefinition_documentation :: Maybe Xsd.XsdString
          -- ^ A brief discussion of what the parameter is for and how it 
          --   is used by the module.
        , parameterDefinition_type :: Code
          -- ^ The type of the parameter.
        , parameterDefinition_profile :: Maybe Reference
          -- ^ If specified, this indicates a profile that the input data 
          --   must conform to, or that the output data will conform to.
        }
        deriving (Eq,Show)
instance SchemaType ParameterDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ParameterDefinition a0)
            `apply` many (parseSchemaType "extension")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "use"
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "documentation")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
    schemaTypeToXML s x@ParameterDefinition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ parameterDefinition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ parameterDefinition_extension x
            , maybe [] (schemaTypeToXML "name") $ parameterDefinition_name x
            , schemaTypeToXML "use" $ parameterDefinition_use x
            , maybe [] (schemaTypeToXML "min") $ parameterDefinition_min x
            , maybe [] (schemaTypeToXML "max") $ parameterDefinition_max x
            , maybe [] (schemaTypeToXML "documentation") $ parameterDefinition_documentation x
            , schemaTypeToXML "type" $ parameterDefinition_type x
            , maybe [] (schemaTypeToXML "profile") $ parameterDefinition_profile x
            ]
instance Extension ParameterDefinition Element where
    supertype (ParameterDefinition a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               Element a0 e0
 
-- | A resource that includes narrative, extensions, and 
--   contained resources.
data DomainResource = DomainResource
        { domainResource_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , domainResource_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , domainResource_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , domainResource_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , domainResource_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , domainResource_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , domainResource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , domainResource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        }
        deriving (Eq,Show)
instance SchemaType DomainResource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DomainResource
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
    schemaTypeToXML s x@DomainResource{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ domainResource_id x
            , maybe [] (schemaTypeToXML "meta") $ domainResource_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ domainResource_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ domainResource_language x
            , maybe [] (schemaTypeToXML "text") $ domainResource_text x
            , concatMap (schemaTypeToXML "contained") $ domainResource_contained x
            , concatMap (schemaTypeToXML "extension") $ domainResource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ domainResource_modifierExtension x
            ]
instance Extension DomainResource Resource where
    supertype (DomainResource e0 e1 e2 e3 e4 e5 e6 e7) =
               Resource e0 e1 e2 e3
 
-- | This is the base resource type for everything.
data Resource = Resource
        { resource_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , resource_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , resource_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , resource_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        }
        deriving (Eq,Show)
instance SchemaType Resource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Resource
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@Resource{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ resource_id x
            , maybe [] (schemaTypeToXML "meta") $ resource_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ resource_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ resource_language x
            ]
 
data PublicationStatus_list
    = PublicationStatus_list_Draft
    | PublicationStatus_list_Active
    | PublicationStatus_list_Retired
    | PublicationStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType PublicationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PublicationStatus_list where
    acceptingParser =  do literal "draft"; return PublicationStatus_list_Draft
                      `onFail` do literal "active"; return PublicationStatus_list_Active
                      `onFail` do literal "retired"; return PublicationStatus_list_Retired
                      `onFail` do literal "unknown"; return PublicationStatus_list_Unknown
                      
    simpleTypeText PublicationStatus_list_Draft = "draft"
    simpleTypeText PublicationStatus_list_Active = "active"
    simpleTypeText PublicationStatus_list_Retired = "retired"
    simpleTypeText PublicationStatus_list_Unknown = "unknown"
 
data PublicationStatus = PublicationStatus
        { publicationStatus_id :: Maybe String_primitive
        , publicationStatus_value :: Maybe PublicationStatus_list
        , publicationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PublicationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PublicationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PublicationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ publicationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ publicationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ publicationStatus_extension x
            ]
instance Extension PublicationStatus Element where
    supertype (PublicationStatus a0 a1 e0) =
               Element a0 e0
 
data SearchParamType_list
    = SearchParamType_list_Number
      -- ^ Number
    | SearchParamType_list_Date
      -- ^ Date/DateTime
    | SearchParamType_list_Xsd.XsdString
      -- ^ String
    | SearchParamType_list_Token
      -- ^ Token
    | SearchParamType_list_Reference
      -- ^ Reference
    | SearchParamType_list_Composite
      -- ^ Composite
    | SearchParamType_list_Quantity
      -- ^ Quantity
    | SearchParamType_list_Uri
      -- ^ URI
    deriving (Eq,Show,Enum)
instance SchemaType SearchParamType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchParamType_list where
    acceptingParser =  do literal "number"; return SearchParamType_list_Number
                      `onFail` do literal "date"; return SearchParamType_list_Date
                      `onFail` do literal "string"; return SearchParamType_list_Xsd.XsdString
                      `onFail` do literal "token"; return SearchParamType_list_Token
                      `onFail` do literal "reference"; return SearchParamType_list_Reference
                      `onFail` do literal "composite"; return SearchParamType_list_Composite
                      `onFail` do literal "quantity"; return SearchParamType_list_Quantity
                      `onFail` do literal "uri"; return SearchParamType_list_Uri
                      
    simpleTypeText SearchParamType_list_Number = "number"
    simpleTypeText SearchParamType_list_Date = "date"
    simpleTypeText SearchParamType_list_Xsd.XsdString = "string"
    simpleTypeText SearchParamType_list_Token = "token"
    simpleTypeText SearchParamType_list_Reference = "reference"
    simpleTypeText SearchParamType_list_Composite = "composite"
    simpleTypeText SearchParamType_list_Quantity = "quantity"
    simpleTypeText SearchParamType_list_Uri = "uri"
 
data SearchParamType = SearchParamType
        { searchParamType_id :: Maybe String_primitive
        , searchParamType_value :: Maybe SearchParamType_list
        , searchParamType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchParamType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchParamType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchParamType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchParamType_id x
                       , maybe [] (toXMLAttribute "value") $ searchParamType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchParamType_extension x
            ]
instance Extension SearchParamType Element where
    supertype (SearchParamType a0 a1 e0) =
               Element a0 e0
 
data AdministrativeGender_list
    = AdministrativeGender_list_Male
      -- ^ Male
    | AdministrativeGender_list_Female
      -- ^ Female
    | AdministrativeGender_list_Other
      -- ^ Other
    | AdministrativeGender_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType AdministrativeGender_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdministrativeGender_list where
    acceptingParser =  do literal "male"; return AdministrativeGender_list_Male
                      `onFail` do literal "female"; return AdministrativeGender_list_Female
                      `onFail` do literal "other"; return AdministrativeGender_list_Other
                      `onFail` do literal "unknown"; return AdministrativeGender_list_Unknown
                      
    simpleTypeText AdministrativeGender_list_Male = "male"
    simpleTypeText AdministrativeGender_list_Female = "female"
    simpleTypeText AdministrativeGender_list_Other = "other"
    simpleTypeText AdministrativeGender_list_Unknown = "unknown"
 
data AdministrativeGender = AdministrativeGender
        { administrativeGender_id :: Maybe String_primitive
        , administrativeGender_value :: Maybe AdministrativeGender_list
        , administrativeGender_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdministrativeGender where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdministrativeGender a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdministrativeGender{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ administrativeGender_id x
                       , maybe [] (toXMLAttribute "value") $ administrativeGender_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ administrativeGender_extension x
            ]
instance Extension AdministrativeGender Element where
    supertype (AdministrativeGender a0 a1 e0) =
               Element a0 e0
 
data RemittanceOutcome_list
    = RemittanceOutcome_list_Complete
      -- ^ Processing Complete
    | RemittanceOutcome_list_Error
      -- ^ Error
    | RemittanceOutcome_list_Partial
      -- ^ Partial Processing
    deriving (Eq,Show,Enum)
instance SchemaType RemittanceOutcome_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RemittanceOutcome_list where
    acceptingParser =  do literal "complete"; return RemittanceOutcome_list_Complete
                      `onFail` do literal "error"; return RemittanceOutcome_list_Error
                      `onFail` do literal "partial"; return RemittanceOutcome_list_Partial
                      
    simpleTypeText RemittanceOutcome_list_Complete = "complete"
    simpleTypeText RemittanceOutcome_list_Error = "error"
    simpleTypeText RemittanceOutcome_list_Partial = "partial"
 
data RemittanceOutcome = RemittanceOutcome
        { remittanceOutcome_id :: Maybe String_primitive
        , remittanceOutcome_value :: Maybe RemittanceOutcome_list
        , remittanceOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RemittanceOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RemittanceOutcome a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RemittanceOutcome{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ remittanceOutcome_id x
                       , maybe [] (toXMLAttribute "value") $ remittanceOutcome_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ remittanceOutcome_extension x
            ]
instance Extension RemittanceOutcome Element where
    supertype (RemittanceOutcome a0 a1 e0) =
               Element a0 e0
 
data NoteType_list
    = NoteType_list_Display
      -- ^ Display
    | NoteType_list_Print
      -- ^ Print (Form)
    | NoteType_list_Printoper
      -- ^ Print (Operator)
    deriving (Eq,Show,Enum)
instance SchemaType NoteType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NoteType_list where
    acceptingParser =  do literal "display"; return NoteType_list_Display
                      `onFail` do literal "print"; return NoteType_list_Print
                      `onFail` do literal "printoper"; return NoteType_list_Printoper
                      
    simpleTypeText NoteType_list_Display = "display"
    simpleTypeText NoteType_list_Print = "print"
    simpleTypeText NoteType_list_Printoper = "printoper"
 
data NoteType = NoteType
        { noteType_id :: Maybe String_primitive
        , noteType_value :: Maybe NoteType_list
        , noteType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NoteType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NoteType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NoteType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ noteType_id x
                       , maybe [] (toXMLAttribute "value") $ noteType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ noteType_extension x
            ]
instance Extension NoteType Element where
    supertype (NoteType a0 a1 e0) =
               Element a0 e0
 
data ConceptMapEquivalence_list
    = ConceptMapEquivalence_list_Relatedto
      -- ^ Related To
    | ConceptMapEquivalence_list_Equivalent
      -- ^ Equivalent
    | ConceptMapEquivalence_list_Equal
      -- ^ Equal
    | ConceptMapEquivalence_list_Wider
      -- ^ Wider
    | ConceptMapEquivalence_list_Subsumes
      -- ^ Subsumes
    | ConceptMapEquivalence_list_Narrower
      -- ^ Narrower
    | ConceptMapEquivalence_list_Specializes
      -- ^ Specializes
    | ConceptMapEquivalence_list_Inexact
      -- ^ Inexact
    | ConceptMapEquivalence_list_Unmatched
      -- ^ Unmatched
    | ConceptMapEquivalence_list_Disjoint
      -- ^ Disjoint
    deriving (Eq,Show,Enum)
instance SchemaType ConceptMapEquivalence_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConceptMapEquivalence_list where
    acceptingParser =  do literal "relatedto"; return ConceptMapEquivalence_list_Relatedto
                      `onFail` do literal "equivalent"; return ConceptMapEquivalence_list_Equivalent
                      `onFail` do literal "equal"; return ConceptMapEquivalence_list_Equal
                      `onFail` do literal "wider"; return ConceptMapEquivalence_list_Wider
                      `onFail` do literal "subsumes"; return ConceptMapEquivalence_list_Subsumes
                      `onFail` do literal "narrower"; return ConceptMapEquivalence_list_Narrower
                      `onFail` do literal "specializes"; return ConceptMapEquivalence_list_Specializes
                      `onFail` do literal "inexact"; return ConceptMapEquivalence_list_Inexact
                      `onFail` do literal "unmatched"; return ConceptMapEquivalence_list_Unmatched
                      `onFail` do literal "disjoint"; return ConceptMapEquivalence_list_Disjoint
                      
    simpleTypeText ConceptMapEquivalence_list_Relatedto = "relatedto"
    simpleTypeText ConceptMapEquivalence_list_Equivalent = "equivalent"
    simpleTypeText ConceptMapEquivalence_list_Equal = "equal"
    simpleTypeText ConceptMapEquivalence_list_Wider = "wider"
    simpleTypeText ConceptMapEquivalence_list_Subsumes = "subsumes"
    simpleTypeText ConceptMapEquivalence_list_Narrower = "narrower"
    simpleTypeText ConceptMapEquivalence_list_Specializes = "specializes"
    simpleTypeText ConceptMapEquivalence_list_Inexact = "inexact"
    simpleTypeText ConceptMapEquivalence_list_Unmatched = "unmatched"
    simpleTypeText ConceptMapEquivalence_list_Disjoint = "disjoint"
 
data ConceptMapEquivalence = ConceptMapEquivalence
        { conceptMapEquivalence_id :: Maybe String_primitive
        , conceptMapEquivalence_value :: Maybe ConceptMapEquivalence_list
        , conceptMapEquivalence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapEquivalence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConceptMapEquivalence a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConceptMapEquivalence{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapEquivalence_id x
                       , maybe [] (toXMLAttribute "value") $ conceptMapEquivalence_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapEquivalence_extension x
            ]
instance Extension ConceptMapEquivalence Element where
    supertype (ConceptMapEquivalence a0 a1 e0) =
               Element a0 e0
 
data DocumentReferenceStatus_list
    = DocumentReferenceStatus_list_Current
      -- ^ Current
    | DocumentReferenceStatus_list_Superseded
      -- ^ Superseded
    | DocumentReferenceStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType DocumentReferenceStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentReferenceStatus_list where
    acceptingParser =  do literal "current"; return DocumentReferenceStatus_list_Current
                      `onFail` do literal "superseded"; return DocumentReferenceStatus_list_Superseded
                      `onFail` do literal "entered-in-error"; return DocumentReferenceStatus_list_Entered_in_error
                      
    simpleTypeText DocumentReferenceStatus_list_Current = "current"
    simpleTypeText DocumentReferenceStatus_list_Superseded = "superseded"
    simpleTypeText DocumentReferenceStatus_list_Entered_in_error = "entered-in-error"
 
data DocumentReferenceStatus = DocumentReferenceStatus
        { documentReferenceStatus_id :: Maybe String_primitive
        , documentReferenceStatus_value :: Maybe DocumentReferenceStatus_list
        , documentReferenceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentReferenceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentReferenceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ documentReferenceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceStatus_extension x
            ]
instance Extension DocumentReferenceStatus Element where
    supertype (DocumentReferenceStatus a0 a1 e0) =
               Element a0 e0
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
elementAccount :: XMLParser Account
elementAccount = parseSchemaType "Account"
elementToXMLAccount :: Account -> [Content ()]
elementToXMLAccount = schemaTypeToXML "Account"
 
data Account = Account
        { account_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , account_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , account_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , account_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , account_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , account_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , account_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , account_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , account_identifier :: [Identifier]
          -- ^ Unique identifier used to reference the account. May or may 
          --   not be intended for human use (e.g. credit card number).
        , account_status :: Maybe AccountStatus
          -- ^ Indicates whether the account is presently used/usable or 
          --   not.
        , account_type :: Maybe CodeableConcept
          -- ^ Categorizes the account for reporting and searching 
          --   purposes.
        , account_name :: Maybe Xsd.XsdString
          -- ^ Name used for the account when displaying it to humans in 
          --   reports, etc.
        , account_subject :: Maybe Reference
          -- ^ Identifies the patient, device, practitioner, location or 
          --   other object the account is associated with.
        , account_period :: Maybe Period
          -- ^ Identifies the period of time the account applies to; e.g. 
          --   accounts created per fiscal year, quarter, etc.
        , account_active :: Maybe Period
          -- ^ Indicates the period of time over which the account is 
          --   allowed to have transactions posted to it. This period may 
          --   be different to the coveragePeriod which is the duration of 
          --   time that services may occur.
        , account_balance :: Maybe Money
          -- ^ Represents the sum of all credits less all debits 
          --   associated with the account. Might be positive, zero or 
          --   negative.
        , account_coverage :: [AccountCoverage]
          -- ^ The party(s) that are responsible for covering the payment 
          --   of this account, and what order should they be applied to 
          --   the account.
        , account_owner :: Maybe Reference
          -- ^ Indicates the organization, department, etc. with 
          --   responsibility for the account.
        , account_description :: Maybe Xsd.XsdString
          -- ^ Provides additional information about what the account 
          --   tracks and how it is used.
        , account_guarantor :: [AccountGuarantor]
          -- ^ Parties financially responsible for the account.
        }
        deriving (Eq,Show)
instance SchemaType Account where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Account
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "balance")
            `apply` many (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "owner")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "guarantor")
    schemaTypeToXML s x@Account{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ account_id x
            , maybe [] (schemaTypeToXML "meta") $ account_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ account_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ account_language x
            , maybe [] (schemaTypeToXML "text") $ account_text x
            , concatMap (schemaTypeToXML "contained") $ account_contained x
            , concatMap (schemaTypeToXML "extension") $ account_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ account_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ account_identifier x
            , maybe [] (schemaTypeToXML "status") $ account_status x
            , maybe [] (schemaTypeToXML "type") $ account_type x
            , maybe [] (schemaTypeToXML "name") $ account_name x
            , maybe [] (schemaTypeToXML "subject") $ account_subject x
            , maybe [] (schemaTypeToXML "period") $ account_period x
            , maybe [] (schemaTypeToXML "active") $ account_active x
            , maybe [] (schemaTypeToXML "balance") $ account_balance x
            , concatMap (schemaTypeToXML "coverage") $ account_coverage x
            , maybe [] (schemaTypeToXML "owner") $ account_owner x
            , maybe [] (schemaTypeToXML "description") $ account_description x
            , concatMap (schemaTypeToXML "guarantor") $ account_guarantor x
            ]
instance Extension Account DomainResource where
    supertype (Account e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Account Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Account -> DomainResource)
              
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
data AccountCoverage = AccountCoverage
        { accountCoverage_id :: Maybe String_primitive
        , accountCoverage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , accountCoverage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , accountCoverage_coverage :: Reference
          -- ^ The party(s) that are responsible for payment (or part of) 
          --   of charges applied to this account (including self-pay). A 
          --   coverage may only be resposible for specific types of 
          --   charges, and the sequence of the coverages in the account 
          --   could be important when processing billing.
        , accountCoverage_priority :: Maybe PositiveInt
          -- ^ The priority of the coverage in the context of this 
          --   account.
        }
        deriving (Eq,Show)
instance SchemaType AccountCoverage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AccountCoverage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "priority")
    schemaTypeToXML s x@AccountCoverage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ accountCoverage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ accountCoverage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ accountCoverage_modifierExtension x
            , schemaTypeToXML "coverage" $ accountCoverage_coverage x
            , maybe [] (schemaTypeToXML "priority") $ accountCoverage_priority x
            ]
instance Extension AccountCoverage BackboneElement where
    supertype (AccountCoverage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension AccountCoverage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AccountCoverage -> BackboneElement)
              
 
-- | A financial tool for tracking value accrued for a 
--   particular purpose. In the healthcare field, used to track 
--   charges for a patient, cost centers, etc.
data AccountGuarantor = AccountGuarantor
        { accountGuarantor_id :: Maybe String_primitive
        , accountGuarantor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , accountGuarantor_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , accountGuarantor_party :: Reference
          -- ^ The entity who is responsible.
        , accountGuarantor_onHold :: Maybe Boolean
          -- ^ A guarantor may be placed on credit hold or otherwise have 
          --   their role temporarily suspended.
        , accountGuarantor_period :: Maybe Period
          -- ^ The timeframe during which the guarantor accepts 
          --   responsibility for the account.
        }
        deriving (Eq,Show)
instance SchemaType AccountGuarantor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AccountGuarantor a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "party"
            `apply` optional (parseSchemaType "onHold")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@AccountGuarantor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ accountGuarantor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ accountGuarantor_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ accountGuarantor_modifierExtension x
            , schemaTypeToXML "party" $ accountGuarantor_party x
            , maybe [] (schemaTypeToXML "onHold") $ accountGuarantor_onHold x
            , maybe [] (schemaTypeToXML "period") $ accountGuarantor_period x
            ]
instance Extension AccountGuarantor BackboneElement where
    supertype (AccountGuarantor a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension AccountGuarantor Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AccountGuarantor -> BackboneElement)
              
 
data AccountStatus_list
    = AccountStatus_list_Active
      -- ^ Active
    | AccountStatus_list_Inactive
      -- ^ Inactive
    | AccountStatus_list_Entered_in_error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType AccountStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AccountStatus_list where
    acceptingParser =  do literal "active"; return AccountStatus_list_Active
                      `onFail` do literal "inactive"; return AccountStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return AccountStatus_list_Entered_in_error
                      
    simpleTypeText AccountStatus_list_Active = "active"
    simpleTypeText AccountStatus_list_Inactive = "inactive"
    simpleTypeText AccountStatus_list_Entered_in_error = "entered-in-error"
 
data AccountStatus = AccountStatus
        { accountStatus_id :: Maybe String_primitive
        , accountStatus_value :: Maybe AccountStatus_list
        , accountStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AccountStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AccountStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AccountStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ accountStatus_id x
                       , maybe [] (toXMLAttribute "value") $ accountStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ accountStatus_extension x
            ]
instance Extension AccountStatus Element where
    supertype (AccountStatus a0 a1 e0) =
               Element a0 e0
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
elementActivityDefinition :: XMLParser ActivityDefinition
elementActivityDefinition = parseSchemaType "ActivityDefinition"
elementToXMLActivityDefinition :: ActivityDefinition -> [Content ()]
elementToXMLActivityDefinition = schemaTypeToXML "ActivityDefinition"
 
data ActivityDefinition = ActivityDefinition
        { activityDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , activityDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , activityDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , activityDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , activityDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , activityDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , activityDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this activity 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   activity definition is (or will be) published. The URL 
          --   SHOULD include the major version of the activity 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , activityDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this activity 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , activityDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   activity definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the activity definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence. To 
          --   provide a version consistent with the Decision Support 
          --   Service specification, use the format Major.Minor.Revision 
          --   (e.g. 1.0.0). For more information on versioning knowledge 
          --   assets, refer to the Decision Support Service 
          --   specification. Note that a version is required for 
          --   non-experimental active assets.
        , activityDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the activity 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , activityDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the activity 
          --   definition.
        , activityDefinition_status :: PublicationStatus
          -- ^ The status of this activity definition. Enables tracking 
          --   the life-cycle of the content.
        , activityDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this activity definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , activityDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the activity definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the activity definition changes.
        , activityDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the activity definition.
        , activityDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the activity 
          --   definition from a consumer's perspective.
        , activityDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this activity definition is needed and 
          --   why it has been designed as it has.
        , activityDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the asset is used from a 
          --   clinical perspective.
        , activityDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , activityDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , activityDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the activity definition content was 
          --   or is planned to be in active use.
        , activityDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   activity definition instances.
        , activityDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the activity 
          --   definition is intended to be used.
        , activityDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the activity. 
          --   Topics provide a high-level categorization of the activity 
          --   that can be useful for filtering and searching.
        , activityDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the asset, including 
          --   authors, editors, reviewers, and endorsers.
        , activityDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , activityDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the activity definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   activity definition.
        , activityDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , activityDefinition_library :: [Reference]
          -- ^ A reference to a Library resource containing any formal 
          --   logic used by the asset.
        , activityDefinition_kind :: Maybe ResourceType
          -- ^ A description of the kind of resource the activity 
          --   definition is representing. For example, a 
          --   MedicationRequest, a ProcedureRequest, or a 
          --   CommunicationRequest. Typically, but not always, this is a 
          --   Request resource.
        , activityDefinition_code :: Maybe CodeableConcept
          -- ^ Detailed description of the type of activity; e.g. What lab 
          --   test, what procedure, what kind of encounter.
        , activityDefinition_choice33 :: (Maybe (OneOf4 Timing DateTime Period Range))
          -- ^ The period, timing or frequency upon which the described 
          --   activity is to occur.
          --   
          --   Choice between:
          --   
          --   (1) timingTiming
          --   
          --   (2) timingDateTime
          --   
          --   (3) timingPeriod
          --   
          --   (4) timingRange
        , activityDefinition_location :: Maybe Reference
          -- ^ Identifies the facility where the activity will occur; e.g. 
          --   home, hospital, specific clinic, etc.
        , activityDefinition_participant :: [ActivityDefinitionParticipant]
          -- ^ Indicates who should participate in performing the action 
          --   described.
        , activityDefinition_choice36 :: (Maybe (OneOf2 Reference CodeableConcept))
          -- ^ Identifies the food, drug or other product being consumed 
          --   or supplied in the activity.
          --   
          --   Choice between:
          --   
          --   (1) productReference
          --   
          --   (2) productCodeableConcept
        , activityDefinition_quantity :: Maybe Quantity
          -- ^ Identifies the quantity expected to be consumed at once 
          --   (per dose, per meal, etc.).
        , activityDefinition_dosage :: [Dosage]
          -- ^ Provides detailed dosage instructions in the same way that 
          --   they are described for MedicationRequest resources.
        , activityDefinition_bodySite :: [CodeableConcept]
          -- ^ Indicates the sites on the subject's body where the 
          --   procedure should be performed (I.e. the target sites).
        , activityDefinition_transform :: Maybe Reference
          -- ^ A reference to a StructureMap resource that defines a 
          --   transform that can be executed to produce the intent 
          --   resource using the ActivityDefinition instance as the 
          --   input.
        , activityDefinition_dynamicValue :: [ActivityDefinitionDynamicValue]
          -- ^ Dynamic values that will be evaluated to produce values for 
          --   elements of the resulting resource. For example, if the 
          --   dosage of a medication must be computed based on the 
          --   patient's weight, a dynamic value would be used to specify 
          --   an expression that calculated the weight, and the path on 
          --   the intent resource that would contain the result.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ActivityDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` optional (parseSchemaType "kind")
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf4 (parseSchemaType "timingTiming"))
                                     , ("DateTime", fmap TwoOf4 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap ThreeOf4 (parseSchemaType "timingPeriod"))
                                     , ("Range", fmap FourOf4 (parseSchemaType "timingRange"))
                                     ])
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "participant")
            `apply` optional (oneOf' [ ("Reference", fmap OneOf2 (parseSchemaType "productReference"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "productCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "dosage")
            `apply` many (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "dynamicValue")
    schemaTypeToXML s x@ActivityDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ activityDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ activityDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ activityDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ activityDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ activityDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ activityDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ activityDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ activityDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ activityDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ activityDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ activityDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ activityDefinition_title x
            , schemaTypeToXML "status" $ activityDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ activityDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ activityDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ activityDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ activityDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ activityDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ activityDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ activityDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ activityDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ activityDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ activityDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ activityDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ activityDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ activityDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ activityDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ activityDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ activityDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ activityDefinition_library x
            , maybe [] (schemaTypeToXML "kind") $ activityDefinition_kind x
            , maybe [] (schemaTypeToXML "code") $ activityDefinition_code x
            , maybe [] (foldOneOf4  (schemaTypeToXML "timingTiming")
                                    (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingRange")
                                   ) $ activityDefinition_choice33 x
            , maybe [] (schemaTypeToXML "location") $ activityDefinition_location x
            , concatMap (schemaTypeToXML "participant") $ activityDefinition_participant x
            , maybe [] (foldOneOf2  (schemaTypeToXML "productReference")
                                    (schemaTypeToXML "productCodeableConcept")
                                   ) $ activityDefinition_choice36 x
            , maybe [] (schemaTypeToXML "quantity") $ activityDefinition_quantity x
            , concatMap (schemaTypeToXML "dosage") $ activityDefinition_dosage x
            , concatMap (schemaTypeToXML "bodySite") $ activityDefinition_bodySite x
            , maybe [] (schemaTypeToXML "transform") $ activityDefinition_transform x
            , concatMap (schemaTypeToXML "dynamicValue") $ activityDefinition_dynamicValue x
            ]
instance Extension ActivityDefinition DomainResource where
    supertype (ActivityDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ActivityDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ActivityDefinition -> DomainResource)
              
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
data ActivityDefinitionParticipant = ActivityDefinitionParticipant
        { activityDefinitionParticipant_id :: Maybe String_primitive
        , activityDefinitionParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinitionParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinitionParticipant_type :: ActionParticipantType
          -- ^ The type of participant in the action.
        , activityDefinitionParticipant_role :: Maybe CodeableConcept
          -- ^ The role the participant should play in performing the 
          --   described action.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinitionParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ActivityDefinitionParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "role")
    schemaTypeToXML s x@ActivityDefinitionParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ activityDefinitionParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ activityDefinitionParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinitionParticipant_modifierExtension x
            , schemaTypeToXML "type" $ activityDefinitionParticipant_type x
            , maybe [] (schemaTypeToXML "role") $ activityDefinitionParticipant_role x
            ]
instance Extension ActivityDefinitionParticipant BackboneElement where
    supertype (ActivityDefinitionParticipant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ActivityDefinitionParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ActivityDefinitionParticipant -> BackboneElement)
              
 
-- | This resource allows for the definition of some activity to 
--   be performed, independent of a particular patient, 
--   practitioner, or other performance context.
data ActivityDefinitionDynamicValue = ActivityDefinitionDynamicValue
        { activityDefinitionDynamicValue_id :: Maybe String_primitive
        , activityDefinitionDynamicValue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , activityDefinitionDynamicValue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , activityDefinitionDynamicValue_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the intended 
          --   semantics of the dynamic value.
        , activityDefinitionDynamicValue_path :: Maybe Xsd.XsdString
          -- ^ The path to the element to be customized. This is the path 
          --   on the resource that will hold the result of the 
          --   calculation defined by the expression.
        , activityDefinitionDynamicValue_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , activityDefinitionDynamicValue_expression :: Maybe Xsd.XsdString
          -- ^ An expression specifying the value of the customized 
          --   element.
        }
        deriving (Eq,Show)
instance SchemaType ActivityDefinitionDynamicValue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ActivityDefinitionDynamicValue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@ActivityDefinitionDynamicValue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ activityDefinitionDynamicValue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ activityDefinitionDynamicValue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ activityDefinitionDynamicValue_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ activityDefinitionDynamicValue_description x
            , maybe [] (schemaTypeToXML "path") $ activityDefinitionDynamicValue_path x
            , maybe [] (schemaTypeToXML "language") $ activityDefinitionDynamicValue_language x
            , maybe [] (schemaTypeToXML "expression") $ activityDefinitionDynamicValue_expression x
            ]
instance Extension ActivityDefinitionDynamicValue BackboneElement where
    supertype (ActivityDefinitionDynamicValue a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ActivityDefinitionDynamicValue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ActivityDefinitionDynamicValue -> BackboneElement)
              
 
data ActionParticipantType_list
    = ActionParticipantType_list_Patient
      -- ^ Patient
    | ActionParticipantType_list_Practitioner
      -- ^ Practitioner
    | ActionParticipantType_list_Related_person
      -- ^ Related Person
    deriving (Eq,Show,Enum)
instance SchemaType ActionParticipantType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionParticipantType_list where
    acceptingParser =  do literal "patient"; return ActionParticipantType_list_Patient
                      `onFail` do literal "practitioner"; return ActionParticipantType_list_Practitioner
                      `onFail` do literal "related-person"; return ActionParticipantType_list_Related_person
                      
    simpleTypeText ActionParticipantType_list_Patient = "patient"
    simpleTypeText ActionParticipantType_list_Practitioner = "practitioner"
    simpleTypeText ActionParticipantType_list_Related_person = "related-person"
 
data ActionParticipantType = ActionParticipantType
        { actionParticipantType_id :: Maybe String_primitive
        , actionParticipantType_value :: Maybe ActionParticipantType_list
        , actionParticipantType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionParticipantType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionParticipantType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionParticipantType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionParticipantType_id x
                       , maybe [] (toXMLAttribute "value") $ actionParticipantType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionParticipantType_extension x
            ]
instance Extension ActionParticipantType Element where
    supertype (ActionParticipantType a0 a1 e0) =
               Element a0 e0
 
data ResourceType_list
    = ResourceType_list_Account
      -- ^ Account
    | ResourceType_list_ActivityDefinition
      -- ^ ActivityDefinition
    | ResourceType_list_AdverseEvent
      -- ^ AdverseEvent
    | ResourceType_list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | ResourceType_list_Appointment
      -- ^ Appointment
    | ResourceType_list_AppointmentResponse
      -- ^ AppointmentResponse
    | ResourceType_list_AuditEvent
      -- ^ AuditEvent
    | ResourceType_list_Basic
      -- ^ Basic
    | ResourceType_list_Binary
      -- ^ Binary
    | ResourceType_list_BodySite
      -- ^ BodySite
    | ResourceType_list_Bundle
      -- ^ Bundle
    | ResourceType_list_CapabilityStatement
      -- ^ CapabilityStatement
    | ResourceType_list_CarePlan
      -- ^ CarePlan
    | ResourceType_list_CareTeam
      -- ^ CareTeam
    | ResourceType_list_ChargeItem
      -- ^ ChargeItem
    | ResourceType_list_Claim
      -- ^ Claim
    | ResourceType_list_ClaimResponse
      -- ^ ClaimResponse
    | ResourceType_list_ClinicalImpression
      -- ^ ClinicalImpression
    | ResourceType_list_CodeSystem
      -- ^ CodeSystem
    | ResourceType_list_Communication
      -- ^ Communication
    | ResourceType_list_CommunicationRequest
      -- ^ CommunicationRequest
    | ResourceType_list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | ResourceType_list_Composition
      -- ^ Composition
    | ResourceType_list_ConceptMap
      -- ^ ConceptMap
    | ResourceType_list_Condition
      -- ^ Condition
    | ResourceType_list_Consent
      -- ^ Consent
    | ResourceType_list_Contract
      -- ^ Contract
    | ResourceType_list_Coverage
      -- ^ Coverage
    | ResourceType_list_DataElement
      -- ^ DataElement
    | ResourceType_list_DetectedIssue
      -- ^ DetectedIssue
    | ResourceType_list_Device
      -- ^ Device
    | ResourceType_list_DeviceComponent
      -- ^ DeviceComponent
    | ResourceType_list_DeviceMetric
      -- ^ DeviceMetric
    | ResourceType_list_DeviceRequest
      -- ^ DeviceRequest
    | ResourceType_list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | ResourceType_list_DiagnosticReport
      -- ^ DiagnosticReport
    | ResourceType_list_DocumentManifest
      -- ^ DocumentManifest
    | ResourceType_list_DocumentReference
      -- ^ DocumentReference
    | ResourceType_list_DomainResource
      -- ^ DomainResource
    | ResourceType_list_EligibilityRequest
      -- ^ EligibilityRequest
    | ResourceType_list_EligibilityResponse
      -- ^ EligibilityResponse
    | ResourceType_list_Encounter
      -- ^ Encounter
    | ResourceType_list_Endpoint
      -- ^ Endpoint
    | ResourceType_list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | ResourceType_list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | ResourceType_list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | ResourceType_list_ExpansionProfile
      -- ^ ExpansionProfile
    | ResourceType_list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | ResourceType_list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | ResourceType_list_Flag
      -- ^ Flag
    | ResourceType_list_Goal
      -- ^ Goal
    | ResourceType_list_GraphDefinition
      -- ^ GraphDefinition
    | ResourceType_list_Group
      -- ^ Group
    | ResourceType_list_GuidanceResponse
      -- ^ GuidanceResponse
    | ResourceType_list_HealthcareService
      -- ^ HealthcareService
    | ResourceType_list_ImagingManifest
      -- ^ ImagingManifest
    | ResourceType_list_ImagingStudy
      -- ^ ImagingStudy
    | ResourceType_list_Immunization
      -- ^ Immunization
    | ResourceType_list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | ResourceType_list_ImplementationGuide
      -- ^ ImplementationGuide
    | ResourceType_list_Library
      -- ^ Library
    | ResourceType_list_Linkage
      -- ^ Linkage
    | ResourceType_list_List
      -- ^ List
    | ResourceType_list_Location
      -- ^ Location
    | ResourceType_list_Measure
      -- ^ Measure
    | ResourceType_list_MeasureReport
      -- ^ MeasureReport
    | ResourceType_list_Media
      -- ^ Media
    | ResourceType_list_Medication
      -- ^ Medication
    | ResourceType_list_MedicationAdministration
      -- ^ MedicationAdministration
    | ResourceType_list_MedicationDispense
      -- ^ MedicationDispense
    | ResourceType_list_MedicationRequest
      -- ^ MedicationRequest
    | ResourceType_list_MedicationStatement
      -- ^ MedicationStatement
    | ResourceType_list_MessageDefinition
      -- ^ MessageDefinition
    | ResourceType_list_MessageHeader
      -- ^ MessageHeader
    | ResourceType_list_NamingSystem
      -- ^ NamingSystem
    | ResourceType_list_NutritionOrder
      -- ^ NutritionOrder
    | ResourceType_list_Observation
      -- ^ Observation
    | ResourceType_list_OperationDefinition
      -- ^ OperationDefinition
    | ResourceType_list_OperationOutcome
      -- ^ OperationOutcome
    | ResourceType_list_Organization
      -- ^ Organization
    | ResourceType_list_Parameters
      -- ^ Parameters
    | ResourceType_list_Patient
      -- ^ Patient
    | ResourceType_list_PaymentNotice
      -- ^ PaymentNotice
    | ResourceType_list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | ResourceType_list_Person
      -- ^ Person
    | ResourceType_list_PlanDefinition
      -- ^ PlanDefinition
    | ResourceType_list_Practitioner
      -- ^ Practitioner
    | ResourceType_list_PractitionerRole
      -- ^ PractitionerRole
    | ResourceType_list_Procedure
      -- ^ Procedure
    | ResourceType_list_ProcedureRequest
      -- ^ ProcedureRequest
    | ResourceType_list_ProcessRequest
      -- ^ ProcessRequest
    | ResourceType_list_ProcessResponse
      -- ^ ProcessResponse
    | ResourceType_list_Provenance
      -- ^ Provenance
    | ResourceType_list_Questionnaire
      -- ^ Questionnaire
    | ResourceType_list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | ResourceType_list_ReferralRequest
      -- ^ ReferralRequest
    | ResourceType_list_RelatedPerson
      -- ^ RelatedPerson
    | ResourceType_list_RequestGroup
      -- ^ RequestGroup
    | ResourceType_list_ResearchStudy
      -- ^ ResearchStudy
    | ResourceType_list_ResearchSubject
      -- ^ ResearchSubject
    | ResourceType_list_Resource
      -- ^ Resource
    | ResourceType_list_RiskAssessment
      -- ^ RiskAssessment
    | ResourceType_list_Schedule
      -- ^ Schedule
    | ResourceType_list_SearchParameter
      -- ^ SearchParameter
    | ResourceType_list_Sequence
      -- ^ Sequence
    | ResourceType_list_ServiceDefinition
      -- ^ ServiceDefinition
    | ResourceType_list_Slot
      -- ^ Slot
    | ResourceType_list_Specimen
      -- ^ Specimen
    | ResourceType_list_StructureDefinition
      -- ^ StructureDefinition
    | ResourceType_list_StructureMap
      -- ^ StructureMap
    | ResourceType_list_Subscription
      -- ^ Subscription
    | ResourceType_list_Substance
      -- ^ Substance
    | ResourceType_list_SupplyDelivery
      -- ^ SupplyDelivery
    | ResourceType_list_SupplyRequest
      -- ^ SupplyRequest
    | ResourceType_list_Task
      -- ^ Task
    | ResourceType_list_TestReport
      -- ^ TestReport
    | ResourceType_list_TestScript
      -- ^ TestScript
    | ResourceType_list_ValueSet
      -- ^ ValueSet
    | ResourceType_list_VisionPrescription
      -- ^ VisionPrescription
    deriving (Eq,Show,Enum)
instance SchemaType ResourceType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResourceType_list where
    acceptingParser =  do literal "Account"; return ResourceType_list_Account
                      `onFail` do literal "ActivityDefinition"; return ResourceType_list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return ResourceType_list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return ResourceType_list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return ResourceType_list_Appointment
                      `onFail` do literal "AppointmentResponse"; return ResourceType_list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return ResourceType_list_AuditEvent
                      `onFail` do literal "Basic"; return ResourceType_list_Basic
                      `onFail` do literal "Binary"; return ResourceType_list_Binary
                      `onFail` do literal "BodySite"; return ResourceType_list_BodySite
                      `onFail` do literal "Bundle"; return ResourceType_list_Bundle
                      `onFail` do literal "CapabilityStatement"; return ResourceType_list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return ResourceType_list_CarePlan
                      `onFail` do literal "CareTeam"; return ResourceType_list_CareTeam
                      `onFail` do literal "ChargeItem"; return ResourceType_list_ChargeItem
                      `onFail` do literal "Claim"; return ResourceType_list_Claim
                      `onFail` do literal "ClaimResponse"; return ResourceType_list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return ResourceType_list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return ResourceType_list_CodeSystem
                      `onFail` do literal "Communication"; return ResourceType_list_Communication
                      `onFail` do literal "CommunicationRequest"; return ResourceType_list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return ResourceType_list_CompartmentDefinition
                      `onFail` do literal "Composition"; return ResourceType_list_Composition
                      `onFail` do literal "ConceptMap"; return ResourceType_list_ConceptMap
                      `onFail` do literal "Condition"; return ResourceType_list_Condition
                      `onFail` do literal "Consent"; return ResourceType_list_Consent
                      `onFail` do literal "Contract"; return ResourceType_list_Contract
                      `onFail` do literal "Coverage"; return ResourceType_list_Coverage
                      `onFail` do literal "DataElement"; return ResourceType_list_DataElement
                      `onFail` do literal "DetectedIssue"; return ResourceType_list_DetectedIssue
                      `onFail` do literal "Device"; return ResourceType_list_Device
                      `onFail` do literal "DeviceComponent"; return ResourceType_list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return ResourceType_list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return ResourceType_list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return ResourceType_list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return ResourceType_list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return ResourceType_list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return ResourceType_list_DocumentReference
                      `onFail` do literal "DomainResource"; return ResourceType_list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return ResourceType_list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return ResourceType_list_EligibilityResponse
                      `onFail` do literal "Encounter"; return ResourceType_list_Encounter
                      `onFail` do literal "Endpoint"; return ResourceType_list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return ResourceType_list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return ResourceType_list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return ResourceType_list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return ResourceType_list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return ResourceType_list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return ResourceType_list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return ResourceType_list_Flag
                      `onFail` do literal "Goal"; return ResourceType_list_Goal
                      `onFail` do literal "GraphDefinition"; return ResourceType_list_GraphDefinition
                      `onFail` do literal "Group"; return ResourceType_list_Group
                      `onFail` do literal "GuidanceResponse"; return ResourceType_list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return ResourceType_list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return ResourceType_list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return ResourceType_list_ImagingStudy
                      `onFail` do literal "Immunization"; return ResourceType_list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return ResourceType_list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return ResourceType_list_ImplementationGuide
                      `onFail` do literal "Library"; return ResourceType_list_Library
                      `onFail` do literal "Linkage"; return ResourceType_list_Linkage
                      `onFail` do literal "List"; return ResourceType_list_List
                      `onFail` do literal "Location"; return ResourceType_list_Location
                      `onFail` do literal "Measure"; return ResourceType_list_Measure
                      `onFail` do literal "MeasureReport"; return ResourceType_list_MeasureReport
                      `onFail` do literal "Media"; return ResourceType_list_Media
                      `onFail` do literal "Medication"; return ResourceType_list_Medication
                      `onFail` do literal "MedicationAdministration"; return ResourceType_list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return ResourceType_list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return ResourceType_list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return ResourceType_list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return ResourceType_list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return ResourceType_list_MessageHeader
                      `onFail` do literal "NamingSystem"; return ResourceType_list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return ResourceType_list_NutritionOrder
                      `onFail` do literal "Observation"; return ResourceType_list_Observation
                      `onFail` do literal "OperationDefinition"; return ResourceType_list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return ResourceType_list_OperationOutcome
                      `onFail` do literal "Organization"; return ResourceType_list_Organization
                      `onFail` do literal "Parameters"; return ResourceType_list_Parameters
                      `onFail` do literal "Patient"; return ResourceType_list_Patient
                      `onFail` do literal "PaymentNotice"; return ResourceType_list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return ResourceType_list_PaymentReconciliation
                      `onFail` do literal "Person"; return ResourceType_list_Person
                      `onFail` do literal "PlanDefinition"; return ResourceType_list_PlanDefinition
                      `onFail` do literal "Practitioner"; return ResourceType_list_Practitioner
                      `onFail` do literal "PractitionerRole"; return ResourceType_list_PractitionerRole
                      `onFail` do literal "Procedure"; return ResourceType_list_Procedure
                      `onFail` do literal "ProcedureRequest"; return ResourceType_list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return ResourceType_list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return ResourceType_list_ProcessResponse
                      `onFail` do literal "Provenance"; return ResourceType_list_Provenance
                      `onFail` do literal "Questionnaire"; return ResourceType_list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return ResourceType_list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return ResourceType_list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return ResourceType_list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return ResourceType_list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return ResourceType_list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return ResourceType_list_ResearchSubject
                      `onFail` do literal "Resource"; return ResourceType_list_Resource
                      `onFail` do literal "RiskAssessment"; return ResourceType_list_RiskAssessment
                      `onFail` do literal "Schedule"; return ResourceType_list_Schedule
                      `onFail` do literal "SearchParameter"; return ResourceType_list_SearchParameter
                      `onFail` do literal "Sequence"; return ResourceType_list_Sequence
                      `onFail` do literal "ServiceDefinition"; return ResourceType_list_ServiceDefinition
                      `onFail` do literal "Slot"; return ResourceType_list_Slot
                      `onFail` do literal "Specimen"; return ResourceType_list_Specimen
                      `onFail` do literal "StructureDefinition"; return ResourceType_list_StructureDefinition
                      `onFail` do literal "StructureMap"; return ResourceType_list_StructureMap
                      `onFail` do literal "Subscription"; return ResourceType_list_Subscription
                      `onFail` do literal "Substance"; return ResourceType_list_Substance
                      `onFail` do literal "SupplyDelivery"; return ResourceType_list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return ResourceType_list_SupplyRequest
                      `onFail` do literal "Task"; return ResourceType_list_Task
                      `onFail` do literal "TestReport"; return ResourceType_list_TestReport
                      `onFail` do literal "TestScript"; return ResourceType_list_TestScript
                      `onFail` do literal "ValueSet"; return ResourceType_list_ValueSet
                      `onFail` do literal "VisionPrescription"; return ResourceType_list_VisionPrescription
                      
    simpleTypeText ResourceType_list_Account = "Account"
    simpleTypeText ResourceType_list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText ResourceType_list_AdverseEvent = "AdverseEvent"
    simpleTypeText ResourceType_list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText ResourceType_list_Appointment = "Appointment"
    simpleTypeText ResourceType_list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText ResourceType_list_AuditEvent = "AuditEvent"
    simpleTypeText ResourceType_list_Basic = "Basic"
    simpleTypeText ResourceType_list_Binary = "Binary"
    simpleTypeText ResourceType_list_BodySite = "BodySite"
    simpleTypeText ResourceType_list_Bundle = "Bundle"
    simpleTypeText ResourceType_list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText ResourceType_list_CarePlan = "CarePlan"
    simpleTypeText ResourceType_list_CareTeam = "CareTeam"
    simpleTypeText ResourceType_list_ChargeItem = "ChargeItem"
    simpleTypeText ResourceType_list_Claim = "Claim"
    simpleTypeText ResourceType_list_ClaimResponse = "ClaimResponse"
    simpleTypeText ResourceType_list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText ResourceType_list_CodeSystem = "CodeSystem"
    simpleTypeText ResourceType_list_Communication = "Communication"
    simpleTypeText ResourceType_list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText ResourceType_list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText ResourceType_list_Composition = "Composition"
    simpleTypeText ResourceType_list_ConceptMap = "ConceptMap"
    simpleTypeText ResourceType_list_Condition = "Condition"
    simpleTypeText ResourceType_list_Consent = "Consent"
    simpleTypeText ResourceType_list_Contract = "Contract"
    simpleTypeText ResourceType_list_Coverage = "Coverage"
    simpleTypeText ResourceType_list_DataElement = "DataElement"
    simpleTypeText ResourceType_list_DetectedIssue = "DetectedIssue"
    simpleTypeText ResourceType_list_Device = "Device"
    simpleTypeText ResourceType_list_DeviceComponent = "DeviceComponent"
    simpleTypeText ResourceType_list_DeviceMetric = "DeviceMetric"
    simpleTypeText ResourceType_list_DeviceRequest = "DeviceRequest"
    simpleTypeText ResourceType_list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText ResourceType_list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText ResourceType_list_DocumentManifest = "DocumentManifest"
    simpleTypeText ResourceType_list_DocumentReference = "DocumentReference"
    simpleTypeText ResourceType_list_DomainResource = "DomainResource"
    simpleTypeText ResourceType_list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText ResourceType_list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText ResourceType_list_Encounter = "Encounter"
    simpleTypeText ResourceType_list_Endpoint = "Endpoint"
    simpleTypeText ResourceType_list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText ResourceType_list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText ResourceType_list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText ResourceType_list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText ResourceType_list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText ResourceType_list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText ResourceType_list_Flag = "Flag"
    simpleTypeText ResourceType_list_Goal = "Goal"
    simpleTypeText ResourceType_list_GraphDefinition = "GraphDefinition"
    simpleTypeText ResourceType_list_Group = "Group"
    simpleTypeText ResourceType_list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText ResourceType_list_HealthcareService = "HealthcareService"
    simpleTypeText ResourceType_list_ImagingManifest = "ImagingManifest"
    simpleTypeText ResourceType_list_ImagingStudy = "ImagingStudy"
    simpleTypeText ResourceType_list_Immunization = "Immunization"
    simpleTypeText ResourceType_list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText ResourceType_list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText ResourceType_list_Library = "Library"
    simpleTypeText ResourceType_list_Linkage = "Linkage"
    simpleTypeText ResourceType_list_List = "List"
    simpleTypeText ResourceType_list_Location = "Location"
    simpleTypeText ResourceType_list_Measure = "Measure"
    simpleTypeText ResourceType_list_MeasureReport = "MeasureReport"
    simpleTypeText ResourceType_list_Media = "Media"
    simpleTypeText ResourceType_list_Medication = "Medication"
    simpleTypeText ResourceType_list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText ResourceType_list_MedicationDispense = "MedicationDispense"
    simpleTypeText ResourceType_list_MedicationRequest = "MedicationRequest"
    simpleTypeText ResourceType_list_MedicationStatement = "MedicationStatement"
    simpleTypeText ResourceType_list_MessageDefinition = "MessageDefinition"
    simpleTypeText ResourceType_list_MessageHeader = "MessageHeader"
    simpleTypeText ResourceType_list_NamingSystem = "NamingSystem"
    simpleTypeText ResourceType_list_NutritionOrder = "NutritionOrder"
    simpleTypeText ResourceType_list_Observation = "Observation"
    simpleTypeText ResourceType_list_OperationDefinition = "OperationDefinition"
    simpleTypeText ResourceType_list_OperationOutcome = "OperationOutcome"
    simpleTypeText ResourceType_list_Organization = "Organization"
    simpleTypeText ResourceType_list_Parameters = "Parameters"
    simpleTypeText ResourceType_list_Patient = "Patient"
    simpleTypeText ResourceType_list_PaymentNotice = "PaymentNotice"
    simpleTypeText ResourceType_list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText ResourceType_list_Person = "Person"
    simpleTypeText ResourceType_list_PlanDefinition = "PlanDefinition"
    simpleTypeText ResourceType_list_Practitioner = "Practitioner"
    simpleTypeText ResourceType_list_PractitionerRole = "PractitionerRole"
    simpleTypeText ResourceType_list_Procedure = "Procedure"
    simpleTypeText ResourceType_list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText ResourceType_list_ProcessRequest = "ProcessRequest"
    simpleTypeText ResourceType_list_ProcessResponse = "ProcessResponse"
    simpleTypeText ResourceType_list_Provenance = "Provenance"
    simpleTypeText ResourceType_list_Questionnaire = "Questionnaire"
    simpleTypeText ResourceType_list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText ResourceType_list_ReferralRequest = "ReferralRequest"
    simpleTypeText ResourceType_list_RelatedPerson = "RelatedPerson"
    simpleTypeText ResourceType_list_RequestGroup = "RequestGroup"
    simpleTypeText ResourceType_list_ResearchStudy = "ResearchStudy"
    simpleTypeText ResourceType_list_ResearchSubject = "ResearchSubject"
    simpleTypeText ResourceType_list_Resource = "Resource"
    simpleTypeText ResourceType_list_RiskAssessment = "RiskAssessment"
    simpleTypeText ResourceType_list_Schedule = "Schedule"
    simpleTypeText ResourceType_list_SearchParameter = "SearchParameter"
    simpleTypeText ResourceType_list_Sequence = "Sequence"
    simpleTypeText ResourceType_list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText ResourceType_list_Slot = "Slot"
    simpleTypeText ResourceType_list_Specimen = "Specimen"
    simpleTypeText ResourceType_list_StructureDefinition = "StructureDefinition"
    simpleTypeText ResourceType_list_StructureMap = "StructureMap"
    simpleTypeText ResourceType_list_Subscription = "Subscription"
    simpleTypeText ResourceType_list_Substance = "Substance"
    simpleTypeText ResourceType_list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText ResourceType_list_SupplyRequest = "SupplyRequest"
    simpleTypeText ResourceType_list_Task = "Task"
    simpleTypeText ResourceType_list_TestReport = "TestReport"
    simpleTypeText ResourceType_list_TestScript = "TestScript"
    simpleTypeText ResourceType_list_ValueSet = "ValueSet"
    simpleTypeText ResourceType_list_VisionPrescription = "VisionPrescription"
 
data ResourceType = ResourceType
        { resourceType_id :: Maybe String_primitive
        , resourceType_value :: Maybe ResourceType_list
        , resourceType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResourceType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResourceType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResourceType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ resourceType_id x
                       , maybe [] (toXMLAttribute "value") $ resourceType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ resourceType_extension x
            ]
instance Extension ResourceType Element where
    supertype (ResourceType a0 a1 e0) =
               Element a0 e0
 
-- | Actual or potential/avoided event causing unintended 
--   physical injury resulting from or contributed to by medical 
--   care, a research study or other healthcare setting factors 
--   that requires additional monitoring, treatment, or 
--   hospitalization, or that results in death.
elementAdverseEvent :: XMLParser AdverseEvent
elementAdverseEvent = parseSchemaType "AdverseEvent"
elementToXMLAdverseEvent :: AdverseEvent -> [Content ()]
elementToXMLAdverseEvent = schemaTypeToXML "AdverseEvent"
 
data AdverseEvent = AdverseEvent
        { adverseEvent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , adverseEvent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , adverseEvent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , adverseEvent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , adverseEvent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , adverseEvent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , adverseEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , adverseEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , adverseEvent_identifier :: Maybe Identifier
          -- ^ The identifier(s) of this adverse event that are assigned 
          --   by business processes and/or used to refer to it when a 
          --   direct URL reference to the resource itsefl is not 
          --   appropriate.
        , adverseEvent_category :: Maybe AdverseEventCategory
          -- ^ The type of event which is important to characterize what 
          --   occurred and caused harm to the subject, or had the 
          --   potential to cause harm to the subject.
        , adverseEvent_type :: Maybe CodeableConcept
          -- ^ This element defines the specific type of event that 
          --   occurred or that was prevented from occurring.
        , adverseEvent_subject :: Maybe Reference
          -- ^ This subject or group impacted by the event. With a 
          --   prospective adverse event, there will be no subject as the 
          --   adverse event was prevented.
        , adverseEvent_date :: Maybe DateTime
          -- ^ The date (and perhaps time) when the adverse event 
          --   occurred.
        , adverseEvent_reaction :: [Reference]
          -- ^ Includes information about the reaction that occurred as a 
          --   result of exposure to a substance (for example, a drug or a 
          --   chemical).
        , adverseEvent_location :: Maybe Reference
          -- ^ The information about where the adverse event occurred.
        , adverseEvent_seriousness :: Maybe CodeableConcept
          -- ^ Describes the seriousness or severity of the adverse event.
        , adverseEvent_outcome :: Maybe CodeableConcept
          -- ^ Describes the type of outcome from the adverse event.
        , adverseEvent_recorder :: Maybe Reference
          -- ^ Information on who recorded the adverse event. May be the 
          --   patient or a practitioner.
        , adverseEvent_eventParticipant :: Maybe Reference
          -- ^ Parties that may or should contribute or have contributed 
          --   information to the Act. Such information includes 
          --   information leading to the decision to perform the Act and 
          --   how to perform the Act (e.g. consultant), information that 
          --   the Act itself seeks to reveal (e.g. informant of clinical 
          --   history), or information about what Act was performed (e.g. 
          --   informant witness).
        , adverseEvent_description :: Maybe Xsd.XsdString
          -- ^ Describes the adverse event in text.
        , adverseEvent_suspectEntity :: [AdverseEventSuspectEntity]
          -- ^ Describes the entity that is suspected to have caused the 
          --   adverse event.
        , adverseEvent_subjectMedicalHistory :: [Reference]
          -- ^ AdverseEvent.subjectMedicalHistory.
        , adverseEvent_referenceDocument :: [Reference]
          -- ^ AdverseEvent.referenceDocument.
        , adverseEvent_study :: [Reference]
          -- ^ AdverseEvent.study.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AdverseEvent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "date")
            `apply` many (parseSchemaType "reaction")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "seriousness")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "recorder")
            `apply` optional (parseSchemaType "eventParticipant")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "suspectEntity")
            `apply` many (parseSchemaType "subjectMedicalHistory")
            `apply` many (parseSchemaType "referenceDocument")
            `apply` many (parseSchemaType "study")
    schemaTypeToXML s x@AdverseEvent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ adverseEvent_id x
            , maybe [] (schemaTypeToXML "meta") $ adverseEvent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ adverseEvent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ adverseEvent_language x
            , maybe [] (schemaTypeToXML "text") $ adverseEvent_text x
            , concatMap (schemaTypeToXML "contained") $ adverseEvent_contained x
            , concatMap (schemaTypeToXML "extension") $ adverseEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ adverseEvent_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ adverseEvent_identifier x
            , maybe [] (schemaTypeToXML "category") $ adverseEvent_category x
            , maybe [] (schemaTypeToXML "type") $ adverseEvent_type x
            , maybe [] (schemaTypeToXML "subject") $ adverseEvent_subject x
            , maybe [] (schemaTypeToXML "date") $ adverseEvent_date x
            , concatMap (schemaTypeToXML "reaction") $ adverseEvent_reaction x
            , maybe [] (schemaTypeToXML "location") $ adverseEvent_location x
            , maybe [] (schemaTypeToXML "seriousness") $ adverseEvent_seriousness x
            , maybe [] (schemaTypeToXML "outcome") $ adverseEvent_outcome x
            , maybe [] (schemaTypeToXML "recorder") $ adverseEvent_recorder x
            , maybe [] (schemaTypeToXML "eventParticipant") $ adverseEvent_eventParticipant x
            , maybe [] (schemaTypeToXML "description") $ adverseEvent_description x
            , concatMap (schemaTypeToXML "suspectEntity") $ adverseEvent_suspectEntity x
            , concatMap (schemaTypeToXML "subjectMedicalHistory") $ adverseEvent_subjectMedicalHistory x
            , concatMap (schemaTypeToXML "referenceDocument") $ adverseEvent_referenceDocument x
            , concatMap (schemaTypeToXML "study") $ adverseEvent_study x
            ]
instance Extension AdverseEvent DomainResource where
    supertype (AdverseEvent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AdverseEvent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AdverseEvent -> DomainResource)
              
 
-- | Actual or potential/avoided event causing unintended 
--   physical injury resulting from or contributed to by medical 
--   care, a research study or other healthcare setting factors 
--   that requires additional monitoring, treatment, or 
--   hospitalization, or that results in death.
data AdverseEventSuspectEntity = AdverseEventSuspectEntity
        { adverseEventSuspectEntity_id :: Maybe String_primitive
        , adverseEventSuspectEntity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , adverseEventSuspectEntity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , adverseEventSuspectEntity_instance :: Reference
          -- ^ Identifies the actual instance of what caused the adverse 
          --   event. May be a substance, medication, medication 
          --   administration, medication statement or a device.
        , adverseEventSuspectEntity_causality :: Maybe AdverseEventCausality
          -- ^ causality1 | causality2.
        , adverseEventSuspectEntity_causalityAssessment :: Maybe CodeableConcept
          -- ^ assess1 | assess2.
        , adverseEventSuspectEntity_causalityProductRelatedness :: Maybe Xsd.XsdString
          -- ^ AdverseEvent.suspectEntity.causalityProductRelatedness.
        , adverseEventSuspectEntity_causalityMethod :: Maybe CodeableConcept
          -- ^ method1 | method2.
        , adverseEventSuspectEntity_causalityAuthor :: Maybe Reference
          -- ^ AdverseEvent.suspectEntity.causalityAuthor.
        , adverseEventSuspectEntity_causalityResult :: Maybe CodeableConcept
          -- ^ result1 | result2.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEventSuspectEntity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AdverseEventSuspectEntity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "instance"
            `apply` optional (parseSchemaType "causality")
            `apply` optional (parseSchemaType "causalityAssessment")
            `apply` optional (parseSchemaType "causalityProductRelatedness")
            `apply` optional (parseSchemaType "causalityMethod")
            `apply` optional (parseSchemaType "causalityAuthor")
            `apply` optional (parseSchemaType "causalityResult")
    schemaTypeToXML s x@AdverseEventSuspectEntity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEventSuspectEntity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEventSuspectEntity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ adverseEventSuspectEntity_modifierExtension x
            , schemaTypeToXML "instance" $ adverseEventSuspectEntity_instance x
            , maybe [] (schemaTypeToXML "causality") $ adverseEventSuspectEntity_causality x
            , maybe [] (schemaTypeToXML "causalityAssessment") $ adverseEventSuspectEntity_causalityAssessment x
            , maybe [] (schemaTypeToXML "causalityProductRelatedness") $ adverseEventSuspectEntity_causalityProductRelatedness x
            , maybe [] (schemaTypeToXML "causalityMethod") $ adverseEventSuspectEntity_causalityMethod x
            , maybe [] (schemaTypeToXML "causalityAuthor") $ adverseEventSuspectEntity_causalityAuthor x
            , maybe [] (schemaTypeToXML "causalityResult") $ adverseEventSuspectEntity_causalityResult x
            ]
instance Extension AdverseEventSuspectEntity BackboneElement where
    supertype (AdverseEventSuspectEntity a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension AdverseEventSuspectEntity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AdverseEventSuspectEntity -> BackboneElement)
              
 
data AdverseEventCausality_list
    = AdverseEventCausality_list_Causality1
      -- ^ causality1 placeholder
    | AdverseEventCausality_list_Causality2
      -- ^ causality2 placeholder
    deriving (Eq,Show,Enum)
instance SchemaType AdverseEventCausality_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdverseEventCausality_list where
    acceptingParser =  do literal "causality1"; return AdverseEventCausality_list_Causality1
                      `onFail` do literal "causality2"; return AdverseEventCausality_list_Causality2
                      
    simpleTypeText AdverseEventCausality_list_Causality1 = "causality1"
    simpleTypeText AdverseEventCausality_list_Causality2 = "causality2"
 
data AdverseEventCausality = AdverseEventCausality
        { adverseEventCausality_id :: Maybe String_primitive
        , adverseEventCausality_value :: Maybe AdverseEventCausality_list
        , adverseEventCausality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEventCausality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdverseEventCausality a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdverseEventCausality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEventCausality_id x
                       , maybe [] (toXMLAttribute "value") $ adverseEventCausality_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEventCausality_extension x
            ]
instance Extension AdverseEventCausality Element where
    supertype (AdverseEventCausality a0 a1 e0) =
               Element a0 e0
 
data AdverseEventCategory_list
    = AdverseEventCategory_list_AE
      -- ^ Adverse Event
    | AdverseEventCategory_list_PAE
      -- ^ Potential Adverse Event
    deriving (Eq,Show,Enum)
instance SchemaType AdverseEventCategory_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AdverseEventCategory_list where
    acceptingParser =  do literal "AE"; return AdverseEventCategory_list_AE
                      `onFail` do literal "PAE"; return AdverseEventCategory_list_PAE
                      
    simpleTypeText AdverseEventCategory_list_AE = "AE"
    simpleTypeText AdverseEventCategory_list_PAE = "PAE"
 
data AdverseEventCategory = AdverseEventCategory
        { adverseEventCategory_id :: Maybe String_primitive
        , adverseEventCategory_value :: Maybe AdverseEventCategory_list
        , adverseEventCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AdverseEventCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AdverseEventCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AdverseEventCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ adverseEventCategory_id x
                       , maybe [] (toXMLAttribute "value") $ adverseEventCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ adverseEventCategory_extension x
            ]
instance Extension AdverseEventCategory Element where
    supertype (AdverseEventCategory a0 a1 e0) =
               Element a0 e0
 
-- | Risk of harmful or undesirable, physiological response 
--   which is unique to an individual and associated with 
--   exposure to a substance.
elementAllergyIntolerance :: XMLParser AllergyIntolerance
elementAllergyIntolerance = parseSchemaType "AllergyIntolerance"
elementToXMLAllergyIntolerance :: AllergyIntolerance -> [Content ()]
elementToXMLAllergyIntolerance = schemaTypeToXML "AllergyIntolerance"
 
data AllergyIntolerance = AllergyIntolerance
        { allergyIntolerance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , allergyIntolerance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , allergyIntolerance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , allergyIntolerance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , allergyIntolerance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , allergyIntolerance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , allergyIntolerance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , allergyIntolerance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , allergyIntolerance_identifier :: [Identifier]
          -- ^ This records identifiers associated with this 
          --   allergy/intolerance concern that are defined by business 
          --   processes and/or used to refer to it when a direct URL 
          --   reference to the resource itself is not appropriate (e.g. 
          --   in CDA documents, or in written / printed documentation).
        , allergyIntolerance_clinicalStatus :: Maybe AllergyIntoleranceClinicalStatus
          -- ^ The clinical status of the allergy or intolerance.
        , allergyIntolerance_verificationStatus :: AllergyIntoleranceVerificationStatus
          -- ^ Assertion about certainty associated with the propensity, 
          --   or potential risk, of a reaction to the identified 
          --   substance (including pharmaceutical product).
        , allergyIntolerance_type :: Maybe AllergyIntoleranceType
          -- ^ Identification of the underlying physiological mechanism 
          --   for the reaction risk.
        , allergyIntolerance_category :: [AllergyIntoleranceCategory]
          -- ^ Category of the identified substance.
        , allergyIntolerance_criticality :: Maybe AllergyIntoleranceCriticality
          -- ^ Estimate of the potential clinical harm, or seriousness, of 
          --   the reaction to the identified substance.
        , allergyIntolerance_code :: Maybe CodeableConcept
          -- ^ Code for an allergy or intolerance statement (either a 
          --   positive or a negated/excluded statement). This may be a 
          --   code for a substance or pharmaceutical product that is 
          --   considered to be responsible for the adverse reaction risk 
          --   (e.g., &quot;Latex&quot;), an allergy or intolerance 
          --   condition (e.g., &quot;Latex allergy&quot;), or a 
          --   negated/excluded code for a specific substance or class 
          --   (e.g., &quot;No latex allergy&quot;) or a general or 
          --   categorical negated statement (e.g., &quot;No known 
          --   allergy&quot;, &quot;No known drug allergies&quot;).
        , allergyIntolerance_patient :: Reference
          -- ^ The patient who has the allergy or intolerance.
        , allergyIntolerance_choice16 :: (Maybe (OneOf5 DateTime Age Period Range Xsd.XsdString))
          -- ^ Estimated or actual date, date-time, or age when allergy or 
          --   intolerance was identified.
          --   
          --   Choice between:
          --   
          --   (1) onsetDateTime
          --   
          --   (2) onsetAge
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetRange
          --   
          --   (5) onsetString
        , allergyIntolerance_assertedDate :: Maybe DateTime
          -- ^ The date on which the existance of the AllergyIntolerance 
          --   was first asserted or acknowledged.
        , allergyIntolerance_recorder :: Maybe Reference
          -- ^ Individual who recorded the record and takes responsibility 
          --   for its content.
        , allergyIntolerance_asserter :: Maybe Reference
          -- ^ The source of the information about the allergy that is 
          --   recorded.
        , allergyIntolerance_lastOccurrence :: Maybe DateTime
          -- ^ Represents the date and/or time of the last known 
          --   occurrence of a reaction event.
        , allergyIntolerance_note :: [Annotation]
          -- ^ Additional narrative about the propensity for the Adverse 
          --   Reaction, not captured in other fields.
        , allergyIntolerance_reaction :: [AllergyIntoleranceReaction]
          -- ^ Details about each adverse reaction event linked to 
          --   exposure to the identified substance.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntolerance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AllergyIntolerance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "clinicalStatus")
            `apply` parseSchemaType "verificationStatus"
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "criticality")
            `apply` optional (parseSchemaType "code")
            `apply` parseSchemaType "patient"
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "onsetDateTime"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "onsetAge"))
                                     , ("Period", fmap ThreeOf5 (parseSchemaType "onsetPeriod"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "onsetRange"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "onsetString"))
                                     ])
            `apply` optional (parseSchemaType "assertedDate")
            `apply` optional (parseSchemaType "recorder")
            `apply` optional (parseSchemaType "asserter")
            `apply` optional (parseSchemaType "lastOccurrence")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "reaction")
    schemaTypeToXML s x@AllergyIntolerance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ allergyIntolerance_id x
            , maybe [] (schemaTypeToXML "meta") $ allergyIntolerance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ allergyIntolerance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ allergyIntolerance_language x
            , maybe [] (schemaTypeToXML "text") $ allergyIntolerance_text x
            , concatMap (schemaTypeToXML "contained") $ allergyIntolerance_contained x
            , concatMap (schemaTypeToXML "extension") $ allergyIntolerance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ allergyIntolerance_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ allergyIntolerance_identifier x
            , maybe [] (schemaTypeToXML "clinicalStatus") $ allergyIntolerance_clinicalStatus x
            , schemaTypeToXML "verificationStatus" $ allergyIntolerance_verificationStatus x
            , maybe [] (schemaTypeToXML "type") $ allergyIntolerance_type x
            , concatMap (schemaTypeToXML "category") $ allergyIntolerance_category x
            , maybe [] (schemaTypeToXML "criticality") $ allergyIntolerance_criticality x
            , maybe [] (schemaTypeToXML "code") $ allergyIntolerance_code x
            , schemaTypeToXML "patient" $ allergyIntolerance_patient x
            , maybe [] (foldOneOf5  (schemaTypeToXML "onsetDateTime")
                                    (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetString")
                                   ) $ allergyIntolerance_choice16 x
            , maybe [] (schemaTypeToXML "assertedDate") $ allergyIntolerance_assertedDate x
            , maybe [] (schemaTypeToXML "recorder") $ allergyIntolerance_recorder x
            , maybe [] (schemaTypeToXML "asserter") $ allergyIntolerance_asserter x
            , maybe [] (schemaTypeToXML "lastOccurrence") $ allergyIntolerance_lastOccurrence x
            , concatMap (schemaTypeToXML "note") $ allergyIntolerance_note x
            , concatMap (schemaTypeToXML "reaction") $ allergyIntolerance_reaction x
            ]
instance Extension AllergyIntolerance DomainResource where
    supertype (AllergyIntolerance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AllergyIntolerance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AllergyIntolerance -> DomainResource)
              
 
-- | Risk of harmful or undesirable, physiological response 
--   which is unique to an individual and associated with 
--   exposure to a substance.
data AllergyIntoleranceReaction = AllergyIntoleranceReaction
        { allergyIntoleranceReaction_id :: Maybe String_primitive
        , allergyIntoleranceReaction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , allergyIntoleranceReaction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , allergyIntoleranceReaction_substance :: Maybe CodeableConcept
          -- ^ Identification of the specific substance (or pharmaceutical 
          --   product) considered to be responsible for the Adverse 
          --   Reaction event. Note: the substance for a specific reaction 
          --   may be different from the substance identified as the cause 
          --   of the risk, but it must be consistent with it. For 
          --   instance, it may be a more specific substance (e.g. a brand 
          --   medication) or a composite product that includes the 
          --   identified substance. It must be clinically safe to only 
          --   process the 'code' and ignore the 'reaction.substance'.
        , allergyIntoleranceReaction_manifestation :: [CodeableConcept]
          -- ^ Clinical symptoms and/or signs that are observed or 
          --   associated with the adverse reaction event.
        , allergyIntoleranceReaction_description :: Maybe Xsd.XsdString
          -- ^ Text description about the reaction as a whole, including 
          --   details of the manifestation if required.
        , allergyIntoleranceReaction_onset :: Maybe DateTime
          -- ^ Record of the date and/or time of the onset of the 
          --   Reaction.
        , allergyIntoleranceReaction_severity :: Maybe AllergyIntoleranceSeverity
          -- ^ Clinical assessment of the severity of the reaction event 
          --   as a whole, potentially considering multiple different 
          --   manifestations.
        , allergyIntoleranceReaction_exposureRoute :: Maybe CodeableConcept
          -- ^ Identification of the route by which the subject was 
          --   exposed to the substance.
        , allergyIntoleranceReaction_note :: [Annotation]
          -- ^ Additional text about the adverse reaction event not 
          --   captured in other fields.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceReaction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AllergyIntoleranceReaction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "substance")
            `apply` many1 (parseSchemaType "manifestation")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "onset")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "exposureRoute")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@AllergyIntoleranceReaction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceReaction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceReaction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ allergyIntoleranceReaction_modifierExtension x
            , maybe [] (schemaTypeToXML "substance") $ allergyIntoleranceReaction_substance x
            , concatMap (schemaTypeToXML "manifestation") $ allergyIntoleranceReaction_manifestation x
            , maybe [] (schemaTypeToXML "description") $ allergyIntoleranceReaction_description x
            , maybe [] (schemaTypeToXML "onset") $ allergyIntoleranceReaction_onset x
            , maybe [] (schemaTypeToXML "severity") $ allergyIntoleranceReaction_severity x
            , maybe [] (schemaTypeToXML "exposureRoute") $ allergyIntoleranceReaction_exposureRoute x
            , concatMap (schemaTypeToXML "note") $ allergyIntoleranceReaction_note x
            ]
instance Extension AllergyIntoleranceReaction BackboneElement where
    supertype (AllergyIntoleranceReaction a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension AllergyIntoleranceReaction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AllergyIntoleranceReaction -> BackboneElement)
              
 
data AllergyIntoleranceCriticality_list
    = AllergyIntoleranceCriticality_list_Low
      -- ^ Low Risk
    | AllergyIntoleranceCriticality_list_High
      -- ^ High Risk
    | AllergyIntoleranceCriticality_list_Unable_to_assess
      -- ^ Unable to Assess Risk
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceCriticality_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceCriticality_list where
    acceptingParser =  do literal "low"; return AllergyIntoleranceCriticality_list_Low
                      `onFail` do literal "high"; return AllergyIntoleranceCriticality_list_High
                      `onFail` do literal "unable-to-assess"; return AllergyIntoleranceCriticality_list_Unable_to_assess
                      
    simpleTypeText AllergyIntoleranceCriticality_list_Low = "low"
    simpleTypeText AllergyIntoleranceCriticality_list_High = "high"
    simpleTypeText AllergyIntoleranceCriticality_list_Unable_to_assess = "unable-to-assess"
 
data AllergyIntoleranceCriticality = AllergyIntoleranceCriticality
        { allergyIntoleranceCriticality_id :: Maybe String_primitive
        , allergyIntoleranceCriticality_value :: Maybe AllergyIntoleranceCriticality_list
        , allergyIntoleranceCriticality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceCriticality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceCriticality a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceCriticality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceCriticality_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceCriticality_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceCriticality_extension x
            ]
instance Extension AllergyIntoleranceCriticality Element where
    supertype (AllergyIntoleranceCriticality a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceType_list
    = AllergyIntoleranceType_list_Allergy
      -- ^ Allergy
    | AllergyIntoleranceType_list_Intolerance
      -- ^ Intolerance
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceType_list where
    acceptingParser =  do literal "allergy"; return AllergyIntoleranceType_list_Allergy
                      `onFail` do literal "intolerance"; return AllergyIntoleranceType_list_Intolerance
                      
    simpleTypeText AllergyIntoleranceType_list_Allergy = "allergy"
    simpleTypeText AllergyIntoleranceType_list_Intolerance = "intolerance"
 
data AllergyIntoleranceType = AllergyIntoleranceType
        { allergyIntoleranceType_id :: Maybe String_primitive
        , allergyIntoleranceType_value :: Maybe AllergyIntoleranceType_list
        , allergyIntoleranceType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceType_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceType_extension x
            ]
instance Extension AllergyIntoleranceType Element where
    supertype (AllergyIntoleranceType a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceCategory_list
    = AllergyIntoleranceCategory_list_Food
      -- ^ Food
    | AllergyIntoleranceCategory_list_Medication
      -- ^ Medication
    | AllergyIntoleranceCategory_list_Environment
      -- ^ Environment
    | AllergyIntoleranceCategory_list_Biologic
      -- ^ Biologic
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceCategory_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceCategory_list where
    acceptingParser =  do literal "food"; return AllergyIntoleranceCategory_list_Food
                      `onFail` do literal "medication"; return AllergyIntoleranceCategory_list_Medication
                      `onFail` do literal "environment"; return AllergyIntoleranceCategory_list_Environment
                      `onFail` do literal "biologic"; return AllergyIntoleranceCategory_list_Biologic
                      
    simpleTypeText AllergyIntoleranceCategory_list_Food = "food"
    simpleTypeText AllergyIntoleranceCategory_list_Medication = "medication"
    simpleTypeText AllergyIntoleranceCategory_list_Environment = "environment"
    simpleTypeText AllergyIntoleranceCategory_list_Biologic = "biologic"
 
data AllergyIntoleranceCategory = AllergyIntoleranceCategory
        { allergyIntoleranceCategory_id :: Maybe String_primitive
        , allergyIntoleranceCategory_value :: Maybe AllergyIntoleranceCategory_list
        , allergyIntoleranceCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceCategory_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceCategory_extension x
            ]
instance Extension AllergyIntoleranceCategory Element where
    supertype (AllergyIntoleranceCategory a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceVerificationStatus_list
    = AllergyIntoleranceVerificationStatus_list_Unconfirmed
      -- ^ Unconfirmed
    | AllergyIntoleranceVerificationStatus_list_Confirmed
      -- ^ Confirmed
    | AllergyIntoleranceVerificationStatus_list_Refuted
      -- ^ Refuted
    | AllergyIntoleranceVerificationStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceVerificationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceVerificationStatus_list where
    acceptingParser =  do literal "unconfirmed"; return AllergyIntoleranceVerificationStatus_list_Unconfirmed
                      `onFail` do literal "confirmed"; return AllergyIntoleranceVerificationStatus_list_Confirmed
                      `onFail` do literal "refuted"; return AllergyIntoleranceVerificationStatus_list_Refuted
                      `onFail` do literal "entered-in-error"; return AllergyIntoleranceVerificationStatus_list_Entered_in_error
                      
    simpleTypeText AllergyIntoleranceVerificationStatus_list_Unconfirmed = "unconfirmed"
    simpleTypeText AllergyIntoleranceVerificationStatus_list_Confirmed = "confirmed"
    simpleTypeText AllergyIntoleranceVerificationStatus_list_Refuted = "refuted"
    simpleTypeText AllergyIntoleranceVerificationStatus_list_Entered_in_error = "entered-in-error"
 
data AllergyIntoleranceVerificationStatus = AllergyIntoleranceVerificationStatus
        { allergyIntoleranceVerificationStatus_id :: Maybe String_primitive
        , allergyIntoleranceVerificationStatus_value :: Maybe AllergyIntoleranceVerificationStatus_list
        , allergyIntoleranceVerificationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceVerificationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceVerificationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceVerificationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceVerificationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceVerificationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceVerificationStatus_extension x
            ]
instance Extension AllergyIntoleranceVerificationStatus Element where
    supertype (AllergyIntoleranceVerificationStatus a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceSeverity_list
    = AllergyIntoleranceSeverity_list_Mild
      -- ^ Mild
    | AllergyIntoleranceSeverity_list_Moderate
      -- ^ Moderate
    | AllergyIntoleranceSeverity_list_Severe
      -- ^ Severe
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceSeverity_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceSeverity_list where
    acceptingParser =  do literal "mild"; return AllergyIntoleranceSeverity_list_Mild
                      `onFail` do literal "moderate"; return AllergyIntoleranceSeverity_list_Moderate
                      `onFail` do literal "severe"; return AllergyIntoleranceSeverity_list_Severe
                      
    simpleTypeText AllergyIntoleranceSeverity_list_Mild = "mild"
    simpleTypeText AllergyIntoleranceSeverity_list_Moderate = "moderate"
    simpleTypeText AllergyIntoleranceSeverity_list_Severe = "severe"
 
data AllergyIntoleranceSeverity = AllergyIntoleranceSeverity
        { allergyIntoleranceSeverity_id :: Maybe String_primitive
        , allergyIntoleranceSeverity_value :: Maybe AllergyIntoleranceSeverity_list
        , allergyIntoleranceSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceSeverity_extension x
            ]
instance Extension AllergyIntoleranceSeverity Element where
    supertype (AllergyIntoleranceSeverity a0 a1 e0) =
               Element a0 e0
 
data AllergyIntoleranceClinicalStatus_list
    = AllergyIntoleranceClinicalStatus_list_Active
      -- ^ Active
    | AllergyIntoleranceClinicalStatus_list_Inactive
      -- ^ Inactive
    | AllergyIntoleranceClinicalStatus_list_Resolved
      -- ^ Resolved
    deriving (Eq,Show,Enum)
instance SchemaType AllergyIntoleranceClinicalStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AllergyIntoleranceClinicalStatus_list where
    acceptingParser =  do literal "active"; return AllergyIntoleranceClinicalStatus_list_Active
                      `onFail` do literal "inactive"; return AllergyIntoleranceClinicalStatus_list_Inactive
                      `onFail` do literal "resolved"; return AllergyIntoleranceClinicalStatus_list_Resolved
                      
    simpleTypeText AllergyIntoleranceClinicalStatus_list_Active = "active"
    simpleTypeText AllergyIntoleranceClinicalStatus_list_Inactive = "inactive"
    simpleTypeText AllergyIntoleranceClinicalStatus_list_Resolved = "resolved"
 
data AllergyIntoleranceClinicalStatus = AllergyIntoleranceClinicalStatus
        { allergyIntoleranceClinicalStatus_id :: Maybe String_primitive
        , allergyIntoleranceClinicalStatus_value :: Maybe AllergyIntoleranceClinicalStatus_list
        , allergyIntoleranceClinicalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AllergyIntoleranceClinicalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AllergyIntoleranceClinicalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AllergyIntoleranceClinicalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ allergyIntoleranceClinicalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ allergyIntoleranceClinicalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ allergyIntoleranceClinicalStatus_extension x
            ]
instance Extension AllergyIntoleranceClinicalStatus Element where
    supertype (AllergyIntoleranceClinicalStatus a0 a1 e0) =
               Element a0 e0
 
-- | A booking of a healthcare event among patient(s), 
--   practitioner(s), related person(s) and/or device(s) for a 
--   specific date/time. This may result in one or more 
--   Encounter(s).
elementAppointment :: XMLParser Appointment
elementAppointment = parseSchemaType "Appointment"
elementToXMLAppointment :: Appointment -> [Content ()]
elementToXMLAppointment = schemaTypeToXML "Appointment"
 
data Appointment = Appointment
        { appointment_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , appointment_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , appointment_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , appointment_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , appointment_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , appointment_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , appointment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointment_identifier :: [Identifier]
          -- ^ This records identifiers associated with this appointment 
          --   concern that are defined by business processes and/or used 
          --   to refer to it when a direct URL reference to the resource 
          --   itself is not appropriate (e.g. in CDA documents, or in 
          --   written / printed documentation).
        , appointment_status :: AppointmentStatus
          -- ^ The overall status of the Appointment. Each of the 
          --   participants has their own participation status which 
          --   indicates their involvement in the process, however this 
          --   status indicates the shared status.
        , appointment_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , appointment_serviceType :: [CodeableConcept]
          -- ^ The specific service that is to be performed during this 
          --   appointment.
        , appointment_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , appointment_appointmentType :: Maybe CodeableConcept
          -- ^ The style of appointment or patient that has been booked in 
          --   the slot (not service type).
        , appointment_reason :: [CodeableConcept]
          -- ^ The reason that this appointment is being scheduled. This 
          --   is more clinical than administrative.
        , appointment_indication :: [Reference]
          -- ^ Reason the appointment has been scheduled to take place, as 
          --   specified using information from another resource. When the 
          --   patient arrives and the encounter begins it may be used as 
          --   the admission diagnosis. The indication will typically be a 
          --   Condition (with other resources referenced in the 
          --   evidence.detail), or a Procedure.
        , appointment_priority :: Maybe UnsignedInt
          -- ^ The priority of the appointment. Can be used to make 
          --   informed decisions if needing to re-prioritize 
          --   appointments. (The iCal Standard specifies 0 as undefined, 
          --   1 as highest, 9 as lowest priority).
        , appointment_description :: Maybe Xsd.XsdString
          -- ^ The brief description of the appointment as would be shown 
          --   on a subject line in a meeting request, or appointment 
          --   list. Detailed or expanded information should be put in the 
          --   comment field.
        , appointment_supportingInformation :: [Reference]
          -- ^ Additional information to support the appointment provided 
          --   when making the appointment.
        , appointment_start :: Maybe Instant
          -- ^ Date/Time that the appointment is to take place.
        , appointment_end :: Maybe Instant
          -- ^ Date/Time that the appointment is to conclude.
        , appointment_minutesDuration :: Maybe PositiveInt
          -- ^ Number of minutes that the appointment is to take. This can 
          --   be less than the duration between the start and end times 
          --   (where actual time of appointment is only an estimate or is 
          --   a planned appointment request).
        , appointment_slot :: [Reference]
          -- ^ The slots from the participants' schedules that will be 
          --   filled by the appointment.
        , appointment_created :: Maybe DateTime
          -- ^ The date that this appointment was initially created. This 
          --   could be different to the meta.lastModified value on the 
          --   initial entry, as this could have been before the resource 
          --   was created on the FHIR server, and should remain unchanged 
          --   over the lifespan of the appointment.
        , appointment_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the appointment.
        , appointment_incomingReferral :: [Reference]
          -- ^ The referral request this appointment is allocated to 
          --   assess (incoming referral).
        , appointment_participant :: [AppointmentParticipant]
          -- ^ List of participants involved in the appointment.
        , appointment_requestedPeriod :: [Period]
          -- ^ A set of date ranges (potentially including times) that the 
          --   appointment is preferred to be scheduled within. When using 
          --   these values, the minutes duration should be provided to 
          --   indicate the length of the appointment to fill and populate 
          --   the start/end times for the actual allocated time.
        }
        deriving (Eq,Show)
instance SchemaType Appointment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Appointment
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` optional (parseSchemaType "appointmentType")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "indication")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "minutesDuration")
            `apply` many (parseSchemaType "slot")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "comment")
            `apply` many (parseSchemaType "incomingReferral")
            `apply` many1 (parseSchemaType "participant")
            `apply` many (parseSchemaType "requestedPeriod")
    schemaTypeToXML s x@Appointment{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ appointment_id x
            , maybe [] (schemaTypeToXML "meta") $ appointment_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ appointment_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ appointment_language x
            , maybe [] (schemaTypeToXML "text") $ appointment_text x
            , concatMap (schemaTypeToXML "contained") $ appointment_contained x
            , concatMap (schemaTypeToXML "extension") $ appointment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointment_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ appointment_identifier x
            , schemaTypeToXML "status" $ appointment_status x
            , maybe [] (schemaTypeToXML "serviceCategory") $ appointment_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ appointment_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ appointment_specialty x
            , maybe [] (schemaTypeToXML "appointmentType") $ appointment_appointmentType x
            , concatMap (schemaTypeToXML "reason") $ appointment_reason x
            , concatMap (schemaTypeToXML "indication") $ appointment_indication x
            , maybe [] (schemaTypeToXML "priority") $ appointment_priority x
            , maybe [] (schemaTypeToXML "description") $ appointment_description x
            , concatMap (schemaTypeToXML "supportingInformation") $ appointment_supportingInformation x
            , maybe [] (schemaTypeToXML "start") $ appointment_start x
            , maybe [] (schemaTypeToXML "end") $ appointment_end x
            , maybe [] (schemaTypeToXML "minutesDuration") $ appointment_minutesDuration x
            , concatMap (schemaTypeToXML "slot") $ appointment_slot x
            , maybe [] (schemaTypeToXML "created") $ appointment_created x
            , maybe [] (schemaTypeToXML "comment") $ appointment_comment x
            , concatMap (schemaTypeToXML "incomingReferral") $ appointment_incomingReferral x
            , concatMap (schemaTypeToXML "participant") $ appointment_participant x
            , concatMap (schemaTypeToXML "requestedPeriod") $ appointment_requestedPeriod x
            ]
instance Extension Appointment DomainResource where
    supertype (Appointment e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Appointment Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Appointment -> DomainResource)
              
 
-- | A booking of a healthcare event among patient(s), 
--   practitioner(s), related person(s) and/or device(s) for a 
--   specific date/time. This may result in one or more 
--   Encounter(s).
data AppointmentParticipant = AppointmentParticipant
        { appointmentParticipant_id :: Maybe String_primitive
        , appointmentParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointmentParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointmentParticipant_type :: [CodeableConcept]
          -- ^ Role of participant in the appointment.
        , appointmentParticipant_actor :: Maybe Reference
          -- ^ A Person, Location/HealthcareService or Device that is 
          --   participating in the appointment.
        , appointmentParticipant_required :: Maybe ParticipantRequired
          -- ^ Is this participant required to be present at the meeting. 
          --   This covers a use-case where 2 doctors need to meet to 
          --   discuss the results for a specific patient, and the patient 
          --   is not required to be present.
        , appointmentParticipant_status :: ParticipationStatus
          -- ^ Participation status of the actor.
        }
        deriving (Eq,Show)
instance SchemaType AppointmentParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AppointmentParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "actor")
            `apply` optional (parseSchemaType "required")
            `apply` parseSchemaType "status"
    schemaTypeToXML s x@AppointmentParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ appointmentParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ appointmentParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointmentParticipant_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ appointmentParticipant_type x
            , maybe [] (schemaTypeToXML "actor") $ appointmentParticipant_actor x
            , maybe [] (schemaTypeToXML "required") $ appointmentParticipant_required x
            , schemaTypeToXML "status" $ appointmentParticipant_status x
            ]
instance Extension AppointmentParticipant BackboneElement where
    supertype (AppointmentParticipant a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension AppointmentParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AppointmentParticipant -> BackboneElement)
              
 
data ParticipantRequired_list
    = ParticipantRequired_list_Required
      -- ^ Required
    | ParticipantRequired_list_Optional
      -- ^ Optional
    | ParticipantRequired_list_Information_only
      -- ^ Information Only
    deriving (Eq,Show,Enum)
instance SchemaType ParticipantRequired_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ParticipantRequired_list where
    acceptingParser =  do literal "required"; return ParticipantRequired_list_Required
                      `onFail` do literal "optional"; return ParticipantRequired_list_Optional
                      `onFail` do literal "information-only"; return ParticipantRequired_list_Information_only
                      
    simpleTypeText ParticipantRequired_list_Required = "required"
    simpleTypeText ParticipantRequired_list_Optional = "optional"
    simpleTypeText ParticipantRequired_list_Information_only = "information-only"
 
data ParticipantRequired = ParticipantRequired
        { participantRequired_id :: Maybe String_primitive
        , participantRequired_value :: Maybe ParticipantRequired_list
        , participantRequired_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ParticipantRequired where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ParticipantRequired a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ParticipantRequired{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ participantRequired_id x
                       , maybe [] (toXMLAttribute "value") $ participantRequired_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ participantRequired_extension x
            ]
instance Extension ParticipantRequired Element where
    supertype (ParticipantRequired a0 a1 e0) =
               Element a0 e0
 
data AppointmentStatus_list
    = AppointmentStatus_list_Proposed
      -- ^ Proposed
    | AppointmentStatus_list_Pending
      -- ^ Pending
    | AppointmentStatus_list_Booked
      -- ^ Booked
    | AppointmentStatus_list_Arrived
      -- ^ Arrived
    | AppointmentStatus_list_Fulfilled
      -- ^ Fulfilled
    | AppointmentStatus_list_Cancelled
      -- ^ Cancelled
    | AppointmentStatus_list_Noshow
      -- ^ No Show
    | AppointmentStatus_list_Entered_in_error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType AppointmentStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AppointmentStatus_list where
    acceptingParser =  do literal "proposed"; return AppointmentStatus_list_Proposed
                      `onFail` do literal "pending"; return AppointmentStatus_list_Pending
                      `onFail` do literal "booked"; return AppointmentStatus_list_Booked
                      `onFail` do literal "arrived"; return AppointmentStatus_list_Arrived
                      `onFail` do literal "fulfilled"; return AppointmentStatus_list_Fulfilled
                      `onFail` do literal "cancelled"; return AppointmentStatus_list_Cancelled
                      `onFail` do literal "noshow"; return AppointmentStatus_list_Noshow
                      `onFail` do literal "entered-in-error"; return AppointmentStatus_list_Entered_in_error
                      
    simpleTypeText AppointmentStatus_list_Proposed = "proposed"
    simpleTypeText AppointmentStatus_list_Pending = "pending"
    simpleTypeText AppointmentStatus_list_Booked = "booked"
    simpleTypeText AppointmentStatus_list_Arrived = "arrived"
    simpleTypeText AppointmentStatus_list_Fulfilled = "fulfilled"
    simpleTypeText AppointmentStatus_list_Cancelled = "cancelled"
    simpleTypeText AppointmentStatus_list_Noshow = "noshow"
    simpleTypeText AppointmentStatus_list_Entered_in_error = "entered-in-error"
 
data AppointmentStatus = AppointmentStatus
        { appointmentStatus_id :: Maybe String_primitive
        , appointmentStatus_value :: Maybe AppointmentStatus_list
        , appointmentStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AppointmentStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AppointmentStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AppointmentStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ appointmentStatus_id x
                       , maybe [] (toXMLAttribute "value") $ appointmentStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ appointmentStatus_extension x
            ]
instance Extension AppointmentStatus Element where
    supertype (AppointmentStatus a0 a1 e0) =
               Element a0 e0
 
data ParticipationStatus_list
    = ParticipationStatus_list_Accepted
      -- ^ Accepted
    | ParticipationStatus_list_Declined
      -- ^ Declined
    | ParticipationStatus_list_Tentative
      -- ^ Tentative
    | ParticipationStatus_list_Needs_action
      -- ^ Needs Action
    deriving (Eq,Show,Enum)
instance SchemaType ParticipationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ParticipationStatus_list where
    acceptingParser =  do literal "accepted"; return ParticipationStatus_list_Accepted
                      `onFail` do literal "declined"; return ParticipationStatus_list_Declined
                      `onFail` do literal "tentative"; return ParticipationStatus_list_Tentative
                      `onFail` do literal "needs-action"; return ParticipationStatus_list_Needs_action
                      
    simpleTypeText ParticipationStatus_list_Accepted = "accepted"
    simpleTypeText ParticipationStatus_list_Declined = "declined"
    simpleTypeText ParticipationStatus_list_Tentative = "tentative"
    simpleTypeText ParticipationStatus_list_Needs_action = "needs-action"
 
data ParticipationStatus = ParticipationStatus
        { participationStatus_id :: Maybe String_primitive
        , participationStatus_value :: Maybe ParticipationStatus_list
        , participationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ParticipationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ParticipationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ParticipationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ participationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ participationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ participationStatus_extension x
            ]
instance Extension ParticipationStatus Element where
    supertype (ParticipationStatus a0 a1 e0) =
               Element a0 e0
 
-- | A reply to an appointment request for a patient and/or 
--   practitioner(s), such as a confirmation or rejection.
elementAppointmentResponse :: XMLParser AppointmentResponse
elementAppointmentResponse = parseSchemaType "AppointmentResponse"
elementToXMLAppointmentResponse :: AppointmentResponse -> [Content ()]
elementToXMLAppointmentResponse = schemaTypeToXML "AppointmentResponse"
 
data AppointmentResponse = AppointmentResponse
        { appointmentResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , appointmentResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , appointmentResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , appointmentResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , appointmentResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , appointmentResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , appointmentResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , appointmentResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , appointmentResponse_identifier :: [Identifier]
          -- ^ This records identifiers associated with this appointment 
          --   response concern that are defined by business processes 
          --   and/ or used to refer to it when a direct URL reference to 
          --   the resource itself is not appropriate.
        , appointmentResponse_appointment :: Reference
          -- ^ Appointment that this response is replying to.
        , appointmentResponse_start :: Maybe Instant
          -- ^ Date/Time that the appointment is to take place, or 
          --   requested new start time.
        , appointmentResponse_end :: Maybe Instant
          -- ^ This may be either the same as the appointment request to 
          --   confirm the details of the appointment, or alternately a 
          --   new time to request a re-negotiation of the end time.
        , appointmentResponse_participantType :: [CodeableConcept]
          -- ^ Role of participant in the appointment.
        , appointmentResponse_actor :: Maybe Reference
          -- ^ A Person, Location/HealthcareService or Device that is 
          --   participating in the appointment.
        , appointmentResponse_participantStatus :: ParticipationStatus
          -- ^ Participation status of the participant. When the status is 
          --   declined or tentative if the start/end times are different 
          --   to the appointment, then these times should be interpreted 
          --   as a requested time change. When the status is accepted, 
          --   the times can either be the time of the appointment (as a 
          --   confirmation of the time) or can be empty.
        , appointmentResponse_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the appointment.
        }
        deriving (Eq,Show)
instance SchemaType AppointmentResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AppointmentResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "appointment"
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` many (parseSchemaType "participantType")
            `apply` optional (parseSchemaType "actor")
            `apply` parseSchemaType "participantStatus"
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@AppointmentResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ appointmentResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ appointmentResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ appointmentResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ appointmentResponse_language x
            , maybe [] (schemaTypeToXML "text") $ appointmentResponse_text x
            , concatMap (schemaTypeToXML "contained") $ appointmentResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ appointmentResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ appointmentResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ appointmentResponse_identifier x
            , schemaTypeToXML "appointment" $ appointmentResponse_appointment x
            , maybe [] (schemaTypeToXML "start") $ appointmentResponse_start x
            , maybe [] (schemaTypeToXML "end") $ appointmentResponse_end x
            , concatMap (schemaTypeToXML "participantType") $ appointmentResponse_participantType x
            , maybe [] (schemaTypeToXML "actor") $ appointmentResponse_actor x
            , schemaTypeToXML "participantStatus" $ appointmentResponse_participantStatus x
            , maybe [] (schemaTypeToXML "comment") $ appointmentResponse_comment x
            ]
instance Extension AppointmentResponse DomainResource where
    supertype (AppointmentResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AppointmentResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AppointmentResponse -> DomainResource)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
elementAuditEvent :: XMLParser AuditEvent
elementAuditEvent = parseSchemaType "AuditEvent"
elementToXMLAuditEvent :: AuditEvent -> [Content ()]
elementToXMLAuditEvent = schemaTypeToXML "AuditEvent"
 
data AuditEvent = AuditEvent
        { auditEvent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , auditEvent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , auditEvent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , auditEvent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , auditEvent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , auditEvent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , auditEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEvent_type :: Coding
          -- ^ Identifier for a family of the event. For example, a menu 
          --   item, program, rule, policy, function code, application 
          --   name or URL. It identifies the performed function.
        , auditEvent_subtype :: [Coding]
          -- ^ Identifier for the category of event.
        , auditEvent_action :: Maybe AuditEventAction
          -- ^ Indicator for type of action performed during the event 
          --   that generated the audit.
        , auditEvent_recorded :: Instant
          -- ^ The time when the event occurred on the source.
        , auditEvent_outcome :: Maybe AuditEventOutcome
          -- ^ Indicates whether the event succeeded or failed.
        , auditEvent_outcomeDesc :: Maybe Xsd.XsdString
          -- ^ A free text description of the outcome of the event.
        , auditEvent_purposeOfEvent :: [CodeableConcept]
          -- ^ The purposeOfUse (reason) that was used during the event 
          --   being recorded.
        , auditEvent_agent :: [AuditEventAgent]
          -- ^ An actor taking an active role in the event or activity 
          --   that is logged.
        , auditEvent_source :: AuditEventSource
          -- ^ The system that is reporting the event.
        , auditEvent_entity :: [AuditEventEntity]
          -- ^ Specific instances of data or objects that have been 
          --   accessed.
        }
        deriving (Eq,Show)
instance SchemaType AuditEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return AuditEvent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "subtype")
            `apply` optional (parseSchemaType "action")
            `apply` parseSchemaType "recorded"
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "outcomeDesc")
            `apply` many (parseSchemaType "purposeOfEvent")
            `apply` many1 (parseSchemaType "agent")
            `apply` parseSchemaType "source"
            `apply` many (parseSchemaType "entity")
    schemaTypeToXML s x@AuditEvent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ auditEvent_id x
            , maybe [] (schemaTypeToXML "meta") $ auditEvent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ auditEvent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ auditEvent_language x
            , maybe [] (schemaTypeToXML "text") $ auditEvent_text x
            , concatMap (schemaTypeToXML "contained") $ auditEvent_contained x
            , concatMap (schemaTypeToXML "extension") $ auditEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEvent_modifierExtension x
            , schemaTypeToXML "type" $ auditEvent_type x
            , concatMap (schemaTypeToXML "subtype") $ auditEvent_subtype x
            , maybe [] (schemaTypeToXML "action") $ auditEvent_action x
            , schemaTypeToXML "recorded" $ auditEvent_recorded x
            , maybe [] (schemaTypeToXML "outcome") $ auditEvent_outcome x
            , maybe [] (schemaTypeToXML "outcomeDesc") $ auditEvent_outcomeDesc x
            , concatMap (schemaTypeToXML "purposeOfEvent") $ auditEvent_purposeOfEvent x
            , concatMap (schemaTypeToXML "agent") $ auditEvent_agent x
            , schemaTypeToXML "source" $ auditEvent_source x
            , concatMap (schemaTypeToXML "entity") $ auditEvent_entity x
            ]
instance Extension AuditEvent DomainResource where
    supertype (AuditEvent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension AuditEvent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: AuditEvent -> DomainResource)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEventAgent = AuditEventAgent
        { auditEventAgent_id :: Maybe String_primitive
        , auditEventAgent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEventAgent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEventAgent_role :: [CodeableConcept]
          -- ^ The security role that the user was acting under, that come 
          --   from local codes defined by the access control security 
          --   system (e.g. RBAC, ABAC) used in the local context.
        , auditEventAgent_reference :: Maybe Reference
          -- ^ Direct reference to a resource that identifies the agent.
        , auditEventAgent_userId :: Maybe Identifier
          -- ^ Unique identifier for the user actively participating in 
          --   the event.
        , auditEventAgent_altId :: Maybe Xsd.XsdString
          -- ^ Alternative agent Identifier. For a human, this should be a 
          --   user identifier text string from authentication system. 
          --   This identifier would be one known to a common 
          --   authentication system (e.g. single sign-on), if available.
        , auditEventAgent_name :: Maybe Xsd.XsdString
          -- ^ Human-meaningful name for the agent.
        , auditEventAgent_requestor :: Boolean
          -- ^ Indicator that the user is or is not the requestor, or 
          --   initiator, for the event being audited.
        , auditEventAgent_location :: Maybe Reference
          -- ^ Where the event occurred.
        , auditEventAgent_policy :: [Uri]
          -- ^ The policy or plan that authorized the activity being 
          --   recorded. Typically, a single activity may have multiple 
          --   applicable policies, such as patient consent, guarantor 
          --   funding, etc. The policy would also indicate the security 
          --   token used.
        , auditEventAgent_media :: Maybe Coding
          -- ^ Type of media involved. Used when the event is about 
          --   exporting/importing onto media.
        , auditEventAgent_network :: Maybe AuditEventNetwork
          -- ^ Logical network location for application activity, if the 
          --   activity has a network location.
        , auditEventAgent_purposeOfUse :: [CodeableConcept]
          -- ^ The reason (purpose of use), specific to this agent, that 
          --   was used during the event being recorded.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventAgent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEventAgent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "role")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "userId")
            `apply` optional (parseSchemaType "altId")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "requestor"
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "media")
            `apply` optional (parseSchemaType "network")
            `apply` many (parseSchemaType "purposeOfUse")
    schemaTypeToXML s x@AuditEventAgent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventAgent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventAgent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEventAgent_modifierExtension x
            , concatMap (schemaTypeToXML "role") $ auditEventAgent_role x
            , maybe [] (schemaTypeToXML "reference") $ auditEventAgent_reference x
            , maybe [] (schemaTypeToXML "userId") $ auditEventAgent_userId x
            , maybe [] (schemaTypeToXML "altId") $ auditEventAgent_altId x
            , maybe [] (schemaTypeToXML "name") $ auditEventAgent_name x
            , schemaTypeToXML "requestor" $ auditEventAgent_requestor x
            , maybe [] (schemaTypeToXML "location") $ auditEventAgent_location x
            , concatMap (schemaTypeToXML "policy") $ auditEventAgent_policy x
            , maybe [] (schemaTypeToXML "media") $ auditEventAgent_media x
            , maybe [] (schemaTypeToXML "network") $ auditEventAgent_network x
            , concatMap (schemaTypeToXML "purposeOfUse") $ auditEventAgent_purposeOfUse x
            ]
instance Extension AuditEventAgent BackboneElement where
    supertype (AuditEventAgent a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               BackboneElement a0 e0 e1
instance Extension AuditEventAgent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEventAgent -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEventNetwork = AuditEventNetwork
        { auditEventNetwork_id :: Maybe String_primitive
        , auditEventNetwork_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEventNetwork_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEventNetwork_address :: Maybe Xsd.XsdString
          -- ^ An identifier for the network access point of the user 
          --   device for the audit event.
        , auditEventNetwork_type :: Maybe AuditEventAgentNetworkType
          -- ^ An identifier for the type of network access point that 
          --   originated the audit event.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventNetwork where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEventNetwork a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "type")
    schemaTypeToXML s x@AuditEventNetwork{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventNetwork_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventNetwork_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEventNetwork_modifierExtension x
            , maybe [] (schemaTypeToXML "address") $ auditEventNetwork_address x
            , maybe [] (schemaTypeToXML "type") $ auditEventNetwork_type x
            ]
instance Extension AuditEventNetwork BackboneElement where
    supertype (AuditEventNetwork a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension AuditEventNetwork Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEventNetwork -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEventSource = AuditEventSource
        { auditEventSource_id :: Maybe String_primitive
        , auditEventSource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEventSource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEventSource_site :: Maybe Xsd.XsdString
          -- ^ Logical source location within the healthcare enterprise 
          --   network. For example, a hospital or other provider location 
          --   within a multi-entity provider group.
        , auditEventSource_identifier :: Identifier
          -- ^ Identifier of the source where the event was detected.
        , auditEventSource_type :: [Coding]
          -- ^ Code specifying the type of source where event originated.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventSource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEventSource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "site")
            `apply` parseSchemaType "identifier"
            `apply` many (parseSchemaType "type")
    schemaTypeToXML s x@AuditEventSource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventSource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventSource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEventSource_modifierExtension x
            , maybe [] (schemaTypeToXML "site") $ auditEventSource_site x
            , schemaTypeToXML "identifier" $ auditEventSource_identifier x
            , concatMap (schemaTypeToXML "type") $ auditEventSource_type x
            ]
instance Extension AuditEventSource BackboneElement where
    supertype (AuditEventSource a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension AuditEventSource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEventSource -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEventEntity = AuditEventEntity
        { auditEventEntity_id :: Maybe String_primitive
        , auditEventEntity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEventEntity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEventEntity_identifier :: Maybe Identifier
          -- ^ Identifies a specific instance of the entity. The reference 
          --   should always be version specific.
        , auditEventEntity_reference :: Maybe Reference
          -- ^ Identifies a specific instance of the entity. The reference 
          --   should be version specific.
        , auditEventEntity_type :: Maybe Coding
          -- ^ The type of the object that was involved in this audit 
          --   event.
        , auditEventEntity_role :: Maybe Coding
          -- ^ Code representing the role the entity played in the event 
          --   being audited.
        , auditEventEntity_lifecycle :: Maybe Coding
          -- ^ Identifier for the data life-cycle stage for the entity.
        , auditEventEntity_securityLabel :: [Coding]
          -- ^ Security labels for the identified entity.
        , auditEventEntity_name :: Maybe Xsd.XsdString
          -- ^ A name of the entity in the audit event.
        , auditEventEntity_description :: Maybe Xsd.XsdString
          -- ^ Text that describes the entity in more detail.
        , auditEventEntity_query :: Maybe Base64Binary
          -- ^ The query parameters for a query-type entities.
        , auditEventEntity_detail :: [AuditEventDetail]
          -- ^ Tagged value pairs for conveying additional information 
          --   about the entity.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventEntity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEventEntity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "lifecycle")
            `apply` many (parseSchemaType "securityLabel")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "query")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@AuditEventEntity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventEntity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventEntity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEventEntity_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ auditEventEntity_identifier x
            , maybe [] (schemaTypeToXML "reference") $ auditEventEntity_reference x
            , maybe [] (schemaTypeToXML "type") $ auditEventEntity_type x
            , maybe [] (schemaTypeToXML "role") $ auditEventEntity_role x
            , maybe [] (schemaTypeToXML "lifecycle") $ auditEventEntity_lifecycle x
            , concatMap (schemaTypeToXML "securityLabel") $ auditEventEntity_securityLabel x
            , maybe [] (schemaTypeToXML "name") $ auditEventEntity_name x
            , maybe [] (schemaTypeToXML "description") $ auditEventEntity_description x
            , maybe [] (schemaTypeToXML "query") $ auditEventEntity_query x
            , concatMap (schemaTypeToXML "detail") $ auditEventEntity_detail x
            ]
instance Extension AuditEventEntity BackboneElement where
    supertype (AuditEventEntity a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension AuditEventEntity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEventEntity -> BackboneElement)
              
 
-- | A record of an event made for purposes of maintaining a 
--   security log. Typical uses include detection of intrusion 
--   attempts and monitoring for inappropriate usage.
data AuditEventDetail = AuditEventDetail
        { auditEventDetail_id :: Maybe String_primitive
        , auditEventDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , auditEventDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , auditEventDetail_type :: Xsd.XsdString
          -- ^ The type of extra detail provided in the value.
        , auditEventDetail_value :: Base64Binary
          -- ^ The details, base64 encoded. Used to carry bulk 
          --   information.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (AuditEventDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@AuditEventDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ auditEventDetail_modifierExtension x
            , schemaTypeToXML "type" $ auditEventDetail_type x
            , schemaTypeToXML "value" $ auditEventDetail_value x
            ]
instance Extension AuditEventDetail BackboneElement where
    supertype (AuditEventDetail a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension AuditEventDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: AuditEventDetail -> BackboneElement)
              
 
data AuditEventOutcome_list
    = AuditEventOutcome_list_V0
      -- ^ Success
    | AuditEventOutcome_list_V4
      -- ^ Minor failure
    | AuditEventOutcome_list_V8
      -- ^ Serious failure
    | AuditEventOutcome_list_V12
      -- ^ Major failure
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventOutcome_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventOutcome_list where
    acceptingParser =  do literal "0"; return AuditEventOutcome_list_V0
                      `onFail` do literal "4"; return AuditEventOutcome_list_V4
                      `onFail` do literal "8"; return AuditEventOutcome_list_V8
                      `onFail` do literal "12"; return AuditEventOutcome_list_V12
                      
    simpleTypeText AuditEventOutcome_list_V0 = "0"
    simpleTypeText AuditEventOutcome_list_V4 = "4"
    simpleTypeText AuditEventOutcome_list_V8 = "8"
    simpleTypeText AuditEventOutcome_list_V12 = "12"
 
data AuditEventOutcome = AuditEventOutcome
        { auditEventOutcome_id :: Maybe String_primitive
        , auditEventOutcome_value :: Maybe AuditEventOutcome_list
        , auditEventOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventOutcome a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventOutcome{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventOutcome_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventOutcome_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventOutcome_extension x
            ]
instance Extension AuditEventOutcome Element where
    supertype (AuditEventOutcome a0 a1 e0) =
               Element a0 e0
 
data AuditEventAction_list
    = AuditEventAction_list_C
      -- ^ Create
    | AuditEventAction_list_R
      -- ^ Read/View/Print
    | AuditEventAction_list_U
      -- ^ Update
    | AuditEventAction_list_D
      -- ^ Delete
    | AuditEventAction_list_E
      -- ^ Execute
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventAction_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventAction_list where
    acceptingParser =  do literal "C"; return AuditEventAction_list_C
                      `onFail` do literal "R"; return AuditEventAction_list_R
                      `onFail` do literal "U"; return AuditEventAction_list_U
                      `onFail` do literal "D"; return AuditEventAction_list_D
                      `onFail` do literal "E"; return AuditEventAction_list_E
                      
    simpleTypeText AuditEventAction_list_C = "C"
    simpleTypeText AuditEventAction_list_R = "R"
    simpleTypeText AuditEventAction_list_U = "U"
    simpleTypeText AuditEventAction_list_D = "D"
    simpleTypeText AuditEventAction_list_E = "E"
 
data AuditEventAction = AuditEventAction
        { auditEventAction_id :: Maybe String_primitive
        , auditEventAction_value :: Maybe AuditEventAction_list
        , auditEventAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventAction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventAction_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventAction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventAction_extension x
            ]
instance Extension AuditEventAction Element where
    supertype (AuditEventAction a0 a1 e0) =
               Element a0 e0
 
data AuditEventAgentNetworkType_list
    = AuditEventAgentNetworkType_list_V1
      -- ^ Machine Name
    | AuditEventAgentNetworkType_list_V2
      -- ^ IP Address
    | AuditEventAgentNetworkType_list_V3
      -- ^ Telephone Number
    | AuditEventAgentNetworkType_list_V4
      -- ^ Email address
    | AuditEventAgentNetworkType_list_V5
      -- ^ URI
    deriving (Eq,Show,Enum)
instance SchemaType AuditEventAgentNetworkType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AuditEventAgentNetworkType_list where
    acceptingParser =  do literal "1"; return AuditEventAgentNetworkType_list_V1
                      `onFail` do literal "2"; return AuditEventAgentNetworkType_list_V2
                      `onFail` do literal "3"; return AuditEventAgentNetworkType_list_V3
                      `onFail` do literal "4"; return AuditEventAgentNetworkType_list_V4
                      `onFail` do literal "5"; return AuditEventAgentNetworkType_list_V5
                      
    simpleTypeText AuditEventAgentNetworkType_list_V1 = "1"
    simpleTypeText AuditEventAgentNetworkType_list_V2 = "2"
    simpleTypeText AuditEventAgentNetworkType_list_V3 = "3"
    simpleTypeText AuditEventAgentNetworkType_list_V4 = "4"
    simpleTypeText AuditEventAgentNetworkType_list_V5 = "5"
 
data AuditEventAgentNetworkType = AuditEventAgentNetworkType
        { auditEventAgentNetworkType_id :: Maybe String_primitive
        , auditEventAgentNetworkType_value :: Maybe AuditEventAgentNetworkType_list
        , auditEventAgentNetworkType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AuditEventAgentNetworkType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AuditEventAgentNetworkType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AuditEventAgentNetworkType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ auditEventAgentNetworkType_id x
                       , maybe [] (toXMLAttribute "value") $ auditEventAgentNetworkType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ auditEventAgentNetworkType_extension x
            ]
instance Extension AuditEventAgentNetworkType Element where
    supertype (AuditEventAgentNetworkType a0 a1 e0) =
               Element a0 e0
 
-- | Basic is used for handling concepts not yet defined in 
--   FHIR, narrative-only resources that don't map to an 
--   existing resource, and custom resources not appropriate for 
--   inclusion in the FHIR specification.
elementBasic :: XMLParser Basic
elementBasic = parseSchemaType "Basic"
elementToXMLBasic :: Basic -> [Content ()]
elementToXMLBasic = schemaTypeToXML "Basic"
 
data Basic = Basic
        { basic_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , basic_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , basic_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , basic_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , basic_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , basic_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , basic_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , basic_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , basic_identifier :: [Identifier]
          -- ^ Identifier assigned to the resource for business purposes, 
          --   outside the context of FHIR.
        , basic_code :: CodeableConcept
          -- ^ Identifies the 'type' of resource - equivalent to the 
          --   resource name for other resources.
        , basic_subject :: Maybe Reference
          -- ^ Identifies the patient, practitioner, device or any other 
          --   resource that is the &quot;focus&quot; of this resource.
        , basic_created :: Maybe Date
          -- ^ Identifies when the resource was first created.
        , basic_author :: Maybe Reference
          -- ^ Indicates who was responsible for creating the resource 
          --   instance.
        }
        deriving (Eq,Show)
instance SchemaType Basic where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Basic
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@Basic{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ basic_id x
            , maybe [] (schemaTypeToXML "meta") $ basic_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ basic_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ basic_language x
            , maybe [] (schemaTypeToXML "text") $ basic_text x
            , concatMap (schemaTypeToXML "contained") $ basic_contained x
            , concatMap (schemaTypeToXML "extension") $ basic_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ basic_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ basic_identifier x
            , schemaTypeToXML "code" $ basic_code x
            , maybe [] (schemaTypeToXML "subject") $ basic_subject x
            , maybe [] (schemaTypeToXML "created") $ basic_created x
            , maybe [] (schemaTypeToXML "author") $ basic_author x
            ]
instance Extension Basic DomainResource where
    supertype (Basic e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Basic Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Basic -> DomainResource)
              
 
-- | A binary resource can contain any content, whether text, 
--   image, pdf, zip archive, etc.
elementBinary :: XMLParser Binary
elementBinary = parseSchemaType "Binary"
elementToXMLBinary :: Binary -> [Content ()]
elementToXMLBinary = schemaTypeToXML "Binary"
 
data Binary = Binary
        { binary_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , binary_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , binary_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , binary_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , binary_contentType :: Code
          -- ^ MimeType of the binary content represented as a standard 
          --   MimeType (BCP 13).
        , binary_securityContext :: Maybe Reference
          -- ^ Treat this binary as if it was this other resource for 
          --   access control purposes.
        , binary_content :: Base64Binary
          -- ^ The actual content, base64 encoded.
        }
        deriving (Eq,Show)
instance SchemaType Binary where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Binary
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` parseSchemaType "contentType"
            `apply` optional (parseSchemaType "securityContext")
            `apply` parseSchemaType "content"
    schemaTypeToXML s x@Binary{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ binary_id x
            , maybe [] (schemaTypeToXML "meta") $ binary_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ binary_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ binary_language x
            , schemaTypeToXML "contentType" $ binary_contentType x
            , maybe [] (schemaTypeToXML "securityContext") $ binary_securityContext x
            , schemaTypeToXML "content" $ binary_content x
            ]
instance Extension Binary Resource where
    supertype (Binary e0 e1 e2 e3 e4 e5 e6) =
               Resource e0 e1 e2 e3
 
-- | Record details about the anatomical location of a specimen 
--   or body part. This resource may be used when a coded 
--   concept does not provide the necessary detail needed for 
--   the use case.
elementBodySite :: XMLParser BodySite
elementBodySite = parseSchemaType "BodySite"
elementToXMLBodySite :: BodySite -> [Content ()]
elementToXMLBodySite = schemaTypeToXML "BodySite"
 
data BodySite = BodySite
        { bodySite_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , bodySite_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , bodySite_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , bodySite_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , bodySite_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , bodySite_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , bodySite_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bodySite_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bodySite_identifier :: [Identifier]
          -- ^ Identifier for this instance of the anatomical location.
        , bodySite_active :: Maybe Boolean
          -- ^ Whether this body site is in active use.
        , bodySite_code :: Maybe CodeableConcept
          -- ^ Named anatomical location - ideally coded where possible.
        , bodySite_qualifier :: [CodeableConcept]
          -- ^ Qualifier to refine the anatomical location. These include 
          --   qualifiers for laterality, relative location, 
          --   directionality, number, and plane.
        , bodySite_description :: Maybe Xsd.XsdString
          -- ^ A summary, charactarization or explanation of the anatomic 
          --   location.
        , bodySite_image :: [Attachment]
          -- ^ Image or images used to identify a location.
        , bodySite_patient :: Reference
          -- ^ The person to which the body site belongs.
        }
        deriving (Eq,Show)
instance SchemaType BodySite where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return BodySite
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "qualifier")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "image")
            `apply` parseSchemaType "patient"
    schemaTypeToXML s x@BodySite{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ bodySite_id x
            , maybe [] (schemaTypeToXML "meta") $ bodySite_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ bodySite_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ bodySite_language x
            , maybe [] (schemaTypeToXML "text") $ bodySite_text x
            , concatMap (schemaTypeToXML "contained") $ bodySite_contained x
            , concatMap (schemaTypeToXML "extension") $ bodySite_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bodySite_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ bodySite_identifier x
            , maybe [] (schemaTypeToXML "active") $ bodySite_active x
            , maybe [] (schemaTypeToXML "code") $ bodySite_code x
            , concatMap (schemaTypeToXML "qualifier") $ bodySite_qualifier x
            , maybe [] (schemaTypeToXML "description") $ bodySite_description x
            , concatMap (schemaTypeToXML "image") $ bodySite_image x
            , schemaTypeToXML "patient" $ bodySite_patient x
            ]
instance Extension BodySite DomainResource where
    supertype (BodySite e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension BodySite Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: BodySite -> DomainResource)
              
 
-- | A container for a collection of resources.
elementBundle :: XMLParser Bundle
elementBundle = parseSchemaType "Bundle"
elementToXMLBundle :: Bundle -> [Content ()]
elementToXMLBundle = schemaTypeToXML "Bundle"
 
data Bundle = Bundle
        { bundle_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , bundle_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , bundle_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , bundle_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , bundle_identifier :: Maybe Identifier
          -- ^ A persistent identifier for the batch that won't change as 
          --   a batch is copied from server to server.
        , bundle_type :: BundleType
          -- ^ Indicates the purpose of this bundle - how it was intended 
          --   to be used.
        , bundle_total :: Maybe UnsignedInt
          -- ^ If a set of search matches, this is the total number of 
          --   matches for the search (as opposed to the number of results 
          --   in this bundle).
        , bundle_link :: [BundleLink]
          -- ^ A series of links that provide context to this bundle.
        , bundle_entry :: [BundleEntry]
          -- ^ An entry in a bundle resource - will either contain a 
          --   resource, or information about a resource (transactions and 
          --   history only).
        , bundle_signature :: Maybe Signature
          -- ^ Digital Signature - base64 encoded. XML-DSIg or a JWT.
        }
        deriving (Eq,Show)
instance SchemaType Bundle where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Bundle
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "total")
            `apply` many (parseSchemaType "link")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "signature")
    schemaTypeToXML s x@Bundle{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ bundle_id x
            , maybe [] (schemaTypeToXML "meta") $ bundle_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ bundle_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ bundle_language x
            , maybe [] (schemaTypeToXML "identifier") $ bundle_identifier x
            , schemaTypeToXML "type" $ bundle_type x
            , maybe [] (schemaTypeToXML "total") $ bundle_total x
            , concatMap (schemaTypeToXML "link") $ bundle_link x
            , concatMap (schemaTypeToXML "entry") $ bundle_entry x
            , maybe [] (schemaTypeToXML "signature") $ bundle_signature x
            ]
instance Extension Bundle Resource where
    supertype (Bundle e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               Resource e0 e1 e2 e3
 
-- | A container for a collection of resources.
data BundleLink = BundleLink
        { bundleLink_id :: Maybe String_primitive
        , bundleLink_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundleLink_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundleLink_relation :: Xsd.XsdString
          -- ^ A name which details the functional use for this link - see 
          --   [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
        , bundleLink_url :: Uri
          -- ^ The reference details for the link.
        }
        deriving (Eq,Show)
instance SchemaType BundleLink where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BundleLink a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "relation"
            `apply` parseSchemaType "url"
    schemaTypeToXML s x@BundleLink{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleLink_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleLink_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundleLink_modifierExtension x
            , schemaTypeToXML "relation" $ bundleLink_relation x
            , schemaTypeToXML "url" $ bundleLink_url x
            ]
instance Extension BundleLink BackboneElement where
    supertype (BundleLink a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension BundleLink Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: BundleLink -> BackboneElement)
              
 
-- | A container for a collection of resources.
data BundleEntry = BundleEntry
        { bundleEntry_id :: Maybe String_primitive
        , bundleEntry_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundleEntry_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundleEntry_link :: [BundleLink]
          -- ^ A series of links that provide context to this entry.
        , bundleEntry_fullUrl :: Maybe Uri
          -- ^ The Absolute URL for the resource. The fullUrl SHALL not 
          --   disagree with the id in the resource. The fullUrl is a 
          --   version independent reference to the resource. The fullUrl 
          --   element SHALL have a value except that: * fullUrl can be 
          --   empty on a POST (although it does not need to when 
          --   specifying a temporary id for reference in the bundle) * 
          --   Results from operations might involve resources that are 
          --   not identified.
        , bundleEntry_resource :: Maybe ResourceContainer
          -- ^ The Resources for the entry.
        , bundleEntry_search :: Maybe BundleSearch
          -- ^ Information about the search process that lead to the 
          --   creation of this entry.
        , bundleEntry_request :: Maybe BundleRequest
          -- ^ Additional information about how this entry should be 
          --   processed as part of a transaction.
        , bundleEntry_response :: Maybe BundleResponse
          -- ^ Additional information about how this entry should be 
          --   processed as part of a transaction.
        }
        deriving (Eq,Show)
instance SchemaType BundleEntry where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BundleEntry a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "link")
            `apply` optional (parseSchemaType "fullUrl")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "search")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
    schemaTypeToXML s x@BundleEntry{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleEntry_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleEntry_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundleEntry_modifierExtension x
            , concatMap (schemaTypeToXML "link") $ bundleEntry_link x
            , maybe [] (schemaTypeToXML "fullUrl") $ bundleEntry_fullUrl x
            , maybe [] (schemaTypeToXML "resource") $ bundleEntry_resource x
            , maybe [] (schemaTypeToXML "search") $ bundleEntry_search x
            , maybe [] (schemaTypeToXML "request") $ bundleEntry_request x
            , maybe [] (schemaTypeToXML "response") $ bundleEntry_response x
            ]
instance Extension BundleEntry BackboneElement where
    supertype (BundleEntry a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension BundleEntry Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: BundleEntry -> BackboneElement)
              
 
-- | A container for a collection of resources.
data BundleSearch = BundleSearch
        { bundleSearch_id :: Maybe String_primitive
        , bundleSearch_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundleSearch_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundleSearch_mode :: Maybe SearchEntryMode
          -- ^ Why this entry is in the result set - whether it's included 
          --   as a match or because of an _include requirement.
        , bundleSearch_score :: Maybe Decimal
          -- ^ When searching, the server's search ranking score for the 
          --   entry.
        }
        deriving (Eq,Show)
instance SchemaType BundleSearch where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BundleSearch a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "score")
    schemaTypeToXML s x@BundleSearch{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleSearch_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleSearch_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundleSearch_modifierExtension x
            , maybe [] (schemaTypeToXML "mode") $ bundleSearch_mode x
            , maybe [] (schemaTypeToXML "score") $ bundleSearch_score x
            ]
instance Extension BundleSearch BackboneElement where
    supertype (BundleSearch a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension BundleSearch Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: BundleSearch -> BackboneElement)
              
 
-- | A container for a collection of resources.
data BundleRequest = BundleRequest
        { bundleRequest_id :: Maybe String_primitive
        , bundleRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundleRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundleRequest_method :: HTTPVerb
          -- ^ The HTTP verb for this entry in either a change history, or 
          --   a transaction/ transaction response.
        , bundleRequest_url :: Uri
          -- ^ The URL for this entry, relative to the root (the address 
          --   to which the request is posted).
        , bundleRequest_ifNoneMatch :: Maybe Xsd.XsdString
          -- ^ If the ETag values match, return a 304 Not Modified status. 
          --   See the API documentation for [&quot;Conditional 
          --   Read&quot;](http.html#cread).
        , bundleRequest_ifModifiedSince :: Maybe Instant
          -- ^ Only perform the operation if the last updated date 
          --   matches. See the API documentation for [&quot;Conditional 
          --   Read&quot;](http.html#cread).
        , bundleRequest_ifMatch :: Maybe Xsd.XsdString
          -- ^ Only perform the operation if the Etag value matches. For 
          --   more information, see the API section [&quot;Managing 
          --   Resource Contention&quot;](http.html#concurrency).
        , bundleRequest_ifNoneExist :: Maybe Xsd.XsdString
          -- ^ Instruct the server not to perform the create if a 
          --   specified resource already exists. For further information, 
          --   see the API documentation for [&quot;Conditional 
          --   Create&quot;](http.html#ccreate). This is just the query 
          --   portion of the URL - what follows the &quot;?&quot; (not 
          --   including the &quot;?&quot;).
        }
        deriving (Eq,Show)
instance SchemaType BundleRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BundleRequest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "method"
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "ifNoneMatch")
            `apply` optional (parseSchemaType "ifModifiedSince")
            `apply` optional (parseSchemaType "ifMatch")
            `apply` optional (parseSchemaType "ifNoneExist")
    schemaTypeToXML s x@BundleRequest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleRequest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundleRequest_modifierExtension x
            , schemaTypeToXML "method" $ bundleRequest_method x
            , schemaTypeToXML "url" $ bundleRequest_url x
            , maybe [] (schemaTypeToXML "ifNoneMatch") $ bundleRequest_ifNoneMatch x
            , maybe [] (schemaTypeToXML "ifModifiedSince") $ bundleRequest_ifModifiedSince x
            , maybe [] (schemaTypeToXML "ifMatch") $ bundleRequest_ifMatch x
            , maybe [] (schemaTypeToXML "ifNoneExist") $ bundleRequest_ifNoneExist x
            ]
instance Extension BundleRequest BackboneElement where
    supertype (BundleRequest a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension BundleRequest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: BundleRequest -> BackboneElement)
              
 
-- | A container for a collection of resources.
data BundleResponse = BundleResponse
        { bundleResponse_id :: Maybe String_primitive
        , bundleResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , bundleResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , bundleResponse_status :: Xsd.XsdString
          -- ^ The status code returned by processing this entry. The 
          --   status SHALL start with a 3 digit HTTP code (e.g. 404) and 
          --   may contain the standard HTTP description associated with 
          --   the status code.
        , bundleResponse_location :: Maybe Uri
          -- ^ The location header created by processing this operation.
        , bundleResponse_etag :: Maybe Xsd.XsdString
          -- ^ The etag for the resource, it the operation for the entry 
          --   produced a versioned resource (see [Resource Metadata and 
          --   Versioning](http.html#versioning) and [Managing Resource 
          --   Contention](http.html#concurrency)).
        , bundleResponse_lastModified :: Maybe Instant
          -- ^ The date/time that the resource was modified on the server.
        , bundleResponse_outcome :: Maybe ResourceContainer
          -- ^ An OperationOutcome containing hints and warnings produced 
          --   as part of processing this entry in a batch or transaction.
        }
        deriving (Eq,Show)
instance SchemaType BundleResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (BundleResponse a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "etag")
            `apply` optional (parseSchemaType "lastModified")
            `apply` optional (parseSchemaType "outcome")
    schemaTypeToXML s x@BundleResponse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleResponse_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ bundleResponse_modifierExtension x
            , schemaTypeToXML "status" $ bundleResponse_status x
            , maybe [] (schemaTypeToXML "location") $ bundleResponse_location x
            , maybe [] (schemaTypeToXML "etag") $ bundleResponse_etag x
            , maybe [] (schemaTypeToXML "lastModified") $ bundleResponse_lastModified x
            , maybe [] (schemaTypeToXML "outcome") $ bundleResponse_outcome x
            ]
instance Extension BundleResponse BackboneElement where
    supertype (BundleResponse a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension BundleResponse Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: BundleResponse -> BackboneElement)
              
 
data HTTPVerb_list
    = HTTPVerb_list_GET
      -- ^ GET
    | HTTPVerb_list_POST
      -- ^ POST
    | HTTPVerb_list_PUT
      -- ^ PUT
    | HTTPVerb_list_DELETE
      -- ^ DELETE
    deriving (Eq,Show,Enum)
instance SchemaType HTTPVerb_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType HTTPVerb_list where
    acceptingParser =  do literal "GET"; return HTTPVerb_list_GET
                      `onFail` do literal "POST"; return HTTPVerb_list_POST
                      `onFail` do literal "PUT"; return HTTPVerb_list_PUT
                      `onFail` do literal "DELETE"; return HTTPVerb_list_DELETE
                      
    simpleTypeText HTTPVerb_list_GET = "GET"
    simpleTypeText HTTPVerb_list_POST = "POST"
    simpleTypeText HTTPVerb_list_PUT = "PUT"
    simpleTypeText HTTPVerb_list_DELETE = "DELETE"
 
data HTTPVerb = HTTPVerb
        { hTTPVerb_id :: Maybe String_primitive
        , hTTPVerb_value :: Maybe HTTPVerb_list
        , hTTPVerb_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType HTTPVerb where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (HTTPVerb a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@HTTPVerb{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ hTTPVerb_id x
                       , maybe [] (toXMLAttribute "value") $ hTTPVerb_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ hTTPVerb_extension x
            ]
instance Extension HTTPVerb Element where
    supertype (HTTPVerb a0 a1 e0) =
               Element a0 e0
 
data BundleType_list
    = BundleType_list_Document
      -- ^ Document
    | BundleType_list_Message
      -- ^ Message
    | BundleType_list_Transaction
      -- ^ Transaction
    | BundleType_list_Transaction_response
      -- ^ Transaction Response
    | BundleType_list_Batch
      -- ^ Batch
    | BundleType_list_Batch_response
      -- ^ Batch Response
    | BundleType_list_History
      -- ^ History List
    | BundleType_list_Searchset
      -- ^ Search Results
    | BundleType_list_Collection
      -- ^ Collection
    deriving (Eq,Show,Enum)
instance SchemaType BundleType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType BundleType_list where
    acceptingParser =  do literal "document"; return BundleType_list_Document
                      `onFail` do literal "message"; return BundleType_list_Message
                      `onFail` do literal "transaction"; return BundleType_list_Transaction
                      `onFail` do literal "transaction-response"; return BundleType_list_Transaction_response
                      `onFail` do literal "batch"; return BundleType_list_Batch
                      `onFail` do literal "batch-response"; return BundleType_list_Batch_response
                      `onFail` do literal "history"; return BundleType_list_History
                      `onFail` do literal "searchset"; return BundleType_list_Searchset
                      `onFail` do literal "collection"; return BundleType_list_Collection
                      
    simpleTypeText BundleType_list_Document = "document"
    simpleTypeText BundleType_list_Message = "message"
    simpleTypeText BundleType_list_Transaction = "transaction"
    simpleTypeText BundleType_list_Transaction_response = "transaction-response"
    simpleTypeText BundleType_list_Batch = "batch"
    simpleTypeText BundleType_list_Batch_response = "batch-response"
    simpleTypeText BundleType_list_History = "history"
    simpleTypeText BundleType_list_Searchset = "searchset"
    simpleTypeText BundleType_list_Collection = "collection"
 
data BundleType = BundleType
        { bundleType_id :: Maybe String_primitive
        , bundleType_value :: Maybe BundleType_list
        , bundleType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType BundleType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (BundleType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@BundleType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ bundleType_id x
                       , maybe [] (toXMLAttribute "value") $ bundleType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ bundleType_extension x
            ]
instance Extension BundleType Element where
    supertype (BundleType a0 a1 e0) =
               Element a0 e0
 
data SearchEntryMode_list
    = SearchEntryMode_list_Match
      -- ^ Match
    | SearchEntryMode_list_Include
      -- ^ Include
    | SearchEntryMode_list_Outcome
      -- ^ Outcome
    deriving (Eq,Show,Enum)
instance SchemaType SearchEntryMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchEntryMode_list where
    acceptingParser =  do literal "match"; return SearchEntryMode_list_Match
                      `onFail` do literal "include"; return SearchEntryMode_list_Include
                      `onFail` do literal "outcome"; return SearchEntryMode_list_Outcome
                      
    simpleTypeText SearchEntryMode_list_Match = "match"
    simpleTypeText SearchEntryMode_list_Include = "include"
    simpleTypeText SearchEntryMode_list_Outcome = "outcome"
 
data SearchEntryMode = SearchEntryMode
        { searchEntryMode_id :: Maybe String_primitive
        , searchEntryMode_value :: Maybe SearchEntryMode_list
        , searchEntryMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchEntryMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchEntryMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchEntryMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchEntryMode_id x
                       , maybe [] (toXMLAttribute "value") $ searchEntryMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchEntryMode_extension x
            ]
instance Extension SearchEntryMode Element where
    supertype (SearchEntryMode a0 a1 e0) =
               Element a0 e0
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
elementCapabilityStatement :: XMLParser CapabilityStatement
elementCapabilityStatement = parseSchemaType "CapabilityStatement"
elementToXMLCapabilityStatement :: CapabilityStatement -> [Content ()]
elementToXMLCapabilityStatement = schemaTypeToXML "CapabilityStatement"
 
data CapabilityStatement = CapabilityStatement
        { capabilityStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , capabilityStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , capabilityStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , capabilityStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , capabilityStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , capabilityStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , capabilityStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatement_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this capability 
          --   statement when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   capability statement is (or will be) published. The URL 
          --   SHOULD include the major version of the capability 
          --   statement. For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , capabilityStatement_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   capability statement when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the capability statement author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , capabilityStatement_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the capability 
          --   statement. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , capabilityStatement_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   capability statement.
        , capabilityStatement_status :: PublicationStatus
          -- ^ The status of this capability statement. Enables tracking 
          --   the life-cycle of the content.
        , capabilityStatement_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this capability statement 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , capabilityStatement_date :: DateTime
          -- ^ The date (and optionally time) when the capability 
          --   statement was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the capability statement changes.
        , capabilityStatement_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the capability statement.
        , capabilityStatement_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , capabilityStatement_description :: Maybe Markdown
          -- ^ A free text natural language description of the capability 
          --   statement from a consumer's perspective. Typically, this is 
          --   used when the capability statement describes a desired 
          --   rather than an actual solution, for example as a formal 
          --   expression of requirements as part of an RFP.
        , capabilityStatement_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   capability statement instances.
        , capabilityStatement_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the capability 
          --   statement is intended to be used.
        , capabilityStatement_purpose :: Maybe Markdown
          -- ^ Explaination of why this capability statement is needed and 
          --   why it has been designed as it has.
        , capabilityStatement_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the capability statement 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   capability statement.
        , capabilityStatement_kind :: CapabilityStatementKind
          -- ^ The way that this statement is intended to be used, to 
          --   describe an actual running instance of software, a 
          --   particular product (kind not instance of software) or a 
          --   class of implementation (e.g. a desired purchase).
        , capabilityStatement_instantiates :: [Uri]
          -- ^ Reference to a canonical URL of another CapabilityStatement 
          --   that this software implements or uses. This capability 
          --   statement is a published API description that corresponds 
          --   to a business service. The rest of the capability statement 
          --   does not need to repeat the details of the referenced 
          --   resource, but can do so.
        , capabilityStatement_software :: Maybe CapabilityStatementSoftware
          -- ^ Software that is covered by this capability statement. It 
          --   is used when the capability statement describes the 
          --   capabilities of a particular software version, independent 
          --   of an installation.
        , capabilityStatement_implementation :: Maybe CapabilityStatementImplementation
          -- ^ Identifies a specific implementation instance that is 
          --   described by the capability statement - i.e. a particular 
          --   installation, rather than the capabilities of a software 
          --   program.
        , capabilityStatement_fhirVersion :: Id
          -- ^ The version of the FHIR specification on which this 
          --   capability statement is based.
        , capabilityStatement_acceptUnknown :: UnknownContentCode
          -- ^ A code that indicates whether the application accepts 
          --   unknown elements or extensions when reading resources.
        , capabilityStatement_format :: [Code]
          -- ^ A list of the formats supported by this implementation 
          --   using their content types.
        , capabilityStatement_patchFormat :: [Code]
          -- ^ A list of the patch formats supported by this 
          --   implementation using their content types.
        , capabilityStatement_implementationGuide :: [Uri]
          -- ^ A list of implementation guides that the server does (or 
          --   should) support in their entirety.
        , capabilityStatement_profile :: [Reference]
          -- ^ A list of profiles that represent different use cases 
          --   supported by the system. For a server, &quot;supported by 
          --   the system&quot; means the system hosts/produces a set of 
          --   resources that are conformant to a particular profile, and 
          --   allows clients that use its services to search using this 
          --   profile and to find appropriate data. For a client, it 
          --   means the system will search by this profile and process 
          --   data according to the guidance implicit in the profile. See 
          --   further discussion in [Using 
          --   Profiles](profiling.html#profile-uses).
        , capabilityStatement_rest :: [CapabilityStatementRest]
          -- ^ A definition of the restful capabilities of the solution, 
          --   if any.
        , capabilityStatement_messaging :: [CapabilityStatementMessaging]
          -- ^ A description of the messaging capabilities of the 
          --   solution.
        , capabilityStatement_document :: [CapabilityStatementDocument]
          -- ^ A document definition.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CapabilityStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` parseSchemaType "kind"
            `apply` many (parseSchemaType "instantiates")
            `apply` optional (parseSchemaType "software")
            `apply` optional (parseSchemaType "implementation")
            `apply` parseSchemaType "fhirVersion"
            `apply` parseSchemaType "acceptUnknown"
            `apply` many1 (parseSchemaType "format")
            `apply` many (parseSchemaType "patchFormat")
            `apply` many (parseSchemaType "implementationGuide")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "rest")
            `apply` many (parseSchemaType "messaging")
            `apply` many (parseSchemaType "document")
    schemaTypeToXML s x@CapabilityStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ capabilityStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ capabilityStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ capabilityStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ capabilityStatement_language x
            , maybe [] (schemaTypeToXML "text") $ capabilityStatement_text x
            , concatMap (schemaTypeToXML "contained") $ capabilityStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ capabilityStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatement_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ capabilityStatement_url x
            , maybe [] (schemaTypeToXML "version") $ capabilityStatement_version x
            , maybe [] (schemaTypeToXML "name") $ capabilityStatement_name x
            , maybe [] (schemaTypeToXML "title") $ capabilityStatement_title x
            , schemaTypeToXML "status" $ capabilityStatement_status x
            , maybe [] (schemaTypeToXML "experimental") $ capabilityStatement_experimental x
            , schemaTypeToXML "date" $ capabilityStatement_date x
            , maybe [] (schemaTypeToXML "publisher") $ capabilityStatement_publisher x
            , concatMap (schemaTypeToXML "contact") $ capabilityStatement_contact x
            , maybe [] (schemaTypeToXML "description") $ capabilityStatement_description x
            , concatMap (schemaTypeToXML "useContext") $ capabilityStatement_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ capabilityStatement_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ capabilityStatement_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ capabilityStatement_copyright x
            , schemaTypeToXML "kind" $ capabilityStatement_kind x
            , concatMap (schemaTypeToXML "instantiates") $ capabilityStatement_instantiates x
            , maybe [] (schemaTypeToXML "software") $ capabilityStatement_software x
            , maybe [] (schemaTypeToXML "implementation") $ capabilityStatement_implementation x
            , schemaTypeToXML "fhirVersion" $ capabilityStatement_fhirVersion x
            , schemaTypeToXML "acceptUnknown" $ capabilityStatement_acceptUnknown x
            , concatMap (schemaTypeToXML "format") $ capabilityStatement_format x
            , concatMap (schemaTypeToXML "patchFormat") $ capabilityStatement_patchFormat x
            , concatMap (schemaTypeToXML "implementationGuide") $ capabilityStatement_implementationGuide x
            , concatMap (schemaTypeToXML "profile") $ capabilityStatement_profile x
            , concatMap (schemaTypeToXML "rest") $ capabilityStatement_rest x
            , concatMap (schemaTypeToXML "messaging") $ capabilityStatement_messaging x
            , concatMap (schemaTypeToXML "document") $ capabilityStatement_document x
            ]
instance Extension CapabilityStatement DomainResource where
    supertype (CapabilityStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CapabilityStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CapabilityStatement -> DomainResource)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementSoftware = CapabilityStatementSoftware
        { capabilityStatementSoftware_id :: Maybe String_primitive
        , capabilityStatementSoftware_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementSoftware_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementSoftware_name :: Xsd.XsdString
          -- ^ Name software is known by.
        , capabilityStatementSoftware_version :: Maybe Xsd.XsdString
          -- ^ The version identifier for the software covered by this 
          --   statement.
        , capabilityStatementSoftware_releaseDate :: Maybe DateTime
          -- ^ Date this version of the software was released.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementSoftware where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementSoftware a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "releaseDate")
    schemaTypeToXML s x@CapabilityStatementSoftware{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementSoftware_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementSoftware_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementSoftware_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatementSoftware_name x
            , maybe [] (schemaTypeToXML "version") $ capabilityStatementSoftware_version x
            , maybe [] (schemaTypeToXML "releaseDate") $ capabilityStatementSoftware_releaseDate x
            ]
instance Extension CapabilityStatementSoftware BackboneElement where
    supertype (CapabilityStatementSoftware a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementSoftware Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementSoftware -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementImplementation = CapabilityStatementImplementation
        { capabilityStatementImplementation_id :: Maybe String_primitive
        , capabilityStatementImplementation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementImplementation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementImplementation_description :: Xsd.XsdString
          -- ^ Information about the specific installation that this 
          --   capability statement relates to.
        , capabilityStatementImplementation_url :: Maybe Uri
          -- ^ An absolute base URL for the implementation. This forms the 
          --   base for REST interfaces as well as the mailbox and 
          --   document interfaces.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementImplementation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementImplementation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@CapabilityStatementImplementation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementImplementation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementImplementation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementImplementation_modifierExtension x
            , schemaTypeToXML "description" $ capabilityStatementImplementation_description x
            , maybe [] (schemaTypeToXML "url") $ capabilityStatementImplementation_url x
            ]
instance Extension CapabilityStatementImplementation BackboneElement where
    supertype (CapabilityStatementImplementation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementImplementation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementImplementation -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementRest = CapabilityStatementRest
        { capabilityStatementRest_id :: Maybe String_primitive
        , capabilityStatementRest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementRest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementRest_mode :: RestfulCapabilityMode
          -- ^ Identifies whether this portion of the statement is 
          --   describing the ability to initiate or receive restful 
          --   operations.
        , capabilityStatementRest_documentation :: Maybe Xsd.XsdString
          -- ^ Information about the system's restful capabilities that 
          --   apply across all applications, such as security.
        , capabilityStatementRest_security :: Maybe CapabilityStatementSecurity
          -- ^ Information about security implementation from an interface 
          --   perspective - what a client needs to know.
        , capabilityStatementRest_resource :: [CapabilityStatementResource]
          -- ^ A specification of the restful capabilities of the solution 
          --   for a specific resource type.
        , capabilityStatementRest_interaction :: [CapabilityStatementInteraction1]
          -- ^ A specification of restful operations supported by the 
          --   system.
        , capabilityStatementRest_searchParam :: [CapabilityStatementSearchParam]
          -- ^ Search parameters that are supported for searching all 
          --   resources for implementations to support and/or make use of 
          --   - either references to ones defined in the specification, 
          --   or additional ones defined for/by the implementation.
        , capabilityStatementRest_operation :: [CapabilityStatementOperation]
          -- ^ Definition of an operation or a named query together with 
          --   its parameters and their meaning and type.
        , capabilityStatementRest_compartment :: [Uri]
          -- ^ An absolute URI which is a reference to the definition of a 
          --   compartment that the system supports. The reference is to a 
          --   CompartmentDefinition resource by its canonical URL .
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementRest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementRest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
            `apply` optional (parseSchemaType "security")
            `apply` many (parseSchemaType "resource")
            `apply` many (parseSchemaType "interaction")
            `apply` many (parseSchemaType "searchParam")
            `apply` many (parseSchemaType "operation")
            `apply` many (parseSchemaType "compartment")
    schemaTypeToXML s x@CapabilityStatementRest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementRest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementRest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementRest_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatementRest_mode x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementRest_documentation x
            , maybe [] (schemaTypeToXML "security") $ capabilityStatementRest_security x
            , concatMap (schemaTypeToXML "resource") $ capabilityStatementRest_resource x
            , concatMap (schemaTypeToXML "interaction") $ capabilityStatementRest_interaction x
            , concatMap (schemaTypeToXML "searchParam") $ capabilityStatementRest_searchParam x
            , concatMap (schemaTypeToXML "operation") $ capabilityStatementRest_operation x
            , concatMap (schemaTypeToXML "compartment") $ capabilityStatementRest_compartment x
            ]
instance Extension CapabilityStatementRest BackboneElement where
    supertype (CapabilityStatementRest a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementRest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementRest -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementSecurity = CapabilityStatementSecurity
        { capabilityStatementSecurity_id :: Maybe String_primitive
        , capabilityStatementSecurity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementSecurity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementSecurity_cors :: Maybe Boolean
          -- ^ Server adds CORS headers when responding to requests - this 
          --   enables javascript applications to use the server.
        , capabilityStatementSecurity_service :: [CodeableConcept]
          -- ^ Types of security services that are supported/required by 
          --   the system.
        , capabilityStatementSecurity_description :: Maybe Xsd.XsdString
          -- ^ General description of how security works.
        , capabilityStatementSecurity_certificate :: [CapabilityStatementCertificate]
          -- ^ Certificates associated with security profiles.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementSecurity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementSecurity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "cors")
            `apply` many (parseSchemaType "service")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "certificate")
    schemaTypeToXML s x@CapabilityStatementSecurity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementSecurity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementSecurity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementSecurity_modifierExtension x
            , maybe [] (schemaTypeToXML "cors") $ capabilityStatementSecurity_cors x
            , concatMap (schemaTypeToXML "service") $ capabilityStatementSecurity_service x
            , maybe [] (schemaTypeToXML "description") $ capabilityStatementSecurity_description x
            , concatMap (schemaTypeToXML "certificate") $ capabilityStatementSecurity_certificate x
            ]
instance Extension CapabilityStatementSecurity BackboneElement where
    supertype (CapabilityStatementSecurity a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementSecurity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementSecurity -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementCertificate = CapabilityStatementCertificate
        { capabilityStatementCertificate_id :: Maybe String_primitive
        , capabilityStatementCertificate_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementCertificate_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementCertificate_type :: Maybe Code
          -- ^ Mime type for a certificate.
        , capabilityStatementCertificate_blob :: Maybe Base64Binary
          -- ^ Actual certificate.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementCertificate where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementCertificate a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "blob")
    schemaTypeToXML s x@CapabilityStatementCertificate{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementCertificate_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementCertificate_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementCertificate_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ capabilityStatementCertificate_type x
            , maybe [] (schemaTypeToXML "blob") $ capabilityStatementCertificate_blob x
            ]
instance Extension CapabilityStatementCertificate BackboneElement where
    supertype (CapabilityStatementCertificate a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementCertificate Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementCertificate -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementResource = CapabilityStatementResource
        { capabilityStatementResource_id :: Maybe String_primitive
        , capabilityStatementResource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementResource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementResource_type :: ResourceType
          -- ^ A type of resource exposed via the restful interface.
        , capabilityStatementResource_profile :: Maybe Reference
          -- ^ A specification of the profile that describes the 
          --   solution's overall support for the resource, including any 
          --   constraints on cardinality, bindings, lengths or other 
          --   limitations. See further discussion in [Using 
          --   Profiles](profiling.html#profile-uses).
        , capabilityStatementResource_documentation :: Maybe Markdown
          -- ^ Additional information about the resource type used by the 
          --   system.
        , capabilityStatementResource_interaction :: [CapabilityStatementInteraction]
          -- ^ Identifies a restful operation supported by the solution.
        , capabilityStatementResource_versioning :: Maybe ResourceVersionPolicy
          -- ^ This field is set to no-version to specify that the system 
          --   does not support (server) or use (client) versioning for 
          --   this resource type. If this has some other value, the 
          --   server must at least correctly track and populate the 
          --   versionId meta-property on resources. If the value is 
          --   'versioned-update', then the server supports all the 
          --   versioning features, including using e-tags for version 
          --   integrity in the API.
        , capabilityStatementResource_readHistory :: Maybe Boolean
          -- ^ A flag for whether the server is able to return past 
          --   versions as part of the vRead operation.
        , capabilityStatementResource_updateCreate :: Maybe Boolean
          -- ^ A flag to indicate that the server allows or needs to allow 
          --   the client to create new identities on the server (e.g. 
          --   that is, the client PUTs to a location where there is no 
          --   existing resource). Allowing this operation means that the 
          --   server allows the client to create new identities on the 
          --   server.
        , capabilityStatementResource_conditionalCreate :: Maybe Boolean
          -- ^ A flag that indicates that the server supports conditional 
          --   create.
        , capabilityStatementResource_conditionalRead :: Maybe ConditionalReadStatus
          -- ^ A code that indicates how the server supports conditional 
          --   read.
        , capabilityStatementResource_conditionalUpdate :: Maybe Boolean
          -- ^ A flag that indicates that the server supports conditional 
          --   update.
        , capabilityStatementResource_conditionalDelete :: Maybe ConditionalDeleteStatus
          -- ^ A code that indicates how the server supports conditional 
          --   delete.
        , capabilityStatementResource_referencePolicy :: [ReferenceHandlingPolicy]
          -- ^ A set of flags that defines how references are supported.
        , capabilityStatementResource_searchInclude :: [Xsd.XsdString]
          -- ^ A list of _include values supported by the server.
        , capabilityStatementResource_searchRevInclude :: [Xsd.XsdString]
          -- ^ A list of _revinclude (reverse include) values supported by 
          --   the server.
        , capabilityStatementResource_searchParam :: [CapabilityStatementSearchParam]
          -- ^ Search parameters for implementations to support and/or 
          --   make use of - either references to ones defined in the 
          --   specification, or additional ones defined for/by the 
          --   implementation.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementResource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementResource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "documentation")
            `apply` many1 (parseSchemaType "interaction")
            `apply` optional (parseSchemaType "versioning")
            `apply` optional (parseSchemaType "readHistory")
            `apply` optional (parseSchemaType "updateCreate")
            `apply` optional (parseSchemaType "conditionalCreate")
            `apply` optional (parseSchemaType "conditionalRead")
            `apply` optional (parseSchemaType "conditionalUpdate")
            `apply` optional (parseSchemaType "conditionalDelete")
            `apply` many (parseSchemaType "referencePolicy")
            `apply` many (parseSchemaType "searchInclude")
            `apply` many (parseSchemaType "searchRevInclude")
            `apply` many (parseSchemaType "searchParam")
    schemaTypeToXML s x@CapabilityStatementResource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementResource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementResource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementResource_modifierExtension x
            , schemaTypeToXML "type" $ capabilityStatementResource_type x
            , maybe [] (schemaTypeToXML "profile") $ capabilityStatementResource_profile x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementResource_documentation x
            , concatMap (schemaTypeToXML "interaction") $ capabilityStatementResource_interaction x
            , maybe [] (schemaTypeToXML "versioning") $ capabilityStatementResource_versioning x
            , maybe [] (schemaTypeToXML "readHistory") $ capabilityStatementResource_readHistory x
            , maybe [] (schemaTypeToXML "updateCreate") $ capabilityStatementResource_updateCreate x
            , maybe [] (schemaTypeToXML "conditionalCreate") $ capabilityStatementResource_conditionalCreate x
            , maybe [] (schemaTypeToXML "conditionalRead") $ capabilityStatementResource_conditionalRead x
            , maybe [] (schemaTypeToXML "conditionalUpdate") $ capabilityStatementResource_conditionalUpdate x
            , maybe [] (schemaTypeToXML "conditionalDelete") $ capabilityStatementResource_conditionalDelete x
            , concatMap (schemaTypeToXML "referencePolicy") $ capabilityStatementResource_referencePolicy x
            , concatMap (schemaTypeToXML "searchInclude") $ capabilityStatementResource_searchInclude x
            , concatMap (schemaTypeToXML "searchRevInclude") $ capabilityStatementResource_searchRevInclude x
            , concatMap (schemaTypeToXML "searchParam") $ capabilityStatementResource_searchParam x
            ]
instance Extension CapabilityStatementResource BackboneElement where
    supertype (CapabilityStatementResource a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementResource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementResource -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementInteraction = CapabilityStatementInteraction
        { capabilityStatementInteraction_id :: Maybe String_primitive
        , capabilityStatementInteraction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementInteraction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementInteraction_code :: TypeRestfulInteraction
          -- ^ Coded identifier of the operation, supported by the system 
          --   resource.
        , capabilityStatementInteraction_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance specific to the implementation of this operation, 
          --   such as 'delete is a logical delete' or 'updates are only 
          --   allowed with version id' or 'creates permitted from 
          --   pre-authorized certificates only'.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementInteraction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementInteraction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatementInteraction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementInteraction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementInteraction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementInteraction_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatementInteraction_code x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementInteraction_documentation x
            ]
instance Extension CapabilityStatementInteraction BackboneElement where
    supertype (CapabilityStatementInteraction a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementInteraction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementInteraction -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementSearchParam = CapabilityStatementSearchParam
        { capabilityStatementSearchParam_id :: Maybe String_primitive
        , capabilityStatementSearchParam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementSearchParam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementSearchParam_name :: Xsd.XsdString
          -- ^ The name of the search parameter used in the interface.
        , capabilityStatementSearchParam_definition :: Maybe Uri
          -- ^ An absolute URI that is a formal reference to where this 
          --   parameter was first defined, so that a client can be 
          --   confident of the meaning of the search parameter (a 
          --   reference to [[[SearchParameter.url]]]).
        , capabilityStatementSearchParam_type :: SearchParamType
          -- ^ The type of value a search parameter refers to, and how the 
          --   content is interpreted.
        , capabilityStatementSearchParam_documentation :: Maybe Xsd.XsdString
          -- ^ This allows documentation of any distinct behaviors about 
          --   how the search parameter is used. For example, text 
          --   matching algorithms.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementSearchParam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementSearchParam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "definition")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatementSearchParam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementSearchParam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementSearchParam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementSearchParam_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatementSearchParam_name x
            , maybe [] (schemaTypeToXML "definition") $ capabilityStatementSearchParam_definition x
            , schemaTypeToXML "type" $ capabilityStatementSearchParam_type x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementSearchParam_documentation x
            ]
instance Extension CapabilityStatementSearchParam BackboneElement where
    supertype (CapabilityStatementSearchParam a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementSearchParam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementSearchParam -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementInteraction1 = CapabilityStatementInteraction1
        { capabilityStatementInteraction1_id :: Maybe String_primitive
        , capabilityStatementInteraction1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementInteraction1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementInteraction1_code :: SystemRestfulInteraction
          -- ^ A coded identifier of the operation, supported by the 
          --   system.
        , capabilityStatementInteraction1_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance specific to the implementation of this operation, 
          --   such as limitations on the kind of transactions allowed, or 
          --   information about system wide search is implemented.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementInteraction1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementInteraction1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatementInteraction1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementInteraction1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementInteraction1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementInteraction1_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatementInteraction1_code x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementInteraction1_documentation x
            ]
instance Extension CapabilityStatementInteraction1 BackboneElement where
    supertype (CapabilityStatementInteraction1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementInteraction1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementInteraction1 -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementOperation = CapabilityStatementOperation
        { capabilityStatementOperation_id :: Maybe String_primitive
        , capabilityStatementOperation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementOperation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementOperation_name :: Xsd.XsdString
          -- ^ The name of the operation or query. For an operation, this 
          --   is the name prefixed with $ and used in the URL. For a 
          --   query, this is the name used in the _query parameter when 
          --   the query is called.
        , capabilityStatementOperation_definition :: Reference
          -- ^ Where the formal definition can be found.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementOperation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementOperation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "definition"
    schemaTypeToXML s x@CapabilityStatementOperation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementOperation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementOperation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementOperation_modifierExtension x
            , schemaTypeToXML "name" $ capabilityStatementOperation_name x
            , schemaTypeToXML "definition" $ capabilityStatementOperation_definition x
            ]
instance Extension CapabilityStatementOperation BackboneElement where
    supertype (CapabilityStatementOperation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementOperation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementOperation -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementMessaging = CapabilityStatementMessaging
        { capabilityStatementMessaging_id :: Maybe String_primitive
        , capabilityStatementMessaging_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementMessaging_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementMessaging_endpoint :: [CapabilityStatementEndpoint]
          -- ^ An endpoint (network accessible address) to which messages 
          --   and/or replies are to be sent.
        , capabilityStatementMessaging_reliableCache :: Maybe UnsignedInt
          -- ^ Length if the receiver's reliable messaging cache in 
          --   minutes (if a receiver) or how long the cache length on the 
          --   receiver should be (if a sender).
        , capabilityStatementMessaging_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation about the system's messaging capabilities for 
          --   this endpoint not otherwise documented by the capability 
          --   statement. For example, the process for becoming an 
          --   authorized messaging exchange partner.
        , capabilityStatementMessaging_supportedMessage :: [CapabilityStatementSupportedMessage]
          -- ^ References to message definitions for messages this system 
          --   can send or receive.
        , capabilityStatementMessaging_event :: [CapabilityStatementEvent]
          -- ^ A description of the solution's support for an event at 
          --   this end-point.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementMessaging where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementMessaging a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "reliableCache")
            `apply` optional (parseSchemaType "documentation")
            `apply` many (parseSchemaType "supportedMessage")
            `apply` many (parseSchemaType "event")
    schemaTypeToXML s x@CapabilityStatementMessaging{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementMessaging_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementMessaging_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementMessaging_modifierExtension x
            , concatMap (schemaTypeToXML "endpoint") $ capabilityStatementMessaging_endpoint x
            , maybe [] (schemaTypeToXML "reliableCache") $ capabilityStatementMessaging_reliableCache x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementMessaging_documentation x
            , concatMap (schemaTypeToXML "supportedMessage") $ capabilityStatementMessaging_supportedMessage x
            , concatMap (schemaTypeToXML "event") $ capabilityStatementMessaging_event x
            ]
instance Extension CapabilityStatementMessaging BackboneElement where
    supertype (CapabilityStatementMessaging a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementMessaging Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementMessaging -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementEndpoint = CapabilityStatementEndpoint
        { capabilityStatementEndpoint_id :: Maybe String_primitive
        , capabilityStatementEndpoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementEndpoint_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementEndpoint_protocol :: Coding
          -- ^ A list of the messaging transport protocol(s) identifiers, 
          --   supported by this endpoint.
        , capabilityStatementEndpoint_address :: Uri
          -- ^ The network address of the end-point. For solutions that do 
          --   not use network addresses for routing, it can be just an 
          --   identifier.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementEndpoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementEndpoint a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "protocol"
            `apply` parseSchemaType "address"
    schemaTypeToXML s x@CapabilityStatementEndpoint{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementEndpoint_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementEndpoint_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementEndpoint_modifierExtension x
            , schemaTypeToXML "protocol" $ capabilityStatementEndpoint_protocol x
            , schemaTypeToXML "address" $ capabilityStatementEndpoint_address x
            ]
instance Extension CapabilityStatementEndpoint BackboneElement where
    supertype (CapabilityStatementEndpoint a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementEndpoint Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementEndpoint -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementSupportedMessage = CapabilityStatementSupportedMessage
        { capabilityStatementSupportedMessage_id :: Maybe String_primitive
        , capabilityStatementSupportedMessage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementSupportedMessage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementSupportedMessage_mode :: EventCapabilityMode
          -- ^ The mode of this event declaration - whether application is 
          --   sender or receiver.
        , capabilityStatementSupportedMessage_definition :: Reference
          -- ^ Points to a message definition that identifies the 
          --   messaging event, message structure, allowed responses, etc.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementSupportedMessage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementSupportedMessage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` parseSchemaType "definition"
    schemaTypeToXML s x@CapabilityStatementSupportedMessage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementSupportedMessage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementSupportedMessage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementSupportedMessage_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatementSupportedMessage_mode x
            , schemaTypeToXML "definition" $ capabilityStatementSupportedMessage_definition x
            ]
instance Extension CapabilityStatementSupportedMessage BackboneElement where
    supertype (CapabilityStatementSupportedMessage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementSupportedMessage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementSupportedMessage -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementEvent = CapabilityStatementEvent
        { capabilityStatementEvent_id :: Maybe String_primitive
        , capabilityStatementEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementEvent_code :: Coding
          -- ^ A coded identifier of a supported messaging event.
        , capabilityStatementEvent_category :: Maybe MessageSignificanceCategory
          -- ^ The impact of the content of the message.
        , capabilityStatementEvent_mode :: EventCapabilityMode
          -- ^ The mode of this event declaration - whether an application 
          --   is a sender or receiver.
        , capabilityStatementEvent_focus :: ResourceType
          -- ^ A resource associated with the event. This is the resource 
          --   that defines the event.
        , capabilityStatementEvent_request :: Reference
          -- ^ Information about the request for this event.
        , capabilityStatementEvent_response :: Reference
          -- ^ Information about the response for this event.
        , capabilityStatementEvent_documentation :: Maybe Xsd.XsdString
          -- ^ Guidance on how this event is handled, such as internal 
          --   system trigger points, business rules, etc.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementEvent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "mode"
            `apply` parseSchemaType "focus"
            `apply` parseSchemaType "request"
            `apply` parseSchemaType "response"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CapabilityStatementEvent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementEvent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementEvent_modifierExtension x
            , schemaTypeToXML "code" $ capabilityStatementEvent_code x
            , maybe [] (schemaTypeToXML "category") $ capabilityStatementEvent_category x
            , schemaTypeToXML "mode" $ capabilityStatementEvent_mode x
            , schemaTypeToXML "focus" $ capabilityStatementEvent_focus x
            , schemaTypeToXML "request" $ capabilityStatementEvent_request x
            , schemaTypeToXML "response" $ capabilityStatementEvent_response x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementEvent_documentation x
            ]
instance Extension CapabilityStatementEvent BackboneElement where
    supertype (CapabilityStatementEvent a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementEvent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementEvent -> BackboneElement)
              
 
-- | A Capability Statement documents a set of capabilities 
--   (behaviors) of a FHIR Server that may be used as a 
--   statement of actual server functionality or a statement of 
--   required or desired server implementation.
data CapabilityStatementDocument = CapabilityStatementDocument
        { capabilityStatementDocument_id :: Maybe String_primitive
        , capabilityStatementDocument_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , capabilityStatementDocument_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , capabilityStatementDocument_mode :: DocumentMode
          -- ^ Mode of this document declaration - whether an application 
          --   is a producer or consumer.
        , capabilityStatementDocument_documentation :: Maybe Xsd.XsdString
          -- ^ A description of how the application supports or uses the 
          --   specified document profile. For example, when documents are 
          --   created, what action is taken with consumed documents, etc.
        , capabilityStatementDocument_profile :: Reference
          -- ^ A constraint on a resource used in the document.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementDocument where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CapabilityStatementDocument a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@CapabilityStatementDocument{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementDocument_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementDocument_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ capabilityStatementDocument_modifierExtension x
            , schemaTypeToXML "mode" $ capabilityStatementDocument_mode x
            , maybe [] (schemaTypeToXML "documentation") $ capabilityStatementDocument_documentation x
            , schemaTypeToXML "profile" $ capabilityStatementDocument_profile x
            ]
instance Extension CapabilityStatementDocument BackboneElement where
    supertype (CapabilityStatementDocument a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CapabilityStatementDocument Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CapabilityStatementDocument -> BackboneElement)
              
 
data CapabilityStatementKind_list
    = CapabilityStatementKind_list_Instance
      -- ^ Instance
    | CapabilityStatementKind_list_Capability
      -- ^ Capability
    | CapabilityStatementKind_list_Requirements
      -- ^ Requirements
    deriving (Eq,Show,Enum)
instance SchemaType CapabilityStatementKind_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CapabilityStatementKind_list where
    acceptingParser =  do literal "instance"; return CapabilityStatementKind_list_Instance
                      `onFail` do literal "capability"; return CapabilityStatementKind_list_Capability
                      `onFail` do literal "requirements"; return CapabilityStatementKind_list_Requirements
                      
    simpleTypeText CapabilityStatementKind_list_Instance = "instance"
    simpleTypeText CapabilityStatementKind_list_Capability = "capability"
    simpleTypeText CapabilityStatementKind_list_Requirements = "requirements"
 
data CapabilityStatementKind = CapabilityStatementKind
        { capabilityStatementKind_id :: Maybe String_primitive
        , capabilityStatementKind_value :: Maybe CapabilityStatementKind_list
        , capabilityStatementKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CapabilityStatementKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CapabilityStatementKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CapabilityStatementKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ capabilityStatementKind_id x
                       , maybe [] (toXMLAttribute "value") $ capabilityStatementKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ capabilityStatementKind_extension x
            ]
instance Extension CapabilityStatementKind Element where
    supertype (CapabilityStatementKind a0 a1 e0) =
               Element a0 e0
 
data EventCapabilityMode_list
    = EventCapabilityMode_list_Sender
      -- ^ Sender
    | EventCapabilityMode_list_Receiver
      -- ^ Receiver
    deriving (Eq,Show,Enum)
instance SchemaType EventCapabilityMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventCapabilityMode_list where
    acceptingParser =  do literal "sender"; return EventCapabilityMode_list_Sender
                      `onFail` do literal "receiver"; return EventCapabilityMode_list_Receiver
                      
    simpleTypeText EventCapabilityMode_list_Sender = "sender"
    simpleTypeText EventCapabilityMode_list_Receiver = "receiver"
 
data EventCapabilityMode = EventCapabilityMode
        { eventCapabilityMode_id :: Maybe String_primitive
        , eventCapabilityMode_value :: Maybe EventCapabilityMode_list
        , eventCapabilityMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventCapabilityMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventCapabilityMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventCapabilityMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventCapabilityMode_id x
                       , maybe [] (toXMLAttribute "value") $ eventCapabilityMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventCapabilityMode_extension x
            ]
instance Extension EventCapabilityMode Element where
    supertype (EventCapabilityMode a0 a1 e0) =
               Element a0 e0
 
data ResourceVersionPolicy_list
    = ResourceVersionPolicy_list_No_version
      -- ^ No VersionId Support
    | ResourceVersionPolicy_list_Versioned
      -- ^ Versioned
    | ResourceVersionPolicy_list_Versioned_update
      -- ^ VersionId tracked fully
    deriving (Eq,Show,Enum)
instance SchemaType ResourceVersionPolicy_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResourceVersionPolicy_list where
    acceptingParser =  do literal "no-version"; return ResourceVersionPolicy_list_No_version
                      `onFail` do literal "versioned"; return ResourceVersionPolicy_list_Versioned
                      `onFail` do literal "versioned-update"; return ResourceVersionPolicy_list_Versioned_update
                      
    simpleTypeText ResourceVersionPolicy_list_No_version = "no-version"
    simpleTypeText ResourceVersionPolicy_list_Versioned = "versioned"
    simpleTypeText ResourceVersionPolicy_list_Versioned_update = "versioned-update"
 
data ResourceVersionPolicy = ResourceVersionPolicy
        { resourceVersionPolicy_id :: Maybe String_primitive
        , resourceVersionPolicy_value :: Maybe ResourceVersionPolicy_list
        , resourceVersionPolicy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResourceVersionPolicy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResourceVersionPolicy a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResourceVersionPolicy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ resourceVersionPolicy_id x
                       , maybe [] (toXMLAttribute "value") $ resourceVersionPolicy_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ resourceVersionPolicy_extension x
            ]
instance Extension ResourceVersionPolicy Element where
    supertype (ResourceVersionPolicy a0 a1 e0) =
               Element a0 e0
 
data MessageSignificanceCategory_list
    = MessageSignificanceCategory_list_Consequence
      -- ^ Consequence
    | MessageSignificanceCategory_list_Currency
      -- ^ Currency
    | MessageSignificanceCategory_list_Notification
      -- ^ Notification
    deriving (Eq,Show,Enum)
instance SchemaType MessageSignificanceCategory_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MessageSignificanceCategory_list where
    acceptingParser =  do literal "Consequence"; return MessageSignificanceCategory_list_Consequence
                      `onFail` do literal "Currency"; return MessageSignificanceCategory_list_Currency
                      `onFail` do literal "Notification"; return MessageSignificanceCategory_list_Notification
                      
    simpleTypeText MessageSignificanceCategory_list_Consequence = "Consequence"
    simpleTypeText MessageSignificanceCategory_list_Currency = "Currency"
    simpleTypeText MessageSignificanceCategory_list_Notification = "Notification"
 
data MessageSignificanceCategory = MessageSignificanceCategory
        { messageSignificanceCategory_id :: Maybe String_primitive
        , messageSignificanceCategory_value :: Maybe MessageSignificanceCategory_list
        , messageSignificanceCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MessageSignificanceCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MessageSignificanceCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MessageSignificanceCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageSignificanceCategory_id x
                       , maybe [] (toXMLAttribute "value") $ messageSignificanceCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageSignificanceCategory_extension x
            ]
instance Extension MessageSignificanceCategory Element where
    supertype (MessageSignificanceCategory a0 a1 e0) =
               Element a0 e0
 
data DocumentMode_list
    = DocumentMode_list_Producer
      -- ^ Producer
    | DocumentMode_list_Consumer
      -- ^ Consumer
    deriving (Eq,Show,Enum)
instance SchemaType DocumentMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentMode_list where
    acceptingParser =  do literal "producer"; return DocumentMode_list_Producer
                      `onFail` do literal "consumer"; return DocumentMode_list_Consumer
                      
    simpleTypeText DocumentMode_list_Producer = "producer"
    simpleTypeText DocumentMode_list_Consumer = "consumer"
 
data DocumentMode = DocumentMode
        { documentMode_id :: Maybe String_primitive
        , documentMode_value :: Maybe DocumentMode_list
        , documentMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentMode_id x
                       , maybe [] (toXMLAttribute "value") $ documentMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentMode_extension x
            ]
instance Extension DocumentMode Element where
    supertype (DocumentMode a0 a1 e0) =
               Element a0 e0
 
data RestfulCapabilityMode_list
    = RestfulCapabilityMode_list_Client
      -- ^ Client
    | RestfulCapabilityMode_list_Server
      -- ^ Server
    deriving (Eq,Show,Enum)
instance SchemaType RestfulCapabilityMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RestfulCapabilityMode_list where
    acceptingParser =  do literal "client"; return RestfulCapabilityMode_list_Client
                      `onFail` do literal "server"; return RestfulCapabilityMode_list_Server
                      
    simpleTypeText RestfulCapabilityMode_list_Client = "client"
    simpleTypeText RestfulCapabilityMode_list_Server = "server"
 
data RestfulCapabilityMode = RestfulCapabilityMode
        { restfulCapabilityMode_id :: Maybe String_primitive
        , restfulCapabilityMode_value :: Maybe RestfulCapabilityMode_list
        , restfulCapabilityMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RestfulCapabilityMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RestfulCapabilityMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RestfulCapabilityMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ restfulCapabilityMode_id x
                       , maybe [] (toXMLAttribute "value") $ restfulCapabilityMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ restfulCapabilityMode_extension x
            ]
instance Extension RestfulCapabilityMode Element where
    supertype (RestfulCapabilityMode a0 a1 e0) =
               Element a0 e0
 
data UnknownContentCode_list
    = UnknownContentCode_list_No
      -- ^ Neither Elements or Extensions
    | UnknownContentCode_list_Extensions
      -- ^ Unknown Extensions
    | UnknownContentCode_list_Elements
      -- ^ Unknown Elements
    | UnknownContentCode_list_Both
      -- ^ Unknown Elements and Extensions
    deriving (Eq,Show,Enum)
instance SchemaType UnknownContentCode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UnknownContentCode_list where
    acceptingParser =  do literal "no"; return UnknownContentCode_list_No
                      `onFail` do literal "extensions"; return UnknownContentCode_list_Extensions
                      `onFail` do literal "elements"; return UnknownContentCode_list_Elements
                      `onFail` do literal "both"; return UnknownContentCode_list_Both
                      
    simpleTypeText UnknownContentCode_list_No = "no"
    simpleTypeText UnknownContentCode_list_Extensions = "extensions"
    simpleTypeText UnknownContentCode_list_Elements = "elements"
    simpleTypeText UnknownContentCode_list_Both = "both"
 
data UnknownContentCode = UnknownContentCode
        { unknownContentCode_id :: Maybe String_primitive
        , unknownContentCode_value :: Maybe UnknownContentCode_list
        , unknownContentCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UnknownContentCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UnknownContentCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UnknownContentCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ unknownContentCode_id x
                       , maybe [] (toXMLAttribute "value") $ unknownContentCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ unknownContentCode_extension x
            ]
instance Extension UnknownContentCode Element where
    supertype (UnknownContentCode a0 a1 e0) =
               Element a0 e0
 
data TypeRestfulInteraction_list
    = TypeRestfulInteraction_list_Read
      -- ^ read
    | TypeRestfulInteraction_list_Vread
      -- ^ vread
    | TypeRestfulInteraction_list_Update
      -- ^ update
    | TypeRestfulInteraction_list_Patch
      -- ^ patch
    | TypeRestfulInteraction_list_Delete
      -- ^ delete
    | TypeRestfulInteraction_list_History_instance
      -- ^ history-instance
    | TypeRestfulInteraction_list_History_type
      -- ^ history-type
    | TypeRestfulInteraction_list_Create
      -- ^ create
    | TypeRestfulInteraction_list_Search_type
      -- ^ search-type
    deriving (Eq,Show,Enum)
instance SchemaType TypeRestfulInteraction_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TypeRestfulInteraction_list where
    acceptingParser =  do literal "read"; return TypeRestfulInteraction_list_Read
                      `onFail` do literal "vread"; return TypeRestfulInteraction_list_Vread
                      `onFail` do literal "update"; return TypeRestfulInteraction_list_Update
                      `onFail` do literal "patch"; return TypeRestfulInteraction_list_Patch
                      `onFail` do literal "delete"; return TypeRestfulInteraction_list_Delete
                      `onFail` do literal "history-instance"; return TypeRestfulInteraction_list_History_instance
                      `onFail` do literal "history-type"; return TypeRestfulInteraction_list_History_type
                      `onFail` do literal "create"; return TypeRestfulInteraction_list_Create
                      `onFail` do literal "search-type"; return TypeRestfulInteraction_list_Search_type
                      
    simpleTypeText TypeRestfulInteraction_list_Read = "read"
    simpleTypeText TypeRestfulInteraction_list_Vread = "vread"
    simpleTypeText TypeRestfulInteraction_list_Update = "update"
    simpleTypeText TypeRestfulInteraction_list_Patch = "patch"
    simpleTypeText TypeRestfulInteraction_list_Delete = "delete"
    simpleTypeText TypeRestfulInteraction_list_History_instance = "history-instance"
    simpleTypeText TypeRestfulInteraction_list_History_type = "history-type"
    simpleTypeText TypeRestfulInteraction_list_Create = "create"
    simpleTypeText TypeRestfulInteraction_list_Search_type = "search-type"
 
data TypeRestfulInteraction = TypeRestfulInteraction
        { typeRestfulInteraction_id :: Maybe String_primitive
        , typeRestfulInteraction_value :: Maybe TypeRestfulInteraction_list
        , typeRestfulInteraction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TypeRestfulInteraction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TypeRestfulInteraction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TypeRestfulInteraction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ typeRestfulInteraction_id x
                       , maybe [] (toXMLAttribute "value") $ typeRestfulInteraction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ typeRestfulInteraction_extension x
            ]
instance Extension TypeRestfulInteraction Element where
    supertype (TypeRestfulInteraction a0 a1 e0) =
               Element a0 e0
 
data SystemRestfulInteraction_list
    = SystemRestfulInteraction_list_Transaction
      -- ^ transaction
    | SystemRestfulInteraction_list_Batch
      -- ^ batch
    | SystemRestfulInteraction_list_Search_system
      -- ^ search-system
    | SystemRestfulInteraction_list_History_system
      -- ^ history-system
    deriving (Eq,Show,Enum)
instance SchemaType SystemRestfulInteraction_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SystemRestfulInteraction_list where
    acceptingParser =  do literal "transaction"; return SystemRestfulInteraction_list_Transaction
                      `onFail` do literal "batch"; return SystemRestfulInteraction_list_Batch
                      `onFail` do literal "search-system"; return SystemRestfulInteraction_list_Search_system
                      `onFail` do literal "history-system"; return SystemRestfulInteraction_list_History_system
                      
    simpleTypeText SystemRestfulInteraction_list_Transaction = "transaction"
    simpleTypeText SystemRestfulInteraction_list_Batch = "batch"
    simpleTypeText SystemRestfulInteraction_list_Search_system = "search-system"
    simpleTypeText SystemRestfulInteraction_list_History_system = "history-system"
 
data SystemRestfulInteraction = SystemRestfulInteraction
        { systemRestfulInteraction_id :: Maybe String_primitive
        , systemRestfulInteraction_value :: Maybe SystemRestfulInteraction_list
        , systemRestfulInteraction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SystemRestfulInteraction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SystemRestfulInteraction a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SystemRestfulInteraction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ systemRestfulInteraction_id x
                       , maybe [] (toXMLAttribute "value") $ systemRestfulInteraction_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ systemRestfulInteraction_extension x
            ]
instance Extension SystemRestfulInteraction Element where
    supertype (SystemRestfulInteraction a0 a1 e0) =
               Element a0 e0
 
data ConditionalReadStatus_list
    = ConditionalReadStatus_list_Not_supported
      -- ^ Not Supported
    | ConditionalReadStatus_list_Modified_since
      -- ^ If-Modified-Since
    | ConditionalReadStatus_list_Not_match
      -- ^ If-None-Match
    | ConditionalReadStatus_list_Full_support
      -- ^ Full Support
    deriving (Eq,Show,Enum)
instance SchemaType ConditionalReadStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionalReadStatus_list where
    acceptingParser =  do literal "not-supported"; return ConditionalReadStatus_list_Not_supported
                      `onFail` do literal "modified-since"; return ConditionalReadStatus_list_Modified_since
                      `onFail` do literal "not-match"; return ConditionalReadStatus_list_Not_match
                      `onFail` do literal "full-support"; return ConditionalReadStatus_list_Full_support
                      
    simpleTypeText ConditionalReadStatus_list_Not_supported = "not-supported"
    simpleTypeText ConditionalReadStatus_list_Modified_since = "modified-since"
    simpleTypeText ConditionalReadStatus_list_Not_match = "not-match"
    simpleTypeText ConditionalReadStatus_list_Full_support = "full-support"
 
data ConditionalReadStatus = ConditionalReadStatus
        { conditionalReadStatus_id :: Maybe String_primitive
        , conditionalReadStatus_value :: Maybe ConditionalReadStatus_list
        , conditionalReadStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionalReadStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionalReadStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionalReadStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionalReadStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionalReadStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionalReadStatus_extension x
            ]
instance Extension ConditionalReadStatus Element where
    supertype (ConditionalReadStatus a0 a1 e0) =
               Element a0 e0
 
data ReferenceHandlingPolicy_list
    = ReferenceHandlingPolicy_list_Literal
      -- ^ Literal References
    | ReferenceHandlingPolicy_list_Logical
      -- ^ Logical References
    | ReferenceHandlingPolicy_list_Resolves
      -- ^ Resolves References
    | ReferenceHandlingPolicy_list_Enforced
      -- ^ Reference Integrity Enforced
    | ReferenceHandlingPolicy_list_Local
      -- ^ Local References Only
    deriving (Eq,Show,Enum)
instance SchemaType ReferenceHandlingPolicy_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ReferenceHandlingPolicy_list where
    acceptingParser =  do literal "literal"; return ReferenceHandlingPolicy_list_Literal
                      `onFail` do literal "logical"; return ReferenceHandlingPolicy_list_Logical
                      `onFail` do literal "resolves"; return ReferenceHandlingPolicy_list_Resolves
                      `onFail` do literal "enforced"; return ReferenceHandlingPolicy_list_Enforced
                      `onFail` do literal "local"; return ReferenceHandlingPolicy_list_Local
                      
    simpleTypeText ReferenceHandlingPolicy_list_Literal = "literal"
    simpleTypeText ReferenceHandlingPolicy_list_Logical = "logical"
    simpleTypeText ReferenceHandlingPolicy_list_Resolves = "resolves"
    simpleTypeText ReferenceHandlingPolicy_list_Enforced = "enforced"
    simpleTypeText ReferenceHandlingPolicy_list_Local = "local"
 
data ReferenceHandlingPolicy = ReferenceHandlingPolicy
        { referenceHandlingPolicy_id :: Maybe String_primitive
        , referenceHandlingPolicy_value :: Maybe ReferenceHandlingPolicy_list
        , referenceHandlingPolicy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ReferenceHandlingPolicy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ReferenceHandlingPolicy a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ReferenceHandlingPolicy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referenceHandlingPolicy_id x
                       , maybe [] (toXMLAttribute "value") $ referenceHandlingPolicy_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referenceHandlingPolicy_extension x
            ]
instance Extension ReferenceHandlingPolicy Element where
    supertype (ReferenceHandlingPolicy a0 a1 e0) =
               Element a0 e0
 
data ConditionalDeleteStatus_list
    = ConditionalDeleteStatus_list_Not_supported
      -- ^ Not Supported
    | ConditionalDeleteStatus_list_Single
      -- ^ Single Deletes Supported
    | ConditionalDeleteStatus_list_Multiple
      -- ^ Multiple Deletes Supported
    deriving (Eq,Show,Enum)
instance SchemaType ConditionalDeleteStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionalDeleteStatus_list where
    acceptingParser =  do literal "not-supported"; return ConditionalDeleteStatus_list_Not_supported
                      `onFail` do literal "single"; return ConditionalDeleteStatus_list_Single
                      `onFail` do literal "multiple"; return ConditionalDeleteStatus_list_Multiple
                      
    simpleTypeText ConditionalDeleteStatus_list_Not_supported = "not-supported"
    simpleTypeText ConditionalDeleteStatus_list_Single = "single"
    simpleTypeText ConditionalDeleteStatus_list_Multiple = "multiple"
 
data ConditionalDeleteStatus = ConditionalDeleteStatus
        { conditionalDeleteStatus_id :: Maybe String_primitive
        , conditionalDeleteStatus_value :: Maybe ConditionalDeleteStatus_list
        , conditionalDeleteStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionalDeleteStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionalDeleteStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionalDeleteStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionalDeleteStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionalDeleteStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionalDeleteStatus_extension x
            ]
instance Extension ConditionalDeleteStatus Element where
    supertype (ConditionalDeleteStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
elementCarePlan :: XMLParser CarePlan
elementCarePlan = parseSchemaType "CarePlan"
elementToXMLCarePlan :: CarePlan -> [Content ()]
elementToXMLCarePlan = schemaTypeToXML "CarePlan"
 
data CarePlan = CarePlan
        { carePlan_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , carePlan_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , carePlan_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , carePlan_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , carePlan_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , carePlan_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , carePlan_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlan_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlan_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care plan 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , carePlan_definition :: [Reference]
          -- ^ Identifies the protocol, questionnaire, guideline or other 
          --   specification the care plan should be conducted in 
          --   accordance with.
        , carePlan_basedOn :: [Reference]
          -- ^ A care plan that is fulfilled in whole or in part by this 
          --   care plan.
        , carePlan_replaces :: [Reference]
          -- ^ Completed or terminated care plan whose function is taken 
          --   by this new care plan.
        , carePlan_partOf :: [Reference]
          -- ^ A larger care plan of which this particular care plan is a 
          --   component or step.
        , carePlan_status :: CarePlanStatus
          -- ^ Indicates whether the plan is currently being acted upon, 
          --   represents future intentions or is now a historical record.
        , carePlan_intent :: CarePlanIntent
          -- ^ Indicates the level of authority/intentionality associated 
          --   with the care plan and where the care plan fits into the 
          --   workflow chain.
        , carePlan_category :: [CodeableConcept]
          -- ^ Identifies what &quot;kind&quot; of plan this is to support 
          --   differentiation between multiple co-existing plans; e.g. 
          --   &quot;Home health&quot;, &quot;psychiatric&quot;, 
          --   &quot;asthma&quot;, &quot;disease management&quot;, 
          --   &quot;wellness plan&quot;, etc.
        , carePlan_title :: Maybe Xsd.XsdString
          -- ^ Human-friendly name for the CarePlan.
        , carePlan_description :: Maybe Xsd.XsdString
          -- ^ A description of the scope and nature of the plan.
        , carePlan_subject :: Reference
          -- ^ Identifies the patient or group whose intended care is 
          --   described by the plan.
        , carePlan_context :: Maybe Reference
          -- ^ Identifies the original context in which this particular 
          --   CarePlan was created.
        , carePlan_period :: Maybe Period
          -- ^ Indicates when the plan did (or is intended to) come into 
          --   effect and end.
        , carePlan_author :: [Reference]
          -- ^ Identifies the individual(s) or ogranization who is 
          --   responsible for the content of the care plan.
        , carePlan_careTeam :: [Reference]
          -- ^ Identifies all people and organizations who are expected to 
          --   be involved in the care envisioned by this plan.
        , carePlan_addresses :: [Reference]
          -- ^ Identifies the conditions/problems/concerns/diagnoses/etc. 
          --   whose management and/or mitigation are handled by this 
          --   plan.
        , carePlan_supportingInfo :: [Reference]
          -- ^ Identifies portions of the patient's record that 
          --   specifically influenced the formation of the plan. These 
          --   might include co-morbidities, recent procedures, 
          --   limitations, recent assessments, etc.
        , carePlan_goal :: [Reference]
          -- ^ Describes the intended objective(s) of carrying out the 
          --   care plan.
        , carePlan_activity :: [CarePlanActivity]
          -- ^ Identifies a planned action to occur as part of the plan. 
          --   For example, a medication to be used, lab tests to perform, 
          --   self-monitoring, education, etc.
        , carePlan_note :: [Annotation]
          -- ^ General notes about the care plan not covered elsewhere.
        }
        deriving (Eq,Show)
instance SchemaType CarePlan where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CarePlan
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "author")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "goal")
            `apply` many (parseSchemaType "activity")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CarePlan{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ carePlan_id x
            , maybe [] (schemaTypeToXML "meta") $ carePlan_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ carePlan_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ carePlan_language x
            , maybe [] (schemaTypeToXML "text") $ carePlan_text x
            , concatMap (schemaTypeToXML "contained") $ carePlan_contained x
            , concatMap (schemaTypeToXML "extension") $ carePlan_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlan_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ carePlan_identifier x
            , concatMap (schemaTypeToXML "definition") $ carePlan_definition x
            , concatMap (schemaTypeToXML "basedOn") $ carePlan_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ carePlan_replaces x
            , concatMap (schemaTypeToXML "partOf") $ carePlan_partOf x
            , schemaTypeToXML "status" $ carePlan_status x
            , schemaTypeToXML "intent" $ carePlan_intent x
            , concatMap (schemaTypeToXML "category") $ carePlan_category x
            , maybe [] (schemaTypeToXML "title") $ carePlan_title x
            , maybe [] (schemaTypeToXML "description") $ carePlan_description x
            , schemaTypeToXML "subject" $ carePlan_subject x
            , maybe [] (schemaTypeToXML "context") $ carePlan_context x
            , maybe [] (schemaTypeToXML "period") $ carePlan_period x
            , concatMap (schemaTypeToXML "author") $ carePlan_author x
            , concatMap (schemaTypeToXML "careTeam") $ carePlan_careTeam x
            , concatMap (schemaTypeToXML "addresses") $ carePlan_addresses x
            , concatMap (schemaTypeToXML "supportingInfo") $ carePlan_supportingInfo x
            , concatMap (schemaTypeToXML "goal") $ carePlan_goal x
            , concatMap (schemaTypeToXML "activity") $ carePlan_activity x
            , concatMap (schemaTypeToXML "note") $ carePlan_note x
            ]
instance Extension CarePlan DomainResource where
    supertype (CarePlan e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CarePlan Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CarePlan -> DomainResource)
              
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
data CarePlanActivity = CarePlanActivity
        { carePlanActivity_id :: Maybe String_primitive
        , carePlanActivity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlanActivity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlanActivity_outcomeCodeableConcept :: [CodeableConcept]
          -- ^ Identifies the outcome at the point when the status of the 
          --   activity is assessed. For example, the outcome of an 
          --   education activity could be patient understands (or not).
        , carePlanActivity_outcomeReference :: [Reference]
          -- ^ Details of the outcome or action resulting from the 
          --   activity. The reference to an &quot;event&quot; resource, 
          --   such as Procedure or Encounter or Observation, is the 
          --   result/outcome of the activity itself. The activity can be 
          --   conveyed using CarePlan.activity.detail OR using the 
          --   CarePlan.activity.reference (a reference to a â€œrequestâ€ 
          --   resource).
        , carePlanActivity_progress :: [Annotation]
          -- ^ Notes about the adherence/status/progress of the activity.
        , carePlanActivity_reference :: Maybe Reference
          -- ^ The details of the proposed activity represented in a 
          --   specific resource.
        , carePlanActivity_detail :: Maybe CarePlanDetail
          -- ^ A simple summary of a planned activity suitable for a 
          --   general care plan system (e.g. form driven) that doesn't 
          --   know about specific resources such as procedure etc.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanActivity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CarePlanActivity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "outcomeCodeableConcept")
            `apply` many (parseSchemaType "outcomeReference")
            `apply` many (parseSchemaType "progress")
            `apply` optional (parseSchemaType "reference")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@CarePlanActivity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanActivity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanActivity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlanActivity_modifierExtension x
            , concatMap (schemaTypeToXML "outcomeCodeableConcept") $ carePlanActivity_outcomeCodeableConcept x
            , concatMap (schemaTypeToXML "outcomeReference") $ carePlanActivity_outcomeReference x
            , concatMap (schemaTypeToXML "progress") $ carePlanActivity_progress x
            , maybe [] (schemaTypeToXML "reference") $ carePlanActivity_reference x
            , maybe [] (schemaTypeToXML "detail") $ carePlanActivity_detail x
            ]
instance Extension CarePlanActivity BackboneElement where
    supertype (CarePlanActivity a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension CarePlanActivity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CarePlanActivity -> BackboneElement)
              
 
-- | Describes the intention of how one or more practitioners 
--   intend to deliver care for a particular patient, group or 
--   community for a period of time, possibly limited to care 
--   for a specific condition or set of conditions.
data CarePlanDetail = CarePlanDetail
        { carePlanDetail_id :: Maybe String_primitive
        , carePlanDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , carePlanDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , carePlanDetail_category :: Maybe CodeableConcept
          -- ^ High-level categorization of the type of activity in a care 
          --   plan.
        , carePlanDetail_definition :: Maybe Reference
          -- ^ Identifies the protocol, questionnaire, guideline or other 
          --   specification the planned activity should be conducted in 
          --   accordance with.
        , carePlanDetail_code :: Maybe CodeableConcept
          -- ^ Detailed description of the type of planned activity; e.g. 
          --   What lab test, what procedure, what kind of encounter.
        , carePlanDetail_reasonCode :: [CodeableConcept]
          -- ^ Provides the rationale that drove the inclusion of this 
          --   particular activity as part of the plan or the reason why 
          --   the activity was prohibited.
        , carePlanDetail_reasonReference :: [Reference]
          -- ^ Provides the health condition(s) that drove the inclusion 
          --   of this particular activity as part of the plan.
        , carePlanDetail_goal :: [Reference]
          -- ^ Internal reference that identifies the goals that this 
          --   activity is intended to contribute towards meeting.
        , carePlanDetail_status :: CarePlanActivityStatus
          -- ^ Identifies what progress is being made for the specific 
          --   activity.
        , carePlanDetail_statusReason :: Maybe Xsd.XsdString
          -- ^ Provides reason why the activity isn't yet started, is on 
          --   hold, was cancelled, etc.
        , carePlanDetail_prohibited :: Maybe Boolean
          -- ^ If true, indicates that the described activity is one that 
          --   must NOT be engaged in when following the plan. If false, 
          --   indicates that the described activity is one that should be 
          --   engaged in when following the plan.
        , carePlanDetail_choice11 :: (Maybe (OneOf3 Timing Period Xsd.XsdString))
          -- ^ The period, timing or frequency upon which the described 
          --   activity is to occur.
          --   
          --   Choice between:
          --   
          --   (1) scheduledTiming
          --   
          --   (2) scheduledPeriod
          --   
          --   (3) scheduledString
        , carePlanDetail_location :: Maybe Reference
          -- ^ Identifies the facility where the activity will occur; e.g. 
          --   home, hospital, specific clinic, etc.
        , carePlanDetail_performer :: [Reference]
          -- ^ Identifies who's expected to be involved in the activity.
        , carePlanDetail_choice14 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Identifies the food, drug or other product to be consumed 
          --   or supplied in the activity.
          --   
          --   Choice between:
          --   
          --   (1) productCodeableConcept
          --   
          --   (2) productReference
        , carePlanDetail_dailyAmount :: Maybe Quantity
          -- ^ Identifies the quantity expected to be consumed in a given 
          --   day.
        , carePlanDetail_quantity :: Maybe Quantity
          -- ^ Identifies the quantity expected to be supplied, 
          --   administered or consumed by the subject.
        , carePlanDetail_description :: Maybe Xsd.XsdString
          -- ^ This provides a textual description of constraints on the 
          --   intended activity occurrence, including relation to other 
          --   activities. It may also include objectives, pre-conditions 
          --   and end-conditions. Finally, it may convey specifics about 
          --   the activity such as body site, method, route, etc.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CarePlanDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "goal")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "prohibited")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf3 (parseSchemaType "scheduledTiming"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "scheduledPeriod"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "scheduledString"))
                                     ])
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "productCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "productReference"))
                                     ])
            `apply` optional (parseSchemaType "dailyAmount")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@CarePlanDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ carePlanDetail_modifierExtension x
            , maybe [] (schemaTypeToXML "category") $ carePlanDetail_category x
            , maybe [] (schemaTypeToXML "definition") $ carePlanDetail_definition x
            , maybe [] (schemaTypeToXML "code") $ carePlanDetail_code x
            , concatMap (schemaTypeToXML "reasonCode") $ carePlanDetail_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ carePlanDetail_reasonReference x
            , concatMap (schemaTypeToXML "goal") $ carePlanDetail_goal x
            , schemaTypeToXML "status" $ carePlanDetail_status x
            , maybe [] (schemaTypeToXML "statusReason") $ carePlanDetail_statusReason x
            , maybe [] (schemaTypeToXML "prohibited") $ carePlanDetail_prohibited x
            , maybe [] (foldOneOf3  (schemaTypeToXML "scheduledTiming")
                                    (schemaTypeToXML "scheduledPeriod")
                                    (schemaTypeToXML "scheduledString")
                                   ) $ carePlanDetail_choice11 x
            , maybe [] (schemaTypeToXML "location") $ carePlanDetail_location x
            , concatMap (schemaTypeToXML "performer") $ carePlanDetail_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "productCodeableConcept")
                                    (schemaTypeToXML "productReference")
                                   ) $ carePlanDetail_choice14 x
            , maybe [] (schemaTypeToXML "dailyAmount") $ carePlanDetail_dailyAmount x
            , maybe [] (schemaTypeToXML "quantity") $ carePlanDetail_quantity x
            , maybe [] (schemaTypeToXML "description") $ carePlanDetail_description x
            ]
instance Extension CarePlanDetail BackboneElement where
    supertype (CarePlanDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               BackboneElement a0 e0 e1
instance Extension CarePlanDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CarePlanDetail -> BackboneElement)
              
 
data CarePlanStatus_list
    = CarePlanStatus_list_Draft
      -- ^ Pending
    | CarePlanStatus_list_Active
      -- ^ Active
    | CarePlanStatus_list_Suspended
      -- ^ Suspended
    | CarePlanStatus_list_Completed
      -- ^ Completed
    | CarePlanStatus_list_Entered_in_error
      -- ^ Entered In Error
    | CarePlanStatus_list_Cancelled
      -- ^ Cancelled
    | CarePlanStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanStatus_list where
    acceptingParser =  do literal "draft"; return CarePlanStatus_list_Draft
                      `onFail` do literal "active"; return CarePlanStatus_list_Active
                      `onFail` do literal "suspended"; return CarePlanStatus_list_Suspended
                      `onFail` do literal "completed"; return CarePlanStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return CarePlanStatus_list_Entered_in_error
                      `onFail` do literal "cancelled"; return CarePlanStatus_list_Cancelled
                      `onFail` do literal "unknown"; return CarePlanStatus_list_Unknown
                      
    simpleTypeText CarePlanStatus_list_Draft = "draft"
    simpleTypeText CarePlanStatus_list_Active = "active"
    simpleTypeText CarePlanStatus_list_Suspended = "suspended"
    simpleTypeText CarePlanStatus_list_Completed = "completed"
    simpleTypeText CarePlanStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText CarePlanStatus_list_Cancelled = "cancelled"
    simpleTypeText CarePlanStatus_list_Unknown = "unknown"
 
data CarePlanStatus = CarePlanStatus
        { carePlanStatus_id :: Maybe String_primitive
        , carePlanStatus_value :: Maybe CarePlanStatus_list
        , carePlanStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanStatus_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanStatus_extension x
            ]
instance Extension CarePlanStatus Element where
    supertype (CarePlanStatus a0 a1 e0) =
               Element a0 e0
 
data CarePlanActivityStatus_list
    = CarePlanActivityStatus_list_Not_started
      -- ^ Not Started
    | CarePlanActivityStatus_list_Scheduled
      -- ^ Scheduled
    | CarePlanActivityStatus_list_In_progress
      -- ^ In Progress
    | CarePlanActivityStatus_list_On_hold
      -- ^ On Hold
    | CarePlanActivityStatus_list_Completed
      -- ^ Completed
    | CarePlanActivityStatus_list_Cancelled
      -- ^ Cancelled
    | CarePlanActivityStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanActivityStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanActivityStatus_list where
    acceptingParser =  do literal "not-started"; return CarePlanActivityStatus_list_Not_started
                      `onFail` do literal "scheduled"; return CarePlanActivityStatus_list_Scheduled
                      `onFail` do literal "in-progress"; return CarePlanActivityStatus_list_In_progress
                      `onFail` do literal "on-hold"; return CarePlanActivityStatus_list_On_hold
                      `onFail` do literal "completed"; return CarePlanActivityStatus_list_Completed
                      `onFail` do literal "cancelled"; return CarePlanActivityStatus_list_Cancelled
                      `onFail` do literal "unknown"; return CarePlanActivityStatus_list_Unknown
                      
    simpleTypeText CarePlanActivityStatus_list_Not_started = "not-started"
    simpleTypeText CarePlanActivityStatus_list_Scheduled = "scheduled"
    simpleTypeText CarePlanActivityStatus_list_In_progress = "in-progress"
    simpleTypeText CarePlanActivityStatus_list_On_hold = "on-hold"
    simpleTypeText CarePlanActivityStatus_list_Completed = "completed"
    simpleTypeText CarePlanActivityStatus_list_Cancelled = "cancelled"
    simpleTypeText CarePlanActivityStatus_list_Unknown = "unknown"
 
data CarePlanActivityStatus = CarePlanActivityStatus
        { carePlanActivityStatus_id :: Maybe String_primitive
        , carePlanActivityStatus_value :: Maybe CarePlanActivityStatus_list
        , carePlanActivityStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanActivityStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanActivityStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanActivityStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanActivityStatus_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanActivityStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanActivityStatus_extension x
            ]
instance Extension CarePlanActivityStatus Element where
    supertype (CarePlanActivityStatus a0 a1 e0) =
               Element a0 e0
 
data CarePlanIntent_list
    = CarePlanIntent_list_Proposal
      -- ^ Proposal
    | CarePlanIntent_list_Plan
      -- ^ Plan
    | CarePlanIntent_list_Order
      -- ^ Order
    | CarePlanIntent_list_Option
      -- ^ Option
    deriving (Eq,Show,Enum)
instance SchemaType CarePlanIntent_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CarePlanIntent_list where
    acceptingParser =  do literal "proposal"; return CarePlanIntent_list_Proposal
                      `onFail` do literal "plan"; return CarePlanIntent_list_Plan
                      `onFail` do literal "order"; return CarePlanIntent_list_Order
                      `onFail` do literal "option"; return CarePlanIntent_list_Option
                      
    simpleTypeText CarePlanIntent_list_Proposal = "proposal"
    simpleTypeText CarePlanIntent_list_Plan = "plan"
    simpleTypeText CarePlanIntent_list_Order = "order"
    simpleTypeText CarePlanIntent_list_Option = "option"
 
data CarePlanIntent = CarePlanIntent
        { carePlanIntent_id :: Maybe String_primitive
        , carePlanIntent_value :: Maybe CarePlanIntent_list
        , carePlanIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CarePlanIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CarePlanIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CarePlanIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ carePlanIntent_id x
                       , maybe [] (toXMLAttribute "value") $ carePlanIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ carePlanIntent_extension x
            ]
instance Extension CarePlanIntent Element where
    supertype (CarePlanIntent a0 a1 e0) =
               Element a0 e0
 
-- | The Care Team includes all the people and organizations who 
--   plan to participate in the coordination and delivery of 
--   care for a patient.
elementCareTeam :: XMLParser CareTeam
elementCareTeam = parseSchemaType "CareTeam"
elementToXMLCareTeam :: CareTeam -> [Content ()]
elementToXMLCareTeam = schemaTypeToXML "CareTeam"
 
data CareTeam = CareTeam
        { careTeam_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , careTeam_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , careTeam_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , careTeam_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , careTeam_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , careTeam_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , careTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , careTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , careTeam_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care team 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate.
        , careTeam_status :: Maybe CareTeamStatus
          -- ^ Indicates the current state of the care team.
        , careTeam_category :: [CodeableConcept]
          -- ^ Identifies what kind of team. This is to support 
          --   differentiation between multiple co-existing teams, such as 
          --   care plan team, episode of care team, longitudinal care 
          --   team.
        , careTeam_name :: Maybe Xsd.XsdString
          -- ^ A label for human use intended to distinguish like teams. 
          --   E.g. the &quot;red&quot; vs. &quot;green&quot; trauma 
          --   teams.
        , careTeam_subject :: Maybe Reference
          -- ^ Identifies the patient or group whose intended care is 
          --   handled by the team.
        , careTeam_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this care team.
        , careTeam_period :: Maybe Period
          -- ^ Indicates when the team did (or is intended to) come into 
          --   effect and end.
        , careTeam_participant :: [CareTeamParticipant]
          -- ^ Identifies all people and organizations who are expected to 
          --   be involved in the care team.
        , careTeam_reasonCode :: [CodeableConcept]
          -- ^ Describes why the care team exists.
        , careTeam_reasonReference :: [Reference]
          -- ^ Condition(s) that this care team addresses.
        , careTeam_managingOrganization :: [Reference]
          -- ^ The organization responsible for the care team.
        , careTeam_note :: [Annotation]
          -- ^ Comments made about the CareTeam.
        }
        deriving (Eq,Show)
instance SchemaType CareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CareTeam
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "participant")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CareTeam{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ careTeam_id x
            , maybe [] (schemaTypeToXML "meta") $ careTeam_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ careTeam_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ careTeam_language x
            , maybe [] (schemaTypeToXML "text") $ careTeam_text x
            , concatMap (schemaTypeToXML "contained") $ careTeam_contained x
            , concatMap (schemaTypeToXML "extension") $ careTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ careTeam_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ careTeam_identifier x
            , maybe [] (schemaTypeToXML "status") $ careTeam_status x
            , concatMap (schemaTypeToXML "category") $ careTeam_category x
            , maybe [] (schemaTypeToXML "name") $ careTeam_name x
            , maybe [] (schemaTypeToXML "subject") $ careTeam_subject x
            , maybe [] (schemaTypeToXML "context") $ careTeam_context x
            , maybe [] (schemaTypeToXML "period") $ careTeam_period x
            , concatMap (schemaTypeToXML "participant") $ careTeam_participant x
            , concatMap (schemaTypeToXML "reasonCode") $ careTeam_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ careTeam_reasonReference x
            , concatMap (schemaTypeToXML "managingOrganization") $ careTeam_managingOrganization x
            , concatMap (schemaTypeToXML "note") $ careTeam_note x
            ]
instance Extension CareTeam DomainResource where
    supertype (CareTeam e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CareTeam Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CareTeam -> DomainResource)
              
 
-- | The Care Team includes all the people and organizations who 
--   plan to participate in the coordination and delivery of 
--   care for a patient.
data CareTeamParticipant = CareTeamParticipant
        { careTeamParticipant_id :: Maybe String_primitive
        , careTeamParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , careTeamParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , careTeamParticipant_role :: Maybe CodeableConcept
          -- ^ Indicates specific responsibility of an individual within 
          --   the care team, such as &quot;Primary care physician&quot;, 
          --   &quot;Trained social worker counselor&quot;, 
          --   &quot;Caregiver&quot;, etc.
        , careTeamParticipant_member :: Maybe Reference
          -- ^ The specific person or organization who is 
          --   participating/expected to participate in the care team.
        , careTeamParticipant_onBehalfOf :: Maybe Reference
          -- ^ The organization of the practitioner.
        , careTeamParticipant_period :: Maybe Period
          -- ^ Indicates when the specific member or organization did (or 
          --   is intended to) come into effect and end.
        }
        deriving (Eq,Show)
instance SchemaType CareTeamParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CareTeamParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "member")
            `apply` optional (parseSchemaType "onBehalfOf")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@CareTeamParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ careTeamParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ careTeamParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ careTeamParticipant_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ careTeamParticipant_role x
            , maybe [] (schemaTypeToXML "member") $ careTeamParticipant_member x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ careTeamParticipant_onBehalfOf x
            , maybe [] (schemaTypeToXML "period") $ careTeamParticipant_period x
            ]
instance Extension CareTeamParticipant BackboneElement where
    supertype (CareTeamParticipant a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CareTeamParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CareTeamParticipant -> BackboneElement)
              
 
data CareTeamStatus_list
    = CareTeamStatus_list_Proposed
      -- ^ Proposed
    | CareTeamStatus_list_Active
      -- ^ Active
    | CareTeamStatus_list_Suspended
      -- ^ Suspended
    | CareTeamStatus_list_Inactive
      -- ^ Inactive
    | CareTeamStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType CareTeamStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CareTeamStatus_list where
    acceptingParser =  do literal "proposed"; return CareTeamStatus_list_Proposed
                      `onFail` do literal "active"; return CareTeamStatus_list_Active
                      `onFail` do literal "suspended"; return CareTeamStatus_list_Suspended
                      `onFail` do literal "inactive"; return CareTeamStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return CareTeamStatus_list_Entered_in_error
                      
    simpleTypeText CareTeamStatus_list_Proposed = "proposed"
    simpleTypeText CareTeamStatus_list_Active = "active"
    simpleTypeText CareTeamStatus_list_Suspended = "suspended"
    simpleTypeText CareTeamStatus_list_Inactive = "inactive"
    simpleTypeText CareTeamStatus_list_Entered_in_error = "entered-in-error"
 
data CareTeamStatus = CareTeamStatus
        { careTeamStatus_id :: Maybe String_primitive
        , careTeamStatus_value :: Maybe CareTeamStatus_list
        , careTeamStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CareTeamStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CareTeamStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CareTeamStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ careTeamStatus_id x
                       , maybe [] (toXMLAttribute "value") $ careTeamStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ careTeamStatus_extension x
            ]
instance Extension CareTeamStatus Element where
    supertype (CareTeamStatus a0 a1 e0) =
               Element a0 e0
 
-- | The resource ChargeItem describes the provision of 
--   healthcare provider products for a certain patient, 
--   therefore referring not only to the product, but containing 
--   in addition details of the provision, like date, time, 
--   amounts and participating organizations and persons. Main 
--   Usage of the ChargeItem is to enable the billing process 
--   and internal cost allocation.
elementChargeItem :: XMLParser ChargeItem
elementChargeItem = parseSchemaType "ChargeItem"
elementToXMLChargeItem :: ChargeItem -> [Content ()]
elementToXMLChargeItem = schemaTypeToXML "ChargeItem"
 
data ChargeItem = ChargeItem
        { chargeItem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , chargeItem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , chargeItem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , chargeItem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , chargeItem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , chargeItem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , chargeItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , chargeItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , chargeItem_identifier :: Maybe Identifier
          -- ^ Identifiers assigned to this event performer or other 
          --   systems.
        , chargeItem_definition :: [Uri]
          -- ^ References the source of pricing information, rules of 
          --   application for the code this ChargeItem uses.
        , chargeItem_status :: ChargeItemStatus
          -- ^ The current state of the ChargeItem.
        , chargeItem_partOf :: [Reference]
          -- ^ ChargeItems can be grouped to larger ChargeItems covering 
          --   the whole set.
        , chargeItem_code :: CodeableConcept
          -- ^ A code that identifies the charge, like a billing code.
        , chargeItem_subject :: Reference
          -- ^ The individual or set of individuals the action is being or 
          --   was performed on.
        , chargeItem_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this event.
        , chargeItem_choice15 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ Date/time(s) or duration when the charged service was 
          --   applied.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , chargeItem_participant :: [ChargeItemParticipant]
          -- ^ Indicates who or what performed or participated in the 
          --   charged service.
        , chargeItem_performingOrganization :: Maybe Reference
          -- ^ The organization requesting the service.
        , chargeItem_requestingOrganization :: Maybe Reference
          -- ^ The organization performing the service.
        , chargeItem_quantity :: Maybe Quantity
          -- ^ Quantity of which the charge item has been serviced.
        , chargeItem_bodysite :: [CodeableConcept]
          -- ^ The anatomical location where the related service has been 
          --   applied.
        , chargeItem_factorOverride :: Maybe Decimal
          -- ^ Factor overriding the factor determined by the rules 
          --   associated with the code.
        , chargeItem_priceOverride :: Maybe Money
          -- ^ Total price of the charge overriding the list price 
          --   associated with the code.
        , chargeItem_overrideReason :: Maybe Xsd.XsdString
          -- ^ If the list price or the rule based factor associated with 
          --   the code is overridden, this attribute can capture a text 
          --   to indicate the reason for this action.
        , chargeItem_enterer :: Maybe Reference
          -- ^ The device, practitioner, etc. who entered the charge item.
        , chargeItem_enteredDate :: Maybe DateTime
          -- ^ Date the charge item was entered.
        , chargeItem_reason :: [CodeableConcept]
          -- ^ Describes why the event occurred in coded or textual form.
        , chargeItem_service :: [Reference]
          -- ^ Indicated the rendered service that caused this charge.
        , chargeItem_account :: [Reference]
          -- ^ Account into which this ChargeItems belongs.
        , chargeItem_note :: [Annotation]
          -- ^ Comments made about the event by the performer, subject or 
          --   other participants.
        , chargeItem_supportingInformation :: [Reference]
          -- ^ Further information supporting the this charge.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ChargeItem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "performingOrganization")
            `apply` optional (parseSchemaType "requestingOrganization")
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "bodysite")
            `apply` optional (parseSchemaType "factorOverride")
            `apply` optional (parseSchemaType "priceOverride")
            `apply` optional (parseSchemaType "overrideReason")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "enteredDate")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "service")
            `apply` many (parseSchemaType "account")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "supportingInformation")
    schemaTypeToXML s x@ChargeItem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ chargeItem_id x
            , maybe [] (schemaTypeToXML "meta") $ chargeItem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ chargeItem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ chargeItem_language x
            , maybe [] (schemaTypeToXML "text") $ chargeItem_text x
            , concatMap (schemaTypeToXML "contained") $ chargeItem_contained x
            , concatMap (schemaTypeToXML "extension") $ chargeItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ chargeItem_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ chargeItem_identifier x
            , concatMap (schemaTypeToXML "definition") $ chargeItem_definition x
            , schemaTypeToXML "status" $ chargeItem_status x
            , concatMap (schemaTypeToXML "partOf") $ chargeItem_partOf x
            , schemaTypeToXML "code" $ chargeItem_code x
            , schemaTypeToXML "subject" $ chargeItem_subject x
            , maybe [] (schemaTypeToXML "context") $ chargeItem_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ chargeItem_choice15 x
            , concatMap (schemaTypeToXML "participant") $ chargeItem_participant x
            , maybe [] (schemaTypeToXML "performingOrganization") $ chargeItem_performingOrganization x
            , maybe [] (schemaTypeToXML "requestingOrganization") $ chargeItem_requestingOrganization x
            , maybe [] (schemaTypeToXML "quantity") $ chargeItem_quantity x
            , concatMap (schemaTypeToXML "bodysite") $ chargeItem_bodysite x
            , maybe [] (schemaTypeToXML "factorOverride") $ chargeItem_factorOverride x
            , maybe [] (schemaTypeToXML "priceOverride") $ chargeItem_priceOverride x
            , maybe [] (schemaTypeToXML "overrideReason") $ chargeItem_overrideReason x
            , maybe [] (schemaTypeToXML "enterer") $ chargeItem_enterer x
            , maybe [] (schemaTypeToXML "enteredDate") $ chargeItem_enteredDate x
            , concatMap (schemaTypeToXML "reason") $ chargeItem_reason x
            , concatMap (schemaTypeToXML "service") $ chargeItem_service x
            , concatMap (schemaTypeToXML "account") $ chargeItem_account x
            , concatMap (schemaTypeToXML "note") $ chargeItem_note x
            , concatMap (schemaTypeToXML "supportingInformation") $ chargeItem_supportingInformation x
            ]
instance Extension ChargeItem DomainResource where
    supertype (ChargeItem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ChargeItem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ChargeItem -> DomainResource)
              
 
-- | The resource ChargeItem describes the provision of 
--   healthcare provider products for a certain patient, 
--   therefore referring not only to the product, but containing 
--   in addition details of the provision, like date, time, 
--   amounts and participating organizations and persons. Main 
--   Usage of the ChargeItem is to enable the billing process 
--   and internal cost allocation.
data ChargeItemParticipant = ChargeItemParticipant
        { chargeItemParticipant_id :: Maybe String_primitive
        , chargeItemParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , chargeItemParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , chargeItemParticipant_role :: Maybe CodeableConcept
          -- ^ Describes the type of performance or participation(e.g. 
          --   primary surgeon, anaesthesiologiest, etc.).
        , chargeItemParticipant_actor :: Reference
          -- ^ The device, practitioner, etc. who performed or 
          --   participated in the service.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItemParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ChargeItemParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@ChargeItemParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ chargeItemParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ chargeItemParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ chargeItemParticipant_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ chargeItemParticipant_role x
            , schemaTypeToXML "actor" $ chargeItemParticipant_actor x
            ]
instance Extension ChargeItemParticipant BackboneElement where
    supertype (ChargeItemParticipant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ChargeItemParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ChargeItemParticipant -> BackboneElement)
              
 
data ChargeItemStatus_list
    = ChargeItemStatus_list_Planned
      -- ^ Planned
    | ChargeItemStatus_list_Billable
      -- ^ Billable
    | ChargeItemStatus_list_Not_billable
      -- ^ Not billable
    | ChargeItemStatus_list_Aborted
      -- ^ Aborted
    | ChargeItemStatus_list_Billed
      -- ^ Billed
    | ChargeItemStatus_list_Entered_in_error
      -- ^ Entered in Error
    | ChargeItemStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ChargeItemStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ChargeItemStatus_list where
    acceptingParser =  do literal "planned"; return ChargeItemStatus_list_Planned
                      `onFail` do literal "billable"; return ChargeItemStatus_list_Billable
                      `onFail` do literal "not-billable"; return ChargeItemStatus_list_Not_billable
                      `onFail` do literal "aborted"; return ChargeItemStatus_list_Aborted
                      `onFail` do literal "billed"; return ChargeItemStatus_list_Billed
                      `onFail` do literal "entered-in-error"; return ChargeItemStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return ChargeItemStatus_list_Unknown
                      
    simpleTypeText ChargeItemStatus_list_Planned = "planned"
    simpleTypeText ChargeItemStatus_list_Billable = "billable"
    simpleTypeText ChargeItemStatus_list_Not_billable = "not-billable"
    simpleTypeText ChargeItemStatus_list_Aborted = "aborted"
    simpleTypeText ChargeItemStatus_list_Billed = "billed"
    simpleTypeText ChargeItemStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText ChargeItemStatus_list_Unknown = "unknown"
 
data ChargeItemStatus = ChargeItemStatus
        { chargeItemStatus_id :: Maybe String_primitive
        , chargeItemStatus_value :: Maybe ChargeItemStatus_list
        , chargeItemStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ChargeItemStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ChargeItemStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ChargeItemStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ chargeItemStatus_id x
                       , maybe [] (toXMLAttribute "value") $ chargeItemStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ chargeItemStatus_extension x
            ]
instance Extension ChargeItemStatus Element where
    supertype (ChargeItemStatus a0 a1 e0) =
               Element a0 e0
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
elementClaim :: XMLParser Claim
elementClaim = parseSchemaType "Claim"
elementToXMLClaim :: Claim -> [Content ()]
elementToXMLClaim = schemaTypeToXML "Claim"
 
data Claim = Claim
        { claim_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , claim_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , claim_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , claim_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , claim_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , claim_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , claim_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claim_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claim_identifier :: [Identifier]
          -- ^ The business identifier for the instance: claim number, 
          --   pre-determination or pre-authorization number.
        , claim_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , claim_type :: Maybe CodeableConcept
          -- ^ The category of claim, eg, oral, pharmacy, vision, 
          --   insitutional, professional.
        , claim_subType :: [CodeableConcept]
          -- ^ A finer grained suite of claim subtype codes which may 
          --   convey Inpatient vs Outpatient and/or a specialty service. 
          --   In the US the BillType.
        , claim_use :: Maybe Use
          -- ^ Complete (Bill or Claim), Proposed (Pre-Authorization), 
          --   Exploratory (Pre-determination).
        , claim_patient :: Maybe Reference
          -- ^ Patient Resource.
        , claim_billablePeriod :: Maybe Period
          -- ^ The billable period for which charges are being submitted.
        , claim_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , claim_enterer :: Maybe Reference
          -- ^ Person who created the invoice/claim/pre-determination or 
          --   pre-authorization.
        , claim_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , claim_provider :: Maybe Reference
          -- ^ The provider which is responsible for the bill, claim 
          --   pre-determination, pre-authorization.
        , claim_organization :: Maybe Reference
          -- ^ The organization which is responsible for the bill, claim 
          --   pre-determination, pre-authorization.
        , claim_priority :: Maybe CodeableConcept
          -- ^ Immediate (STAT), best effort (NORMAL), deferred (DEFER).
        , claim_fundsReserve :: Maybe CodeableConcept
          -- ^ In the case of a Pre-Determination/Pre-Authorization the 
          --   provider may request that funds in the amount of the 
          --   expected Benefit be reserved ('Patient' or 'Provider') to 
          --   pay for the Benefits determined on the subsequent claim(s). 
          --   'None' explicitly indicates no funds reserving is 
          --   requested.
        , claim_related :: [ClaimRelated]
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , claim_prescription :: Maybe Reference
          -- ^ Prescription to support the dispensing of Pharmacy or 
          --   Vision products.
        , claim_originalPrescription :: Maybe Reference
          -- ^ Original prescription which has been superceded by this 
          --   prescription to support the dispensing of pharmacy 
          --   services, medications or products. For example, a physician 
          --   may prescribe a medication which the pharmacy determines is 
          --   contraindicated, or for which the patient has an 
          --   intolerance, and therefor issues a new precription for an 
          --   alternate medication which has the same theraputic intent. 
          --   The prescription from the pharmacy becomes the 
          --   'prescription' and that from the physician becomes the 
          --   'original prescription'.
        , claim_payee :: Maybe ClaimPayee
          -- ^ The party to be reimbursed for the services.
        , claim_referral :: Maybe Reference
          -- ^ The referral resource which lists the date, practitioner, 
          --   reason and other supporting information.
        , claim_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , claim_careTeam :: [ClaimCareTeam]
          -- ^ The members of the team who provided the overall service as 
          --   well as their role and whether responsible and 
          --   qualifications.
        , claim_information :: [ClaimInformation]
          -- ^ Additional information codes regarding exceptions, special 
          --   considerations, the condition, situation, prior or 
          --   concurrent issues. Often there are mutiple jurisdiction 
          --   specific valuesets which are required.
        , claim_diagnosis :: [ClaimDiagnosis]
          -- ^ List of patient diagnosis for which care is sought.
        , claim_procedure :: [ClaimProcedure]
          -- ^ Ordered list of patient procedures performed to support the 
          --   adjudication.
        , claim_insurance :: [ClaimInsurance]
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , claim_accident :: Maybe ClaimAccident
          -- ^ An accident which resulted in the need for healthcare 
          --   services.
        , claim_employmentImpacted :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   precluded from working due to the treatable condition(s).
        , claim_hospitalization :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   confined to a treatment center.
        , claim_item :: [ClaimItem]
          -- ^ First tier of goods and services.
        , claim_total :: Maybe Money
          -- ^ The total value of the claim.
        }
        deriving (Eq,Show)
instance SchemaType Claim where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Claim
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` optional (parseSchemaType "use")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "billablePeriod")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "fundsReserve")
            `apply` many (parseSchemaType "related")
            `apply` optional (parseSchemaType "prescription")
            `apply` optional (parseSchemaType "originalPrescription")
            `apply` optional (parseSchemaType "payee")
            `apply` optional (parseSchemaType "referral")
            `apply` optional (parseSchemaType "facility")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "information")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "procedure")
            `apply` many (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "accident")
            `apply` optional (parseSchemaType "employmentImpacted")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "item")
            `apply` optional (parseSchemaType "total")
    schemaTypeToXML s x@Claim{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ claim_id x
            , maybe [] (schemaTypeToXML "meta") $ claim_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ claim_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ claim_language x
            , maybe [] (schemaTypeToXML "text") $ claim_text x
            , concatMap (schemaTypeToXML "contained") $ claim_contained x
            , concatMap (schemaTypeToXML "extension") $ claim_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claim_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ claim_identifier x
            , maybe [] (schemaTypeToXML "status") $ claim_status x
            , maybe [] (schemaTypeToXML "type") $ claim_type x
            , concatMap (schemaTypeToXML "subType") $ claim_subType x
            , maybe [] (schemaTypeToXML "use") $ claim_use x
            , maybe [] (schemaTypeToXML "patient") $ claim_patient x
            , maybe [] (schemaTypeToXML "billablePeriod") $ claim_billablePeriod x
            , maybe [] (schemaTypeToXML "created") $ claim_created x
            , maybe [] (schemaTypeToXML "enterer") $ claim_enterer x
            , maybe [] (schemaTypeToXML "insurer") $ claim_insurer x
            , maybe [] (schemaTypeToXML "provider") $ claim_provider x
            , maybe [] (schemaTypeToXML "organization") $ claim_organization x
            , maybe [] (schemaTypeToXML "priority") $ claim_priority x
            , maybe [] (schemaTypeToXML "fundsReserve") $ claim_fundsReserve x
            , concatMap (schemaTypeToXML "related") $ claim_related x
            , maybe [] (schemaTypeToXML "prescription") $ claim_prescription x
            , maybe [] (schemaTypeToXML "originalPrescription") $ claim_originalPrescription x
            , maybe [] (schemaTypeToXML "payee") $ claim_payee x
            , maybe [] (schemaTypeToXML "referral") $ claim_referral x
            , maybe [] (schemaTypeToXML "facility") $ claim_facility x
            , concatMap (schemaTypeToXML "careTeam") $ claim_careTeam x
            , concatMap (schemaTypeToXML "information") $ claim_information x
            , concatMap (schemaTypeToXML "diagnosis") $ claim_diagnosis x
            , concatMap (schemaTypeToXML "procedure") $ claim_procedure x
            , concatMap (schemaTypeToXML "insurance") $ claim_insurance x
            , maybe [] (schemaTypeToXML "accident") $ claim_accident x
            , maybe [] (schemaTypeToXML "employmentImpacted") $ claim_employmentImpacted x
            , maybe [] (schemaTypeToXML "hospitalization") $ claim_hospitalization x
            , concatMap (schemaTypeToXML "item") $ claim_item x
            , maybe [] (schemaTypeToXML "total") $ claim_total x
            ]
instance Extension Claim DomainResource where
    supertype (Claim e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Claim Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Claim -> DomainResource)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimRelated = ClaimRelated
        { claimRelated_id :: Maybe String_primitive
        , claimRelated_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimRelated_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimRelated_claim :: Maybe Reference
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , claimRelated_relationship :: Maybe CodeableConcept
          -- ^ For example prior or umbrella.
        , claimRelated_reference :: Maybe Identifier
          -- ^ An alternate organizational reference to the case or file 
          --   to which this particular claim pertains - eg 
          --   Property/Casualy insurer claim # or Workers Compensation 
          --   case # .
        }
        deriving (Eq,Show)
instance SchemaType ClaimRelated where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimRelated a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "reference")
    schemaTypeToXML s x@ClaimRelated{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimRelated_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimRelated_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimRelated_modifierExtension x
            , maybe [] (schemaTypeToXML "claim") $ claimRelated_claim x
            , maybe [] (schemaTypeToXML "relationship") $ claimRelated_relationship x
            , maybe [] (schemaTypeToXML "reference") $ claimRelated_reference x
            ]
instance Extension ClaimRelated BackboneElement where
    supertype (ClaimRelated a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimRelated Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimRelated -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimPayee = ClaimPayee
        { claimPayee_id :: Maybe String_primitive
        , claimPayee_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimPayee_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimPayee_type :: CodeableConcept
          -- ^ Type of Party to be reimbursed: Subscriber, provider, 
          --   other.
        , claimPayee_resourceType :: Maybe Coding
          -- ^ organization | patient | practitioner | relatedperson.
        , claimPayee_party :: Maybe Reference
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        }
        deriving (Eq,Show)
instance SchemaType ClaimPayee where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimPayee a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "resourceType")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@ClaimPayee{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimPayee_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimPayee_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimPayee_modifierExtension x
            , schemaTypeToXML "type" $ claimPayee_type x
            , maybe [] (schemaTypeToXML "resourceType") $ claimPayee_resourceType x
            , maybe [] (schemaTypeToXML "party") $ claimPayee_party x
            ]
instance Extension ClaimPayee BackboneElement where
    supertype (ClaimPayee a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimPayee Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimPayee -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimCareTeam = ClaimCareTeam
        { claimCareTeam_id :: Maybe String_primitive
        , claimCareTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimCareTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimCareTeam_sequence :: PositiveInt
          -- ^ Sequence of the careTeam which serves to order and provide 
          --   a link.
        , claimCareTeam_provider :: Reference
          -- ^ Member of the team who provided the overall service.
        , claimCareTeam_responsible :: Maybe Boolean
          -- ^ The party who is billing and responsible for the claimed 
          --   good or service rendered to the patient.
        , claimCareTeam_role :: Maybe CodeableConcept
          -- ^ The lead, assisting or supervising practitioner and their 
          --   discipline if a multidisiplinary team.
        , claimCareTeam_qualification :: Maybe CodeableConcept
          -- ^ The qualification which is applicable for this service.
        }
        deriving (Eq,Show)
instance SchemaType ClaimCareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimCareTeam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "provider"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "qualification")
    schemaTypeToXML s x@ClaimCareTeam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimCareTeam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimCareTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimCareTeam_modifierExtension x
            , schemaTypeToXML "sequence" $ claimCareTeam_sequence x
            , schemaTypeToXML "provider" $ claimCareTeam_provider x
            , maybe [] (schemaTypeToXML "responsible") $ claimCareTeam_responsible x
            , maybe [] (schemaTypeToXML "role") $ claimCareTeam_role x
            , maybe [] (schemaTypeToXML "qualification") $ claimCareTeam_qualification x
            ]
instance Extension ClaimCareTeam BackboneElement where
    supertype (ClaimCareTeam a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ClaimCareTeam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimCareTeam -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimInformation = ClaimInformation
        { claimInformation_id :: Maybe String_primitive
        , claimInformation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimInformation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimInformation_sequence :: PositiveInt
          -- ^ Sequence of the information element which serves to provide 
          --   a link.
        , claimInformation_category :: CodeableConcept
          -- ^ The general class of the information supplied: information; 
          --   exception; accident, employment; onset, etc.
        , claimInformation_code :: Maybe CodeableConcept
          -- ^ System and code pertaining to the specific information 
          --   regarding special conditions relating to the setting, 
          --   treatment or patient for which care is sought which may 
          --   influence the adjudication.
        , claimInformation_choice5 :: (Maybe (OneOf2 Date Period))
          -- ^ The date when or period to which this information refers.
          --   
          --   Choice between:
          --   
          --   (1) timingDate
          --   
          --   (2) timingPeriod
        , claimInformation_choice6 :: (Maybe (OneOf4 Xsd.XsdString Quantity Attachment Reference))
          -- ^ Additional data or information such as resources, 
          --   documents, images etc. including references to the data or 
          --   the actual inclusion of the data.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueAttachment
          --   
          --   (4) valueReference
        , claimInformation_reason :: Maybe CodeableConcept
          -- ^ For example, provides the reason for: the additional stay, 
          --   or missing tooth or any other situation where a reason code 
          --   is required in addition to the content.
        }
        deriving (Eq,Show)
instance SchemaType ClaimInformation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimInformation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "timingDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timingPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf4 (parseSchemaType "valueString"))
                                     , ("Quantity", fmap TwoOf4 (parseSchemaType "valueQuantity"))
                                     , ("Attachment", fmap ThreeOf4 (parseSchemaType "valueAttachment"))
                                     , ("Reference", fmap FourOf4 (parseSchemaType "valueReference"))
                                     ])
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@ClaimInformation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimInformation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimInformation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimInformation_modifierExtension x
            , schemaTypeToXML "sequence" $ claimInformation_sequence x
            , schemaTypeToXML "category" $ claimInformation_category x
            , maybe [] (schemaTypeToXML "code") $ claimInformation_code x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timingDate")
                                    (schemaTypeToXML "timingPeriod")
                                   ) $ claimInformation_choice5 x
            , maybe [] (foldOneOf4  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueQuantity")
                                    (schemaTypeToXML "valueAttachment")
                                    (schemaTypeToXML "valueReference")
                                   ) $ claimInformation_choice6 x
            , maybe [] (schemaTypeToXML "reason") $ claimInformation_reason x
            ]
instance Extension ClaimInformation BackboneElement where
    supertype (ClaimInformation a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimInformation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimInformation -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimDiagnosis = ClaimDiagnosis
        { claimDiagnosis_id :: Maybe String_primitive
        , claimDiagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimDiagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimDiagnosis_sequence :: PositiveInt
          -- ^ Sequence of diagnosis which serves to provide a link.
        , claimDiagnosis_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ The diagnosis.
          --   
          --   Choice between:
          --   
          --   (1) diagnosisCodeableConcept
          --   
          --   (2) diagnosisReference
        , claimDiagnosis_type :: [CodeableConcept]
          -- ^ The type of the Diagnosis, for example: admitting, primary, 
          --   secondary, discharge.
        , claimDiagnosis_packageCode :: Maybe CodeableConcept
          -- ^ The package billing code, for example DRG, based on the 
          --   assigned grouping code system.
        }
        deriving (Eq,Show)
instance SchemaType ClaimDiagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimDiagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "diagnosisCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "diagnosisReference"))
                           ]
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "packageCode")
    schemaTypeToXML s x@ClaimDiagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimDiagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimDiagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimDiagnosis_modifierExtension x
            , schemaTypeToXML "sequence" $ claimDiagnosis_sequence x
            , foldOneOf2  (schemaTypeToXML "diagnosisCodeableConcept")
                          (schemaTypeToXML "diagnosisReference")
                          $ claimDiagnosis_choice3 x
            , concatMap (schemaTypeToXML "type") $ claimDiagnosis_type x
            , maybe [] (schemaTypeToXML "packageCode") $ claimDiagnosis_packageCode x
            ]
instance Extension ClaimDiagnosis BackboneElement where
    supertype (ClaimDiagnosis a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimDiagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimDiagnosis -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimProcedure = ClaimProcedure
        { claimProcedure_id :: Maybe String_primitive
        , claimProcedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimProcedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimProcedure_sequence :: PositiveInt
          -- ^ Sequence of procedures which serves to order and provide a 
          --   link.
        , claimProcedure_date :: Maybe DateTime
          -- ^ Date and optionally time the procedure was performed .
        , claimProcedure_choice4 :: OneOf2 CodeableConcept Reference
          -- ^ The procedure code.
          --   
          --   Choice between:
          --   
          --   (1) procedureCodeableConcept
          --   
          --   (2) procedureReference
        }
        deriving (Eq,Show)
instance SchemaType ClaimProcedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimProcedure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "date")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "procedureCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "procedureReference"))
                           ]
    schemaTypeToXML s x@ClaimProcedure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimProcedure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimProcedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimProcedure_modifierExtension x
            , schemaTypeToXML "sequence" $ claimProcedure_sequence x
            , maybe [] (schemaTypeToXML "date") $ claimProcedure_date x
            , foldOneOf2  (schemaTypeToXML "procedureCodeableConcept")
                          (schemaTypeToXML "procedureReference")
                          $ claimProcedure_choice4 x
            ]
instance Extension ClaimProcedure BackboneElement where
    supertype (ClaimProcedure a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimProcedure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimProcedure -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimInsurance = ClaimInsurance
        { claimInsurance_id :: Maybe String_primitive
        , claimInsurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimInsurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimInsurance_sequence :: PositiveInt
          -- ^ Sequence of coverage which serves to provide a link and 
          --   convey coordination of benefit order.
        , claimInsurance_focal :: Boolean
          -- ^ A flag to indicate that this Coverage is the focus for 
          --   adjudication. The Coverage against which the claim is to be 
          --   adjudicated.
        , claimInsurance_coverage :: Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , claimInsurance_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , claimInsurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        , claimInsurance_claimResponse :: Maybe Reference
          -- ^ The Coverages adjudication details.
        }
        deriving (Eq,Show)
instance SchemaType ClaimInsurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimInsurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "focal"
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` many (parseSchemaType "preAuthRef")
            `apply` optional (parseSchemaType "claimResponse")
    schemaTypeToXML s x@ClaimInsurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimInsurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimInsurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimInsurance_modifierExtension x
            , schemaTypeToXML "sequence" $ claimInsurance_sequence x
            , schemaTypeToXML "focal" $ claimInsurance_focal x
            , schemaTypeToXML "coverage" $ claimInsurance_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ claimInsurance_businessArrangement x
            , concatMap (schemaTypeToXML "preAuthRef") $ claimInsurance_preAuthRef x
            , maybe [] (schemaTypeToXML "claimResponse") $ claimInsurance_claimResponse x
            ]
instance Extension ClaimInsurance BackboneElement where
    supertype (ClaimInsurance a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimInsurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimInsurance -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimAccident = ClaimAccident
        { claimAccident_id :: Maybe String_primitive
        , claimAccident_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimAccident_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimAccident_date :: Date
          -- ^ Date of an accident which these services are addressing.
        , claimAccident_type :: Maybe CodeableConcept
          -- ^ Type of accident: work, auto, etc.
        , claimAccident_choice4 :: (Maybe (OneOf2 Address Reference))
          -- ^ Accident Place.
          --   
          --   Choice between:
          --   
          --   (1) locationAddress
          --   
          --   (2) locationReference
        }
        deriving (Eq,Show)
instance SchemaType ClaimAccident where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimAccident a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Address", fmap OneOf2 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "locationReference"))
                                     ])
    schemaTypeToXML s x@ClaimAccident{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimAccident_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimAccident_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimAccident_modifierExtension x
            , schemaTypeToXML "date" $ claimAccident_date x
            , maybe [] (schemaTypeToXML "type") $ claimAccident_type x
            , maybe [] (foldOneOf2  (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ claimAccident_choice4 x
            ]
instance Extension ClaimAccident BackboneElement where
    supertype (ClaimAccident a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimAccident Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimAccident -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimItem = ClaimItem
        { claimItem_id :: Maybe String_primitive
        , claimItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimItem_sequence :: PositiveInt
          -- ^ A service line number.
        , claimItem_careTeamLinkId :: [PositiveInt]
          -- ^ CareTeam applicable for this service or product line.
        , claimItem_diagnosisLinkId :: [PositiveInt]
          -- ^ Diagnosis applicable for this service or product line.
        , claimItem_procedureLinkId :: [PositiveInt]
          -- ^ Procedures applicable for this service or product line.
        , claimItem_informationLinkId :: [PositiveInt]
          -- ^ Exceptions, special conditions and supporting information 
          --   pplicable for this service or product line.
        , claimItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimItem_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a 
          --   group code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , claimItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimItem_programCode :: [CodeableConcept]
          -- ^ For programs which require reason codes for the inclusion 
          --   or covering of this billed item under the program or 
          --   sub-program.
        , claimItem_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , claimItem_choice13 :: (Maybe (OneOf3 CodeableConcept Address Reference))
          -- ^ Where the service was provided.
          --   
          --   Choice between:
          --   
          --   (1) locationCodeableConcept
          --   
          --   (2) locationAddress
          --   
          --   (3) locationReference
        , claimItem_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claimItem_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , claimItem_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claimItem_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claimItem_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , claimItem_bodySite :: Maybe CodeableConcept
          -- ^ Physical service site on the patient (limb, tooth, etc).
        , claimItem_subSite :: [CodeableConcept]
          -- ^ A region or surface of the site, eg. limb region or tooth 
          --   surface(s).
        , claimItem_encounter :: [Reference]
          -- ^ A billed item may include goods or services provided in 
          --   multiple encounters.
        , claimItem_detail :: [ClaimDetail]
          -- ^ Second tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` many (parseSchemaType "careTeamLinkId")
            `apply` many (parseSchemaType "diagnosisLinkId")
            `apply` many (parseSchemaType "procedureLinkId")
            `apply` many (parseSchemaType "informationLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf3 (parseSchemaType "locationCodeableConcept"))
                                     , ("Address", fmap TwoOf3 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "locationReference"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "subSite")
            `apply` many (parseSchemaType "encounter")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ClaimItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimItem_modifierExtension x
            , schemaTypeToXML "sequence" $ claimItem_sequence x
            , concatMap (schemaTypeToXML "careTeamLinkId") $ claimItem_careTeamLinkId x
            , concatMap (schemaTypeToXML "diagnosisLinkId") $ claimItem_diagnosisLinkId x
            , concatMap (schemaTypeToXML "procedureLinkId") $ claimItem_procedureLinkId x
            , concatMap (schemaTypeToXML "informationLinkId") $ claimItem_informationLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ claimItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimItem_category x
            , maybe [] (schemaTypeToXML "service") $ claimItem_service x
            , concatMap (schemaTypeToXML "modifier") $ claimItem_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claimItem_programCode x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ claimItem_choice12 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "locationCodeableConcept")
                                    (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ claimItem_choice13 x
            , maybe [] (schemaTypeToXML "quantity") $ claimItem_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claimItem_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claimItem_factor x
            , maybe [] (schemaTypeToXML "net") $ claimItem_net x
            , concatMap (schemaTypeToXML "udi") $ claimItem_udi x
            , maybe [] (schemaTypeToXML "bodySite") $ claimItem_bodySite x
            , concatMap (schemaTypeToXML "subSite") $ claimItem_subSite x
            , concatMap (schemaTypeToXML "encounter") $ claimItem_encounter x
            , concatMap (schemaTypeToXML "detail") $ claimItem_detail x
            ]
instance Extension ClaimItem BackboneElement where
    supertype (ClaimItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               BackboneElement a0 e0 e1
instance Extension ClaimItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimItem -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimDetail = ClaimDetail
        { claimDetail_id :: Maybe String_primitive
        , claimDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , claimDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimDetail_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , claimDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , claimDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claimDetail_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , claimDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claimDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claimDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , claimDetail_subDetail :: [ClaimSubDetail]
          -- ^ Third tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@ClaimDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ claimDetail_sequence x
            , maybe [] (schemaTypeToXML "revenue") $ claimDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimDetail_category x
            , maybe [] (schemaTypeToXML "service") $ claimDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ claimDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claimDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ claimDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claimDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claimDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ claimDetail_net x
            , concatMap (schemaTypeToXML "udi") $ claimDetail_udi x
            , concatMap (schemaTypeToXML "subDetail") $ claimDetail_subDetail x
            ]
instance Extension ClaimDetail BackboneElement where
    supertype (ClaimDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension ClaimDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimDetail -> BackboneElement)
              
 
-- | A provider issued list of services and products provided, 
--   or to be provided, to a patient which is provided to an 
--   insurer for payment recovery.
data ClaimSubDetail = ClaimSubDetail
        { claimSubDetail_id :: Maybe String_primitive
        , claimSubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimSubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimSubDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , claimSubDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimSubDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimSubDetail_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , claimSubDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimSubDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , claimSubDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , claimSubDetail_unitPrice :: Maybe Money
          -- ^ The fee for an addittional service or product or charge.
        , claimSubDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , claimSubDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , claimSubDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        }
        deriving (Eq,Show)
instance SchemaType ClaimSubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimSubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
    schemaTypeToXML s x@ClaimSubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimSubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimSubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimSubDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ claimSubDetail_sequence x
            , maybe [] (schemaTypeToXML "revenue") $ claimSubDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimSubDetail_category x
            , maybe [] (schemaTypeToXML "service") $ claimSubDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ claimSubDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ claimSubDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ claimSubDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ claimSubDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ claimSubDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ claimSubDetail_net x
            , concatMap (schemaTypeToXML "udi") $ claimSubDetail_udi x
            ]
instance Extension ClaimSubDetail BackboneElement where
    supertype (ClaimSubDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12) =
               BackboneElement a0 e0 e1
instance Extension ClaimSubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimSubDetail -> BackboneElement)
              
 
data Use_list
    = Use_list_Complete
      -- ^ Complete
    | Use_list_Proposed
      -- ^ Proposed
    | Use_list_Exploratory
      -- ^ Exploratory
    | Use_list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType Use_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType Use_list where
    acceptingParser =  do literal "complete"; return Use_list_Complete
                      `onFail` do literal "proposed"; return Use_list_Proposed
                      `onFail` do literal "exploratory"; return Use_list_Exploratory
                      `onFail` do literal "other"; return Use_list_Other
                      
    simpleTypeText Use_list_Complete = "complete"
    simpleTypeText Use_list_Proposed = "proposed"
    simpleTypeText Use_list_Exploratory = "exploratory"
    simpleTypeText Use_list_Other = "other"
 
data Use = Use
        { use_id :: Maybe String_primitive
        , use_value :: Maybe Use_list
        , use_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType Use where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (Use a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@Use{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ use_id x
                       , maybe [] (toXMLAttribute "value") $ use_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ use_extension x
            ]
instance Extension Use Element where
    supertype (Use a0 a1 e0) =
               Element a0 e0
 
data FinancialResourceStatusCodes_list
    = FinancialResourceStatusCodes_list_Active
      -- ^ Active
    | FinancialResourceStatusCodes_list_Cancelled
      -- ^ Cancelled
    | FinancialResourceStatusCodes_list_Draft
      -- ^ Draft
    | FinancialResourceStatusCodes_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FinancialResourceStatusCodes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FinancialResourceStatusCodes_list where
    acceptingParser =  do literal "active"; return FinancialResourceStatusCodes_list_Active
                      `onFail` do literal "cancelled"; return FinancialResourceStatusCodes_list_Cancelled
                      `onFail` do literal "draft"; return FinancialResourceStatusCodes_list_Draft
                      `onFail` do literal "entered-in-error"; return FinancialResourceStatusCodes_list_Entered_in_error
                      
    simpleTypeText FinancialResourceStatusCodes_list_Active = "active"
    simpleTypeText FinancialResourceStatusCodes_list_Cancelled = "cancelled"
    simpleTypeText FinancialResourceStatusCodes_list_Draft = "draft"
    simpleTypeText FinancialResourceStatusCodes_list_Entered_in_error = "entered-in-error"
 
data FinancialResourceStatusCodes = FinancialResourceStatusCodes
        { financialResourceStatusCodes_id :: Maybe String_primitive
        , financialResourceStatusCodes_value :: Maybe FinancialResourceStatusCodes_list
        , financialResourceStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FinancialResourceStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FinancialResourceStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FinancialResourceStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ financialResourceStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ financialResourceStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ financialResourceStatusCodes_extension x
            ]
instance Extension FinancialResourceStatusCodes Element where
    supertype (FinancialResourceStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
elementClaimResponse :: XMLParser ClaimResponse
elementClaimResponse = parseSchemaType "ClaimResponse"
elementToXMLClaimResponse :: ClaimResponse -> [Content ()]
elementToXMLClaimResponse = schemaTypeToXML "ClaimResponse"
 
data ClaimResponse = ClaimResponse
        { claimResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , claimResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , claimResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , claimResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , claimResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , claimResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , claimResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , claimResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , claimResponse_patient :: Maybe Reference
          -- ^ Patient Resource.
        , claimResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , claimResponse_insurer :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , claimResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , claimResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , claimResponse_request :: Maybe Reference
          -- ^ Original request resource referrence.
        , claimResponse_outcome :: Maybe CodeableConcept
          -- ^ Processing outcome errror, partial or complete processing.
        , claimResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , claimResponse_payeeType :: Maybe CodeableConcept
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        , claimResponse_item :: [ClaimResponseItem]
          -- ^ The first tier service adjudications for submitted 
          --   services.
        , claimResponse_addItem :: [ClaimResponseAddItem]
          -- ^ The first tier service adjudications for payor added 
          --   services.
        , claimResponse_error :: [ClaimResponseError]
          -- ^ Mutually exclusive with Services Provided (Item).
        , claimResponse_totalCost :: Maybe Money
          -- ^ The total cost of the services reported.
        , claimResponse_unallocDeductable :: Maybe Money
          -- ^ The amount of deductible applied which was not allocated to 
          --   any particular service line.
        , claimResponse_totalBenefit :: Maybe Money
          -- ^ Total amount of benefit payable (Equal to sum of the 
          --   Benefit amounts from all detail lines and additions less 
          --   the Unallocated Deductible).
        , claimResponse_payment :: Maybe ClaimResponsePayment
          -- ^ Payment details for the claim if the claim has been paid.
        , claimResponse_reserved :: Maybe Coding
          -- ^ Status of funds reservation (For provider, for Patient, 
          --   None).
        , claimResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , claimResponse_processNote :: [ClaimResponseProcessNote]
          -- ^ Note text.
        , claimResponse_communicationRequest :: [Reference]
          -- ^ Request for additional supporting or authorizing 
          --   information, such as: documents, images or resources.
        , claimResponse_insurance :: [ClaimResponseInsurance]
          -- ^ Financial instrument by which payment information for 
          --   health care.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ClaimResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "payeeType")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "addItem")
            `apply` many (parseSchemaType "error")
            `apply` optional (parseSchemaType "totalCost")
            `apply` optional (parseSchemaType "unallocDeductable")
            `apply` optional (parseSchemaType "totalBenefit")
            `apply` optional (parseSchemaType "payment")
            `apply` optional (parseSchemaType "reserved")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "communicationRequest")
            `apply` many (parseSchemaType "insurance")
    schemaTypeToXML s x@ClaimResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ claimResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ claimResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ claimResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ claimResponse_language x
            , maybe [] (schemaTypeToXML "text") $ claimResponse_text x
            , concatMap (schemaTypeToXML "contained") $ claimResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ claimResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ claimResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ claimResponse_status x
            , maybe [] (schemaTypeToXML "patient") $ claimResponse_patient x
            , maybe [] (schemaTypeToXML "created") $ claimResponse_created x
            , maybe [] (schemaTypeToXML "insurer") $ claimResponse_insurer x
            , maybe [] (schemaTypeToXML "requestProvider") $ claimResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ claimResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "request") $ claimResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ claimResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ claimResponse_disposition x
            , maybe [] (schemaTypeToXML "payeeType") $ claimResponse_payeeType x
            , concatMap (schemaTypeToXML "item") $ claimResponse_item x
            , concatMap (schemaTypeToXML "addItem") $ claimResponse_addItem x
            , concatMap (schemaTypeToXML "error") $ claimResponse_error x
            , maybe [] (schemaTypeToXML "totalCost") $ claimResponse_totalCost x
            , maybe [] (schemaTypeToXML "unallocDeductable") $ claimResponse_unallocDeductable x
            , maybe [] (schemaTypeToXML "totalBenefit") $ claimResponse_totalBenefit x
            , maybe [] (schemaTypeToXML "payment") $ claimResponse_payment x
            , maybe [] (schemaTypeToXML "reserved") $ claimResponse_reserved x
            , maybe [] (schemaTypeToXML "form") $ claimResponse_form x
            , concatMap (schemaTypeToXML "processNote") $ claimResponse_processNote x
            , concatMap (schemaTypeToXML "communicationRequest") $ claimResponse_communicationRequest x
            , concatMap (schemaTypeToXML "insurance") $ claimResponse_insurance x
            ]
instance Extension ClaimResponse DomainResource where
    supertype (ClaimResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ClaimResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ClaimResponse -> DomainResource)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseItem = ClaimResponseItem
        { claimResponseItem_id :: Maybe String_primitive
        , claimResponseItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseItem_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponseItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponseItem_adjudication :: [ClaimResponseAdjudication]
          -- ^ The adjudication results.
        , claimResponseItem_detail :: [ClaimResponseDetail]
          -- ^ The second tier service adjudications for submitted 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ClaimResponseItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseItem_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponseItem_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponseItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponseItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ claimResponseItem_detail x
            ]
instance Extension ClaimResponseItem BackboneElement where
    supertype (ClaimResponseItem a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseItem -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseAdjudication = ClaimResponseAdjudication
        { claimResponseAdjudication_id :: Maybe String_primitive
        , claimResponseAdjudication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseAdjudication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseAdjudication_category :: CodeableConcept
          -- ^ Code indicating: Co-Pay, deductible, eligible, benefit, 
          --   tax, etc.
        , claimResponseAdjudication_reason :: Maybe CodeableConcept
          -- ^ Adjudication reason such as limit reached.
        , claimResponseAdjudication_amount :: Maybe Money
          -- ^ Monetary amount associated with the code.
        , claimResponseAdjudication_value :: Maybe Decimal
          -- ^ A non-monetary value for example a percentage. Mutually 
          --   exclusive to the amount element above.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseAdjudication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseAdjudication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@ClaimResponseAdjudication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseAdjudication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseAdjudication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseAdjudication_modifierExtension x
            , schemaTypeToXML "category" $ claimResponseAdjudication_category x
            , maybe [] (schemaTypeToXML "reason") $ claimResponseAdjudication_reason x
            , maybe [] (schemaTypeToXML "amount") $ claimResponseAdjudication_amount x
            , maybe [] (schemaTypeToXML "value") $ claimResponseAdjudication_value x
            ]
instance Extension ClaimResponseAdjudication BackboneElement where
    supertype (ClaimResponseAdjudication a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseAdjudication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseAdjudication -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseDetail = ClaimResponseDetail
        { claimResponseDetail_id :: Maybe String_primitive
        , claimResponseDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseDetail_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponseDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponseDetail_adjudication :: [ClaimResponseAdjudication]
          -- ^ The adjudications results.
        , claimResponseDetail_subDetail :: [ClaimResponseSubDetail]
          -- ^ The third tier service adjudications for submitted 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@ClaimResponseDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseDetail_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponseDetail_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponseDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponseDetail_adjudication x
            , concatMap (schemaTypeToXML "subDetail") $ claimResponseDetail_subDetail x
            ]
instance Extension ClaimResponseDetail BackboneElement where
    supertype (ClaimResponseDetail a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseDetail -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseSubDetail = ClaimResponseSubDetail
        { claimResponseSubDetail_id :: Maybe String_primitive
        , claimResponseSubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseSubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseSubDetail_sequenceLinkId :: PositiveInt
          -- ^ A service line number.
        , claimResponseSubDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponseSubDetail_adjudication :: [ClaimResponseAdjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseSubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseSubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ClaimResponseSubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseSubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseSubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseSubDetail_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ claimResponseSubDetail_sequenceLinkId x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponseSubDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponseSubDetail_adjudication x
            ]
instance Extension ClaimResponseSubDetail BackboneElement where
    supertype (ClaimResponseSubDetail a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseSubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseSubDetail -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseAddItem = ClaimResponseAddItem
        { claimResponseAddItem_id :: Maybe String_primitive
        , claimResponseAddItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseAddItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseAddItem_sequenceLinkId :: [PositiveInt]
          -- ^ List of input service items which this service line is 
          --   intended to replace.
        , claimResponseAddItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimResponseAddItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimResponseAddItem_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied.
        , claimResponseAddItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimResponseAddItem_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product..
        , claimResponseAddItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponseAddItem_adjudication :: [ClaimResponseAdjudication]
          -- ^ The adjudications results.
        , claimResponseAddItem_detail :: [ClaimResponseDetail1]
          -- ^ The second tier service adjudications for payor added 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseAddItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseAddItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ClaimResponseAddItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseAddItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseAddItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseAddItem_modifierExtension x
            , concatMap (schemaTypeToXML "sequenceLinkId") $ claimResponseAddItem_sequenceLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ claimResponseAddItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimResponseAddItem_category x
            , maybe [] (schemaTypeToXML "service") $ claimResponseAddItem_service x
            , concatMap (schemaTypeToXML "modifier") $ claimResponseAddItem_modifier x
            , maybe [] (schemaTypeToXML "fee") $ claimResponseAddItem_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponseAddItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponseAddItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ claimResponseAddItem_detail x
            ]
instance Extension ClaimResponseAddItem BackboneElement where
    supertype (ClaimResponseAddItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseAddItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseAddItem -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseDetail1 = ClaimResponseDetail1
        { claimResponseDetail1_id :: Maybe String_primitive
        , claimResponseDetail1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseDetail1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseDetail1_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , claimResponseDetail1_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , claimResponseDetail1_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied.
        , claimResponseDetail1_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , claimResponseDetail1_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product..
        , claimResponseDetail1_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , claimResponseDetail1_adjudication :: [ClaimResponseAdjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseDetail1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseDetail1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ClaimResponseDetail1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseDetail1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseDetail1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseDetail1_modifierExtension x
            , maybe [] (schemaTypeToXML "revenue") $ claimResponseDetail1_revenue x
            , maybe [] (schemaTypeToXML "category") $ claimResponseDetail1_category x
            , maybe [] (schemaTypeToXML "service") $ claimResponseDetail1_service x
            , concatMap (schemaTypeToXML "modifier") $ claimResponseDetail1_modifier x
            , maybe [] (schemaTypeToXML "fee") $ claimResponseDetail1_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ claimResponseDetail1_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ claimResponseDetail1_adjudication x
            ]
instance Extension ClaimResponseDetail1 BackboneElement where
    supertype (ClaimResponseDetail1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseDetail1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseDetail1 -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseError = ClaimResponseError
        { claimResponseError_id :: Maybe String_primitive
        , claimResponseError_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseError_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseError_sequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the line item submitted which 
          --   contains the error. This value is omitted when the error is 
          --   elsewhere.
        , claimResponseError_detailSequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the addition within the line item 
          --   submitted which contains the error. This value is omitted 
          --   when the error is not related to an Addition.
        , claimResponseError_subdetailSequenceLinkId :: Maybe PositiveInt
          -- ^ The sequence number of the addition within the line item 
          --   submitted which contains the error. This value is omitted 
          --   when the error is not related to an Addition.
        , claimResponseError_code :: CodeableConcept
          -- ^ An error code,from a specified code system, which details 
          --   why the claim could not be adjudicated.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseError where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseError a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "detailSequenceLinkId")
            `apply` optional (parseSchemaType "subdetailSequenceLinkId")
            `apply` parseSchemaType "code"
    schemaTypeToXML s x@ClaimResponseError{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseError_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseError_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseError_modifierExtension x
            , maybe [] (schemaTypeToXML "sequenceLinkId") $ claimResponseError_sequenceLinkId x
            , maybe [] (schemaTypeToXML "detailSequenceLinkId") $ claimResponseError_detailSequenceLinkId x
            , maybe [] (schemaTypeToXML "subdetailSequenceLinkId") $ claimResponseError_subdetailSequenceLinkId x
            , schemaTypeToXML "code" $ claimResponseError_code x
            ]
instance Extension ClaimResponseError BackboneElement where
    supertype (ClaimResponseError a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseError Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseError -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponsePayment = ClaimResponsePayment
        { claimResponsePayment_id :: Maybe String_primitive
        , claimResponsePayment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponsePayment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponsePayment_type :: Maybe CodeableConcept
          -- ^ Whether this represents partial or complete payment of the 
          --   claim.
        , claimResponsePayment_adjustment :: Maybe Money
          -- ^ Adjustment to the payment of this transaction which is not 
          --   related to adjudication of this transaction.
        , claimResponsePayment_adjustmentReason :: Maybe CodeableConcept
          -- ^ Reason for the payment adjustment.
        , claimResponsePayment_date :: Maybe Date
          -- ^ Estimated payment data.
        , claimResponsePayment_amount :: Maybe Money
          -- ^ Payable less any payment adjustment.
        , claimResponsePayment_identifier :: Maybe Identifier
          -- ^ Payment identifier.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponsePayment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponsePayment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "adjustment")
            `apply` optional (parseSchemaType "adjustmentReason")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "identifier")
    schemaTypeToXML s x@ClaimResponsePayment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponsePayment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponsePayment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponsePayment_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ claimResponsePayment_type x
            , maybe [] (schemaTypeToXML "adjustment") $ claimResponsePayment_adjustment x
            , maybe [] (schemaTypeToXML "adjustmentReason") $ claimResponsePayment_adjustmentReason x
            , maybe [] (schemaTypeToXML "date") $ claimResponsePayment_date x
            , maybe [] (schemaTypeToXML "amount") $ claimResponsePayment_amount x
            , maybe [] (schemaTypeToXML "identifier") $ claimResponsePayment_identifier x
            ]
instance Extension ClaimResponsePayment BackboneElement where
    supertype (ClaimResponsePayment a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponsePayment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponsePayment -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseProcessNote = ClaimResponseProcessNote
        { claimResponseProcessNote_id :: Maybe String_primitive
        , claimResponseProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseProcessNote_number :: Maybe PositiveInt
          -- ^ An integer associated with each note which may be referred 
          --   to from each service line item.
        , claimResponseProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , claimResponseProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        , claimResponseProcessNote_language :: Maybe CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "number")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@ClaimResponseProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "number") $ claimResponseProcessNote_number x
            , maybe [] (schemaTypeToXML "type") $ claimResponseProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ claimResponseProcessNote_text x
            , maybe [] (schemaTypeToXML "language") $ claimResponseProcessNote_language x
            ]
instance Extension ClaimResponseProcessNote BackboneElement where
    supertype (ClaimResponseProcessNote a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseProcessNote -> BackboneElement)
              
 
-- | This resource provides the adjudication details from the 
--   processing of a Claim resource.
data ClaimResponseInsurance = ClaimResponseInsurance
        { claimResponseInsurance_id :: Maybe String_primitive
        , claimResponseInsurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , claimResponseInsurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , claimResponseInsurance_sequence :: PositiveInt
          -- ^ A service line item.
        , claimResponseInsurance_focal :: Boolean
          -- ^ The instance number of the Coverage which is the focus for 
          --   adjudication. The Coverage against which the claim is to be 
          --   adjudicated.
        , claimResponseInsurance_coverage :: Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , claimResponseInsurance_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , claimResponseInsurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        , claimResponseInsurance_claimResponse :: Maybe Reference
          -- ^ The Coverages adjudication details.
        }
        deriving (Eq,Show)
instance SchemaType ClaimResponseInsurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClaimResponseInsurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "focal"
            `apply` parseSchemaType "coverage"
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` many (parseSchemaType "preAuthRef")
            `apply` optional (parseSchemaType "claimResponse")
    schemaTypeToXML s x@ClaimResponseInsurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ claimResponseInsurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ claimResponseInsurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ claimResponseInsurance_modifierExtension x
            , schemaTypeToXML "sequence" $ claimResponseInsurance_sequence x
            , schemaTypeToXML "focal" $ claimResponseInsurance_focal x
            , schemaTypeToXML "coverage" $ claimResponseInsurance_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ claimResponseInsurance_businessArrangement x
            , concatMap (schemaTypeToXML "preAuthRef") $ claimResponseInsurance_preAuthRef x
            , maybe [] (schemaTypeToXML "claimResponse") $ claimResponseInsurance_claimResponse x
            ]
instance Extension ClaimResponseInsurance BackboneElement where
    supertype (ClaimResponseInsurance a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ClaimResponseInsurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClaimResponseInsurance -> BackboneElement)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
elementClinicalImpression :: XMLParser ClinicalImpression
elementClinicalImpression = parseSchemaType "ClinicalImpression"
elementToXMLClinicalImpression :: ClinicalImpression -> [Content ()]
elementToXMLClinicalImpression = schemaTypeToXML "ClinicalImpression"
 
data ClinicalImpression = ClinicalImpression
        { clinicalImpression_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , clinicalImpression_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , clinicalImpression_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , clinicalImpression_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , clinicalImpression_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , clinicalImpression_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , clinicalImpression_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpression_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpression_identifier :: [Identifier]
          -- ^ A unique identifier assigned to the clinical impression 
          --   that remains consistent regardless of what server the 
          --   impression is stored on.
        , clinicalImpression_status :: ClinicalImpressionStatus
          -- ^ Identifies the workflow status of the assessment.
        , clinicalImpression_code :: Maybe CodeableConcept
          -- ^ Categorizes the type of clinical assessment performed.
        , clinicalImpression_description :: Maybe Xsd.XsdString
          -- ^ A summary of the context and/or cause of the assessment - 
          --   why / where was it performed, and what patient 
          --   events/status prompted it.
        , clinicalImpression_subject :: Reference
          -- ^ The patient or group of individuals assessed as part of 
          --   this record.
        , clinicalImpression_context :: Maybe Reference
          -- ^ The encounter or episode of care this impression was 
          --   created as part of.
        , clinicalImpression_choice14 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The point in time or period over which the subject was 
          --   assessed.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , clinicalImpression_date :: Maybe DateTime
          -- ^ Indicates when the documentation of the assessment was 
          --   complete.
        , clinicalImpression_assessor :: Maybe Reference
          -- ^ The clinician performing the assessment.
        , clinicalImpression_previous :: Maybe Reference
          -- ^ A reference to the last assesment that was conducted bon 
          --   this patient. Assessments are often/usually ongoing in 
          --   nature; a care provider (practitioner or team) will make 
          --   new assessments on an ongoing basis as new data arises or 
          --   the patient's conditions changes.
        , clinicalImpression_problem :: [Reference]
          -- ^ This a list of the relevant problems/conditions for a 
          --   patient.
        , clinicalImpression_investigation :: [ClinicalImpressionInvestigation]
          -- ^ One or more sets of investigations (signs, symptions, 
          --   etc.). The actual grouping of investigations vary greatly 
          --   depending on the type and context of the assessment. These 
          --   investigations may include data generated during the 
          --   assessment process, or data previously generated and 
          --   recorded that is pertinent to the outcomes.
        , clinicalImpression_protocol :: [Uri]
          -- ^ Reference to a specific published clinical protocol that 
          --   was followed during this assessment, and/or that provides 
          --   evidence in support of the diagnosis.
        , clinicalImpression_summary :: Maybe Xsd.XsdString
          -- ^ A text summary of the investigations and the diagnosis.
        , clinicalImpression_finding :: [ClinicalImpressionFinding]
          -- ^ Specific findings or diagnoses that was considered likely 
          --   or relevant to ongoing treatment.
        , clinicalImpression_prognosisCodeableConcept :: [CodeableConcept]
          -- ^ Estimate of likely outcome.
        , clinicalImpression_prognosisReference :: [Reference]
          -- ^ RiskAssessment expressing likely outcome.
        , clinicalImpression_action :: [Reference]
          -- ^ Action taken as part of assessment procedure.
        , clinicalImpression_note :: [Annotation]
          -- ^ Commentary about the impression, typically recorded after 
          --   the impression itself was made, though supplemental notes 
          --   by the original author could also appear.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpression where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ClinicalImpression
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "assessor")
            `apply` optional (parseSchemaType "previous")
            `apply` many (parseSchemaType "problem")
            `apply` many (parseSchemaType "investigation")
            `apply` many (parseSchemaType "protocol")
            `apply` optional (parseSchemaType "summary")
            `apply` many (parseSchemaType "finding")
            `apply` many (parseSchemaType "prognosisCodeableConcept")
            `apply` many (parseSchemaType "prognosisReference")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@ClinicalImpression{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ clinicalImpression_id x
            , maybe [] (schemaTypeToXML "meta") $ clinicalImpression_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ clinicalImpression_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ clinicalImpression_language x
            , maybe [] (schemaTypeToXML "text") $ clinicalImpression_text x
            , concatMap (schemaTypeToXML "contained") $ clinicalImpression_contained x
            , concatMap (schemaTypeToXML "extension") $ clinicalImpression_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpression_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ clinicalImpression_identifier x
            , schemaTypeToXML "status" $ clinicalImpression_status x
            , maybe [] (schemaTypeToXML "code") $ clinicalImpression_code x
            , maybe [] (schemaTypeToXML "description") $ clinicalImpression_description x
            , schemaTypeToXML "subject" $ clinicalImpression_subject x
            , maybe [] (schemaTypeToXML "context") $ clinicalImpression_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ clinicalImpression_choice14 x
            , maybe [] (schemaTypeToXML "date") $ clinicalImpression_date x
            , maybe [] (schemaTypeToXML "assessor") $ clinicalImpression_assessor x
            , maybe [] (schemaTypeToXML "previous") $ clinicalImpression_previous x
            , concatMap (schemaTypeToXML "problem") $ clinicalImpression_problem x
            , concatMap (schemaTypeToXML "investigation") $ clinicalImpression_investigation x
            , concatMap (schemaTypeToXML "protocol") $ clinicalImpression_protocol x
            , maybe [] (schemaTypeToXML "summary") $ clinicalImpression_summary x
            , concatMap (schemaTypeToXML "finding") $ clinicalImpression_finding x
            , concatMap (schemaTypeToXML "prognosisCodeableConcept") $ clinicalImpression_prognosisCodeableConcept x
            , concatMap (schemaTypeToXML "prognosisReference") $ clinicalImpression_prognosisReference x
            , concatMap (schemaTypeToXML "action") $ clinicalImpression_action x
            , concatMap (schemaTypeToXML "note") $ clinicalImpression_note x
            ]
instance Extension ClinicalImpression DomainResource where
    supertype (ClinicalImpression e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ClinicalImpression Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ClinicalImpression -> DomainResource)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
data ClinicalImpressionInvestigation = ClinicalImpressionInvestigation
        { clinicalImpressionInvestigation_id :: Maybe String_primitive
        , clinicalImpressionInvestigation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpressionInvestigation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpressionInvestigation_code :: CodeableConcept
          -- ^ A name/code for the group (&quot;set&quot;) of 
          --   investigations. Typically, this will be something like 
          --   &quot;signs&quot;, &quot;symptoms&quot;, 
          --   &quot;clinical&quot;, &quot;diagnostic&quot;, but the list 
          --   is not constrained, and others such groups such as 
          --   (exposure|family|travel|nutitirional) history may be used.
        , clinicalImpressionInvestigation_item :: [Reference]
          -- ^ A record of a specific investigation that was undertaken.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpressionInvestigation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClinicalImpressionInvestigation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@ClinicalImpressionInvestigation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpressionInvestigation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpressionInvestigation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpressionInvestigation_modifierExtension x
            , schemaTypeToXML "code" $ clinicalImpressionInvestigation_code x
            , concatMap (schemaTypeToXML "item") $ clinicalImpressionInvestigation_item x
            ]
instance Extension ClinicalImpressionInvestigation BackboneElement where
    supertype (ClinicalImpressionInvestigation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ClinicalImpressionInvestigation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClinicalImpressionInvestigation -> BackboneElement)
              
 
-- | A record of a clinical assessment performed to determine 
--   what problem(s) may affect the patient and before planning 
--   the treatments or management strategies that are best to 
--   manage a patient's condition. Assessments are often 1:1 
--   with a clinical consultation / encounter, but this varies 
--   greatly depending on the clinical workflow. This resource 
--   is called &quot;ClinicalImpression&quot; rather than 
--   &quot;ClinicalAssessment&quot; to avoid confusion with the 
--   recording of assessment tools such as Apgar score.
data ClinicalImpressionFinding = ClinicalImpressionFinding
        { clinicalImpressionFinding_id :: Maybe String_primitive
        , clinicalImpressionFinding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , clinicalImpressionFinding_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , clinicalImpressionFinding_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ Specific text, code or reference for finding or diagnosis, 
          --   which may include ruled-out or resolved conditions.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , clinicalImpressionFinding_basis :: Maybe Xsd.XsdString
          -- ^ Which investigations support finding or diagnosis.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpressionFinding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ClinicalImpressionFinding a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "basis")
    schemaTypeToXML s x@ClinicalImpressionFinding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpressionFinding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpressionFinding_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ clinicalImpressionFinding_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ clinicalImpressionFinding_choice2 x
            , maybe [] (schemaTypeToXML "basis") $ clinicalImpressionFinding_basis x
            ]
instance Extension ClinicalImpressionFinding BackboneElement where
    supertype (ClinicalImpressionFinding a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ClinicalImpressionFinding Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ClinicalImpressionFinding -> BackboneElement)
              
 
data ClinicalImpressionStatus_list
    = ClinicalImpressionStatus_list_Draft
      -- ^ In progress
    | ClinicalImpressionStatus_list_Completed
      -- ^ Completed
    | ClinicalImpressionStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ClinicalImpressionStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ClinicalImpressionStatus_list where
    acceptingParser =  do literal "draft"; return ClinicalImpressionStatus_list_Draft
                      `onFail` do literal "completed"; return ClinicalImpressionStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return ClinicalImpressionStatus_list_Entered_in_error
                      
    simpleTypeText ClinicalImpressionStatus_list_Draft = "draft"
    simpleTypeText ClinicalImpressionStatus_list_Completed = "completed"
    simpleTypeText ClinicalImpressionStatus_list_Entered_in_error = "entered-in-error"
 
data ClinicalImpressionStatus = ClinicalImpressionStatus
        { clinicalImpressionStatus_id :: Maybe String_primitive
        , clinicalImpressionStatus_value :: Maybe ClinicalImpressionStatus_list
        , clinicalImpressionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ClinicalImpressionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ClinicalImpressionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ClinicalImpressionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ clinicalImpressionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ clinicalImpressionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ clinicalImpressionStatus_extension x
            ]
instance Extension ClinicalImpressionStatus Element where
    supertype (ClinicalImpressionStatus a0 a1 e0) =
               Element a0 e0
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
elementCodeSystem :: XMLParser CodeSystem
elementCodeSystem = parseSchemaType "CodeSystem"
elementToXMLCodeSystem :: CodeSystem -> [Content ()]
elementToXMLCodeSystem = schemaTypeToXML "CodeSystem"
 
data CodeSystem = CodeSystem
        { codeSystem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , codeSystem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , codeSystem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , codeSystem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , codeSystem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , codeSystem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , codeSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystem_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this code system 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this code system 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the code system. For more information see 
          --   [Technical and Business Versions](resource.html#versions). 
          --   This is used in [Coding]{datatypes.html#Coding}.system.
        , codeSystem_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this code 
          --   system when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , codeSystem_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   code system when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the code system author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. This is used in 
          --   [Coding]{datatypes.html#Coding}.version.
        , codeSystem_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the code system. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , codeSystem_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the code 
          --   system.
        , codeSystem_status :: PublicationStatus
          -- ^ The status of this code system. Enables tracking the 
          --   life-cycle of the content.
        , codeSystem_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this code system is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , codeSystem_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the code system was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the code system changes.
        , codeSystem_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the code system.
        , codeSystem_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , codeSystem_description :: Maybe Markdown
          -- ^ A free text natural language description of the code system 
          --   from a consumer's perspective.
        , codeSystem_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   code system instances.
        , codeSystem_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the code system is 
          --   intended to be used.
        , codeSystem_purpose :: Maybe Markdown
          -- ^ Explaination of why this code system is needed and why it 
          --   has been designed as it has.
        , codeSystem_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the code system and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the code system.
        , codeSystem_caseSensitive :: Maybe Boolean
          -- ^ If code comparison is case sensitive when codes within this 
          --   system are compared to each other.
        , codeSystem_valueSet :: Maybe Uri
          -- ^ Canonical URL of value set that contains the entire code 
          --   system.
        , codeSystem_hierarchyMeaning :: Maybe CodeSystemHierarchyMeaning
          -- ^ The meaning of the hierarchy of concepts.
        , codeSystem_compositional :: Maybe Boolean
          -- ^ True If code system defines a post-composition grammar.
        , codeSystem_versionNeeded :: Maybe Boolean
          -- ^ This flag is used to signify that the code system has not 
          --   (or does not) maintain the definitions, and a version must 
          --   be specified when referencing this code system.
        , codeSystem_content :: CodeSystemContentMode
          -- ^ How much of the content of the code system - the concepts 
          --   and codes it defines - are represented in this resource.
        , codeSystem_count :: Maybe UnsignedInt
          -- ^ The total number of concepts defined by the code system. 
          --   Where the code system has a compositional grammar, the 
          --   count refers to the number of base (primitive) concepts.
        , codeSystem_filter :: [CodeSystemFilter]
          -- ^ A filter that can be used in a value set compose statement 
          --   when selecting concepts using a filter.
        , codeSystem_property :: [CodeSystemProperty]
          -- ^ A property defines an additional slot through which 
          --   additional information can be provided about a concept.
        , codeSystem_concept :: [CodeSystemConcept]
          -- ^ Concepts that are in the code system. The concept 
          --   definitions are inherently hierarchical, but the 
          --   definitions must be consulted to determine what the meaning 
          --   of the hierarchical relationships are.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CodeSystem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "caseSensitive")
            `apply` optional (parseSchemaType "valueSet")
            `apply` optional (parseSchemaType "hierarchyMeaning")
            `apply` optional (parseSchemaType "compositional")
            `apply` optional (parseSchemaType "versionNeeded")
            `apply` parseSchemaType "content"
            `apply` optional (parseSchemaType "count")
            `apply` many (parseSchemaType "filter")
            `apply` many (parseSchemaType "property")
            `apply` many (parseSchemaType "concept")
    schemaTypeToXML s x@CodeSystem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ codeSystem_id x
            , maybe [] (schemaTypeToXML "meta") $ codeSystem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ codeSystem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ codeSystem_language x
            , maybe [] (schemaTypeToXML "text") $ codeSystem_text x
            , concatMap (schemaTypeToXML "contained") $ codeSystem_contained x
            , concatMap (schemaTypeToXML "extension") $ codeSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystem_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ codeSystem_url x
            , maybe [] (schemaTypeToXML "identifier") $ codeSystem_identifier x
            , maybe [] (schemaTypeToXML "version") $ codeSystem_version x
            , maybe [] (schemaTypeToXML "name") $ codeSystem_name x
            , maybe [] (schemaTypeToXML "title") $ codeSystem_title x
            , schemaTypeToXML "status" $ codeSystem_status x
            , maybe [] (schemaTypeToXML "experimental") $ codeSystem_experimental x
            , maybe [] (schemaTypeToXML "date") $ codeSystem_date x
            , maybe [] (schemaTypeToXML "publisher") $ codeSystem_publisher x
            , concatMap (schemaTypeToXML "contact") $ codeSystem_contact x
            , maybe [] (schemaTypeToXML "description") $ codeSystem_description x
            , concatMap (schemaTypeToXML "useContext") $ codeSystem_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ codeSystem_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ codeSystem_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ codeSystem_copyright x
            , maybe [] (schemaTypeToXML "caseSensitive") $ codeSystem_caseSensitive x
            , maybe [] (schemaTypeToXML "valueSet") $ codeSystem_valueSet x
            , maybe [] (schemaTypeToXML "hierarchyMeaning") $ codeSystem_hierarchyMeaning x
            , maybe [] (schemaTypeToXML "compositional") $ codeSystem_compositional x
            , maybe [] (schemaTypeToXML "versionNeeded") $ codeSystem_versionNeeded x
            , schemaTypeToXML "content" $ codeSystem_content x
            , maybe [] (schemaTypeToXML "count") $ codeSystem_count x
            , concatMap (schemaTypeToXML "filter") $ codeSystem_filter x
            , concatMap (schemaTypeToXML "property") $ codeSystem_property x
            , concatMap (schemaTypeToXML "concept") $ codeSystem_concept x
            ]
instance Extension CodeSystem DomainResource where
    supertype (CodeSystem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CodeSystem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CodeSystem -> DomainResource)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystemFilter = CodeSystemFilter
        { codeSystemFilter_id :: Maybe String_primitive
        , codeSystemFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystemFilter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystemFilter_code :: Code
          -- ^ The code that identifies this filter when it is used in the 
          --   instance.
        , codeSystemFilter_description :: Maybe Xsd.XsdString
          -- ^ A description of how or why the filter is used.
        , codeSystemFilter_operator :: [FilterOperator]
          -- ^ A list of operators that can be used with the filter.
        , codeSystemFilter_value :: Xsd.XsdString
          -- ^ A description of what the value for the filter should be.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystemFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "operator")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@CodeSystemFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemFilter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystemFilter_modifierExtension x
            , schemaTypeToXML "code" $ codeSystemFilter_code x
            , maybe [] (schemaTypeToXML "description") $ codeSystemFilter_description x
            , concatMap (schemaTypeToXML "operator") $ codeSystemFilter_operator x
            , schemaTypeToXML "value" $ codeSystemFilter_value x
            ]
instance Extension CodeSystemFilter BackboneElement where
    supertype (CodeSystemFilter a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CodeSystemFilter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystemFilter -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystemProperty = CodeSystemProperty
        { codeSystemProperty_id :: Maybe String_primitive
        , codeSystemProperty_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystemProperty_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystemProperty_code :: Code
          -- ^ A code that is used to identify the property. The code is 
          --   used internally (in CodeSystem.concept.property.code) and 
          --   also externally, such as in property filters.
        , codeSystemProperty_uri :: Maybe Uri
          -- ^ Reference to the formal meaning of the property. One 
          --   possible source of meaning is the [Concept 
          --   Properties](codesystem-concept-properties.html) code 
          --   system.
        , codeSystemProperty_description :: Maybe Xsd.XsdString
          -- ^ A description of the property- why it is defined, and how 
          --   its value might be used.
        , codeSystemProperty_type :: PropertyType
          -- ^ The type of the property value. Properties of type 
          --   &quot;code&quot; contain a code defined by the code system 
          --   (e.g. a reference to anotherr defined concept).
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemProperty where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystemProperty a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "type"
    schemaTypeToXML s x@CodeSystemProperty{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemProperty_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemProperty_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystemProperty_modifierExtension x
            , schemaTypeToXML "code" $ codeSystemProperty_code x
            , maybe [] (schemaTypeToXML "uri") $ codeSystemProperty_uri x
            , maybe [] (schemaTypeToXML "description") $ codeSystemProperty_description x
            , schemaTypeToXML "type" $ codeSystemProperty_type x
            ]
instance Extension CodeSystemProperty BackboneElement where
    supertype (CodeSystemProperty a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension CodeSystemProperty Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystemProperty -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystemConcept = CodeSystemConcept
        { codeSystemConcept_id :: Maybe String_primitive
        , codeSystemConcept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystemConcept_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystemConcept_code :: Code
          -- ^ A code - a text symbol - that uniquely identifies the 
          --   concept within the code system.
        , codeSystemConcept_display :: Maybe Xsd.XsdString
          -- ^ A human readable string that is the recommended default way 
          --   to present this concept to a user.
        , codeSystemConcept_definition :: Maybe Xsd.XsdString
          -- ^ The formal definition of the concept. The code system 
          --   resource does not make formal definitions required, because 
          --   of the prevalence of legacy systems. However, they are 
          --   highly recommended, as without them there is no formal 
          --   meaning associated with the concept.
        , codeSystemConcept_designation :: [CodeSystemDesignation]
          -- ^ Additional representations for the concept - other 
          --   languages, aliases, specialized purposes, used for 
          --   particular purposes, etc.
        , codeSystemConcept_property :: [CodeSystemProperty1]
          -- ^ A property value for this concept.
        , codeSystemConcept_concept :: [CodeSystemConcept]
          -- ^ Defines children of a concept to produce a hierarchy of 
          --   concepts. The nature of the relationships is variable 
          --   (is-a/contains/categorizes) - see hierarchyMeaning.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemConcept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystemConcept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "definition")
            `apply` many (parseSchemaType "designation")
            `apply` many (parseSchemaType "property")
            `apply` many (parseSchemaType "concept")
    schemaTypeToXML s x@CodeSystemConcept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemConcept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemConcept_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystemConcept_modifierExtension x
            , schemaTypeToXML "code" $ codeSystemConcept_code x
            , maybe [] (schemaTypeToXML "display") $ codeSystemConcept_display x
            , maybe [] (schemaTypeToXML "definition") $ codeSystemConcept_definition x
            , concatMap (schemaTypeToXML "designation") $ codeSystemConcept_designation x
            , concatMap (schemaTypeToXML "property") $ codeSystemConcept_property x
            , concatMap (schemaTypeToXML "concept") $ codeSystemConcept_concept x
            ]
instance Extension CodeSystemConcept BackboneElement where
    supertype (CodeSystemConcept a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension CodeSystemConcept Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystemConcept -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystemDesignation = CodeSystemDesignation
        { codeSystemDesignation_id :: Maybe String_primitive
        , codeSystemDesignation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystemDesignation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystemDesignation_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , codeSystemDesignation_use :: Maybe Coding
          -- ^ A code that details how this designation would be used.
        , codeSystemDesignation_value :: Xsd.XsdString
          -- ^ The text value for this designation.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemDesignation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystemDesignation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@CodeSystemDesignation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemDesignation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemDesignation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystemDesignation_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ codeSystemDesignation_language x
            , maybe [] (schemaTypeToXML "use") $ codeSystemDesignation_use x
            , schemaTypeToXML "value" $ codeSystemDesignation_value x
            ]
instance Extension CodeSystemDesignation BackboneElement where
    supertype (CodeSystemDesignation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CodeSystemDesignation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystemDesignation -> BackboneElement)
              
 
-- | A code system resource specifies a set of codes drawn from 
--   one or more code systems.
data CodeSystemProperty1 = CodeSystemProperty1
        { codeSystemProperty1_id :: Maybe String_primitive
        , codeSystemProperty1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , codeSystemProperty1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , codeSystemProperty1_code :: Code
          -- ^ A code that is a reference to CodeSystem.property.code.
        , codeSystemProperty1_choice3 :: OneOf6 Code Coding Xsd.XsdString Integer Boolean DateTime
          -- ^ The value of this property.
          --   
          --   Choice between:
          --   
          --   (1) valueCode
          --   
          --   (2) valueCoding
          --   
          --   (3) valueString
          --   
          --   (4) valueInteger
          --   
          --   (5) valueBoolean
          --   
          --   (6) valueDateTime
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemProperty1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CodeSystemProperty1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("Code", fmap OneOf6 (parseSchemaType "valueCode"))
                           , ("Coding", fmap TwoOf6 (parseSchemaType "valueCoding"))
                           , ("Xsd.XsdString", fmap ThreeOf6 (parseSchemaType "valueString"))
                           , ("Integer", fmap FourOf6 (parseSchemaType "valueInteger"))
                           , ("Boolean", fmap FiveOf6 (parseSchemaType "valueBoolean"))
                           , ("DateTime", fmap SixOf6 (parseSchemaType "valueDateTime"))
                           ]
    schemaTypeToXML s x@CodeSystemProperty1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemProperty1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemProperty1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ codeSystemProperty1_modifierExtension x
            , schemaTypeToXML "code" $ codeSystemProperty1_code x
            , foldOneOf6  (schemaTypeToXML "valueCode")
                          (schemaTypeToXML "valueCoding")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueDateTime")
                          $ codeSystemProperty1_choice3 x
            ]
instance Extension CodeSystemProperty1 BackboneElement where
    supertype (CodeSystemProperty1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CodeSystemProperty1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CodeSystemProperty1 -> BackboneElement)
              
 
data FilterOperator_list
    = FilterOperator_list_Eq
      -- ^ Equals
    | FilterOperator_list_Is_a
      -- ^ Is A (by subsumption)
    | FilterOperator_list_Descendent_of
      -- ^ Descendent Of (by subsumption)
    | FilterOperator_list_Is_not_a
      -- ^ Not (Is A) (by subsumption)
    | FilterOperator_list_Regex
      -- ^ Regular Expression
    | FilterOperator_list_In
      -- ^ In Set
    | FilterOperator_list_Not_in
      -- ^ Not in Set
    | FilterOperator_list_Generalizes
      -- ^ Generalizes (by Subsumption)
    | FilterOperator_list_Exists
      -- ^ Exists
    deriving (Eq,Show,Enum)
instance SchemaType FilterOperator_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FilterOperator_list where
    acceptingParser =  do literal "="; return FilterOperator_list_Eq
                      `onFail` do literal "is-a"; return FilterOperator_list_Is_a
                      `onFail` do literal "descendent-of"; return FilterOperator_list_Descendent_of
                      `onFail` do literal "is-not-a"; return FilterOperator_list_Is_not_a
                      `onFail` do literal "regex"; return FilterOperator_list_Regex
                      `onFail` do literal "in"; return FilterOperator_list_In
                      `onFail` do literal "not-in"; return FilterOperator_list_Not_in
                      `onFail` do literal "generalizes"; return FilterOperator_list_Generalizes
                      `onFail` do literal "exists"; return FilterOperator_list_Exists
                      
    simpleTypeText FilterOperator_list_Eq = "="
    simpleTypeText FilterOperator_list_Is_a = "is-a"
    simpleTypeText FilterOperator_list_Descendent_of = "descendent-of"
    simpleTypeText FilterOperator_list_Is_not_a = "is-not-a"
    simpleTypeText FilterOperator_list_Regex = "regex"
    simpleTypeText FilterOperator_list_In = "in"
    simpleTypeText FilterOperator_list_Not_in = "not-in"
    simpleTypeText FilterOperator_list_Generalizes = "generalizes"
    simpleTypeText FilterOperator_list_Exists = "exists"
 
data FilterOperator = FilterOperator
        { filterOperator_id :: Maybe String_primitive
        , filterOperator_value :: Maybe FilterOperator_list
        , filterOperator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FilterOperator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FilterOperator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FilterOperator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ filterOperator_id x
                       , maybe [] (toXMLAttribute "value") $ filterOperator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ filterOperator_extension x
            ]
instance Extension FilterOperator Element where
    supertype (FilterOperator a0 a1 e0) =
               Element a0 e0
 
data PropertyType_list
    = PropertyType_list_Code
      -- ^ code (internal reference)
    | PropertyType_list_Coding
      -- ^ Coding (external reference)
    | PropertyType_list_Xsd.XsdString
      -- ^ string
    | PropertyType_list_Integer
      -- ^ integer
    | PropertyType_list_Boolean
      -- ^ boolean
    | PropertyType_list_DateTime
      -- ^ dateTime
    deriving (Eq,Show,Enum)
instance SchemaType PropertyType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType PropertyType_list where
    acceptingParser =  do literal "code"; return PropertyType_list_Code
                      `onFail` do literal "Coding"; return PropertyType_list_Coding
                      `onFail` do literal "string"; return PropertyType_list_Xsd.XsdString
                      `onFail` do literal "integer"; return PropertyType_list_Integer
                      `onFail` do literal "boolean"; return PropertyType_list_Boolean
                      `onFail` do literal "dateTime"; return PropertyType_list_DateTime
                      
    simpleTypeText PropertyType_list_Code = "code"
    simpleTypeText PropertyType_list_Coding = "Coding"
    simpleTypeText PropertyType_list_Xsd.XsdString = "string"
    simpleTypeText PropertyType_list_Integer = "integer"
    simpleTypeText PropertyType_list_Boolean = "boolean"
    simpleTypeText PropertyType_list_DateTime = "dateTime"
 
data PropertyType = PropertyType
        { propertyType_id :: Maybe String_primitive
        , propertyType_value :: Maybe PropertyType_list
        , propertyType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType PropertyType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (PropertyType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@PropertyType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ propertyType_id x
                       , maybe [] (toXMLAttribute "value") $ propertyType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ propertyType_extension x
            ]
instance Extension PropertyType Element where
    supertype (PropertyType a0 a1 e0) =
               Element a0 e0
 
data CodeSystemHierarchyMeaning_list
    = CodeSystemHierarchyMeaning_list_Grouped_by
      -- ^ Grouped By
    | CodeSystemHierarchyMeaning_list_Is_a
      -- ^ Is-A
    | CodeSystemHierarchyMeaning_list_Part_of
      -- ^ Part Of
    | CodeSystemHierarchyMeaning_list_Classified_with
      -- ^ Classified With
    deriving (Eq,Show,Enum)
instance SchemaType CodeSystemHierarchyMeaning_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CodeSystemHierarchyMeaning_list where
    acceptingParser =  do literal "grouped-by"; return CodeSystemHierarchyMeaning_list_Grouped_by
                      `onFail` do literal "is-a"; return CodeSystemHierarchyMeaning_list_Is_a
                      `onFail` do literal "part-of"; return CodeSystemHierarchyMeaning_list_Part_of
                      `onFail` do literal "classified-with"; return CodeSystemHierarchyMeaning_list_Classified_with
                      
    simpleTypeText CodeSystemHierarchyMeaning_list_Grouped_by = "grouped-by"
    simpleTypeText CodeSystemHierarchyMeaning_list_Is_a = "is-a"
    simpleTypeText CodeSystemHierarchyMeaning_list_Part_of = "part-of"
    simpleTypeText CodeSystemHierarchyMeaning_list_Classified_with = "classified-with"
 
data CodeSystemHierarchyMeaning = CodeSystemHierarchyMeaning
        { codeSystemHierarchyMeaning_id :: Maybe String_primitive
        , codeSystemHierarchyMeaning_value :: Maybe CodeSystemHierarchyMeaning_list
        , codeSystemHierarchyMeaning_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemHierarchyMeaning where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CodeSystemHierarchyMeaning a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CodeSystemHierarchyMeaning{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemHierarchyMeaning_id x
                       , maybe [] (toXMLAttribute "value") $ codeSystemHierarchyMeaning_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemHierarchyMeaning_extension x
            ]
instance Extension CodeSystemHierarchyMeaning Element where
    supertype (CodeSystemHierarchyMeaning a0 a1 e0) =
               Element a0 e0
 
data CodeSystemContentMode_list
    = CodeSystemContentMode_list_Not_present
      -- ^ Not Present
    | CodeSystemContentMode_list_Example
      -- ^ Example
    | CodeSystemContentMode_list_Fragment
      -- ^ Fragment
    | CodeSystemContentMode_list_Complete
      -- ^ Complete
    deriving (Eq,Show,Enum)
instance SchemaType CodeSystemContentMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CodeSystemContentMode_list where
    acceptingParser =  do literal "not-present"; return CodeSystemContentMode_list_Not_present
                      `onFail` do literal "example"; return CodeSystemContentMode_list_Example
                      `onFail` do literal "fragment"; return CodeSystemContentMode_list_Fragment
                      `onFail` do literal "complete"; return CodeSystemContentMode_list_Complete
                      
    simpleTypeText CodeSystemContentMode_list_Not_present = "not-present"
    simpleTypeText CodeSystemContentMode_list_Example = "example"
    simpleTypeText CodeSystemContentMode_list_Fragment = "fragment"
    simpleTypeText CodeSystemContentMode_list_Complete = "complete"
 
data CodeSystemContentMode = CodeSystemContentMode
        { codeSystemContentMode_id :: Maybe String_primitive
        , codeSystemContentMode_value :: Maybe CodeSystemContentMode_list
        , codeSystemContentMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CodeSystemContentMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CodeSystemContentMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CodeSystemContentMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ codeSystemContentMode_id x
                       , maybe [] (toXMLAttribute "value") $ codeSystemContentMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ codeSystemContentMode_extension x
            ]
instance Extension CodeSystemContentMode Element where
    supertype (CodeSystemContentMode a0 a1 e0) =
               Element a0 e0
 
-- | An occurrence of information being transmitted; e.g. an 
--   alert that was sent to a responsible provider, a public 
--   health agency was notified about a reportable condition.
elementCommunication :: XMLParser Communication
elementCommunication = parseSchemaType "Communication"
elementToXMLCommunication :: Communication -> [Content ()]
elementToXMLCommunication = schemaTypeToXML "Communication"
 
data Communication = Communication
        { communication_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , communication_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , communication_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , communication_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , communication_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , communication_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , communication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communication_identifier :: [Identifier]
          -- ^ Identifiers associated with this Communication that are 
          --   defined by business processes and/ or used to refer to it 
          --   when a direct URL reference to the resource itself is not 
          --   appropriate (e.g. in CDA documents, or in written / printed 
          --   documentation).
        , communication_definition :: [Reference]
          -- ^ A protocol, guideline, or other definition that was adhered 
          --   to in whole or in part by this communication event.
        , communication_basedOn :: [Reference]
          -- ^ An order, proposal or plan fulfilled in whole or in part by 
          --   this Communication.
        , communication_partOf :: [Reference]
          -- ^ Part of this action.
        , communication_status :: EventStatus
          -- ^ The status of the transmission.
        , communication_notDone :: Maybe Boolean
          -- ^ If true, indicates that the described communication event 
          --   did not actually occur.
        , communication_notDoneReason :: Maybe CodeableConcept
          -- ^ Describes why the communication event did not occur in 
          --   coded and/or textual form.
        , communication_category :: [CodeableConcept]
          -- ^ The type of message conveyed such as alert, notification, 
          --   reminder, instruction, etc.
        , communication_medium :: [CodeableConcept]
          -- ^ A channel that was used for this communication (e.g. email, 
          --   fax).
        , communication_subject :: Maybe Reference
          -- ^ The patient or group that was the focus of this 
          --   communication.
        , communication_recipient :: [Reference]
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which was the target of the 
          --   communication. If receipts need to be tracked by 
          --   individual, a separate resource instance will need to be 
          --   created for each recipient. Multiple recipient 
          --   communications are intended where either a receipt(s) is 
          --   not tracked (e.g. a mass mail-out) or is captured in 
          --   aggregate (all emails confirmed received by a particular 
          --   time).
        , communication_topic :: [Reference]
          -- ^ The resources which were responsible for or related to 
          --   producing this communication.
        , communication_context :: Maybe Reference
          -- ^ The encounter within which the communication was sent.
        , communication_sent :: Maybe DateTime
          -- ^ The time when this communication was sent.
        , communication_received :: Maybe DateTime
          -- ^ The time when this communication arrived at the 
          --   destination.
        , communication_sender :: Maybe Reference
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which was the source of the 
          --   communication.
        , communication_reasonCode :: [CodeableConcept]
          -- ^ The reason or justification for the communication.
        , communication_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   communication.
        , communication_payload :: [CommunicationPayload]
          -- ^ Text, attachment(s), or resource(s) that was communicated 
          --   to the recipient.
        , communication_note :: [Annotation]
          -- ^ Additional notes or commentary about the communication by 
          --   the sender, receiver or other interested parties.
        }
        deriving (Eq,Show)
instance SchemaType Communication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Communication
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` many (parseSchemaType "category")
            `apply` many (parseSchemaType "medium")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "topic")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "sent")
            `apply` optional (parseSchemaType "received")
            `apply` optional (parseSchemaType "sender")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "payload")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Communication{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ communication_id x
            , maybe [] (schemaTypeToXML "meta") $ communication_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ communication_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ communication_language x
            , maybe [] (schemaTypeToXML "text") $ communication_text x
            , concatMap (schemaTypeToXML "contained") $ communication_contained x
            , concatMap (schemaTypeToXML "extension") $ communication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communication_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ communication_identifier x
            , concatMap (schemaTypeToXML "definition") $ communication_definition x
            , concatMap (schemaTypeToXML "basedOn") $ communication_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ communication_partOf x
            , schemaTypeToXML "status" $ communication_status x
            , maybe [] (schemaTypeToXML "notDone") $ communication_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ communication_notDoneReason x
            , concatMap (schemaTypeToXML "category") $ communication_category x
            , concatMap (schemaTypeToXML "medium") $ communication_medium x
            , maybe [] (schemaTypeToXML "subject") $ communication_subject x
            , concatMap (schemaTypeToXML "recipient") $ communication_recipient x
            , concatMap (schemaTypeToXML "topic") $ communication_topic x
            , maybe [] (schemaTypeToXML "context") $ communication_context x
            , maybe [] (schemaTypeToXML "sent") $ communication_sent x
            , maybe [] (schemaTypeToXML "received") $ communication_received x
            , maybe [] (schemaTypeToXML "sender") $ communication_sender x
            , concatMap (schemaTypeToXML "reasonCode") $ communication_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ communication_reasonReference x
            , concatMap (schemaTypeToXML "payload") $ communication_payload x
            , concatMap (schemaTypeToXML "note") $ communication_note x
            ]
instance Extension Communication DomainResource where
    supertype (Communication e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Communication Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Communication -> DomainResource)
              
 
-- | An occurrence of information being transmitted; e.g. an 
--   alert that was sent to a responsible provider, a public 
--   health agency was notified about a reportable condition.
data CommunicationPayload = CommunicationPayload
        { communicationPayload_id :: Maybe String_primitive
        , communicationPayload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationPayload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationPayload_choice2 :: OneOf3 Xsd.XsdString Attachment Reference
          -- ^ A communicated content (or for multi-part communications, 
          --   one portion of the communication).
          --   
          --   Choice between:
          --   
          --   (1) contentString
          --   
          --   (2) contentAttachment
          --   
          --   (3) contentReference
        }
        deriving (Eq,Show)
instance SchemaType CommunicationPayload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CommunicationPayload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Xsd.XsdString", fmap OneOf3 (parseSchemaType "contentString"))
                           , ("Attachment", fmap TwoOf3 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap ThreeOf3 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@CommunicationPayload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communicationPayload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communicationPayload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationPayload_modifierExtension x
            , foldOneOf3  (schemaTypeToXML "contentString")
                          (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ communicationPayload_choice2 x
            ]
instance Extension CommunicationPayload BackboneElement where
    supertype (CommunicationPayload a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension CommunicationPayload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CommunicationPayload -> BackboneElement)
              
 
data EventStatus_list
    = EventStatus_list_Preparation
      -- ^ Preparation
    | EventStatus_list_In_progress
      -- ^ In Progress
    | EventStatus_list_Suspended
      -- ^ Suspended
    | EventStatus_list_Aborted
      -- ^ Aborted
    | EventStatus_list_Completed
      -- ^ Completed
    | EventStatus_list_Entered_in_error
      -- ^ Entered in Error
    | EventStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType EventStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EventStatus_list where
    acceptingParser =  do literal "preparation"; return EventStatus_list_Preparation
                      `onFail` do literal "in-progress"; return EventStatus_list_In_progress
                      `onFail` do literal "suspended"; return EventStatus_list_Suspended
                      `onFail` do literal "aborted"; return EventStatus_list_Aborted
                      `onFail` do literal "completed"; return EventStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return EventStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return EventStatus_list_Unknown
                      
    simpleTypeText EventStatus_list_Preparation = "preparation"
    simpleTypeText EventStatus_list_In_progress = "in-progress"
    simpleTypeText EventStatus_list_Suspended = "suspended"
    simpleTypeText EventStatus_list_Aborted = "aborted"
    simpleTypeText EventStatus_list_Completed = "completed"
    simpleTypeText EventStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText EventStatus_list_Unknown = "unknown"
 
data EventStatus = EventStatus
        { eventStatus_id :: Maybe String_primitive
        , eventStatus_value :: Maybe EventStatus_list
        , eventStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EventStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EventStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EventStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eventStatus_id x
                       , maybe [] (toXMLAttribute "value") $ eventStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eventStatus_extension x
            ]
instance Extension EventStatus Element where
    supertype (EventStatus a0 a1 e0) =
               Element a0 e0
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
elementCommunicationRequest :: XMLParser CommunicationRequest
elementCommunicationRequest = parseSchemaType "CommunicationRequest"
elementToXMLCommunicationRequest :: CommunicationRequest -> [Content ()]
elementToXMLCommunicationRequest = schemaTypeToXML "CommunicationRequest"
 
data CommunicationRequest = CommunicationRequest
        { communicationRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , communicationRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , communicationRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , communicationRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , communicationRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , communicationRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , communicationRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequest_identifier :: [Identifier]
          -- ^ A unique ID of this request for reference purposes. It must 
          --   be provided if user wants it returned as part of any 
          --   output, otherwise it will be autogenerated, if needed, by 
          --   CDS system. Does not need to be the actual ID of the source 
          --   system.
        , communicationRequest_basedOn :: [Reference]
          -- ^ A plan or proposal that is fulfilled in whole or in part by 
          --   this request.
        , communicationRequest_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , communicationRequest_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition, 
          --   prescription or similar form.
        , communicationRequest_status :: RequestStatus
          -- ^ The status of the proposal or order.
        , communicationRequest_category :: [CodeableConcept]
          -- ^ The type of message to be sent such as alert, notification, 
          --   reminder, instruction, etc.
        , communicationRequest_priority :: Maybe RequestPriority
          -- ^ Characterizes how quickly the proposed act must be 
          --   initiated. Includes concepts such as stat, urgent, routine.
        , communicationRequest_medium :: [CodeableConcept]
          -- ^ A channel that was used for this communication (e.g. email, 
          --   fax).
        , communicationRequest_subject :: Maybe Reference
          -- ^ The patient or group that is the focus of this 
          --   communication request.
        , communicationRequest_recipient :: [Reference]
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, device, group, or care team) which is the intended 
          --   target of the communication.
        , communicationRequest_topic :: [Reference]
          -- ^ The resources which were related to producing this 
          --   communication request.
        , communicationRequest_context :: Maybe Reference
          -- ^ The encounter or episode of care within which the 
          --   communication request was created.
        , communicationRequest_payload :: [CommunicationRequestPayload]
          -- ^ Text, attachment(s), or resource(s) to be communicated to 
          --   the recipient.
        , communicationRequest_choice21 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time when this communication is to occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , communicationRequest_authoredOn :: Maybe DateTime
          -- ^ For draft requests, indicates the date of initial creation. 
          --   For requests with other statuses, indicates the date of 
          --   activation.
        , communicationRequest_sender :: Maybe Reference
          -- ^ The entity (e.g. person, organization, clinical information 
          --   system, or device) which is to be the source of the 
          --   communication.
        , communicationRequest_requester :: Maybe CommunicationRequestRequester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , communicationRequest_reasonCode :: [CodeableConcept]
          -- ^ Describes why the request is being made in coded or textual 
          --   form.
        , communicationRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   request.
        , communicationRequest_note :: [Annotation]
          -- ^ Comments made about the request by the requester, sender, 
          --   recipient, subject or other participants.
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CommunicationRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` many (parseSchemaType "medium")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "topic")
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "payload")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "sender")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@CommunicationRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ communicationRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ communicationRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ communicationRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ communicationRequest_language x
            , maybe [] (schemaTypeToXML "text") $ communicationRequest_text x
            , concatMap (schemaTypeToXML "contained") $ communicationRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ communicationRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ communicationRequest_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ communicationRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ communicationRequest_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ communicationRequest_groupIdentifier x
            , schemaTypeToXML "status" $ communicationRequest_status x
            , concatMap (schemaTypeToXML "category") $ communicationRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ communicationRequest_priority x
            , concatMap (schemaTypeToXML "medium") $ communicationRequest_medium x
            , maybe [] (schemaTypeToXML "subject") $ communicationRequest_subject x
            , concatMap (schemaTypeToXML "recipient") $ communicationRequest_recipient x
            , concatMap (schemaTypeToXML "topic") $ communicationRequest_topic x
            , maybe [] (schemaTypeToXML "context") $ communicationRequest_context x
            , concatMap (schemaTypeToXML "payload") $ communicationRequest_payload x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ communicationRequest_choice21 x
            , maybe [] (schemaTypeToXML "authoredOn") $ communicationRequest_authoredOn x
            , maybe [] (schemaTypeToXML "sender") $ communicationRequest_sender x
            , maybe [] (schemaTypeToXML "requester") $ communicationRequest_requester x
            , concatMap (schemaTypeToXML "reasonCode") $ communicationRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ communicationRequest_reasonReference x
            , concatMap (schemaTypeToXML "note") $ communicationRequest_note x
            ]
instance Extension CommunicationRequest DomainResource where
    supertype (CommunicationRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CommunicationRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CommunicationRequest -> DomainResource)
              
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
data CommunicationRequestPayload = CommunicationRequestPayload
        { communicationRequestPayload_id :: Maybe String_primitive
        , communicationRequestPayload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequestPayload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequestPayload_choice2 :: OneOf3 Xsd.XsdString Attachment Reference
          -- ^ The communicated content (or for multi-part communications, 
          --   one portion of the communication).
          --   
          --   Choice between:
          --   
          --   (1) contentString
          --   
          --   (2) contentAttachment
          --   
          --   (3) contentReference
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequestPayload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CommunicationRequestPayload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Xsd.XsdString", fmap OneOf3 (parseSchemaType "contentString"))
                           , ("Attachment", fmap TwoOf3 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap ThreeOf3 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@CommunicationRequestPayload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communicationRequestPayload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communicationRequestPayload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequestPayload_modifierExtension x
            , foldOneOf3  (schemaTypeToXML "contentString")
                          (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ communicationRequestPayload_choice2 x
            ]
instance Extension CommunicationRequestPayload BackboneElement where
    supertype (CommunicationRequestPayload a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension CommunicationRequestPayload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CommunicationRequestPayload -> BackboneElement)
              
 
-- | A request to convey information; e.g. the CDS system 
--   proposes that an alert be sent to a responsible provider, 
--   the CDS system proposes that the public health agency be 
--   notified about a reportable condition.
data CommunicationRequestRequester = CommunicationRequestRequester
        { communicationRequestRequester_id :: Maybe String_primitive
        , communicationRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , communicationRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , communicationRequestRequester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , communicationRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType CommunicationRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CommunicationRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@CommunicationRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ communicationRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ communicationRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ communicationRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ communicationRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ communicationRequestRequester_onBehalfOf x
            ]
instance Extension CommunicationRequestRequester BackboneElement where
    supertype (CommunicationRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CommunicationRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CommunicationRequestRequester -> BackboneElement)
              
 
data RequestStatus_list
    = RequestStatus_list_Draft
      -- ^ Draft
    | RequestStatus_list_Active
      -- ^ Active
    | RequestStatus_list_Suspended
      -- ^ Suspended
    | RequestStatus_list_Cancelled
      -- ^ Cancelled
    | RequestStatus_list_Completed
      -- ^ Completed
    | RequestStatus_list_Entered_in_error
      -- ^ Entered in Error
    | RequestStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType RequestStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestStatus_list where
    acceptingParser =  do literal "draft"; return RequestStatus_list_Draft
                      `onFail` do literal "active"; return RequestStatus_list_Active
                      `onFail` do literal "suspended"; return RequestStatus_list_Suspended
                      `onFail` do literal "cancelled"; return RequestStatus_list_Cancelled
                      `onFail` do literal "completed"; return RequestStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return RequestStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return RequestStatus_list_Unknown
                      
    simpleTypeText RequestStatus_list_Draft = "draft"
    simpleTypeText RequestStatus_list_Active = "active"
    simpleTypeText RequestStatus_list_Suspended = "suspended"
    simpleTypeText RequestStatus_list_Cancelled = "cancelled"
    simpleTypeText RequestStatus_list_Completed = "completed"
    simpleTypeText RequestStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText RequestStatus_list_Unknown = "unknown"
 
data RequestStatus = RequestStatus
        { requestStatus_id :: Maybe String_primitive
        , requestStatus_value :: Maybe RequestStatus_list
        , requestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ requestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestStatus_extension x
            ]
instance Extension RequestStatus Element where
    supertype (RequestStatus a0 a1 e0) =
               Element a0 e0
 
data RequestPriority_list
    = RequestPriority_list_Routine
      -- ^ Routine
    | RequestPriority_list_Urgent
      -- ^ Urgent
    | RequestPriority_list_Asap
      -- ^ ASAP
    | RequestPriority_list_Stat
      -- ^ STAT
    deriving (Eq,Show,Enum)
instance SchemaType RequestPriority_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestPriority_list where
    acceptingParser =  do literal "routine"; return RequestPriority_list_Routine
                      `onFail` do literal "urgent"; return RequestPriority_list_Urgent
                      `onFail` do literal "asap"; return RequestPriority_list_Asap
                      `onFail` do literal "stat"; return RequestPriority_list_Stat
                      
    simpleTypeText RequestPriority_list_Routine = "routine"
    simpleTypeText RequestPriority_list_Urgent = "urgent"
    simpleTypeText RequestPriority_list_Asap = "asap"
    simpleTypeText RequestPriority_list_Stat = "stat"
 
data RequestPriority = RequestPriority
        { requestPriority_id :: Maybe String_primitive
        , requestPriority_value :: Maybe RequestPriority_list
        , requestPriority_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestPriority where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestPriority a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestPriority{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestPriority_id x
                       , maybe [] (toXMLAttribute "value") $ requestPriority_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestPriority_extension x
            ]
instance Extension RequestPriority Element where
    supertype (RequestPriority a0 a1 e0) =
               Element a0 e0
 
-- | A compartment definition that defines how resources are 
--   accessed on a server.
elementCompartmentDefinition :: XMLParser CompartmentDefinition
elementCompartmentDefinition = parseSchemaType "CompartmentDefinition"
elementToXMLCompartmentDefinition :: CompartmentDefinition -> [Content ()]
elementToXMLCompartmentDefinition = schemaTypeToXML "CompartmentDefinition"
 
data CompartmentDefinition = CompartmentDefinition
        { compartmentDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , compartmentDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , compartmentDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , compartmentDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , compartmentDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , compartmentDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , compartmentDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compartmentDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compartmentDefinition_url :: Uri
          -- ^ An absolute URI that is used to identify this compartment 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   compartment definition is (or will be) published. The URL 
          --   SHOULD include the major version of the compartment 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , compartmentDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the compartment 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , compartmentDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   compartment definition.
        , compartmentDefinition_status :: PublicationStatus
          -- ^ The status of this compartment definition. Enables tracking 
          --   the life-cycle of the content.
        , compartmentDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this compartment 
          --   definition is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , compartmentDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the compartment 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the compartment definition changes.
        , compartmentDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the compartment definition.
        , compartmentDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , compartmentDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the compartment 
          --   definition from a consumer's perspective.
        , compartmentDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this compartment definition is needed 
          --   and why it has been designed as it has.
        , compartmentDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   compartment definition instances.
        , compartmentDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the compartment 
          --   definition is intended to be used.
        , compartmentDefinition_code :: CompartmentType
          -- ^ Which compartment this definition describes.
        , compartmentDefinition_search :: Boolean
          -- ^ Whether the search syntax is supported,.
        , compartmentDefinition_resource :: [CompartmentDefinitionResource]
          -- ^ Information about how a resource is related to the 
          --   compartment.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return CompartmentDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "search"
            `apply` many (parseSchemaType "resource")
    schemaTypeToXML s x@CompartmentDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ compartmentDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ compartmentDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ compartmentDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ compartmentDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ compartmentDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ compartmentDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ compartmentDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compartmentDefinition_modifierExtension x
            , schemaTypeToXML "url" $ compartmentDefinition_url x
            , schemaTypeToXML "name" $ compartmentDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ compartmentDefinition_title x
            , schemaTypeToXML "status" $ compartmentDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ compartmentDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ compartmentDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ compartmentDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ compartmentDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ compartmentDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ compartmentDefinition_purpose x
            , concatMap (schemaTypeToXML "useContext") $ compartmentDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ compartmentDefinition_jurisdiction x
            , schemaTypeToXML "code" $ compartmentDefinition_code x
            , schemaTypeToXML "search" $ compartmentDefinition_search x
            , concatMap (schemaTypeToXML "resource") $ compartmentDefinition_resource x
            ]
instance Extension CompartmentDefinition DomainResource where
    supertype (CompartmentDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension CompartmentDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: CompartmentDefinition -> DomainResource)
              
 
-- | A compartment definition that defines how resources are 
--   accessed on a server.
data CompartmentDefinitionResource = CompartmentDefinitionResource
        { compartmentDefinitionResource_id :: Maybe String_primitive
        , compartmentDefinitionResource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compartmentDefinitionResource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compartmentDefinitionResource_code :: ResourceType
          -- ^ The name of a resource supported by the server.
        , compartmentDefinitionResource_param :: [Xsd.XsdString]
          -- ^ The name of a search parameter that represents the link to 
          --   the compartment. More than one may be listed because a 
          --   resource may be linked to a compartment in more than one 
          --   way,.
        , compartmentDefinitionResource_documentation :: Maybe Xsd.XsdString
          -- ^ Additional documentation about the resource and 
          --   compartment.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentDefinitionResource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompartmentDefinitionResource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` many (parseSchemaType "param")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@CompartmentDefinitionResource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compartmentDefinitionResource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compartmentDefinitionResource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compartmentDefinitionResource_modifierExtension x
            , schemaTypeToXML "code" $ compartmentDefinitionResource_code x
            , concatMap (schemaTypeToXML "param") $ compartmentDefinitionResource_param x
            , maybe [] (schemaTypeToXML "documentation") $ compartmentDefinitionResource_documentation x
            ]
instance Extension CompartmentDefinitionResource BackboneElement where
    supertype (CompartmentDefinitionResource a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CompartmentDefinitionResource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompartmentDefinitionResource -> BackboneElement)
              
 
data CompartmentType_list
    = CompartmentType_list_Patient
      -- ^ Patient
    | CompartmentType_list_Encounter
      -- ^ Encounter
    | CompartmentType_list_RelatedPerson
      -- ^ RelatedPerson
    | CompartmentType_list_Practitioner
      -- ^ Practitioner
    | CompartmentType_list_Device
      -- ^ Device
    deriving (Eq,Show,Enum)
instance SchemaType CompartmentType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompartmentType_list where
    acceptingParser =  do literal "Patient"; return CompartmentType_list_Patient
                      `onFail` do literal "Encounter"; return CompartmentType_list_Encounter
                      `onFail` do literal "RelatedPerson"; return CompartmentType_list_RelatedPerson
                      `onFail` do literal "Practitioner"; return CompartmentType_list_Practitioner
                      `onFail` do literal "Device"; return CompartmentType_list_Device
                      
    simpleTypeText CompartmentType_list_Patient = "Patient"
    simpleTypeText CompartmentType_list_Encounter = "Encounter"
    simpleTypeText CompartmentType_list_RelatedPerson = "RelatedPerson"
    simpleTypeText CompartmentType_list_Practitioner = "Practitioner"
    simpleTypeText CompartmentType_list_Device = "Device"
 
data CompartmentType = CompartmentType
        { compartmentType_id :: Maybe String_primitive
        , compartmentType_value :: Maybe CompartmentType_list
        , compartmentType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompartmentType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompartmentType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompartmentType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compartmentType_id x
                       , maybe [] (toXMLAttribute "value") $ compartmentType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compartmentType_extension x
            ]
instance Extension CompartmentType Element where
    supertype (CompartmentType a0 a1 e0) =
               Element a0 e0
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
elementComposition :: XMLParser Composition
elementComposition = parseSchemaType "Composition"
elementToXMLComposition :: Composition -> [Content ()]
elementToXMLComposition = schemaTypeToXML "Composition"
 
data Composition = Composition
        { composition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , composition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , composition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , composition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , composition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , composition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , composition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , composition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , composition_identifier :: Maybe Identifier
          -- ^ Logical identifier for the composition, assigned when 
          --   created. This identifier stays constant as the composition 
          --   is changed over time.
        , composition_status :: CompositionStatus
          -- ^ The workflow/clinical status of this composition. The 
          --   status is a marker for the clinical standing of the 
          --   document.
        , composition_type :: CodeableConcept
          -- ^ Specifies the particular kind of composition (e.g. History 
          --   and Physical, Discharge Summary, Progress Note). This 
          --   usually equates to the purpose of making the composition.
        , composition_class :: Maybe CodeableConcept
          -- ^ A categorization for the type of the composition - helps 
          --   for indexing and searching. This may be implied by or 
          --   derived from the code specified in the Composition Type.
        , composition_subject :: Reference
          -- ^ Who or what the composition is about. The composition can 
          --   be about a person, (patient or healthcare practitioner), a 
          --   device (e.g. a machine) or even a group of subjects (such 
          --   as a document about a herd of livestock, or a set of 
          --   patients that share a common exposure).
        , composition_encounter :: Maybe Reference
          -- ^ Describes the clinical encounter or type of care this 
          --   documentation is associated with.
        , composition_date :: DateTime
          -- ^ The composition editing time, when the composition was last 
          --   logically changed by the author.
        , composition_author :: [Reference]
          -- ^ Identifies who is responsible for the information in the 
          --   composition, not necessarily who typed it in.
        , composition_title :: Xsd.XsdString
          -- ^ Official human-readable label for the composition.
        , composition_confidentiality :: Maybe ConfidentialityClassification
          -- ^ The code specifying the level of confidentiality of the 
          --   Composition.
        , composition_attester :: [CompositionAttester]
          -- ^ A participant who has attested to the accuracy of the 
          --   composition/document.
        , composition_custodian :: Maybe Reference
          -- ^ Identifies the organization or group who is responsible for 
          --   ongoing maintenance of and access to the 
          --   composition/document information.
        , composition_relatesTo :: [CompositionRelatesTo]
          -- ^ Relationships that this composition has with other 
          --   compositions or documents that already exist.
        , composition_event :: [CompositionEvent]
          -- ^ The clinical service, such as a colonoscopy or an 
          --   appendectomy, being documented.
        , composition_section :: [CompositionSection]
          -- ^ The root of the sections that make up the composition.
        }
        deriving (Eq,Show)
instance SchemaType Composition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Composition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "class")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "encounter")
            `apply` parseSchemaType "date"
            `apply` many1 (parseSchemaType "author")
            `apply` parseSchemaType "title"
            `apply` optional (parseSchemaType "confidentiality")
            `apply` many (parseSchemaType "attester")
            `apply` optional (parseSchemaType "custodian")
            `apply` many (parseSchemaType "relatesTo")
            `apply` many (parseSchemaType "event")
            `apply` many (parseSchemaType "section")
    schemaTypeToXML s x@Composition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ composition_id x
            , maybe [] (schemaTypeToXML "meta") $ composition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ composition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ composition_language x
            , maybe [] (schemaTypeToXML "text") $ composition_text x
            , concatMap (schemaTypeToXML "contained") $ composition_contained x
            , concatMap (schemaTypeToXML "extension") $ composition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ composition_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ composition_identifier x
            , schemaTypeToXML "status" $ composition_status x
            , schemaTypeToXML "type" $ composition_type x
            , maybe [] (schemaTypeToXML "class") $ composition_class x
            , schemaTypeToXML "subject" $ composition_subject x
            , maybe [] (schemaTypeToXML "encounter") $ composition_encounter x
            , schemaTypeToXML "date" $ composition_date x
            , concatMap (schemaTypeToXML "author") $ composition_author x
            , schemaTypeToXML "title" $ composition_title x
            , maybe [] (schemaTypeToXML "confidentiality") $ composition_confidentiality x
            , concatMap (schemaTypeToXML "attester") $ composition_attester x
            , maybe [] (schemaTypeToXML "custodian") $ composition_custodian x
            , concatMap (schemaTypeToXML "relatesTo") $ composition_relatesTo x
            , concatMap (schemaTypeToXML "event") $ composition_event x
            , concatMap (schemaTypeToXML "section") $ composition_section x
            ]
instance Extension Composition DomainResource where
    supertype (Composition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Composition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Composition -> DomainResource)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data CompositionAttester = CompositionAttester
        { compositionAttester_id :: Maybe String_primitive
        , compositionAttester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compositionAttester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compositionAttester_mode :: [CompositionAttestationMode]
          -- ^ The type of attestation the authenticator offers.
        , compositionAttester_time :: Maybe DateTime
          -- ^ When the composition was attested by the party.
        , compositionAttester_party :: Maybe Reference
          -- ^ Who attested the composition in the specified way.
        }
        deriving (Eq,Show)
instance SchemaType CompositionAttester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompositionAttester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "mode")
            `apply` optional (parseSchemaType "time")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@CompositionAttester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionAttester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionAttester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compositionAttester_modifierExtension x
            , concatMap (schemaTypeToXML "mode") $ compositionAttester_mode x
            , maybe [] (schemaTypeToXML "time") $ compositionAttester_time x
            , maybe [] (schemaTypeToXML "party") $ compositionAttester_party x
            ]
instance Extension CompositionAttester BackboneElement where
    supertype (CompositionAttester a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CompositionAttester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompositionAttester -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data CompositionRelatesTo = CompositionRelatesTo
        { compositionRelatesTo_id :: Maybe String_primitive
        , compositionRelatesTo_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compositionRelatesTo_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compositionRelatesTo_code :: DocumentRelationshipType
          -- ^ The type of relationship that this composition has with 
          --   anther composition or document.
        , compositionRelatesTo_choice3 :: OneOf2 Identifier Reference
          -- ^ The target composition/document of this relationship.
          --   
          --   Choice between:
          --   
          --   (1) targetIdentifier
          --   
          --   (2) targetReference
        }
        deriving (Eq,Show)
instance SchemaType CompositionRelatesTo where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompositionRelatesTo a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("Identifier", fmap OneOf2 (parseSchemaType "targetIdentifier"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "targetReference"))
                           ]
    schemaTypeToXML s x@CompositionRelatesTo{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionRelatesTo_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionRelatesTo_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compositionRelatesTo_modifierExtension x
            , schemaTypeToXML "code" $ compositionRelatesTo_code x
            , foldOneOf2  (schemaTypeToXML "targetIdentifier")
                          (schemaTypeToXML "targetReference")
                          $ compositionRelatesTo_choice3 x
            ]
instance Extension CompositionRelatesTo BackboneElement where
    supertype (CompositionRelatesTo a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension CompositionRelatesTo Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompositionRelatesTo -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data CompositionEvent = CompositionEvent
        { compositionEvent_id :: Maybe String_primitive
        , compositionEvent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compositionEvent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compositionEvent_code :: [CodeableConcept]
          -- ^ This list of codes represents the main clinical acts, such 
          --   as a colonoscopy or an appendectomy, being documented. In 
          --   some cases, the event is inherent in the typeCode, such as 
          --   a &quot;History and Physical Report&quot; in which the 
          --   procedure being documented is necessarily a &quot;History 
          --   and Physical&quot; act.
        , compositionEvent_period :: Maybe Period
          -- ^ The period of time covered by the documentation. There is 
          --   no assertion that the documentation is a complete 
          --   representation for this period, only that it documents 
          --   events during this time.
        , compositionEvent_detail :: [Reference]
          -- ^ The description and/or reference of the event(s) being 
          --   documented. For example, this could be used to document 
          --   such a colonoscopy or an appendectomy.
        }
        deriving (Eq,Show)
instance SchemaType CompositionEvent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompositionEvent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@CompositionEvent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionEvent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionEvent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compositionEvent_modifierExtension x
            , concatMap (schemaTypeToXML "code") $ compositionEvent_code x
            , maybe [] (schemaTypeToXML "period") $ compositionEvent_period x
            , concatMap (schemaTypeToXML "detail") $ compositionEvent_detail x
            ]
instance Extension CompositionEvent BackboneElement where
    supertype (CompositionEvent a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension CompositionEvent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompositionEvent -> BackboneElement)
              
 
-- | A set of healthcare-related information that is assembled 
--   together into a single logical document that provides a 
--   single coherent statement of meaning, establishes its own 
--   context and that has clinical attestation with regard to 
--   who is making the statement. While a Composition defines 
--   the structure, it does not actually contain the content: 
--   rather the full content of a document is contained in a 
--   Bundle, of which the Composition is the first resource 
--   contained.
data CompositionSection = CompositionSection
        { compositionSection_id :: Maybe String_primitive
        , compositionSection_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , compositionSection_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , compositionSection_title :: Maybe Xsd.XsdString
          -- ^ The label for this particular section. This will be part of 
          --   the rendered content for the document, and is often used to 
          --   build a table of contents.
        , compositionSection_code :: Maybe CodeableConcept
          -- ^ A code identifying the kind of content contained within the 
          --   section. This must be consistent with the section title.
        , compositionSection_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains the attested 
          --   content of the section, used to represent the content of 
          --   the resource to a human. The narrative need not encode all 
          --   the structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative.
        , compositionSection_mode :: Maybe ListMode
          -- ^ How the entry list was prepared - whether it is a working 
          --   list that is suitable for being maintained on an ongoing 
          --   basis, or if it represents a snapshot of a list of items 
          --   from another source, or whether it is a prepared list where 
          --   items may be marked as added, modified or deleted.
        , compositionSection_orderedBy :: Maybe CodeableConcept
          -- ^ Specifies the order applied to the items in the section 
          --   entries.
        , compositionSection_entry :: [Reference]
          -- ^ A reference to the actual resource from which the narrative 
          --   in the section is derived.
        , compositionSection_emptyReason :: Maybe CodeableConcept
          -- ^ If the section is empty, why the list is empty. An empty 
          --   section typically has some text explaining the empty 
          --   reason.
        , compositionSection_section :: [CompositionSection]
          -- ^ A nested sub-section within this section.
        }
        deriving (Eq,Show)
instance SchemaType CompositionSection where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CompositionSection a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "orderedBy")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "emptyReason")
            `apply` many (parseSchemaType "section")
    schemaTypeToXML s x@CompositionSection{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionSection_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionSection_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ compositionSection_modifierExtension x
            , maybe [] (schemaTypeToXML "title") $ compositionSection_title x
            , maybe [] (schemaTypeToXML "code") $ compositionSection_code x
            , maybe [] (schemaTypeToXML "text") $ compositionSection_text x
            , maybe [] (schemaTypeToXML "mode") $ compositionSection_mode x
            , maybe [] (schemaTypeToXML "orderedBy") $ compositionSection_orderedBy x
            , concatMap (schemaTypeToXML "entry") $ compositionSection_entry x
            , maybe [] (schemaTypeToXML "emptyReason") $ compositionSection_emptyReason x
            , concatMap (schemaTypeToXML "section") $ compositionSection_section x
            ]
instance Extension CompositionSection BackboneElement where
    supertype (CompositionSection a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension CompositionSection Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CompositionSection -> BackboneElement)
              
 
data CompositionStatus_list
    = CompositionStatus_list_Preliminary
      -- ^ Preliminary
    | CompositionStatus_list_Final
      -- ^ Final
    | CompositionStatus_list_Amended
      -- ^ Amended
    | CompositionStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType CompositionStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompositionStatus_list where
    acceptingParser =  do literal "preliminary"; return CompositionStatus_list_Preliminary
                      `onFail` do literal "final"; return CompositionStatus_list_Final
                      `onFail` do literal "amended"; return CompositionStatus_list_Amended
                      `onFail` do literal "entered-in-error"; return CompositionStatus_list_Entered_in_error
                      
    simpleTypeText CompositionStatus_list_Preliminary = "preliminary"
    simpleTypeText CompositionStatus_list_Final = "final"
    simpleTypeText CompositionStatus_list_Amended = "amended"
    simpleTypeText CompositionStatus_list_Entered_in_error = "entered-in-error"
 
data CompositionStatus = CompositionStatus
        { compositionStatus_id :: Maybe String_primitive
        , compositionStatus_value :: Maybe CompositionStatus_list
        , compositionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompositionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompositionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompositionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ compositionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionStatus_extension x
            ]
instance Extension CompositionStatus Element where
    supertype (CompositionStatus a0 a1 e0) =
               Element a0 e0
 
data ConfidentialityClassification_list
    = ConfidentialityClassification_list_U
      -- ^ unrestricted
    | ConfidentialityClassification_list_L
      -- ^ low
    | ConfidentialityClassification_list_M
      -- ^ moderate
    | ConfidentialityClassification_list_N
      -- ^ normal
    | ConfidentialityClassification_list_R
      -- ^ restricted
    | ConfidentialityClassification_list_V
      -- ^ very restricted
    deriving (Eq,Show,Enum)
instance SchemaType ConfidentialityClassification_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConfidentialityClassification_list where
    acceptingParser =  do literal "U"; return ConfidentialityClassification_list_U
                      `onFail` do literal "L"; return ConfidentialityClassification_list_L
                      `onFail` do literal "M"; return ConfidentialityClassification_list_M
                      `onFail` do literal "N"; return ConfidentialityClassification_list_N
                      `onFail` do literal "R"; return ConfidentialityClassification_list_R
                      `onFail` do literal "V"; return ConfidentialityClassification_list_V
                      
    simpleTypeText ConfidentialityClassification_list_U = "U"
    simpleTypeText ConfidentialityClassification_list_L = "L"
    simpleTypeText ConfidentialityClassification_list_M = "M"
    simpleTypeText ConfidentialityClassification_list_N = "N"
    simpleTypeText ConfidentialityClassification_list_R = "R"
    simpleTypeText ConfidentialityClassification_list_V = "V"
 
data ConfidentialityClassification = ConfidentialityClassification
        { confidentialityClassification_id :: Maybe String_primitive
        , confidentialityClassification_value :: Maybe ConfidentialityClassification_list
        , confidentialityClassification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConfidentialityClassification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConfidentialityClassification a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConfidentialityClassification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ confidentialityClassification_id x
                       , maybe [] (toXMLAttribute "value") $ confidentialityClassification_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ confidentialityClassification_extension x
            ]
instance Extension ConfidentialityClassification Element where
    supertype (ConfidentialityClassification a0 a1 e0) =
               Element a0 e0
 
data DocumentRelationshipType_list
    = DocumentRelationshipType_list_Replaces
      -- ^ Replaces
    | DocumentRelationshipType_list_Transforms
      -- ^ Transforms
    | DocumentRelationshipType_list_Signs
      -- ^ Signs
    | DocumentRelationshipType_list_Appends
      -- ^ Appends
    deriving (Eq,Show,Enum)
instance SchemaType DocumentRelationshipType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DocumentRelationshipType_list where
    acceptingParser =  do literal "replaces"; return DocumentRelationshipType_list_Replaces
                      `onFail` do literal "transforms"; return DocumentRelationshipType_list_Transforms
                      `onFail` do literal "signs"; return DocumentRelationshipType_list_Signs
                      `onFail` do literal "appends"; return DocumentRelationshipType_list_Appends
                      
    simpleTypeText DocumentRelationshipType_list_Replaces = "replaces"
    simpleTypeText DocumentRelationshipType_list_Transforms = "transforms"
    simpleTypeText DocumentRelationshipType_list_Signs = "signs"
    simpleTypeText DocumentRelationshipType_list_Appends = "appends"
 
data DocumentRelationshipType = DocumentRelationshipType
        { documentRelationshipType_id :: Maybe String_primitive
        , documentRelationshipType_value :: Maybe DocumentRelationshipType_list
        , documentRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DocumentRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DocumentRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DocumentRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ documentRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentRelationshipType_extension x
            ]
instance Extension DocumentRelationshipType Element where
    supertype (DocumentRelationshipType a0 a1 e0) =
               Element a0 e0
 
data CompositionAttestationMode_list
    = CompositionAttestationMode_list_Personal
      -- ^ Personal
    | CompositionAttestationMode_list_Professional
      -- ^ Professional
    | CompositionAttestationMode_list_Legal
      -- ^ Legal
    | CompositionAttestationMode_list_Official
      -- ^ Official
    deriving (Eq,Show,Enum)
instance SchemaType CompositionAttestationMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType CompositionAttestationMode_list where
    acceptingParser =  do literal "personal"; return CompositionAttestationMode_list_Personal
                      `onFail` do literal "professional"; return CompositionAttestationMode_list_Professional
                      `onFail` do literal "legal"; return CompositionAttestationMode_list_Legal
                      `onFail` do literal "official"; return CompositionAttestationMode_list_Official
                      
    simpleTypeText CompositionAttestationMode_list_Personal = "personal"
    simpleTypeText CompositionAttestationMode_list_Professional = "professional"
    simpleTypeText CompositionAttestationMode_list_Legal = "legal"
    simpleTypeText CompositionAttestationMode_list_Official = "official"
 
data CompositionAttestationMode = CompositionAttestationMode
        { compositionAttestationMode_id :: Maybe String_primitive
        , compositionAttestationMode_value :: Maybe CompositionAttestationMode_list
        , compositionAttestationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType CompositionAttestationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (CompositionAttestationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@CompositionAttestationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ compositionAttestationMode_id x
                       , maybe [] (toXMLAttribute "value") $ compositionAttestationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ compositionAttestationMode_extension x
            ]
instance Extension CompositionAttestationMode Element where
    supertype (CompositionAttestationMode a0 a1 e0) =
               Element a0 e0
 
data ListMode_list
    = ListMode_list_Working
      -- ^ Working List
    | ListMode_list_Snapshot
      -- ^ Snapshot List
    | ListMode_list_Changes
      -- ^ Change List
    deriving (Eq,Show,Enum)
instance SchemaType ListMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ListMode_list where
    acceptingParser =  do literal "working"; return ListMode_list_Working
                      `onFail` do literal "snapshot"; return ListMode_list_Snapshot
                      `onFail` do literal "changes"; return ListMode_list_Changes
                      
    simpleTypeText ListMode_list_Working = "working"
    simpleTypeText ListMode_list_Snapshot = "snapshot"
    simpleTypeText ListMode_list_Changes = "changes"
 
data ListMode = ListMode
        { listMode_id :: Maybe String_primitive
        , listMode_value :: Maybe ListMode_list
        , listMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ listMode_id x
                       , maybe [] (toXMLAttribute "value") $ listMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ listMode_extension x
            ]
instance Extension ListMode Element where
    supertype (ListMode a0 a1 e0) =
               Element a0 e0
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
elementConceptMap :: XMLParser ConceptMap
elementConceptMap = parseSchemaType "ConceptMap"
elementToXMLConceptMap :: ConceptMap -> [Content ()]
elementToXMLConceptMap = schemaTypeToXML "ConceptMap"
 
data ConceptMap = ConceptMap
        { conceptMap_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , conceptMap_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , conceptMap_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , conceptMap_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , conceptMap_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , conceptMap_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , conceptMap_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMap_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMap_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this concept map 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this concept map 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the concept map. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , conceptMap_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this concept 
          --   map when it is represented in other formats, or referenced 
          --   in a specification, model, design or an instance.
        , conceptMap_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   concept map when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the concept map author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , conceptMap_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the concept map. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , conceptMap_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the concept 
          --   map.
        , conceptMap_status :: PublicationStatus
          -- ^ The status of this concept map. Enables tracking the 
          --   life-cycle of the content.
        , conceptMap_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this concept map is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , conceptMap_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the concept map was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the concept map changes.
        , conceptMap_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the concept map.
        , conceptMap_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , conceptMap_description :: Maybe Markdown
          -- ^ A free text natural language description of the concept map 
          --   from a consumer's perspective.
        , conceptMap_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   concept map instances.
        , conceptMap_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the concept map is 
          --   intended to be used.
        , conceptMap_purpose :: Maybe Markdown
          -- ^ Explaination of why this concept map is needed and why it 
          --   has been designed as it has.
        , conceptMap_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the concept map and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the concept map.
        , conceptMap_choice23 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The source value set that specifies the concepts that are 
          --   being mapped.
          --   
          --   Choice between:
          --   
          --   (1) sourceUri
          --   
          --   (2) sourceReference
        , conceptMap_choice24 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The target value set provides context to the mappings. Note 
          --   that the mapping is made between concepts, not between 
          --   value sets, but the value set provides important context 
          --   about how the concept mapping choices are made.
          --   
          --   Choice between:
          --   
          --   (1) targetUri
          --   
          --   (2) targetReference
        , conceptMap_group :: [ConceptMapGroup]
          -- ^ A group of mappings that all have the same source and 
          --   target system.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMap where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ConceptMap
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "sourceUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "sourceReference"))
                                     ])
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "targetUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "targetReference"))
                                     ])
            `apply` many (parseSchemaType "group")
    schemaTypeToXML s x@ConceptMap{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ conceptMap_id x
            , maybe [] (schemaTypeToXML "meta") $ conceptMap_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ conceptMap_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ conceptMap_language x
            , maybe [] (schemaTypeToXML "text") $ conceptMap_text x
            , concatMap (schemaTypeToXML "contained") $ conceptMap_contained x
            , concatMap (schemaTypeToXML "extension") $ conceptMap_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMap_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ conceptMap_url x
            , maybe [] (schemaTypeToXML "identifier") $ conceptMap_identifier x
            , maybe [] (schemaTypeToXML "version") $ conceptMap_version x
            , maybe [] (schemaTypeToXML "name") $ conceptMap_name x
            , maybe [] (schemaTypeToXML "title") $ conceptMap_title x
            , schemaTypeToXML "status" $ conceptMap_status x
            , maybe [] (schemaTypeToXML "experimental") $ conceptMap_experimental x
            , maybe [] (schemaTypeToXML "date") $ conceptMap_date x
            , maybe [] (schemaTypeToXML "publisher") $ conceptMap_publisher x
            , concatMap (schemaTypeToXML "contact") $ conceptMap_contact x
            , maybe [] (schemaTypeToXML "description") $ conceptMap_description x
            , concatMap (schemaTypeToXML "useContext") $ conceptMap_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ conceptMap_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ conceptMap_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ conceptMap_copyright x
            , maybe [] (foldOneOf2  (schemaTypeToXML "sourceUri")
                                    (schemaTypeToXML "sourceReference")
                                   ) $ conceptMap_choice23 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "targetUri")
                                    (schemaTypeToXML "targetReference")
                                   ) $ conceptMap_choice24 x
            , concatMap (schemaTypeToXML "group") $ conceptMap_group x
            ]
instance Extension ConceptMap DomainResource where
    supertype (ConceptMap e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ConceptMap Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ConceptMap -> DomainResource)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMapGroup = ConceptMapGroup
        { conceptMapGroup_id :: Maybe String_primitive
        , conceptMapGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMapGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMapGroup_source :: Maybe Uri
          -- ^ An absolute URI that identifies the Code System (if the 
          --   source is a value set that crosses more than one code 
          --   system).
        , conceptMapGroup_sourceVersion :: Maybe Xsd.XsdString
          -- ^ The specific version of the code system, as determined by 
          --   the code system authority.
        , conceptMapGroup_target :: Maybe Uri
          -- ^ An absolute URI that identifies the code system of the 
          --   target code (if the target is a value set that cross code 
          --   systems).
        , conceptMapGroup_targetVersion :: Maybe Xsd.XsdString
          -- ^ The specific version of the code system, as determined by 
          --   the code system authority.
        , conceptMapGroup_element :: [ConceptMapElement]
          -- ^ Mappings for an individual concept in the source to one or 
          --   more concepts in the target.
        , conceptMapGroup_unmapped :: Maybe ConceptMapUnmapped
          -- ^ What to do when there is no match in the mappings in the 
          --   group.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMapGroup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "sourceVersion")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "targetVersion")
            `apply` many1 (parseSchemaType "element")
            `apply` optional (parseSchemaType "unmapped")
    schemaTypeToXML s x@ConceptMapGroup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapGroup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMapGroup_modifierExtension x
            , maybe [] (schemaTypeToXML "source") $ conceptMapGroup_source x
            , maybe [] (schemaTypeToXML "sourceVersion") $ conceptMapGroup_sourceVersion x
            , maybe [] (schemaTypeToXML "target") $ conceptMapGroup_target x
            , maybe [] (schemaTypeToXML "targetVersion") $ conceptMapGroup_targetVersion x
            , concatMap (schemaTypeToXML "element") $ conceptMapGroup_element x
            , maybe [] (schemaTypeToXML "unmapped") $ conceptMapGroup_unmapped x
            ]
instance Extension ConceptMapGroup BackboneElement where
    supertype (ConceptMapGroup a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ConceptMapGroup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMapGroup -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMapElement = ConceptMapElement
        { conceptMapElement_id :: Maybe String_primitive
        , conceptMapElement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMapElement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMapElement_code :: Maybe Code
          -- ^ Identity (code or path) or the element/item being mapped.
        , conceptMapElement_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMapElement_target :: [ConceptMapTarget]
          -- ^ A concept from the target value set that this concept maps 
          --   to.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapElement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMapElement a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "target")
    schemaTypeToXML s x@ConceptMapElement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapElement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapElement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMapElement_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ conceptMapElement_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMapElement_display x
            , concatMap (schemaTypeToXML "target") $ conceptMapElement_target x
            ]
instance Extension ConceptMapElement BackboneElement where
    supertype (ConceptMapElement a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ConceptMapElement Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMapElement -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMapTarget = ConceptMapTarget
        { conceptMapTarget_id :: Maybe String_primitive
        , conceptMapTarget_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMapTarget_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMapTarget_code :: Maybe Code
          -- ^ Identity (code or path) or the element/item that the map 
          --   refers to.
        , conceptMapTarget_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMapTarget_equivalence :: Maybe ConceptMapEquivalence
          -- ^ The equivalence between the source and target concepts 
          --   (counting for the dependencies and products). The 
          --   equivalence is read from target to source (e.g. the target 
          --   is 'wider' than the source).
        , conceptMapTarget_comment :: Maybe Xsd.XsdString
          -- ^ A description of status/issues in mapping that conveys 
          --   additional information not represented in the structured 
          --   data.
        , conceptMapTarget_dependsOn :: [ConceptMapDependsOn]
          -- ^ A set of additional dependencies for this mapping to hold. 
          --   This mapping is only applicable if the specified element 
          --   can be resolved, and it has the specified value.
        , conceptMapTarget_product :: [ConceptMapDependsOn]
          -- ^ A set of additional outcomes from this mapping to other 
          --   elements. To properly execute this mapping, the specified 
          --   element must be mapped to some data element or source that 
          --   is in context. The mapping may still be useful without a 
          --   place for the additional data elements, but the equivalence 
          --   cannot be relied on.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapTarget where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMapTarget a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "equivalence")
            `apply` optional (parseSchemaType "comment")
            `apply` many (parseSchemaType "dependsOn")
            `apply` many (parseSchemaType "product")
    schemaTypeToXML s x@ConceptMapTarget{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapTarget_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapTarget_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMapTarget_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ conceptMapTarget_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMapTarget_display x
            , maybe [] (schemaTypeToXML "equivalence") $ conceptMapTarget_equivalence x
            , maybe [] (schemaTypeToXML "comment") $ conceptMapTarget_comment x
            , concatMap (schemaTypeToXML "dependsOn") $ conceptMapTarget_dependsOn x
            , concatMap (schemaTypeToXML "product") $ conceptMapTarget_product x
            ]
instance Extension ConceptMapTarget BackboneElement where
    supertype (ConceptMapTarget a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ConceptMapTarget Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMapTarget -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMapDependsOn = ConceptMapDependsOn
        { conceptMapDependsOn_id :: Maybe String_primitive
        , conceptMapDependsOn_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMapDependsOn_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMapDependsOn_property :: Uri
          -- ^ A reference to an element that holds a coded value that 
          --   corresponds to a code system property. The idea is that the 
          --   information model carries an element somwhere that is 
          --   labeled to correspond with a code system property.
        , conceptMapDependsOn_system :: Maybe Uri
          -- ^ An absolute URI that identifies the code system of the 
          --   dependency code (if the source/dependency is a value set 
          --   that crosses code systems).
        , conceptMapDependsOn_code :: Xsd.XsdString
          -- ^ Identity (code or path) or the element/item/ValueSet that 
          --   the map depends on / refers to.
        , conceptMapDependsOn_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapDependsOn where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMapDependsOn a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "property"
            `apply` optional (parseSchemaType "system")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@ConceptMapDependsOn{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapDependsOn_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapDependsOn_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMapDependsOn_modifierExtension x
            , schemaTypeToXML "property" $ conceptMapDependsOn_property x
            , maybe [] (schemaTypeToXML "system") $ conceptMapDependsOn_system x
            , schemaTypeToXML "code" $ conceptMapDependsOn_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMapDependsOn_display x
            ]
instance Extension ConceptMapDependsOn BackboneElement where
    supertype (ConceptMapDependsOn a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ConceptMapDependsOn Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMapDependsOn -> BackboneElement)
              
 
-- | A statement of relationships from one set of concepts to 
--   one or more other concepts - either code systems or data 
--   elements, or classes in class models.
data ConceptMapUnmapped = ConceptMapUnmapped
        { conceptMapUnmapped_id :: Maybe String_primitive
        , conceptMapUnmapped_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conceptMapUnmapped_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conceptMapUnmapped_mode :: ConceptMapGroupUnmappedMode
          -- ^ Defines which action to take if there is no match in the 
          --   group. One of 3 actions is possible: use the unmapped code 
          --   (this is useful when doing a mapping between versions, and 
          --   only a few codes have changed), use a fixed code (a default 
          --   code), or alternatively, a reference to a different concept 
          --   map can be provided (by canonical URL).
        , conceptMapUnmapped_code :: Maybe Code
          -- ^ The fixed code to use when the mode = 'fixed' - all 
          --   unmapped codes are mapped to a single fixed code.
        , conceptMapUnmapped_display :: Maybe Xsd.XsdString
          -- ^ The display for the code. The display is only provided to 
          --   help editors when editing the concept map.
        , conceptMapUnmapped_url :: Maybe Uri
          -- ^ The canonical URL of the map to use if this map contains no 
          --   mapping.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapUnmapped where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConceptMapUnmapped a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@ConceptMapUnmapped{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapUnmapped_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapUnmapped_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conceptMapUnmapped_modifierExtension x
            , schemaTypeToXML "mode" $ conceptMapUnmapped_mode x
            , maybe [] (schemaTypeToXML "code") $ conceptMapUnmapped_code x
            , maybe [] (schemaTypeToXML "display") $ conceptMapUnmapped_display x
            , maybe [] (schemaTypeToXML "url") $ conceptMapUnmapped_url x
            ]
instance Extension ConceptMapUnmapped BackboneElement where
    supertype (ConceptMapUnmapped a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ConceptMapUnmapped Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConceptMapUnmapped -> BackboneElement)
              
 
data ConceptMapGroupUnmappedMode_list
    = ConceptMapGroupUnmappedMode_list_Provided
      -- ^ Provided Code
    | ConceptMapGroupUnmappedMode_list_Fixed
      -- ^ Fixed Code
    | ConceptMapGroupUnmappedMode_list_Other_map
      -- ^ Other Map
    deriving (Eq,Show,Enum)
instance SchemaType ConceptMapGroupUnmappedMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConceptMapGroupUnmappedMode_list where
    acceptingParser =  do literal "provided"; return ConceptMapGroupUnmappedMode_list_Provided
                      `onFail` do literal "fixed"; return ConceptMapGroupUnmappedMode_list_Fixed
                      `onFail` do literal "other-map"; return ConceptMapGroupUnmappedMode_list_Other_map
                      
    simpleTypeText ConceptMapGroupUnmappedMode_list_Provided = "provided"
    simpleTypeText ConceptMapGroupUnmappedMode_list_Fixed = "fixed"
    simpleTypeText ConceptMapGroupUnmappedMode_list_Other_map = "other-map"
 
data ConceptMapGroupUnmappedMode = ConceptMapGroupUnmappedMode
        { conceptMapGroupUnmappedMode_id :: Maybe String_primitive
        , conceptMapGroupUnmappedMode_value :: Maybe ConceptMapGroupUnmappedMode_list
        , conceptMapGroupUnmappedMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConceptMapGroupUnmappedMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConceptMapGroupUnmappedMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConceptMapGroupUnmappedMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conceptMapGroupUnmappedMode_id x
                       , maybe [] (toXMLAttribute "value") $ conceptMapGroupUnmappedMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conceptMapGroupUnmappedMode_extension x
            ]
instance Extension ConceptMapGroupUnmappedMode Element where
    supertype (ConceptMapGroupUnmappedMode a0 a1 e0) =
               Element a0 e0
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
elementCondition :: XMLParser Condition
elementCondition = parseSchemaType "Condition"
elementToXMLCondition :: Condition -> [Content ()]
elementToXMLCondition = schemaTypeToXML "Condition"
 
data Condition = Condition
        { condition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , condition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , condition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , condition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , condition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , condition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , condition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , condition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , condition_identifier :: [Identifier]
          -- ^ This records identifiers associated with this condition 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , condition_clinicalStatus :: Maybe ConditionClinicalStatusCodes
          -- ^ The clinical status of the condition.
        , condition_verificationStatus :: Maybe ConditionVerificationStatus
          -- ^ The verification status to support the clinical status of 
          --   the condition.
        , condition_category :: [CodeableConcept]
          -- ^ A category assigned to the condition.
        , condition_severity :: Maybe CodeableConcept
          -- ^ A subjective assessment of the severity of the condition as 
          --   evaluated by the clinician.
        , condition_code :: Maybe CodeableConcept
          -- ^ Identification of the condition, problem or diagnosis.
        , condition_bodySite :: [CodeableConcept]
          -- ^ The anatomical location where this condition manifests 
          --   itself.
        , condition_subject :: Reference
          -- ^ Indicates the patient or group who the condition record is 
          --   associated with.
        , condition_context :: Maybe Reference
          -- ^ Encounter during which the condition was first asserted.
        , condition_choice17 :: (Maybe (OneOf5 DateTime Age Period Range Xsd.XsdString))
          -- ^ Estimated or actual date or date-time the condition began, 
          --   in the opinion of the clinician.
          --   
          --   Choice between:
          --   
          --   (1) onsetDateTime
          --   
          --   (2) onsetAge
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetRange
          --   
          --   (5) onsetString
        , condition_choice18 :: (Maybe (OneOf6 DateTime Age Boolean Period Range Xsd.XsdString))
          -- ^ The date or estimated date that the condition resolved or 
          --   went into remission. This is called &quot;abatement&quot; 
          --   because of the many overloaded connotations associated with 
          --   &quot;remission&quot; or &quot;resolution&quot; - 
          --   Conditions are never really resolved, but they can abate.
          --   
          --   Choice between:
          --   
          --   (1) abatementDateTime
          --   
          --   (2) abatementAge
          --   
          --   (3) abatementBoolean
          --   
          --   (4) abatementPeriod
          --   
          --   (5) abatementRange
          --   
          --   (6) abatementString
        , condition_assertedDate :: Maybe DateTime
          -- ^ The date on which the existance of the Condition was first 
          --   asserted or acknowledged.
        , condition_asserter :: Maybe Reference
          -- ^ Individual who is making the condition statement.
        , condition_stage :: Maybe ConditionStage
          -- ^ Clinical stage or grade of a condition. May include formal 
          --   severity assessments.
        , condition_evidence :: [ConditionEvidence]
          -- ^ Supporting Evidence / manifestations that are the basis on 
          --   which this condition is suspected or confirmed.
        , condition_note :: [Annotation]
          -- ^ Additional information about the Condition. This is a 
          --   general notes/comments entry for description of the 
          --   Condition, its diagnosis and prognosis.
        }
        deriving (Eq,Show)
instance SchemaType Condition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Condition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "clinicalStatus")
            `apply` optional (parseSchemaType "verificationStatus")
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "code")
            `apply` many (parseSchemaType "bodySite")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "onsetDateTime"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "onsetAge"))
                                     , ("Period", fmap ThreeOf5 (parseSchemaType "onsetPeriod"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "onsetRange"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "onsetString"))
                                     ])
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf6 (parseSchemaType "abatementDateTime"))
                                     , ("Age", fmap TwoOf6 (parseSchemaType "abatementAge"))
                                     , ("Boolean", fmap ThreeOf6 (parseSchemaType "abatementBoolean"))
                                     , ("Period", fmap FourOf6 (parseSchemaType "abatementPeriod"))
                                     , ("Range", fmap FiveOf6 (parseSchemaType "abatementRange"))
                                     , ("Xsd.XsdString", fmap SixOf6 (parseSchemaType "abatementString"))
                                     ])
            `apply` optional (parseSchemaType "assertedDate")
            `apply` optional (parseSchemaType "asserter")
            `apply` optional (parseSchemaType "stage")
            `apply` many (parseSchemaType "evidence")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Condition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ condition_id x
            , maybe [] (schemaTypeToXML "meta") $ condition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ condition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ condition_language x
            , maybe [] (schemaTypeToXML "text") $ condition_text x
            , concatMap (schemaTypeToXML "contained") $ condition_contained x
            , concatMap (schemaTypeToXML "extension") $ condition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ condition_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ condition_identifier x
            , maybe [] (schemaTypeToXML "clinicalStatus") $ condition_clinicalStatus x
            , maybe [] (schemaTypeToXML "verificationStatus") $ condition_verificationStatus x
            , concatMap (schemaTypeToXML "category") $ condition_category x
            , maybe [] (schemaTypeToXML "severity") $ condition_severity x
            , maybe [] (schemaTypeToXML "code") $ condition_code x
            , concatMap (schemaTypeToXML "bodySite") $ condition_bodySite x
            , schemaTypeToXML "subject" $ condition_subject x
            , maybe [] (schemaTypeToXML "context") $ condition_context x
            , maybe [] (foldOneOf5  (schemaTypeToXML "onsetDateTime")
                                    (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetString")
                                   ) $ condition_choice17 x
            , maybe [] (foldOneOf6  (schemaTypeToXML "abatementDateTime")
                                    (schemaTypeToXML "abatementAge")
                                    (schemaTypeToXML "abatementBoolean")
                                    (schemaTypeToXML "abatementPeriod")
                                    (schemaTypeToXML "abatementRange")
                                    (schemaTypeToXML "abatementString")
                                   ) $ condition_choice18 x
            , maybe [] (schemaTypeToXML "assertedDate") $ condition_assertedDate x
            , maybe [] (schemaTypeToXML "asserter") $ condition_asserter x
            , maybe [] (schemaTypeToXML "stage") $ condition_stage x
            , concatMap (schemaTypeToXML "evidence") $ condition_evidence x
            , concatMap (schemaTypeToXML "note") $ condition_note x
            ]
instance Extension Condition DomainResource where
    supertype (Condition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Condition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Condition -> DomainResource)
              
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
data ConditionStage = ConditionStage
        { conditionStage_id :: Maybe String_primitive
        , conditionStage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conditionStage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conditionStage_summary :: Maybe CodeableConcept
          -- ^ A simple summary of the stage such as &quot;Stage 3&quot;. 
          --   The determination of the stage is disease-specific.
        , conditionStage_assessment :: [Reference]
          -- ^ Reference to a formal record of the evidence on which the 
          --   staging assessment is based.
        }
        deriving (Eq,Show)
instance SchemaType ConditionStage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConditionStage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "summary")
            `apply` many (parseSchemaType "assessment")
    schemaTypeToXML s x@ConditionStage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionStage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionStage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conditionStage_modifierExtension x
            , maybe [] (schemaTypeToXML "summary") $ conditionStage_summary x
            , concatMap (schemaTypeToXML "assessment") $ conditionStage_assessment x
            ]
instance Extension ConditionStage BackboneElement where
    supertype (ConditionStage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConditionStage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConditionStage -> BackboneElement)
              
 
-- | A clinical condition, problem, diagnosis, or other event, 
--   situation, issue, or clinical concept that has risen to a 
--   level of concern.
data ConditionEvidence = ConditionEvidence
        { conditionEvidence_id :: Maybe String_primitive
        , conditionEvidence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , conditionEvidence_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , conditionEvidence_code :: [CodeableConcept]
          -- ^ A manifestation or symptom that led to the recording of 
          --   this condition.
        , conditionEvidence_detail :: [Reference]
          -- ^ Links to other relevant information, including pathology 
          --   reports.
        }
        deriving (Eq,Show)
instance SchemaType ConditionEvidence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConditionEvidence a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ConditionEvidence{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionEvidence_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionEvidence_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ conditionEvidence_modifierExtension x
            , concatMap (schemaTypeToXML "code") $ conditionEvidence_code x
            , concatMap (schemaTypeToXML "detail") $ conditionEvidence_detail x
            ]
instance Extension ConditionEvidence BackboneElement where
    supertype (ConditionEvidence a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConditionEvidence Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConditionEvidence -> BackboneElement)
              
 
data ConditionVerificationStatus_list
    = ConditionVerificationStatus_list_Provisional
      -- ^ Provisional
    | ConditionVerificationStatus_list_Differential
      -- ^ Differential
    | ConditionVerificationStatus_list_Confirmed
      -- ^ Confirmed
    | ConditionVerificationStatus_list_Refuted
      -- ^ Refuted
    | ConditionVerificationStatus_list_Entered_in_error
      -- ^ Entered In Error
    | ConditionVerificationStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ConditionVerificationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionVerificationStatus_list where
    acceptingParser =  do literal "provisional"; return ConditionVerificationStatus_list_Provisional
                      `onFail` do literal "differential"; return ConditionVerificationStatus_list_Differential
                      `onFail` do literal "confirmed"; return ConditionVerificationStatus_list_Confirmed
                      `onFail` do literal "refuted"; return ConditionVerificationStatus_list_Refuted
                      `onFail` do literal "entered-in-error"; return ConditionVerificationStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return ConditionVerificationStatus_list_Unknown
                      
    simpleTypeText ConditionVerificationStatus_list_Provisional = "provisional"
    simpleTypeText ConditionVerificationStatus_list_Differential = "differential"
    simpleTypeText ConditionVerificationStatus_list_Confirmed = "confirmed"
    simpleTypeText ConditionVerificationStatus_list_Refuted = "refuted"
    simpleTypeText ConditionVerificationStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText ConditionVerificationStatus_list_Unknown = "unknown"
 
data ConditionVerificationStatus = ConditionVerificationStatus
        { conditionVerificationStatus_id :: Maybe String_primitive
        , conditionVerificationStatus_value :: Maybe ConditionVerificationStatus_list
        , conditionVerificationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionVerificationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionVerificationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionVerificationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionVerificationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ conditionVerificationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionVerificationStatus_extension x
            ]
instance Extension ConditionVerificationStatus Element where
    supertype (ConditionVerificationStatus a0 a1 e0) =
               Element a0 e0
 
data ConditionClinicalStatusCodes_list
    = ConditionClinicalStatusCodes_list_Active
      -- ^ Active
    | ConditionClinicalStatusCodes_list_Recurrence
      -- ^ Recurrence
    | ConditionClinicalStatusCodes_list_Inactive
      -- ^ Inactive
    | ConditionClinicalStatusCodes_list_Remission
      -- ^ Remission
    | ConditionClinicalStatusCodes_list_Resolved
      -- ^ Resolved
    deriving (Eq,Show,Enum)
instance SchemaType ConditionClinicalStatusCodes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConditionClinicalStatusCodes_list where
    acceptingParser =  do literal "active"; return ConditionClinicalStatusCodes_list_Active
                      `onFail` do literal "recurrence"; return ConditionClinicalStatusCodes_list_Recurrence
                      `onFail` do literal "inactive"; return ConditionClinicalStatusCodes_list_Inactive
                      `onFail` do literal "remission"; return ConditionClinicalStatusCodes_list_Remission
                      `onFail` do literal "resolved"; return ConditionClinicalStatusCodes_list_Resolved
                      
    simpleTypeText ConditionClinicalStatusCodes_list_Active = "active"
    simpleTypeText ConditionClinicalStatusCodes_list_Recurrence = "recurrence"
    simpleTypeText ConditionClinicalStatusCodes_list_Inactive = "inactive"
    simpleTypeText ConditionClinicalStatusCodes_list_Remission = "remission"
    simpleTypeText ConditionClinicalStatusCodes_list_Resolved = "resolved"
 
data ConditionClinicalStatusCodes = ConditionClinicalStatusCodes
        { conditionClinicalStatusCodes_id :: Maybe String_primitive
        , conditionClinicalStatusCodes_value :: Maybe ConditionClinicalStatusCodes_list
        , conditionClinicalStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConditionClinicalStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConditionClinicalStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConditionClinicalStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ conditionClinicalStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ conditionClinicalStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ conditionClinicalStatusCodes_extension x
            ]
instance Extension ConditionClinicalStatusCodes Element where
    supertype (ConditionClinicalStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
elementConsent :: XMLParser Consent
elementConsent = parseSchemaType "Consent"
elementToXMLConsent :: Consent -> [Content ()]
elementToXMLConsent = schemaTypeToXML "Consent"
 
data Consent = Consent
        { consent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , consent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , consent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , consent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , consent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , consent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , consent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consent_identifier :: Maybe Identifier
          -- ^ Unique identifier for this copy of the Consent Statement.
        , consent_status :: ConsentState
          -- ^ Indicates the current state of this consent.
        , consent_category :: [CodeableConcept]
          -- ^ A classification of the type of consents found in the 
          --   statement. This element supports indexing and retrieval of 
          --   consent statements.
        , consent_patient :: Reference
          -- ^ The patient/healthcare consumer to whom this consent 
          --   applies.
        , consent_period :: Maybe Period
          -- ^ Relevant time or time-period when this Consent is 
          --   applicable.
        , consent_dateTime :: Maybe DateTime
          -- ^ When this Consent was issued / created / indexed.
        , consent_consentingParty :: [Reference]
          -- ^ Either the Grantor, which is the entity responsible for 
          --   granting the rights listed in a Consent Directive or the 
          --   Grantee, which is the entity responsible for complying with 
          --   the Consent Directive, including any obligations or 
          --   limitations on authorizations and enforcement of 
          --   prohibitions.
        , consent_actor :: [ConsentActor]
          -- ^ Who or what is controlled by this consent. Use group to 
          --   identify a set of actors by some property they share (e.g. 
          --   'admitting officers').
        , consent_action :: [CodeableConcept]
          -- ^ Actions controlled by this consent.
        , consent_organization :: [Reference]
          -- ^ The organization that manages the consent, and the 
          --   framework within which it is executed.
        , consent_choice18 :: (Maybe (OneOf3 Attachment Identifier Reference))
          -- ^ The source on which this consent statement is based. The 
          --   source might be a scanned original paper form, or a 
          --   reference to a consent that links back to such a source, a 
          --   reference to a document repository (e.g. XDS) that stores 
          --   the original consent document.
          --   
          --   Choice between:
          --   
          --   (1) sourceAttachment
          --   
          --   (2) sourceIdentifier
          --   
          --   (3) sourceReference
        , consent_policy :: [ConsentPolicy]
          -- ^ The references to the policies that are included in this 
          --   consent scope. Policies may be organizational, but are 
          --   often defined jurisdictionally, or in law.
        , consent_policyRule :: Maybe Uri
          -- ^ A referece to the specific computable policy.
        , consent_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this consent. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , consent_purpose :: [Coding]
          -- ^ The context of the activities a user is taking - why the 
          --   user is accessing the data - that are controlled by this 
          --   consent.
        , consent_dataPeriod :: Maybe Period
          -- ^ Clinical or Operational Relevant period of time that bounds 
          --   the data controlled by this consent.
        , consent_data :: [ConsentData]
          -- ^ The resources controlled by this consent, if specific 
          --   resources are referenced.
        , consent_except :: [ConsentExcept]
          -- ^ An exception to the base policy of this consent. An 
          --   exception can be an addition or removal of access 
          --   permissions.
        }
        deriving (Eq,Show)
instance SchemaType Consent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Consent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "dateTime")
            `apply` many (parseSchemaType "consentingParty")
            `apply` many (parseSchemaType "actor")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "organization")
            `apply` optional (oneOf' [ ("Attachment", fmap OneOf3 (parseSchemaType "sourceAttachment"))
                                     , ("Identifier", fmap TwoOf3 (parseSchemaType "sourceIdentifier"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "sourceReference"))
                                     ])
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "policyRule")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "dataPeriod")
            `apply` many (parseSchemaType "data")
            `apply` many (parseSchemaType "except")
    schemaTypeToXML s x@Consent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ consent_id x
            , maybe [] (schemaTypeToXML "meta") $ consent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ consent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ consent_language x
            , maybe [] (schemaTypeToXML "text") $ consent_text x
            , concatMap (schemaTypeToXML "contained") $ consent_contained x
            , concatMap (schemaTypeToXML "extension") $ consent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consent_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ consent_identifier x
            , schemaTypeToXML "status" $ consent_status x
            , concatMap (schemaTypeToXML "category") $ consent_category x
            , schemaTypeToXML "patient" $ consent_patient x
            , maybe [] (schemaTypeToXML "period") $ consent_period x
            , maybe [] (schemaTypeToXML "dateTime") $ consent_dateTime x
            , concatMap (schemaTypeToXML "consentingParty") $ consent_consentingParty x
            , concatMap (schemaTypeToXML "actor") $ consent_actor x
            , concatMap (schemaTypeToXML "action") $ consent_action x
            , concatMap (schemaTypeToXML "organization") $ consent_organization x
            , maybe [] (foldOneOf3  (schemaTypeToXML "sourceAttachment")
                                    (schemaTypeToXML "sourceIdentifier")
                                    (schemaTypeToXML "sourceReference")
                                   ) $ consent_choice18 x
            , concatMap (schemaTypeToXML "policy") $ consent_policy x
            , maybe [] (schemaTypeToXML "policyRule") $ consent_policyRule x
            , concatMap (schemaTypeToXML "securityLabel") $ consent_securityLabel x
            , concatMap (schemaTypeToXML "purpose") $ consent_purpose x
            , maybe [] (schemaTypeToXML "dataPeriod") $ consent_dataPeriod x
            , concatMap (schemaTypeToXML "data") $ consent_data x
            , concatMap (schemaTypeToXML "except") $ consent_except x
            ]
instance Extension Consent DomainResource where
    supertype (Consent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Consent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Consent -> DomainResource)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentActor = ConsentActor
        { consentActor_id :: Maybe String_primitive
        , consentActor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentActor_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentActor_role :: CodeableConcept
          -- ^ How the individual is involved in the resources content 
          --   that is described in the consent.
        , consentActor_reference :: Reference
          -- ^ The resource that identifies the actor. To identify a 
          --   actors by type, use group to identify a set of actors by 
          --   some property they share (e.g. 'admitting officers').
        }
        deriving (Eq,Show)
instance SchemaType ConsentActor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentActor a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@ConsentActor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentActor_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentActor_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentActor_modifierExtension x
            , schemaTypeToXML "role" $ consentActor_role x
            , schemaTypeToXML "reference" $ consentActor_reference x
            ]
instance Extension ConsentActor BackboneElement where
    supertype (ConsentActor a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConsentActor Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentActor -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentPolicy = ConsentPolicy
        { consentPolicy_id :: Maybe String_primitive
        , consentPolicy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentPolicy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentPolicy_authority :: Maybe Uri
          -- ^ Entity or Organization having regulatory jurisdiction or 
          --   accountability for enforcing policies pertaining to Consent 
          --   Directives.
        , consentPolicy_uri :: Maybe Uri
          -- ^ The references to the policies that are included in this 
          --   consent scope. Policies may be organizational, but are 
          --   often defined jurisdictionally, or in law.
        }
        deriving (Eq,Show)
instance SchemaType ConsentPolicy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentPolicy a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "uri")
    schemaTypeToXML s x@ConsentPolicy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentPolicy_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentPolicy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentPolicy_modifierExtension x
            , maybe [] (schemaTypeToXML "authority") $ consentPolicy_authority x
            , maybe [] (schemaTypeToXML "uri") $ consentPolicy_uri x
            ]
instance Extension ConsentPolicy BackboneElement where
    supertype (ConsentPolicy a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConsentPolicy Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentPolicy -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentData = ConsentData
        { consentData_id :: Maybe String_primitive
        , consentData_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentData_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentData_meaning :: ConsentDataMeaning
          -- ^ How the resource reference is interpreted when testing 
          --   consent restrictions.
        , consentData_reference :: Reference
          -- ^ A reference to a specific resource that defines which 
          --   resources are covered by this consent.
        }
        deriving (Eq,Show)
instance SchemaType ConsentData where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentData a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "meaning"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@ConsentData{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentData_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentData_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentData_modifierExtension x
            , schemaTypeToXML "meaning" $ consentData_meaning x
            , schemaTypeToXML "reference" $ consentData_reference x
            ]
instance Extension ConsentData BackboneElement where
    supertype (ConsentData a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConsentData Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentData -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentExcept = ConsentExcept
        { consentExcept_id :: Maybe String_primitive
        , consentExcept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentExcept_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentExcept_type :: ConsentExceptType
          -- ^ Action to take - permit or deny - when the exception 
          --   conditions are met.
        , consentExcept_period :: Maybe Period
          -- ^ The timeframe in this exception is valid.
        , consentExcept_actor :: [ConsentActor1]
          -- ^ Who or what is controlled by this Exception. Use group to 
          --   identify a set of actors by some property they share (e.g. 
          --   'admitting officers').
        , consentExcept_action :: [CodeableConcept]
          -- ^ Actions controlled by this Exception.
        , consentExcept_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this exception. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , consentExcept_purpose :: [Coding]
          -- ^ The context of the activities a user is taking - why the 
          --   user is accessing the data - that are controlled by this 
          --   exception.
        , consentExcept_class :: [Coding]
          -- ^ The class of information covered by this exception. The 
          --   type can be a FHIR resource type, a profile on a type, or a 
          --   CDA document, or some other type that indicates what sort 
          --   of information the consent relates to.
        , consentExcept_code :: [Coding]
          -- ^ If this code is found in an instance, then the exception 
          --   applies.
        , consentExcept_dataPeriod :: Maybe Period
          -- ^ Clinical or Operational Relevant period of time that bounds 
          --   the data controlled by this exception.
        , consentExcept_data :: [ConsentData1]
          -- ^ The resources controlled by this exception, if specific 
          --   resources are referenced.
        }
        deriving (Eq,Show)
instance SchemaType ConsentExcept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentExcept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "actor")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "purpose")
            `apply` many (parseSchemaType "class")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "dataPeriod")
            `apply` many (parseSchemaType "data")
    schemaTypeToXML s x@ConsentExcept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentExcept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentExcept_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentExcept_modifierExtension x
            , schemaTypeToXML "type" $ consentExcept_type x
            , maybe [] (schemaTypeToXML "period") $ consentExcept_period x
            , concatMap (schemaTypeToXML "actor") $ consentExcept_actor x
            , concatMap (schemaTypeToXML "action") $ consentExcept_action x
            , concatMap (schemaTypeToXML "securityLabel") $ consentExcept_securityLabel x
            , concatMap (schemaTypeToXML "purpose") $ consentExcept_purpose x
            , concatMap (schemaTypeToXML "class") $ consentExcept_class x
            , concatMap (schemaTypeToXML "code") $ consentExcept_code x
            , maybe [] (schemaTypeToXML "dataPeriod") $ consentExcept_dataPeriod x
            , concatMap (schemaTypeToXML "data") $ consentExcept_data x
            ]
instance Extension ConsentExcept BackboneElement where
    supertype (ConsentExcept a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension ConsentExcept Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentExcept -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentActor1 = ConsentActor1
        { consentActor1_id :: Maybe String_primitive
        , consentActor1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentActor1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentActor1_role :: CodeableConcept
          -- ^ How the individual is involved in the resources content 
          --   that is described in the exception.
        , consentActor1_reference :: Reference
          -- ^ The resource that identifies the actor. To identify a 
          --   actors by type, use group to identify a set of actors by 
          --   some property they share (e.g. 'admitting officers').
        }
        deriving (Eq,Show)
instance SchemaType ConsentActor1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentActor1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@ConsentActor1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentActor1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentActor1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentActor1_modifierExtension x
            , schemaTypeToXML "role" $ consentActor1_role x
            , schemaTypeToXML "reference" $ consentActor1_reference x
            ]
instance Extension ConsentActor1 BackboneElement where
    supertype (ConsentActor1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConsentActor1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentActor1 -> BackboneElement)
              
 
-- | A record of a healthcare consumerâ€™s policy choices, which 
--   permits or denies identified recipient(s) or recipient 
--   role(s) to perform one or more actions within a given 
--   policy context, for specific purposes and periods of time.
data ConsentData1 = ConsentData1
        { consentData1_id :: Maybe String_primitive
        , consentData1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , consentData1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , consentData1_meaning :: ConsentDataMeaning
          -- ^ How the resource reference is interpreted when testing 
          --   consent restrictions.
        , consentData1_reference :: Reference
          -- ^ A reference to a specific resource that defines which 
          --   resources are covered by this consent.
        }
        deriving (Eq,Show)
instance SchemaType ConsentData1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ConsentData1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "meaning"
            `apply` parseSchemaType "reference"
    schemaTypeToXML s x@ConsentData1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentData1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentData1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ consentData1_modifierExtension x
            , schemaTypeToXML "meaning" $ consentData1_meaning x
            , schemaTypeToXML "reference" $ consentData1_reference x
            ]
instance Extension ConsentData1 BackboneElement where
    supertype (ConsentData1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ConsentData1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ConsentData1 -> BackboneElement)
              
 
data ConsentDataMeaning_list
    = ConsentDataMeaning_list_Instance
      -- ^ Instance
    | ConsentDataMeaning_list_Related
      -- ^ Related
    | ConsentDataMeaning_list_Dependents
      -- ^ Dependents
    | ConsentDataMeaning_list_Authoredby
      -- ^ AuthoredBy
    deriving (Eq,Show,Enum)
instance SchemaType ConsentDataMeaning_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentDataMeaning_list where
    acceptingParser =  do literal "instance"; return ConsentDataMeaning_list_Instance
                      `onFail` do literal "related"; return ConsentDataMeaning_list_Related
                      `onFail` do literal "dependents"; return ConsentDataMeaning_list_Dependents
                      `onFail` do literal "authoredby"; return ConsentDataMeaning_list_Authoredby
                      
    simpleTypeText ConsentDataMeaning_list_Instance = "instance"
    simpleTypeText ConsentDataMeaning_list_Related = "related"
    simpleTypeText ConsentDataMeaning_list_Dependents = "dependents"
    simpleTypeText ConsentDataMeaning_list_Authoredby = "authoredby"
 
data ConsentDataMeaning = ConsentDataMeaning
        { consentDataMeaning_id :: Maybe String_primitive
        , consentDataMeaning_value :: Maybe ConsentDataMeaning_list
        , consentDataMeaning_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentDataMeaning where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentDataMeaning a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentDataMeaning{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentDataMeaning_id x
                       , maybe [] (toXMLAttribute "value") $ consentDataMeaning_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentDataMeaning_extension x
            ]
instance Extension ConsentDataMeaning Element where
    supertype (ConsentDataMeaning a0 a1 e0) =
               Element a0 e0
 
data ConsentState_list
    = ConsentState_list_Draft
      -- ^ Pending
    | ConsentState_list_Proposed
      -- ^ Proposed
    | ConsentState_list_Active
      -- ^ Active
    | ConsentState_list_Rejected
      -- ^ Rejected
    | ConsentState_list_Inactive
      -- ^ Inactive
    | ConsentState_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ConsentState_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentState_list where
    acceptingParser =  do literal "draft"; return ConsentState_list_Draft
                      `onFail` do literal "proposed"; return ConsentState_list_Proposed
                      `onFail` do literal "active"; return ConsentState_list_Active
                      `onFail` do literal "rejected"; return ConsentState_list_Rejected
                      `onFail` do literal "inactive"; return ConsentState_list_Inactive
                      `onFail` do literal "entered-in-error"; return ConsentState_list_Entered_in_error
                      
    simpleTypeText ConsentState_list_Draft = "draft"
    simpleTypeText ConsentState_list_Proposed = "proposed"
    simpleTypeText ConsentState_list_Active = "active"
    simpleTypeText ConsentState_list_Rejected = "rejected"
    simpleTypeText ConsentState_list_Inactive = "inactive"
    simpleTypeText ConsentState_list_Entered_in_error = "entered-in-error"
 
data ConsentState = ConsentState
        { consentState_id :: Maybe String_primitive
        , consentState_value :: Maybe ConsentState_list
        , consentState_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentState where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentState a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentState{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentState_id x
                       , maybe [] (toXMLAttribute "value") $ consentState_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentState_extension x
            ]
instance Extension ConsentState Element where
    supertype (ConsentState a0 a1 e0) =
               Element a0 e0
 
data ConsentExceptType_list
    = ConsentExceptType_list_Deny
      -- ^ Opt Out
    | ConsentExceptType_list_Permit
      -- ^ Opt In
    deriving (Eq,Show,Enum)
instance SchemaType ConsentExceptType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ConsentExceptType_list where
    acceptingParser =  do literal "deny"; return ConsentExceptType_list_Deny
                      `onFail` do literal "permit"; return ConsentExceptType_list_Permit
                      
    simpleTypeText ConsentExceptType_list_Deny = "deny"
    simpleTypeText ConsentExceptType_list_Permit = "permit"
 
data ConsentExceptType = ConsentExceptType
        { consentExceptType_id :: Maybe String_primitive
        , consentExceptType_value :: Maybe ConsentExceptType_list
        , consentExceptType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ConsentExceptType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ConsentExceptType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ConsentExceptType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ consentExceptType_id x
                       , maybe [] (toXMLAttribute "value") $ consentExceptType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ consentExceptType_extension x
            ]
instance Extension ConsentExceptType Element where
    supertype (ConsentExceptType a0 a1 e0) =
               Element a0 e0
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
elementContract :: XMLParser Contract
elementContract = parseSchemaType "Contract"
elementToXMLContract :: Contract -> [Content ()]
elementToXMLContract = schemaTypeToXML "Contract"
 
data Contract = Contract
        { contract_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , contract_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , contract_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , contract_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , contract_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , contract_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , contract_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contract_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contract_identifier :: Maybe Identifier
          -- ^ Unique identifier for this Contract.
        , contract_status :: Maybe ContractResourceStatusCodes
          -- ^ The status of the resource instance.
        , contract_issued :: Maybe DateTime
          -- ^ When this Contract was issued.
        , contract_applies :: Maybe Period
          -- ^ Relevant time or time-period when this Contract is 
          --   applicable.
        , contract_subject :: [Reference]
          -- ^ The target entity impacted by or of interest to parties to 
          --   the agreement.
        , contract_topic :: [Reference]
          -- ^ The matter of concern in the context of this agreement.
        , contract_authority :: [Reference]
          -- ^ A formally or informally recognized grouping of people, 
          --   principals, organizations, or jurisdictions formed for the 
          --   purpose of achieving some form of collective action such as 
          --   the promulgation, administration and enforcement of 
          --   contracts and policies.
        , contract_domain :: [Reference]
          -- ^ Recognized governance framework or system operating with a 
          --   circumscribed scope in accordance with specified 
          --   principles, policies, processes or procedures for managing 
          --   rights, actions, or behaviors of parties or principals 
          --   relative to resources.
        , contract_type :: Maybe CodeableConcept
          -- ^ Type of Contract such as an insurance policy, real estate 
          --   contract, a will, power of attorny, Privacy or Security 
          --   policy , trust framework agreement, etc.
        , contract_subType :: [CodeableConcept]
          -- ^ More specific type or specialization of an overarching or 
          --   more general contract such as auto insurance, home owner 
          --   insurance, prenupial agreement, Advanced-Directive, or 
          --   privacy consent.
        , contract_action :: [CodeableConcept]
          -- ^ Action stipulated by this Contract.
        , contract_actionReason :: [CodeableConcept]
          -- ^ Reason for action stipulated by this Contract.
        , contract_decisionType :: Maybe CodeableConcept
          -- ^ The type of decision made by a grantor with respect to an 
          --   offer made by a grantee.
        , contract_contentDerivative :: Maybe CodeableConcept
          -- ^ The minimal content derived from the basal information 
          --   source at a specific stage in its lifecycle.
        , contract_securityLabel :: [Coding]
          -- ^ A set of security labels that define which resources are 
          --   controlled by this consent. If more than one label is 
          --   specified, all resources must have all the specified 
          --   labels.
        , contract_agent :: [ContractAgent]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , contract_signer :: [ContractSigner]
          -- ^ Parties with legal standing in the Contract, including the 
          --   principal parties, the grantor(s) and grantee(s), which are 
          --   any person or organization bound by the contract, and any 
          --   ancillary parties, which facilitate the execution of the 
          --   contract such as a notary or witness.
        , contract_valuedItem :: [ContractValuedItem]
          -- ^ Contract Valued Item List.
        , contract_term :: [ContractTerm]
          -- ^ One or more Contract Provisions, which may be related and 
          --   conveyed as a group, and may contain nested groups.
        , contract_choice27 :: (Maybe (OneOf2 Attachment Reference))
          -- ^ Legally binding Contract: This is the signed and legally 
          --   recognized representation of the Contract, which is 
          --   considered the &quot;source of truth&quot; and which would 
          --   be the basis for legal action related to enforcement of 
          --   this Contract.
          --   
          --   Choice between:
          --   
          --   (1) bindingAttachment
          --   
          --   (2) bindingReference
        , contract_friendly :: [ContractFriendly]
          -- ^ The &quot;patient friendly language&quot; versionof the 
          --   Contract in whole or in parts. &quot;Patient friendly 
          --   language&quot; means the representation of the Contract and 
          --   Contract Provisions in a manner that is readily accessible 
          --   and understandable by a layperson in accordance with best 
          --   practices for communication styles that ensure that those 
          --   agreeing to or signing the Contract understand the roles, 
          --   actions, obligations, responsibilities, and implication of 
          --   the agreement.
        , contract_legal :: [ContractLegal]
          -- ^ List of Legal expressions or representations of this 
          --   Contract.
        , contract_rule :: [ContractRule]
          -- ^ List of Computable Policy Rule Language Representations of 
          --   this Contract.
        }
        deriving (Eq,Show)
instance SchemaType Contract where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Contract
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "issued")
            `apply` optional (parseSchemaType "applies")
            `apply` many (parseSchemaType "subject")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "authority")
            `apply` many (parseSchemaType "domain")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "actionReason")
            `apply` optional (parseSchemaType "decisionType")
            `apply` optional (parseSchemaType "contentDerivative")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "agent")
            `apply` many (parseSchemaType "signer")
            `apply` many (parseSchemaType "valuedItem")
            `apply` many (parseSchemaType "term")
            `apply` optional (oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "bindingAttachment"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "bindingReference"))
                                     ])
            `apply` many (parseSchemaType "friendly")
            `apply` many (parseSchemaType "legal")
            `apply` many (parseSchemaType "rule")
    schemaTypeToXML s x@Contract{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ contract_id x
            , maybe [] (schemaTypeToXML "meta") $ contract_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ contract_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ contract_language x
            , maybe [] (schemaTypeToXML "text") $ contract_text x
            , concatMap (schemaTypeToXML "contained") $ contract_contained x
            , concatMap (schemaTypeToXML "extension") $ contract_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contract_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ contract_identifier x
            , maybe [] (schemaTypeToXML "status") $ contract_status x
            , maybe [] (schemaTypeToXML "issued") $ contract_issued x
            , maybe [] (schemaTypeToXML "applies") $ contract_applies x
            , concatMap (schemaTypeToXML "subject") $ contract_subject x
            , concatMap (schemaTypeToXML "topic") $ contract_topic x
            , concatMap (schemaTypeToXML "authority") $ contract_authority x
            , concatMap (schemaTypeToXML "domain") $ contract_domain x
            , maybe [] (schemaTypeToXML "type") $ contract_type x
            , concatMap (schemaTypeToXML "subType") $ contract_subType x
            , concatMap (schemaTypeToXML "action") $ contract_action x
            , concatMap (schemaTypeToXML "actionReason") $ contract_actionReason x
            , maybe [] (schemaTypeToXML "decisionType") $ contract_decisionType x
            , maybe [] (schemaTypeToXML "contentDerivative") $ contract_contentDerivative x
            , concatMap (schemaTypeToXML "securityLabel") $ contract_securityLabel x
            , concatMap (schemaTypeToXML "agent") $ contract_agent x
            , concatMap (schemaTypeToXML "signer") $ contract_signer x
            , concatMap (schemaTypeToXML "valuedItem") $ contract_valuedItem x
            , concatMap (schemaTypeToXML "term") $ contract_term x
            , maybe [] (foldOneOf2  (schemaTypeToXML "bindingAttachment")
                                    (schemaTypeToXML "bindingReference")
                                   ) $ contract_choice27 x
            , concatMap (schemaTypeToXML "friendly") $ contract_friendly x
            , concatMap (schemaTypeToXML "legal") $ contract_legal x
            , concatMap (schemaTypeToXML "rule") $ contract_rule x
            ]
instance Extension Contract DomainResource where
    supertype (Contract e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Contract Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Contract -> DomainResource)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractAgent = ContractAgent
        { contractAgent_id :: Maybe String_primitive
        , contractAgent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractAgent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractAgent_actor :: Reference
          -- ^ Who or what parties are assigned roles in this Contract.
        , contractAgent_role :: [CodeableConcept]
          -- ^ Role type of agent assigned roles in this Contract.
        }
        deriving (Eq,Show)
instance SchemaType ContractAgent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractAgent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` many (parseSchemaType "role")
    schemaTypeToXML s x@ContractAgent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractAgent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractAgent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractAgent_modifierExtension x
            , schemaTypeToXML "actor" $ contractAgent_actor x
            , concatMap (schemaTypeToXML "role") $ contractAgent_role x
            ]
instance Extension ContractAgent BackboneElement where
    supertype (ContractAgent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ContractAgent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractAgent -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractSigner = ContractSigner
        { contractSigner_id :: Maybe String_primitive
        , contractSigner_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractSigner_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractSigner_type :: Coding
          -- ^ Role of this Contract signer, e.g. notary, grantee.
        , contractSigner_party :: Reference
          -- ^ Party which is a signator to this Contract.
        , contractSigner_signature :: [Signature]
          -- ^ Legally binding Contract DSIG signature contents in Base64.
        }
        deriving (Eq,Show)
instance SchemaType ContractSigner where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractSigner a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "party"
            `apply` many1 (parseSchemaType "signature")
    schemaTypeToXML s x@ContractSigner{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractSigner_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractSigner_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractSigner_modifierExtension x
            , schemaTypeToXML "type" $ contractSigner_type x
            , schemaTypeToXML "party" $ contractSigner_party x
            , concatMap (schemaTypeToXML "signature") $ contractSigner_signature x
            ]
instance Extension ContractSigner BackboneElement where
    supertype (ContractSigner a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ContractSigner Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractSigner -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractValuedItem = ContractValuedItem
        { contractValuedItem_id :: Maybe String_primitive
        , contractValuedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractValuedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractValuedItem_choice2 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Specific type of Contract Valued Item that may be priced.
          --   
          --   Choice between:
          --   
          --   (1) entityCodeableConcept
          --   
          --   (2) entityReference
        , contractValuedItem_identifier :: Maybe Identifier
          -- ^ Identifies a Contract Valued Item instance.
        , contractValuedItem_effectiveTime :: Maybe DateTime
          -- ^ Indicates the time during which this Contract ValuedItem 
          --   information is effective.
        , contractValuedItem_quantity :: Maybe Quantity
          -- ^ Specifies the units by which the Contract Valued Item is 
          --   measured or counted, and quantifies the countable or 
          --   measurable Contract Valued Item instances.
        , contractValuedItem_unitPrice :: Maybe Money
          -- ^ A Contract Valued Item unit valuation measure.
        , contractValuedItem_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of the Contract Valued Item 
          --   delivered. The concept of a Factor allows for a discount or 
          --   surcharge multiplier to be applied to a monetary amount.
        , contractValuedItem_points :: Maybe Decimal
          -- ^ An amount that expresses the weighting (based on 
          --   difficulty, cost and/or resource intensiveness) associated 
          --   with the Contract Valued Item delivered. The concept of 
          --   Points allows for assignment of point values for a Contract 
          --   Valued Item, such that a monetary amount can be assigned to 
          --   each point.
        , contractValuedItem_net :: Maybe Money
          -- ^ Expresses the product of the Contract Valued Item 
          --   unitQuantity and the unitPriceAmt. For example, the 
          --   formula: unit Quantity * unit Price (Cost per Point) * 
          --   factor Number * points = net Amount. Quantity, factor and 
          --   points are assumed to be 1 if not supplied.
        }
        deriving (Eq,Show)
instance SchemaType ContractValuedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractValuedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "entityCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "entityReference"))
                                     ])
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "effectiveTime")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "points")
            `apply` optional (parseSchemaType "net")
    schemaTypeToXML s x@ContractValuedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractValuedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractValuedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractValuedItem_modifierExtension x
            , maybe [] (foldOneOf2  (schemaTypeToXML "entityCodeableConcept")
                                    (schemaTypeToXML "entityReference")
                                   ) $ contractValuedItem_choice2 x
            , maybe [] (schemaTypeToXML "identifier") $ contractValuedItem_identifier x
            , maybe [] (schemaTypeToXML "effectiveTime") $ contractValuedItem_effectiveTime x
            , maybe [] (schemaTypeToXML "quantity") $ contractValuedItem_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ contractValuedItem_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ contractValuedItem_factor x
            , maybe [] (schemaTypeToXML "points") $ contractValuedItem_points x
            , maybe [] (schemaTypeToXML "net") $ contractValuedItem_net x
            ]
instance Extension ContractValuedItem BackboneElement where
    supertype (ContractValuedItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension ContractValuedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractValuedItem -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractTerm = ContractTerm
        { contractTerm_id :: Maybe String_primitive
        , contractTerm_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractTerm_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractTerm_identifier :: Maybe Identifier
          -- ^ Unique identifier for this particular Contract Provision.
        , contractTerm_issued :: Maybe DateTime
          -- ^ When this Contract Provision was issued.
        , contractTerm_applies :: Maybe Period
          -- ^ Relevant time or time-period when this Contract Provision 
          --   is applicable.
        , contractTerm_type :: Maybe CodeableConcept
          -- ^ Type of Contract Provision such as specific requirements, 
          --   purposes for actions, obligations, prohibitions, e.g. life 
          --   time maximum benefit.
        , contractTerm_subType :: Maybe CodeableConcept
          -- ^ Subtype of this Contract Provision, e.g. life time maximum 
          --   payment for a contract term for specific valued item, e.g. 
          --   disability payment.
        , contractTerm_topic :: [Reference]
          -- ^ The matter of concern in the context of this provision of 
          --   the agrement.
        , contractTerm_action :: [CodeableConcept]
          -- ^ Action stipulated by this Contract Provision.
        , contractTerm_actionReason :: [CodeableConcept]
          -- ^ Reason or purpose for the action stipulated by this 
          --   Contract Provision.
        , contractTerm_securityLabel :: [Coding]
          -- ^ A set of security labels that define which terms are 
          --   controlled by this condition.
        , contractTerm_agent :: [ContractAgent1]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , contractTerm_text :: Maybe Xsd.XsdString
          -- ^ Human readable form of this Contract Provision.
        , contractTerm_valuedItem :: [ContractValuedItem1]
          -- ^ Contract Provision Valued Item List.
        , contractTerm_group :: [ContractTerm]
          -- ^ Nested group of Contract Provisions.
        }
        deriving (Eq,Show)
instance SchemaType ContractTerm where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractTerm a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "issued")
            `apply` optional (parseSchemaType "applies")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subType")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "action")
            `apply` many (parseSchemaType "actionReason")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many (parseSchemaType "agent")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "valuedItem")
            `apply` many (parseSchemaType "group")
    schemaTypeToXML s x@ContractTerm{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractTerm_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractTerm_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractTerm_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ contractTerm_identifier x
            , maybe [] (schemaTypeToXML "issued") $ contractTerm_issued x
            , maybe [] (schemaTypeToXML "applies") $ contractTerm_applies x
            , maybe [] (schemaTypeToXML "type") $ contractTerm_type x
            , maybe [] (schemaTypeToXML "subType") $ contractTerm_subType x
            , concatMap (schemaTypeToXML "topic") $ contractTerm_topic x
            , concatMap (schemaTypeToXML "action") $ contractTerm_action x
            , concatMap (schemaTypeToXML "actionReason") $ contractTerm_actionReason x
            , concatMap (schemaTypeToXML "securityLabel") $ contractTerm_securityLabel x
            , concatMap (schemaTypeToXML "agent") $ contractTerm_agent x
            , maybe [] (schemaTypeToXML "text") $ contractTerm_text x
            , concatMap (schemaTypeToXML "valuedItem") $ contractTerm_valuedItem x
            , concatMap (schemaTypeToXML "group") $ contractTerm_group x
            ]
instance Extension ContractTerm BackboneElement where
    supertype (ContractTerm a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               BackboneElement a0 e0 e1
instance Extension ContractTerm Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractTerm -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractAgent1 = ContractAgent1
        { contractAgent1_id :: Maybe String_primitive
        , contractAgent1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractAgent1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractAgent1_actor :: Reference
          -- ^ The agent assigned a role in this Contract Provision.
        , contractAgent1_role :: [CodeableConcept]
          -- ^ Role played by the agent assigned this role in the 
          --   execution of this Contract Provision.
        }
        deriving (Eq,Show)
instance SchemaType ContractAgent1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractAgent1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` many (parseSchemaType "role")
    schemaTypeToXML s x@ContractAgent1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractAgent1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractAgent1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractAgent1_modifierExtension x
            , schemaTypeToXML "actor" $ contractAgent1_actor x
            , concatMap (schemaTypeToXML "role") $ contractAgent1_role x
            ]
instance Extension ContractAgent1 BackboneElement where
    supertype (ContractAgent1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ContractAgent1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractAgent1 -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractValuedItem1 = ContractValuedItem1
        { contractValuedItem1_id :: Maybe String_primitive
        , contractValuedItem1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractValuedItem1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractValuedItem1_choice2 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Specific type of Contract Provision Valued Item that may be 
          --   priced.
          --   
          --   Choice between:
          --   
          --   (1) entityCodeableConcept
          --   
          --   (2) entityReference
        , contractValuedItem1_identifier :: Maybe Identifier
          -- ^ Identifies a Contract Provision Valued Item instance.
        , contractValuedItem1_effectiveTime :: Maybe DateTime
          -- ^ Indicates the time during which this Contract Term 
          --   ValuedItem information is effective.
        , contractValuedItem1_quantity :: Maybe Quantity
          -- ^ Specifies the units by which the Contract Provision Valued 
          --   Item is measured or counted, and quantifies the countable 
          --   or measurable Contract Term Valued Item instances.
        , contractValuedItem1_unitPrice :: Maybe Money
          -- ^ A Contract Provision Valued Item unit valuation measure.
        , contractValuedItem1_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of the Contract Provision 
          --   Valued Item delivered. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , contractValuedItem1_points :: Maybe Decimal
          -- ^ An amount that expresses the weighting (based on 
          --   difficulty, cost and/or resource intensiveness) associated 
          --   with the Contract Provision Valued Item delivered. The 
          --   concept of Points allows for assignment of point values for 
          --   a Contract ProvisionValued Item, such that a monetary 
          --   amount can be assigned to each point.
        , contractValuedItem1_net :: Maybe Money
          -- ^ Expresses the product of the Contract Provision Valued Item 
          --   unitQuantity and the unitPriceAmt. For example, the 
          --   formula: unit Quantity * unit Price (Cost per Point) * 
          --   factor Number * points = net Amount. Quantity, factor and 
          --   points are assumed to be 1 if not supplied.
        }
        deriving (Eq,Show)
instance SchemaType ContractValuedItem1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractValuedItem1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "entityCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "entityReference"))
                                     ])
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "effectiveTime")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "points")
            `apply` optional (parseSchemaType "net")
    schemaTypeToXML s x@ContractValuedItem1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractValuedItem1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractValuedItem1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractValuedItem1_modifierExtension x
            , maybe [] (foldOneOf2  (schemaTypeToXML "entityCodeableConcept")
                                    (schemaTypeToXML "entityReference")
                                   ) $ contractValuedItem1_choice2 x
            , maybe [] (schemaTypeToXML "identifier") $ contractValuedItem1_identifier x
            , maybe [] (schemaTypeToXML "effectiveTime") $ contractValuedItem1_effectiveTime x
            , maybe [] (schemaTypeToXML "quantity") $ contractValuedItem1_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ contractValuedItem1_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ contractValuedItem1_factor x
            , maybe [] (schemaTypeToXML "points") $ contractValuedItem1_points x
            , maybe [] (schemaTypeToXML "net") $ contractValuedItem1_net x
            ]
instance Extension ContractValuedItem1 BackboneElement where
    supertype (ContractValuedItem1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension ContractValuedItem1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractValuedItem1 -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractFriendly = ContractFriendly
        { contractFriendly_id :: Maybe String_primitive
        , contractFriendly_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractFriendly_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractFriendly_choice2 :: OneOf2 Attachment Reference
          -- ^ Human readable rendering of this Contract in a format and 
          --   representation intended to enhance comprehension and ensure 
          --   understandability.
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType ContractFriendly where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractFriendly a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@ContractFriendly{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractFriendly_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractFriendly_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractFriendly_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contractFriendly_choice2 x
            ]
instance Extension ContractFriendly BackboneElement where
    supertype (ContractFriendly a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ContractFriendly Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractFriendly -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractLegal = ContractLegal
        { contractLegal_id :: Maybe String_primitive
        , contractLegal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractLegal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractLegal_choice2 :: OneOf2 Attachment Reference
          -- ^ Contract legal text in human renderable form.
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType ContractLegal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractLegal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@ContractLegal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractLegal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractLegal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractLegal_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contractLegal_choice2 x
            ]
instance Extension ContractLegal BackboneElement where
    supertype (ContractLegal a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ContractLegal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractLegal -> BackboneElement)
              
 
-- | A formal agreement between parties regarding the conduct of 
--   business, exchange of information or other matters.
data ContractRule = ContractRule
        { contractRule_id :: Maybe String_primitive
        , contractRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , contractRule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , contractRule_choice2 :: OneOf2 Attachment Reference
          -- ^ Computable Contract conveyed using a policy rule language 
          --   (e.g. XACML, DKAL, SecPal).
          --   
          --   Choice between:
          --   
          --   (1) contentAttachment
          --   
          --   (2) contentReference
        }
        deriving (Eq,Show)
instance SchemaType ContractRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ContractRule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "contentAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "contentReference"))
                           ]
    schemaTypeToXML s x@ContractRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractRule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractRule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ contractRule_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "contentAttachment")
                          (schemaTypeToXML "contentReference")
                          $ contractRule_choice2 x
            ]
instance Extension ContractRule BackboneElement where
    supertype (ContractRule a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ContractRule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ContractRule -> BackboneElement)
              
 
data ContractResourceStatusCodes_list
    = ContractResourceStatusCodes_list_Amended
      -- ^ Amended
    | ContractResourceStatusCodes_list_Appended
      -- ^ Appended
    | ContractResourceStatusCodes_list_Cancelled
      -- ^ Cancelled
    | ContractResourceStatusCodes_list_Disputed
      -- ^ Disputed
    | ContractResourceStatusCodes_list_Entered_in_error
      -- ^ Entered in Error
    | ContractResourceStatusCodes_list_Executable
      -- ^ Executable
    | ContractResourceStatusCodes_list_Executed
      -- ^ Executed
    | ContractResourceStatusCodes_list_Negotiable
      -- ^ Negotiable
    | ContractResourceStatusCodes_list_Offered
      -- ^ Offered
    | ContractResourceStatusCodes_list_Policy
      -- ^ Policy
    | ContractResourceStatusCodes_list_Rejected
      -- ^ Rejected
    | ContractResourceStatusCodes_list_Renewed
      -- ^ Renewed
    | ContractResourceStatusCodes_list_Revoked
      -- ^ Revoked
    | ContractResourceStatusCodes_list_Resolved
      -- ^ Resolved
    | ContractResourceStatusCodes_list_Terminated
      -- ^ Terminated
    deriving (Eq,Show,Enum)
instance SchemaType ContractResourceStatusCodes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContractResourceStatusCodes_list where
    acceptingParser =  do literal "amended"; return ContractResourceStatusCodes_list_Amended
                      `onFail` do literal "appended"; return ContractResourceStatusCodes_list_Appended
                      `onFail` do literal "cancelled"; return ContractResourceStatusCodes_list_Cancelled
                      `onFail` do literal "disputed"; return ContractResourceStatusCodes_list_Disputed
                      `onFail` do literal "entered-in-error"; return ContractResourceStatusCodes_list_Entered_in_error
                      `onFail` do literal "executable"; return ContractResourceStatusCodes_list_Executable
                      `onFail` do literal "executed"; return ContractResourceStatusCodes_list_Executed
                      `onFail` do literal "negotiable"; return ContractResourceStatusCodes_list_Negotiable
                      `onFail` do literal "offered"; return ContractResourceStatusCodes_list_Offered
                      `onFail` do literal "policy"; return ContractResourceStatusCodes_list_Policy
                      `onFail` do literal "rejected"; return ContractResourceStatusCodes_list_Rejected
                      `onFail` do literal "renewed"; return ContractResourceStatusCodes_list_Renewed
                      `onFail` do literal "revoked"; return ContractResourceStatusCodes_list_Revoked
                      `onFail` do literal "resolved"; return ContractResourceStatusCodes_list_Resolved
                      `onFail` do literal "terminated"; return ContractResourceStatusCodes_list_Terminated
                      
    simpleTypeText ContractResourceStatusCodes_list_Amended = "amended"
    simpleTypeText ContractResourceStatusCodes_list_Appended = "appended"
    simpleTypeText ContractResourceStatusCodes_list_Cancelled = "cancelled"
    simpleTypeText ContractResourceStatusCodes_list_Disputed = "disputed"
    simpleTypeText ContractResourceStatusCodes_list_Entered_in_error = "entered-in-error"
    simpleTypeText ContractResourceStatusCodes_list_Executable = "executable"
    simpleTypeText ContractResourceStatusCodes_list_Executed = "executed"
    simpleTypeText ContractResourceStatusCodes_list_Negotiable = "negotiable"
    simpleTypeText ContractResourceStatusCodes_list_Offered = "offered"
    simpleTypeText ContractResourceStatusCodes_list_Policy = "policy"
    simpleTypeText ContractResourceStatusCodes_list_Rejected = "rejected"
    simpleTypeText ContractResourceStatusCodes_list_Renewed = "renewed"
    simpleTypeText ContractResourceStatusCodes_list_Revoked = "revoked"
    simpleTypeText ContractResourceStatusCodes_list_Resolved = "resolved"
    simpleTypeText ContractResourceStatusCodes_list_Terminated = "terminated"
 
data ContractResourceStatusCodes = ContractResourceStatusCodes
        { contractResourceStatusCodes_id :: Maybe String_primitive
        , contractResourceStatusCodes_value :: Maybe ContractResourceStatusCodes_list
        , contractResourceStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContractResourceStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContractResourceStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContractResourceStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contractResourceStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ contractResourceStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contractResourceStatusCodes_extension x
            ]
instance Extension ContractResourceStatusCodes Element where
    supertype (ContractResourceStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | Financial instrument which may be used to reimburse or pay 
--   for health care products and services.
elementCoverage :: XMLParser Coverage
elementCoverage = parseSchemaType "Coverage"
elementToXMLCoverage :: Coverage -> [Content ()]
elementToXMLCoverage = schemaTypeToXML "Coverage"
 
data Coverage = Coverage
        { coverage_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , coverage_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , coverage_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , coverage_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , coverage_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , coverage_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , coverage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coverage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , coverage_identifier :: [Identifier]
          -- ^ The main (and possibly only) identifier for the coverage - 
          --   often referred to as a Member Id, Certificate number, 
          --   Personal Health Number or Case ID. May be constructed as 
          --   the concatination of the Coverage.SubscriberID and the 
          --   Coverage.dependant.
        , coverage_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , coverage_type :: Maybe CodeableConcept
          -- ^ The type of coverage: social program, medical plan, 
          --   accident coverage (workers compensation, auto), group 
          --   health or payment by an individual or organization.
        , coverage_policyHolder :: Maybe Reference
          -- ^ The party who 'owns' the insurance policy, may be an 
          --   individual, corporation or the subscriber's employer.
        , coverage_subscriber :: Maybe Reference
          -- ^ The party who has signed-up for or 'owns' the contractual 
          --   relationship to the policy or to whom the benefit of the 
          --   policy for services rendered to them or their family is 
          --   due.
        , coverage_subscriberId :: Maybe Xsd.XsdString
          -- ^ The insurer assigned ID for the Subscriber.
        , coverage_beneficiary :: Maybe Reference
          -- ^ The party who benefits from the insurance coverage., the 
          --   patient when services are provided.
        , coverage_relationship :: Maybe CodeableConcept
          -- ^ The relationship of beneficiary (patient) to the 
          --   subscriber.
        , coverage_period :: Maybe Period
          -- ^ Time period during which the coverage is in force. A 
          --   missing start date indicates the start date isn't known, a 
          --   missing end date means the coverage is continuing to be in 
          --   force.
        , coverage_payor :: [Reference]
          -- ^ The program or plan underwriter or payor including both 
          --   insurance and non-insurance agreements, such as patient-pay 
          --   agreements. May provide multiple identifiers such as 
          --   insurance company identifier or business identifier (BIN 
          --   number).
        , coverage_grouping :: Maybe CoverageGrouping
          -- ^ A suite of underwrite specific classifiers, for example may 
          --   be used to identify a class of coverage or employer group, 
          --   Policy, Plan.
        , coverage_dependent :: Maybe Xsd.XsdString
          -- ^ A unique identifier for a dependent under the coverage.
        , coverage_sequence :: Maybe Xsd.XsdString
          -- ^ An optional counter for a particular instance of the 
          --   identified coverage which increments upon each renewal.
        , coverage_order :: Maybe PositiveInt
          -- ^ The order of applicability of this coverage relative to 
          --   other coverages which are currently inforce. Note, there 
          --   may be gaps in the numbering and this does not imply 
          --   primary, secondard etc. as the specific positioning of 
          --   coverages depends upon the episode of care.
        , coverage_network :: Maybe Xsd.XsdString
          -- ^ The insurer-specific identifier for the insurer-defined 
          --   network of providers to which the beneficiary may seek 
          --   treatment which will be covered at the 'in-network' rate, 
          --   otherwise 'out of network' terms and conditions apply.
        , coverage_contract :: [Reference]
          -- ^ The policy(s) which constitute this insurance coverage.
        }
        deriving (Eq,Show)
instance SchemaType Coverage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Coverage
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "policyHolder")
            `apply` optional (parseSchemaType "subscriber")
            `apply` optional (parseSchemaType "subscriberId")
            `apply` optional (parseSchemaType "beneficiary")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "payor")
            `apply` optional (parseSchemaType "grouping")
            `apply` optional (parseSchemaType "dependent")
            `apply` optional (parseSchemaType "sequence")
            `apply` optional (parseSchemaType "order")
            `apply` optional (parseSchemaType "network")
            `apply` many (parseSchemaType "contract")
    schemaTypeToXML s x@Coverage{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ coverage_id x
            , maybe [] (schemaTypeToXML "meta") $ coverage_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ coverage_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ coverage_language x
            , maybe [] (schemaTypeToXML "text") $ coverage_text x
            , concatMap (schemaTypeToXML "contained") $ coverage_contained x
            , concatMap (schemaTypeToXML "extension") $ coverage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ coverage_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ coverage_identifier x
            , maybe [] (schemaTypeToXML "status") $ coverage_status x
            , maybe [] (schemaTypeToXML "type") $ coverage_type x
            , maybe [] (schemaTypeToXML "policyHolder") $ coverage_policyHolder x
            , maybe [] (schemaTypeToXML "subscriber") $ coverage_subscriber x
            , maybe [] (schemaTypeToXML "subscriberId") $ coverage_subscriberId x
            , maybe [] (schemaTypeToXML "beneficiary") $ coverage_beneficiary x
            , maybe [] (schemaTypeToXML "relationship") $ coverage_relationship x
            , maybe [] (schemaTypeToXML "period") $ coverage_period x
            , concatMap (schemaTypeToXML "payor") $ coverage_payor x
            , maybe [] (schemaTypeToXML "grouping") $ coverage_grouping x
            , maybe [] (schemaTypeToXML "dependent") $ coverage_dependent x
            , maybe [] (schemaTypeToXML "sequence") $ coverage_sequence x
            , maybe [] (schemaTypeToXML "order") $ coverage_order x
            , maybe [] (schemaTypeToXML "network") $ coverage_network x
            , concatMap (schemaTypeToXML "contract") $ coverage_contract x
            ]
instance Extension Coverage DomainResource where
    supertype (Coverage e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Coverage Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Coverage -> DomainResource)
              
 
-- | Financial instrument which may be used to reimburse or pay 
--   for health care products and services.
data CoverageGrouping = CoverageGrouping
        { coverageGrouping_id :: Maybe String_primitive
        , coverageGrouping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , coverageGrouping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , coverageGrouping_group :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify an 
          --   employer group. May also be referred to as a Policy or 
          --   Group ID.
        , coverageGrouping_groupDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the group.
        , coverageGrouping_subGroup :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify a subset 
          --   of an employer group.
        , coverageGrouping_subGroupDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subgroup.
        , coverageGrouping_plan :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issued by the 
          --   underwriter, for example may be used to identify a 
          --   collection of benefits provided to employees. May be 
          --   referred to as a Section or Division ID.
        , coverageGrouping_planDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the plan.
        , coverageGrouping_subPlan :: Maybe Xsd.XsdString
          -- ^ Identifies a sub-style or sub-collective of coverage issued 
          --   by the underwriter, for example may be used to identify a 
          --   subset of a collection of benefits provided to employees.
        , coverageGrouping_subPlanDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subplan.
        , coverageGrouping_class :: Maybe Xsd.XsdString
          -- ^ Identifies a style or collective of coverage issues by the 
          --   underwriter, for example may be used to identify a class of 
          --   coverage such as a level of deductables or co-payment.
        , coverageGrouping_classDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the class.
        , coverageGrouping_subClass :: Maybe Xsd.XsdString
          -- ^ Identifies a sub-style or sub-collective of coverage issues 
          --   by the underwriter, for example may be used to identify a 
          --   subclass of coverage such as a sub-level of deductables or 
          --   co-payment.
        , coverageGrouping_subClassDisplay :: Maybe Xsd.XsdString
          -- ^ A short description for the subclass.
        }
        deriving (Eq,Show)
instance SchemaType CoverageGrouping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (CoverageGrouping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "group")
            `apply` optional (parseSchemaType "groupDisplay")
            `apply` optional (parseSchemaType "subGroup")
            `apply` optional (parseSchemaType "subGroupDisplay")
            `apply` optional (parseSchemaType "plan")
            `apply` optional (parseSchemaType "planDisplay")
            `apply` optional (parseSchemaType "subPlan")
            `apply` optional (parseSchemaType "subPlanDisplay")
            `apply` optional (parseSchemaType "class")
            `apply` optional (parseSchemaType "classDisplay")
            `apply` optional (parseSchemaType "subClass")
            `apply` optional (parseSchemaType "subClassDisplay")
    schemaTypeToXML s x@CoverageGrouping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ coverageGrouping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ coverageGrouping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ coverageGrouping_modifierExtension x
            , maybe [] (schemaTypeToXML "group") $ coverageGrouping_group x
            , maybe [] (schemaTypeToXML "groupDisplay") $ coverageGrouping_groupDisplay x
            , maybe [] (schemaTypeToXML "subGroup") $ coverageGrouping_subGroup x
            , maybe [] (schemaTypeToXML "subGroupDisplay") $ coverageGrouping_subGroupDisplay x
            , maybe [] (schemaTypeToXML "plan") $ coverageGrouping_plan x
            , maybe [] (schemaTypeToXML "planDisplay") $ coverageGrouping_planDisplay x
            , maybe [] (schemaTypeToXML "subPlan") $ coverageGrouping_subPlan x
            , maybe [] (schemaTypeToXML "subPlanDisplay") $ coverageGrouping_subPlanDisplay x
            , maybe [] (schemaTypeToXML "class") $ coverageGrouping_class x
            , maybe [] (schemaTypeToXML "classDisplay") $ coverageGrouping_classDisplay x
            , maybe [] (schemaTypeToXML "subClass") $ coverageGrouping_subClass x
            , maybe [] (schemaTypeToXML "subClassDisplay") $ coverageGrouping_subClassDisplay x
            ]
instance Extension CoverageGrouping BackboneElement where
    supertype (CoverageGrouping a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension CoverageGrouping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: CoverageGrouping -> BackboneElement)
              
 
-- | The formal description of a single piece of information 
--   that can be gathered and reported.
elementDataElement :: XMLParser DataElement
elementDataElement = parseSchemaType "DataElement"
elementToXMLDataElement :: DataElement -> [Content ()]
elementToXMLDataElement = schemaTypeToXML "DataElement"
 
data DataElement = DataElement
        { dataElement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , dataElement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , dataElement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , dataElement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , dataElement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , dataElement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , dataElement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataElement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , dataElement_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this data element 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this data element 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the data element. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , dataElement_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this data 
          --   element when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , dataElement_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   data element when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the data element author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , dataElement_status :: PublicationStatus
          -- ^ The status of this data element. Enables tracking the 
          --   life-cycle of the content.
        , dataElement_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this data element is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , dataElement_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the data element was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the data element changes.
        , dataElement_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the data element.
        , dataElement_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the data element. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , dataElement_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the data 
          --   element.
        , dataElement_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , dataElement_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   data element instances.
        , dataElement_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the data element is 
          --   intended to be used.
        , dataElement_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the data element and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the data element.
        , dataElement_stringency :: Maybe DataElementStringency
          -- ^ Identifies how precise the data element is in its 
          --   definition.
        , dataElement_mapping :: [DataElementMapping]
          -- ^ Identifies a specification (other than a terminology) that 
          --   the elements which make up the DataElement have some 
          --   correspondence with.
        , dataElement_element :: [ElementDefinition]
          -- ^ Defines the structure, type, allowed values and other 
          --   constraining characteristics of the data element.
        }
        deriving (Eq,Show)
instance SchemaType DataElement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DataElement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "stringency")
            `apply` many (parseSchemaType "mapping")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@DataElement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ dataElement_id x
            , maybe [] (schemaTypeToXML "meta") $ dataElement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ dataElement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ dataElement_language x
            , maybe [] (schemaTypeToXML "text") $ dataElement_text x
            , concatMap (schemaTypeToXML "contained") $ dataElement_contained x
            , concatMap (schemaTypeToXML "extension") $ dataElement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ dataElement_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ dataElement_url x
            , concatMap (schemaTypeToXML "identifier") $ dataElement_identifier x
            , maybe [] (schemaTypeToXML "version") $ dataElement_version x
            , schemaTypeToXML "status" $ dataElement_status x
            , maybe [] (schemaTypeToXML "experimental") $ dataElement_experimental x
            , maybe [] (schemaTypeToXML "date") $ dataElement_date x
            , maybe [] (schemaTypeToXML "publisher") $ dataElement_publisher x
            , maybe [] (schemaTypeToXML "name") $ dataElement_name x
            , maybe [] (schemaTypeToXML "title") $ dataElement_title x
            , concatMap (schemaTypeToXML "contact") $ dataElement_contact x
            , concatMap (schemaTypeToXML "useContext") $ dataElement_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ dataElement_jurisdiction x
            , maybe [] (schemaTypeToXML "copyright") $ dataElement_copyright x
            , maybe [] (schemaTypeToXML "stringency") $ dataElement_stringency x
            , concatMap (schemaTypeToXML "mapping") $ dataElement_mapping x
            , concatMap (schemaTypeToXML "element") $ dataElement_element x
            ]
instance Extension DataElement DomainResource where
    supertype (DataElement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DataElement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DataElement -> DomainResource)
              
 
-- | The formal description of a single piece of information 
--   that can be gathered and reported.
data DataElementMapping = DataElementMapping
        { dataElementMapping_id :: Maybe String_primitive
        , dataElementMapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , dataElementMapping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , dataElementMapping_identity :: Id
          -- ^ An internal id that is used to identify this mapping set 
          --   when specific mappings are made on a per-element basis.
        , dataElementMapping_uri :: Maybe Uri
          -- ^ An absolute URI that identifies the specification that this 
          --   mapping is expressed to.
        , dataElementMapping_name :: Maybe Xsd.XsdString
          -- ^ A name for the specification that is being mapped to.
        , dataElementMapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments about this mapping, including version notes, 
          --   issues, scope limitations, and other important notes for 
          --   usage.
        }
        deriving (Eq,Show)
instance SchemaType DataElementMapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DataElementMapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@DataElementMapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataElementMapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataElementMapping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ dataElementMapping_modifierExtension x
            , schemaTypeToXML "identity" $ dataElementMapping_identity x
            , maybe [] (schemaTypeToXML "uri") $ dataElementMapping_uri x
            , maybe [] (schemaTypeToXML "name") $ dataElementMapping_name x
            , maybe [] (schemaTypeToXML "comment") $ dataElementMapping_comment x
            ]
instance Extension DataElementMapping BackboneElement where
    supertype (DataElementMapping a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension DataElementMapping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DataElementMapping -> BackboneElement)
              
 
data DataElementStringency_list
    = DataElementStringency_list_Comparable
      -- ^ Comparable
    | DataElementStringency_list_Fully_specified
      -- ^ Fully Specified
    | DataElementStringency_list_Equivalent
      -- ^ Equivalent
    | DataElementStringency_list_Convertable
      -- ^ Convertable
    | DataElementStringency_list_Scaleable
      -- ^ Scaleable
    | DataElementStringency_list_Flexible
      -- ^ Flexible
    deriving (Eq,Show,Enum)
instance SchemaType DataElementStringency_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DataElementStringency_list where
    acceptingParser =  do literal "comparable"; return DataElementStringency_list_Comparable
                      `onFail` do literal "fully-specified"; return DataElementStringency_list_Fully_specified
                      `onFail` do literal "equivalent"; return DataElementStringency_list_Equivalent
                      `onFail` do literal "convertable"; return DataElementStringency_list_Convertable
                      `onFail` do literal "scaleable"; return DataElementStringency_list_Scaleable
                      `onFail` do literal "flexible"; return DataElementStringency_list_Flexible
                      
    simpleTypeText DataElementStringency_list_Comparable = "comparable"
    simpleTypeText DataElementStringency_list_Fully_specified = "fully-specified"
    simpleTypeText DataElementStringency_list_Equivalent = "equivalent"
    simpleTypeText DataElementStringency_list_Convertable = "convertable"
    simpleTypeText DataElementStringency_list_Scaleable = "scaleable"
    simpleTypeText DataElementStringency_list_Flexible = "flexible"
 
data DataElementStringency = DataElementStringency
        { dataElementStringency_id :: Maybe String_primitive
        , dataElementStringency_value :: Maybe DataElementStringency_list
        , dataElementStringency_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DataElementStringency where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DataElementStringency a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DataElementStringency{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ dataElementStringency_id x
                       , maybe [] (toXMLAttribute "value") $ dataElementStringency_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ dataElementStringency_extension x
            ]
instance Extension DataElementStringency Element where
    supertype (DataElementStringency a0 a1 e0) =
               Element a0 e0
 
-- | Indicates an actual or potential clinical issue with or 
--   between one or more active or proposed clinical actions for 
--   a patient; e.g. Drug-drug interaction, Ineffective 
--   treatment frequency, Procedure-condition conflict, etc.
elementDetectedIssue :: XMLParser DetectedIssue
elementDetectedIssue = parseSchemaType "DetectedIssue"
elementToXMLDetectedIssue :: DetectedIssue -> [Content ()]
elementToXMLDetectedIssue = schemaTypeToXML "DetectedIssue"
 
data DetectedIssue = DetectedIssue
        { detectedIssue_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , detectedIssue_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , detectedIssue_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , detectedIssue_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , detectedIssue_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , detectedIssue_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , detectedIssue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , detectedIssue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , detectedIssue_identifier :: Maybe Identifier
          -- ^ Business identifier associated with the detected issue 
          --   record.
        , detectedIssue_status :: ObservationStatus
          -- ^ Indicates the status of the detected issue.
        , detectedIssue_category :: Maybe CodeableConcept
          -- ^ Identifies the general type of issue identified.
        , detectedIssue_severity :: Maybe DetectedIssueSeverity
          -- ^ Indicates the degree of importance associated with the 
          --   identified issue based on the potential impact on the 
          --   patient.
        , detectedIssue_patient :: Maybe Reference
          -- ^ Indicates the patient whose record the detected issue is 
          --   associated with.
        , detectedIssue_date :: Maybe DateTime
          -- ^ The date or date-time when the detected issue was initially 
          --   identified.
        , detectedIssue_author :: Maybe Reference
          -- ^ Individual or device responsible for the issue being 
          --   raised. For example, a decision support application or a 
          --   pharmacist conducting a medication review.
        , detectedIssue_implicated :: [Reference]
          -- ^ Indicates the resource representing the current activity or 
          --   proposed activity that is potentially problematic.
        , detectedIssue_detail :: Maybe Xsd.XsdString
          -- ^ A textual explanation of the detected issue.
        , detectedIssue_reference :: Maybe Uri
          -- ^ The literature, knowledge-base or similar reference that 
          --   describes the propensity for the detected issue identified.
        , detectedIssue_mitigation :: [DetectedIssueMitigation]
          -- ^ Indicates an action that has been taken or is committed to 
          --   to reduce or eliminate the likelihood of the risk 
          --   identified by the detected issue from manifesting. Can also 
          --   reflect an observation of known mitigating factors that may 
          --   reduce/eliminate the need for any action.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DetectedIssue
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "severity")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "author")
            `apply` many (parseSchemaType "implicated")
            `apply` optional (parseSchemaType "detail")
            `apply` optional (parseSchemaType "reference")
            `apply` many (parseSchemaType "mitigation")
    schemaTypeToXML s x@DetectedIssue{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ detectedIssue_id x
            , maybe [] (schemaTypeToXML "meta") $ detectedIssue_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ detectedIssue_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ detectedIssue_language x
            , maybe [] (schemaTypeToXML "text") $ detectedIssue_text x
            , concatMap (schemaTypeToXML "contained") $ detectedIssue_contained x
            , concatMap (schemaTypeToXML "extension") $ detectedIssue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ detectedIssue_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ detectedIssue_identifier x
            , schemaTypeToXML "status" $ detectedIssue_status x
            , maybe [] (schemaTypeToXML "category") $ detectedIssue_category x
            , maybe [] (schemaTypeToXML "severity") $ detectedIssue_severity x
            , maybe [] (schemaTypeToXML "patient") $ detectedIssue_patient x
            , maybe [] (schemaTypeToXML "date") $ detectedIssue_date x
            , maybe [] (schemaTypeToXML "author") $ detectedIssue_author x
            , concatMap (schemaTypeToXML "implicated") $ detectedIssue_implicated x
            , maybe [] (schemaTypeToXML "detail") $ detectedIssue_detail x
            , maybe [] (schemaTypeToXML "reference") $ detectedIssue_reference x
            , concatMap (schemaTypeToXML "mitigation") $ detectedIssue_mitigation x
            ]
instance Extension DetectedIssue DomainResource where
    supertype (DetectedIssue e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DetectedIssue Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DetectedIssue -> DomainResource)
              
 
-- | Indicates an actual or potential clinical issue with or 
--   between one or more active or proposed clinical actions for 
--   a patient; e.g. Drug-drug interaction, Ineffective 
--   treatment frequency, Procedure-condition conflict, etc.
data DetectedIssueMitigation = DetectedIssueMitigation
        { detectedIssueMitigation_id :: Maybe String_primitive
        , detectedIssueMitigation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , detectedIssueMitigation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , detectedIssueMitigation_action :: CodeableConcept
          -- ^ Describes the action that was taken or the observation that 
          --   was made that reduces/eliminates the risk associated with 
          --   the identified issue.
        , detectedIssueMitigation_date :: Maybe DateTime
          -- ^ Indicates when the mitigating action was documented.
        , detectedIssueMitigation_author :: Maybe Reference
          -- ^ Identifies the practitioner who determined the mitigation 
          --   and takes responsibility for the mitigation step occurring.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssueMitigation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DetectedIssueMitigation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "action"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@DetectedIssueMitigation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ detectedIssueMitigation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ detectedIssueMitigation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ detectedIssueMitigation_modifierExtension x
            , schemaTypeToXML "action" $ detectedIssueMitigation_action x
            , maybe [] (schemaTypeToXML "date") $ detectedIssueMitigation_date x
            , maybe [] (schemaTypeToXML "author") $ detectedIssueMitigation_author x
            ]
instance Extension DetectedIssueMitigation BackboneElement where
    supertype (DetectedIssueMitigation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DetectedIssueMitigation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DetectedIssueMitigation -> BackboneElement)
              
 
data ObservationStatus_list
    = ObservationStatus_list_Registered
      -- ^ Registered
    | ObservationStatus_list_Preliminary
      -- ^ Preliminary
    | ObservationStatus_list_Final
      -- ^ Final
    | ObservationStatus_list_Amended
      -- ^ Amended
    | ObservationStatus_list_Corrected
      -- ^ Corrected
    | ObservationStatus_list_Cancelled
      -- ^ Cancelled
    | ObservationStatus_list_Entered_in_error
      -- ^ Entered in Error
    | ObservationStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType ObservationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ObservationStatus_list where
    acceptingParser =  do literal "registered"; return ObservationStatus_list_Registered
                      `onFail` do literal "preliminary"; return ObservationStatus_list_Preliminary
                      `onFail` do literal "final"; return ObservationStatus_list_Final
                      `onFail` do literal "amended"; return ObservationStatus_list_Amended
                      `onFail` do literal "corrected"; return ObservationStatus_list_Corrected
                      `onFail` do literal "cancelled"; return ObservationStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return ObservationStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return ObservationStatus_list_Unknown
                      
    simpleTypeText ObservationStatus_list_Registered = "registered"
    simpleTypeText ObservationStatus_list_Preliminary = "preliminary"
    simpleTypeText ObservationStatus_list_Final = "final"
    simpleTypeText ObservationStatus_list_Amended = "amended"
    simpleTypeText ObservationStatus_list_Corrected = "corrected"
    simpleTypeText ObservationStatus_list_Cancelled = "cancelled"
    simpleTypeText ObservationStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText ObservationStatus_list_Unknown = "unknown"
 
data ObservationStatus = ObservationStatus
        { observationStatus_id :: Maybe String_primitive
        , observationStatus_value :: Maybe ObservationStatus_list
        , observationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ObservationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ObservationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ObservationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ observationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationStatus_extension x
            ]
instance Extension ObservationStatus Element where
    supertype (ObservationStatus a0 a1 e0) =
               Element a0 e0
 
data DetectedIssueSeverity_list
    = DetectedIssueSeverity_list_High
      -- ^ High
    | DetectedIssueSeverity_list_Moderate
      -- ^ Moderate
    | DetectedIssueSeverity_list_Low
      -- ^ Low
    deriving (Eq,Show,Enum)
instance SchemaType DetectedIssueSeverity_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DetectedIssueSeverity_list where
    acceptingParser =  do literal "high"; return DetectedIssueSeverity_list_High
                      `onFail` do literal "moderate"; return DetectedIssueSeverity_list_Moderate
                      `onFail` do literal "low"; return DetectedIssueSeverity_list_Low
                      
    simpleTypeText DetectedIssueSeverity_list_High = "high"
    simpleTypeText DetectedIssueSeverity_list_Moderate = "moderate"
    simpleTypeText DetectedIssueSeverity_list_Low = "low"
 
data DetectedIssueSeverity = DetectedIssueSeverity
        { detectedIssueSeverity_id :: Maybe String_primitive
        , detectedIssueSeverity_value :: Maybe DetectedIssueSeverity_list
        , detectedIssueSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DetectedIssueSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DetectedIssueSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DetectedIssueSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ detectedIssueSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ detectedIssueSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ detectedIssueSeverity_extension x
            ]
instance Extension DetectedIssueSeverity Element where
    supertype (DetectedIssueSeverity a0 a1 e0) =
               Element a0 e0
 
-- | This resource identifies an instance or a type of a 
--   manufactured item that is used in the provision of 
--   healthcare without being substantially changed through that 
--   activity. The device may be a medical or non-medical 
--   device. Medical devices include durable (reusable) medical 
--   equipment, implantable devices, as well as disposable 
--   equipment used for diagnostic, treatment, and research for 
--   healthcare and public health. Non-medical devices may 
--   include items such as a machine, cellphone, computer, 
--   application, etc.
elementDevice :: XMLParser Device
elementDevice = parseSchemaType "Device"
elementToXMLDevice :: Device -> [Content ()]
elementToXMLDevice = schemaTypeToXML "Device"
 
data Device = Device
        { device_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , device_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , device_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , device_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , device_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , device_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , device_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , device_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , device_identifier :: [Identifier]
          -- ^ Unique instance identifiers assigned to a device by 
          --   manufacturers other organizations or owners.
        , device_udi :: Maybe DeviceUdi
          -- ^ [Unique device identifier (UDI)](device.html#5.11.3.2.2) 
          --   assigned to device label or package.
        , device_status :: Maybe FHIRDeviceStatus
          -- ^ Status of the Device availability.
        , device_type :: Maybe CodeableConcept
          -- ^ Code or identifier to identify a kind of device.
        , device_lotNumber :: Maybe Xsd.XsdString
          -- ^ Lot number assigned by the manufacturer.
        , device_manufacturer :: Maybe Xsd.XsdString
          -- ^ A name of the manufacturer.
        , device_manufactureDate :: Maybe DateTime
          -- ^ The date and time when the device was manufactured.
        , device_expirationDate :: Maybe DateTime
          -- ^ The date and time beyond which this device is no longer 
          --   valid or should not be used (if applicable).
        , device_model :: Maybe Xsd.XsdString
          -- ^ The &quot;model&quot; is an identifier assigned by the 
          --   manufacturer to identify the product by its type. This 
          --   number is shared by the all devices sold as the same type.
        , device_version :: Maybe Xsd.XsdString
          -- ^ The version of the device, if the device has multiple 
          --   releases under the same model, or if the device is software 
          --   or carries firmware.
        , device_patient :: Maybe Reference
          -- ^ Patient information, If the device is affixed to a person.
        , device_owner :: Maybe Reference
          -- ^ An organization that is responsible for the provision and 
          --   ongoing maintenance of the device.
        , device_contact :: [ContactPoint]
          -- ^ Contact details for an organization or a particular human 
          --   that is responsible for the device.
        , device_location :: Maybe Reference
          -- ^ The place where the device can be found.
        , device_url :: Maybe Uri
          -- ^ A network address on which the device may be contacted 
          --   directly.
        , device_note :: [Annotation]
          -- ^ Descriptive information, usage information or implantation 
          --   information that is not captured in an existing element.
        , device_safety :: [CodeableConcept]
          -- ^ Provides additional safety characteristics about a medical 
          --   device. For example devices containing latex.
        }
        deriving (Eq,Show)
instance SchemaType Device where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Device
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "udi")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "manufactureDate")
            `apply` optional (parseSchemaType "expirationDate")
            `apply` optional (parseSchemaType "model")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "owner")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "safety")
    schemaTypeToXML s x@Device{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ device_id x
            , maybe [] (schemaTypeToXML "meta") $ device_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ device_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ device_language x
            , maybe [] (schemaTypeToXML "text") $ device_text x
            , concatMap (schemaTypeToXML "contained") $ device_contained x
            , concatMap (schemaTypeToXML "extension") $ device_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ device_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ device_identifier x
            , maybe [] (schemaTypeToXML "udi") $ device_udi x
            , maybe [] (schemaTypeToXML "status") $ device_status x
            , maybe [] (schemaTypeToXML "type") $ device_type x
            , maybe [] (schemaTypeToXML "lotNumber") $ device_lotNumber x
            , maybe [] (schemaTypeToXML "manufacturer") $ device_manufacturer x
            , maybe [] (schemaTypeToXML "manufactureDate") $ device_manufactureDate x
            , maybe [] (schemaTypeToXML "expirationDate") $ device_expirationDate x
            , maybe [] (schemaTypeToXML "model") $ device_model x
            , maybe [] (schemaTypeToXML "version") $ device_version x
            , maybe [] (schemaTypeToXML "patient") $ device_patient x
            , maybe [] (schemaTypeToXML "owner") $ device_owner x
            , concatMap (schemaTypeToXML "contact") $ device_contact x
            , maybe [] (schemaTypeToXML "location") $ device_location x
            , maybe [] (schemaTypeToXML "url") $ device_url x
            , concatMap (schemaTypeToXML "note") $ device_note x
            , concatMap (schemaTypeToXML "safety") $ device_safety x
            ]
instance Extension Device DomainResource where
    supertype (Device e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Device Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Device -> DomainResource)
              
 
-- | This resource identifies an instance or a type of a 
--   manufactured item that is used in the provision of 
--   healthcare without being substantially changed through that 
--   activity. The device may be a medical or non-medical 
--   device. Medical devices include durable (reusable) medical 
--   equipment, implantable devices, as well as disposable 
--   equipment used for diagnostic, treatment, and research for 
--   healthcare and public health. Non-medical devices may 
--   include items such as a machine, cellphone, computer, 
--   application, etc.
data DeviceUdi = DeviceUdi
        { deviceUdi_id :: Maybe String_primitive
        , deviceUdi_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceUdi_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceUdi_deviceIdentifier :: Maybe Xsd.XsdString
          -- ^ The device identifier (DI) is a mandatory, fixed portion of 
          --   a UDI that identifies the labeler and the specific version 
          --   or model of a device.
        , deviceUdi_name :: Maybe Xsd.XsdString
          -- ^ Name of device as used in labeling or catalog.
        , deviceUdi_jurisdiction :: Maybe Uri
          -- ^ The identity of the authoritative source for UDI generation 
          --   within a jurisdiction. All UDIs are globally unique within 
          --   a single namespace. with the appropriate repository uri as 
          --   the system. For example, UDIs of devices managed in the 
          --   U.S. by the FDA, the value is 
          --   http://hl7.org/fhir/NamingSystem/fda-udi.
        , deviceUdi_carrierHRF :: Maybe Xsd.XsdString
          -- ^ The full UDI carrier as the human readable form (HRF) 
          --   representation of the barcode string as printed on the 
          --   packaging of the device.
        , deviceUdi_carrierAIDC :: Maybe Base64Binary
          -- ^ The full UDI carrier of the Automatic Identification and 
          --   Data Capture (AIDC) technology representation of the 
          --   barcode string as printed on the packaging of the device - 
          --   E.g a barcode or RFID. Because of limitations on character 
          --   sets in XML and the need to round-trip JSON data through 
          --   XML, AIDC Formats *SHALL* be base64 encoded.
        , deviceUdi_issuer :: Maybe Uri
          -- ^ Organization that is charged with issuing UDIs for devices. 
          --   For example, the US FDA issuers include : 1) GS1: 
          --   http://hl7.org/fhir/NamingSystem/gs1-di, 2) HIBCC: 
          --   http://hl7.org/fhir/NamingSystem/hibcc-dI, 3) ICCBBA for 
          --   blood containers: 
          --   http://hl7.org/fhir/NamingSystem/iccbba-blood-di, 4) ICCBA 
          --   for other devices: 
          --   http://hl7.org/fhir/NamingSystem/iccbba-other-di.
        , deviceUdi_entryType :: Maybe UDIEntryType
          -- ^ A coded entry to indicate how the data was entered.
        }
        deriving (Eq,Show)
instance SchemaType DeviceUdi where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceUdi a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "deviceIdentifier")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "carrierHRF")
            `apply` optional (parseSchemaType "carrierAIDC")
            `apply` optional (parseSchemaType "issuer")
            `apply` optional (parseSchemaType "entryType")
    schemaTypeToXML s x@DeviceUdi{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceUdi_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceUdi_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceUdi_modifierExtension x
            , maybe [] (schemaTypeToXML "deviceIdentifier") $ deviceUdi_deviceIdentifier x
            , maybe [] (schemaTypeToXML "name") $ deviceUdi_name x
            , maybe [] (schemaTypeToXML "jurisdiction") $ deviceUdi_jurisdiction x
            , maybe [] (schemaTypeToXML "carrierHRF") $ deviceUdi_carrierHRF x
            , maybe [] (schemaTypeToXML "carrierAIDC") $ deviceUdi_carrierAIDC x
            , maybe [] (schemaTypeToXML "issuer") $ deviceUdi_issuer x
            , maybe [] (schemaTypeToXML "entryType") $ deviceUdi_entryType x
            ]
instance Extension DeviceUdi BackboneElement where
    supertype (DeviceUdi a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension DeviceUdi Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceUdi -> BackboneElement)
              
 
data FHIRDeviceStatus_list
    = FHIRDeviceStatus_list_Active
      -- ^ Active
    | FHIRDeviceStatus_list_Inactive
      -- ^ Inactive
    | FHIRDeviceStatus_list_Entered_in_error
      -- ^ Entered in Error
    | FHIRDeviceStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType FHIRDeviceStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRDeviceStatus_list where
    acceptingParser =  do literal "active"; return FHIRDeviceStatus_list_Active
                      `onFail` do literal "inactive"; return FHIRDeviceStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return FHIRDeviceStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return FHIRDeviceStatus_list_Unknown
                      
    simpleTypeText FHIRDeviceStatus_list_Active = "active"
    simpleTypeText FHIRDeviceStatus_list_Inactive = "inactive"
    simpleTypeText FHIRDeviceStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText FHIRDeviceStatus_list_Unknown = "unknown"
 
data FHIRDeviceStatus = FHIRDeviceStatus
        { fHIRDeviceStatus_id :: Maybe String_primitive
        , fHIRDeviceStatus_value :: Maybe FHIRDeviceStatus_list
        , fHIRDeviceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRDeviceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRDeviceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRDeviceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRDeviceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRDeviceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRDeviceStatus_extension x
            ]
instance Extension FHIRDeviceStatus Element where
    supertype (FHIRDeviceStatus a0 a1 e0) =
               Element a0 e0
 
data UDIEntryType_list
    = UDIEntryType_list_Barcode
      -- ^ BarCode
    | UDIEntryType_list_Rfid
      -- ^ RFID
    | UDIEntryType_list_Manual
      -- ^ Manual
    | UDIEntryType_list_Card
      -- ^ Card
    | UDIEntryType_list_Self_reported
      -- ^ Self Reported
    | UDIEntryType_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType UDIEntryType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType UDIEntryType_list where
    acceptingParser =  do literal "barcode"; return UDIEntryType_list_Barcode
                      `onFail` do literal "rfid"; return UDIEntryType_list_Rfid
                      `onFail` do literal "manual"; return UDIEntryType_list_Manual
                      `onFail` do literal "card"; return UDIEntryType_list_Card
                      `onFail` do literal "self-reported"; return UDIEntryType_list_Self_reported
                      `onFail` do literal "unknown"; return UDIEntryType_list_Unknown
                      
    simpleTypeText UDIEntryType_list_Barcode = "barcode"
    simpleTypeText UDIEntryType_list_Rfid = "rfid"
    simpleTypeText UDIEntryType_list_Manual = "manual"
    simpleTypeText UDIEntryType_list_Card = "card"
    simpleTypeText UDIEntryType_list_Self_reported = "self-reported"
    simpleTypeText UDIEntryType_list_Unknown = "unknown"
 
data UDIEntryType = UDIEntryType
        { uDIEntryType_id :: Maybe String_primitive
        , uDIEntryType_value :: Maybe UDIEntryType_list
        , uDIEntryType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType UDIEntryType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (UDIEntryType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@UDIEntryType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ uDIEntryType_id x
                       , maybe [] (toXMLAttribute "value") $ uDIEntryType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ uDIEntryType_extension x
            ]
instance Extension UDIEntryType Element where
    supertype (UDIEntryType a0 a1 e0) =
               Element a0 e0
 
-- | The characteristics, operational status and capabilities of 
--   a medical-related component of a medical device.
elementDeviceComponent :: XMLParser DeviceComponent
elementDeviceComponent = parseSchemaType "DeviceComponent"
elementToXMLDeviceComponent :: DeviceComponent -> [Content ()]
elementToXMLDeviceComponent = schemaTypeToXML "DeviceComponent"
 
data DeviceComponent = DeviceComponent
        { deviceComponent_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceComponent_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceComponent_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceComponent_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceComponent_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceComponent_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceComponent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceComponent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceComponent_identifier :: Identifier
          -- ^ The locally assigned unique identification by the software. 
          --   For example: handle ID.
        , deviceComponent_type :: CodeableConcept
          -- ^ The component type as defined in the object-oriented or 
          --   metric nomenclature partition.
        , deviceComponent_lastSystemChange :: Maybe Instant
          -- ^ The timestamp for the most recent system change which 
          --   includes device configuration or setting change.
        , deviceComponent_source :: Maybe Reference
          -- ^ The link to the source Device that contains administrative 
          --   device information such as manufacture, serial number, etc.
        , deviceComponent_parent :: Maybe Reference
          -- ^ The link to the parent resource. For example: Channel is 
          --   linked to its VMD parent.
        , deviceComponent_operationalStatus :: [CodeableConcept]
          -- ^ The current operational status of the device. For example: 
          --   On, Off, Standby, etc.
        , deviceComponent_parameterGroup :: Maybe CodeableConcept
          -- ^ The parameter group supported by the current device 
          --   component that is based on some nomenclature, e.g. 
          --   cardiovascular.
        , deviceComponent_measurementPrinciple :: Maybe MeasmntPrinciple
          -- ^ The physical principle of the measurement. For example: 
          --   thermal, chemical, acoustical, etc.
        , deviceComponent_productionSpecification :: [DeviceComponentProductionSpecification]
          -- ^ The production specification such as component revision, 
          --   serial number, etc.
        , deviceComponent_languageCode :: Maybe CodeableConcept
          -- ^ The language code for the human-readable text string 
          --   produced by the device. This language code will follow the 
          --   IETF language tag. Example: en-US.
        }
        deriving (Eq,Show)
instance SchemaType DeviceComponent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceComponent
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "lastSystemChange")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "parent")
            `apply` many (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "parameterGroup")
            `apply` optional (parseSchemaType "measurementPrinciple")
            `apply` many (parseSchemaType "productionSpecification")
            `apply` optional (parseSchemaType "languageCode")
    schemaTypeToXML s x@DeviceComponent{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceComponent_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceComponent_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceComponent_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceComponent_language x
            , maybe [] (schemaTypeToXML "text") $ deviceComponent_text x
            , concatMap (schemaTypeToXML "contained") $ deviceComponent_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceComponent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceComponent_modifierExtension x
            , schemaTypeToXML "identifier" $ deviceComponent_identifier x
            , schemaTypeToXML "type" $ deviceComponent_type x
            , maybe [] (schemaTypeToXML "lastSystemChange") $ deviceComponent_lastSystemChange x
            , maybe [] (schemaTypeToXML "source") $ deviceComponent_source x
            , maybe [] (schemaTypeToXML "parent") $ deviceComponent_parent x
            , concatMap (schemaTypeToXML "operationalStatus") $ deviceComponent_operationalStatus x
            , maybe [] (schemaTypeToXML "parameterGroup") $ deviceComponent_parameterGroup x
            , maybe [] (schemaTypeToXML "measurementPrinciple") $ deviceComponent_measurementPrinciple x
            , concatMap (schemaTypeToXML "productionSpecification") $ deviceComponent_productionSpecification x
            , maybe [] (schemaTypeToXML "languageCode") $ deviceComponent_languageCode x
            ]
instance Extension DeviceComponent DomainResource where
    supertype (DeviceComponent e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceComponent Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceComponent -> DomainResource)
              
 
-- | The characteristics, operational status and capabilities of 
--   a medical-related component of a medical device.
data DeviceComponentProductionSpecification = DeviceComponentProductionSpecification
        { deviceComponentProductionSpecification_id :: Maybe String_primitive
        , deviceComponentProductionSpecification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceComponentProductionSpecification_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceComponentProductionSpecification_specType :: Maybe CodeableConcept
          -- ^ The specification type, such as, serial number, part 
          --   number, hardware revision, software revision, etc.
        , deviceComponentProductionSpecification_componentId :: Maybe Identifier
          -- ^ The internal component unique identification. This is a 
          --   provision for manufacture specific standard components 
          --   using a private OID. 11073-10101 has a partition for 
          --   private OID semantic that the manufacturer can make use of.
        , deviceComponentProductionSpecification_productionSpec :: Maybe Xsd.XsdString
          -- ^ The printable string defining the component.
        }
        deriving (Eq,Show)
instance SchemaType DeviceComponentProductionSpecification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceComponentProductionSpecification a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "specType")
            `apply` optional (parseSchemaType "componentId")
            `apply` optional (parseSchemaType "productionSpec")
    schemaTypeToXML s x@DeviceComponentProductionSpecification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceComponentProductionSpecification_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceComponentProductionSpecification_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceComponentProductionSpecification_modifierExtension x
            , maybe [] (schemaTypeToXML "specType") $ deviceComponentProductionSpecification_specType x
            , maybe [] (schemaTypeToXML "componentId") $ deviceComponentProductionSpecification_componentId x
            , maybe [] (schemaTypeToXML "productionSpec") $ deviceComponentProductionSpecification_productionSpec x
            ]
instance Extension DeviceComponentProductionSpecification BackboneElement where
    supertype (DeviceComponentProductionSpecification a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DeviceComponentProductionSpecification Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceComponentProductionSpecification -> BackboneElement)
              
 
data MeasmntPrinciple_list
    = MeasmntPrinciple_list_Other
      -- ^ MSP Other
    | MeasmntPrinciple_list_Chemical
      -- ^ MSP Chemical
    | MeasmntPrinciple_list_Electrical
      -- ^ MSP Electrical
    | MeasmntPrinciple_list_Impedance
      -- ^ MSP Impedance
    | MeasmntPrinciple_list_Nuclear
      -- ^ MSP Nuclear
    | MeasmntPrinciple_list_Optical
      -- ^ MSP Optical
    | MeasmntPrinciple_list_Thermal
      -- ^ MSP Thermal
    | MeasmntPrinciple_list_Biological
      -- ^ MSP Biological
    | MeasmntPrinciple_list_Mechanical
      -- ^ MSP Mechanical
    | MeasmntPrinciple_list_Acoustical
      -- ^ MSP Acoustical
    | MeasmntPrinciple_list_Manual
      -- ^ MSP Manual
    deriving (Eq,Show,Enum)
instance SchemaType MeasmntPrinciple_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasmntPrinciple_list where
    acceptingParser =  do literal "other"; return MeasmntPrinciple_list_Other
                      `onFail` do literal "chemical"; return MeasmntPrinciple_list_Chemical
                      `onFail` do literal "electrical"; return MeasmntPrinciple_list_Electrical
                      `onFail` do literal "impedance"; return MeasmntPrinciple_list_Impedance
                      `onFail` do literal "nuclear"; return MeasmntPrinciple_list_Nuclear
                      `onFail` do literal "optical"; return MeasmntPrinciple_list_Optical
                      `onFail` do literal "thermal"; return MeasmntPrinciple_list_Thermal
                      `onFail` do literal "biological"; return MeasmntPrinciple_list_Biological
                      `onFail` do literal "mechanical"; return MeasmntPrinciple_list_Mechanical
                      `onFail` do literal "acoustical"; return MeasmntPrinciple_list_Acoustical
                      `onFail` do literal "manual"; return MeasmntPrinciple_list_Manual
                      
    simpleTypeText MeasmntPrinciple_list_Other = "other"
    simpleTypeText MeasmntPrinciple_list_Chemical = "chemical"
    simpleTypeText MeasmntPrinciple_list_Electrical = "electrical"
    simpleTypeText MeasmntPrinciple_list_Impedance = "impedance"
    simpleTypeText MeasmntPrinciple_list_Nuclear = "nuclear"
    simpleTypeText MeasmntPrinciple_list_Optical = "optical"
    simpleTypeText MeasmntPrinciple_list_Thermal = "thermal"
    simpleTypeText MeasmntPrinciple_list_Biological = "biological"
    simpleTypeText MeasmntPrinciple_list_Mechanical = "mechanical"
    simpleTypeText MeasmntPrinciple_list_Acoustical = "acoustical"
    simpleTypeText MeasmntPrinciple_list_Manual = "manual"
 
data MeasmntPrinciple = MeasmntPrinciple
        { measmntPrinciple_id :: Maybe String_primitive
        , measmntPrinciple_value :: Maybe MeasmntPrinciple_list
        , measmntPrinciple_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasmntPrinciple where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasmntPrinciple a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasmntPrinciple{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measmntPrinciple_id x
                       , maybe [] (toXMLAttribute "value") $ measmntPrinciple_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measmntPrinciple_extension x
            ]
instance Extension MeasmntPrinciple Element where
    supertype (MeasmntPrinciple a0 a1 e0) =
               Element a0 e0
 
-- | Describes a measurement, calculation or setting capability 
--   of a medical device.
elementDeviceMetric :: XMLParser DeviceMetric
elementDeviceMetric = parseSchemaType "DeviceMetric"
elementToXMLDeviceMetric :: DeviceMetric -> [Content ()]
elementToXMLDeviceMetric = schemaTypeToXML "DeviceMetric"
 
data DeviceMetric = DeviceMetric
        { deviceMetric_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceMetric_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceMetric_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceMetric_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceMetric_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceMetric_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceMetric_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceMetric_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceMetric_identifier :: Identifier
          -- ^ Describes the unique identification of this metric that has 
          --   been assigned by the device or gateway software. For 
          --   example: handle ID. It should be noted that in order to 
          --   make the identifier unique, the system element of the 
          --   identifier should be set to the unique identifier of the 
          --   device.
        , deviceMetric_type :: CodeableConcept
          -- ^ Describes the type of the metric. For example: Heart Rate, 
          --   PEEP Setting, etc.
        , deviceMetric_unit :: Maybe CodeableConcept
          -- ^ Describes the unit that an observed value determined for 
          --   this metric will have. For example: Percent, Seconds, etc.
        , deviceMetric_source :: Maybe Reference
          -- ^ Describes the link to the Device that this DeviceMetric 
          --   belongs to and that contains administrative device 
          --   information such as manufacturer, serial number, etc.
        , deviceMetric_parent :: Maybe Reference
          -- ^ Describes the link to the DeviceComponent that this 
          --   DeviceMetric belongs to and that provide information about 
          --   the location of this DeviceMetric in the containment 
          --   structure of the parent Device. An example would be a 
          --   DeviceComponent that represents a Channel. This reference 
          --   can be used by a client application to distinguish 
          --   DeviceMetrics that have the same type, but should be 
          --   interpreted based on their containment location.
        , deviceMetric_operationalStatus :: Maybe DeviceMetricOperationalStatus
          -- ^ Indicates current operational state of the device. For 
          --   example: On, Off, Standby, etc.
        , deviceMetric_color :: Maybe DeviceMetricColor
          -- ^ Describes the color representation for the metric. This is 
          --   often used to aid clinicians to track and identify 
          --   parameter types by color. In practice, consider a Patient 
          --   Monitor that has ECG/HR and Pleth for example; the 
          --   parameters are displayed in different characteristic 
          --   colors, such as HR-blue, BP-green, and PR and SpO2- 
          --   magenta.
        , deviceMetric_category :: DeviceMetricCategory
          -- ^ Indicates the category of the observation generation 
          --   process. A DeviceMetric can be for example a setting, 
          --   measurement, or calculation.
        , deviceMetric_measurementPeriod :: Maybe Timing
          -- ^ Describes the measurement repetition time. This is not 
          --   necessarily the same as the update period. The measurement 
          --   repetition time can range from milliseconds up to hours. An 
          --   example for a measurement repetition time in the range of 
          --   milliseconds is the sampling rate of an ECG. An example for 
          --   a measurement repetition time in the range of hours is a 
          --   NIBP that is triggered automatically every hour. The update 
          --   period may be different than the measurement repetition 
          --   time, if the device does not update the published observed 
          --   value with the same frequency as it was measured.
        , deviceMetric_calibration :: [DeviceMetricCalibration]
          -- ^ Describes the calibrations that have been performed or that 
          --   are required to be performed.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetric where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceMetric
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "parent")
            `apply` optional (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "color")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "measurementPeriod")
            `apply` many (parseSchemaType "calibration")
    schemaTypeToXML s x@DeviceMetric{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceMetric_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceMetric_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceMetric_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceMetric_language x
            , maybe [] (schemaTypeToXML "text") $ deviceMetric_text x
            , concatMap (schemaTypeToXML "contained") $ deviceMetric_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceMetric_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceMetric_modifierExtension x
            , schemaTypeToXML "identifier" $ deviceMetric_identifier x
            , schemaTypeToXML "type" $ deviceMetric_type x
            , maybe [] (schemaTypeToXML "unit") $ deviceMetric_unit x
            , maybe [] (schemaTypeToXML "source") $ deviceMetric_source x
            , maybe [] (schemaTypeToXML "parent") $ deviceMetric_parent x
            , maybe [] (schemaTypeToXML "operationalStatus") $ deviceMetric_operationalStatus x
            , maybe [] (schemaTypeToXML "color") $ deviceMetric_color x
            , schemaTypeToXML "category" $ deviceMetric_category x
            , maybe [] (schemaTypeToXML "measurementPeriod") $ deviceMetric_measurementPeriod x
            , concatMap (schemaTypeToXML "calibration") $ deviceMetric_calibration x
            ]
instance Extension DeviceMetric DomainResource where
    supertype (DeviceMetric e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceMetric Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceMetric -> DomainResource)
              
 
-- | Describes a measurement, calculation or setting capability 
--   of a medical device.
data DeviceMetricCalibration = DeviceMetricCalibration
        { deviceMetricCalibration_id :: Maybe String_primitive
        , deviceMetricCalibration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceMetricCalibration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceMetricCalibration_type :: Maybe DeviceMetricCalibrationType
          -- ^ Describes the type of the calibration method.
        , deviceMetricCalibration_state :: Maybe DeviceMetricCalibrationState
          -- ^ Describes the state of the calibration.
        , deviceMetricCalibration_time :: Maybe Instant
          -- ^ Describes the time last calibration has been performed.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCalibration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceMetricCalibration a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "state")
            `apply` optional (parseSchemaType "time")
    schemaTypeToXML s x@DeviceMetricCalibration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCalibration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCalibration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceMetricCalibration_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ deviceMetricCalibration_type x
            , maybe [] (schemaTypeToXML "state") $ deviceMetricCalibration_state x
            , maybe [] (schemaTypeToXML "time") $ deviceMetricCalibration_time x
            ]
instance Extension DeviceMetricCalibration BackboneElement where
    supertype (DeviceMetricCalibration a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension DeviceMetricCalibration Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceMetricCalibration -> BackboneElement)
              
 
data DeviceMetricCalibrationType_list
    = DeviceMetricCalibrationType_list_Unspecified
      -- ^ Unspecified
    | DeviceMetricCalibrationType_list_Offset
      -- ^ Offset
    | DeviceMetricCalibrationType_list_Gain
      -- ^ Gain
    | DeviceMetricCalibrationType_list_Two_point
      -- ^ Two Point
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCalibrationType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCalibrationType_list where
    acceptingParser =  do literal "unspecified"; return DeviceMetricCalibrationType_list_Unspecified
                      `onFail` do literal "offset"; return DeviceMetricCalibrationType_list_Offset
                      `onFail` do literal "gain"; return DeviceMetricCalibrationType_list_Gain
                      `onFail` do literal "two-point"; return DeviceMetricCalibrationType_list_Two_point
                      
    simpleTypeText DeviceMetricCalibrationType_list_Unspecified = "unspecified"
    simpleTypeText DeviceMetricCalibrationType_list_Offset = "offset"
    simpleTypeText DeviceMetricCalibrationType_list_Gain = "gain"
    simpleTypeText DeviceMetricCalibrationType_list_Two_point = "two-point"
 
data DeviceMetricCalibrationType = DeviceMetricCalibrationType
        { deviceMetricCalibrationType_id :: Maybe String_primitive
        , deviceMetricCalibrationType_value :: Maybe DeviceMetricCalibrationType_list
        , deviceMetricCalibrationType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCalibrationType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCalibrationType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCalibrationType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCalibrationType_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCalibrationType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCalibrationType_extension x
            ]
instance Extension DeviceMetricCalibrationType Element where
    supertype (DeviceMetricCalibrationType a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricColor_list
    = DeviceMetricColor_list_Black
      -- ^ Color Black
    | DeviceMetricColor_list_Red
      -- ^ Color Red
    | DeviceMetricColor_list_Green
      -- ^ Color Green
    | DeviceMetricColor_list_Yellow
      -- ^ Color Yellow
    | DeviceMetricColor_list_Blue
      -- ^ Color Blue
    | DeviceMetricColor_list_Magenta
      -- ^ Color Magenta
    | DeviceMetricColor_list_Cyan
      -- ^ Color Cyan
    | DeviceMetricColor_list_White
      -- ^ Color White
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricColor_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricColor_list where
    acceptingParser =  do literal "black"; return DeviceMetricColor_list_Black
                      `onFail` do literal "red"; return DeviceMetricColor_list_Red
                      `onFail` do literal "green"; return DeviceMetricColor_list_Green
                      `onFail` do literal "yellow"; return DeviceMetricColor_list_Yellow
                      `onFail` do literal "blue"; return DeviceMetricColor_list_Blue
                      `onFail` do literal "magenta"; return DeviceMetricColor_list_Magenta
                      `onFail` do literal "cyan"; return DeviceMetricColor_list_Cyan
                      `onFail` do literal "white"; return DeviceMetricColor_list_White
                      
    simpleTypeText DeviceMetricColor_list_Black = "black"
    simpleTypeText DeviceMetricColor_list_Red = "red"
    simpleTypeText DeviceMetricColor_list_Green = "green"
    simpleTypeText DeviceMetricColor_list_Yellow = "yellow"
    simpleTypeText DeviceMetricColor_list_Blue = "blue"
    simpleTypeText DeviceMetricColor_list_Magenta = "magenta"
    simpleTypeText DeviceMetricColor_list_Cyan = "cyan"
    simpleTypeText DeviceMetricColor_list_White = "white"
 
data DeviceMetricColor = DeviceMetricColor
        { deviceMetricColor_id :: Maybe String_primitive
        , deviceMetricColor_value :: Maybe DeviceMetricColor_list
        , deviceMetricColor_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricColor where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricColor a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricColor{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricColor_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricColor_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricColor_extension x
            ]
instance Extension DeviceMetricColor Element where
    supertype (DeviceMetricColor a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricCalibrationState_list
    = DeviceMetricCalibrationState_list_Not_calibrated
      -- ^ Not Calibrated
    | DeviceMetricCalibrationState_list_Calibration_required
      -- ^ Calibration Required
    | DeviceMetricCalibrationState_list_Calibrated
      -- ^ Calibrated
    | DeviceMetricCalibrationState_list_Unspecified
      -- ^ Unspecified
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCalibrationState_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCalibrationState_list where
    acceptingParser =  do literal "not-calibrated"; return DeviceMetricCalibrationState_list_Not_calibrated
                      `onFail` do literal "calibration-required"; return DeviceMetricCalibrationState_list_Calibration_required
                      `onFail` do literal "calibrated"; return DeviceMetricCalibrationState_list_Calibrated
                      `onFail` do literal "unspecified"; return DeviceMetricCalibrationState_list_Unspecified
                      
    simpleTypeText DeviceMetricCalibrationState_list_Not_calibrated = "not-calibrated"
    simpleTypeText DeviceMetricCalibrationState_list_Calibration_required = "calibration-required"
    simpleTypeText DeviceMetricCalibrationState_list_Calibrated = "calibrated"
    simpleTypeText DeviceMetricCalibrationState_list_Unspecified = "unspecified"
 
data DeviceMetricCalibrationState = DeviceMetricCalibrationState
        { deviceMetricCalibrationState_id :: Maybe String_primitive
        , deviceMetricCalibrationState_value :: Maybe DeviceMetricCalibrationState_list
        , deviceMetricCalibrationState_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCalibrationState where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCalibrationState a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCalibrationState{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCalibrationState_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCalibrationState_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCalibrationState_extension x
            ]
instance Extension DeviceMetricCalibrationState Element where
    supertype (DeviceMetricCalibrationState a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricOperationalStatus_list
    = DeviceMetricOperationalStatus_list_On
      -- ^ On
    | DeviceMetricOperationalStatus_list_Off
      -- ^ Off
    | DeviceMetricOperationalStatus_list_Standby
      -- ^ Standby
    | DeviceMetricOperationalStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricOperationalStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricOperationalStatus_list where
    acceptingParser =  do literal "on"; return DeviceMetricOperationalStatus_list_On
                      `onFail` do literal "off"; return DeviceMetricOperationalStatus_list_Off
                      `onFail` do literal "standby"; return DeviceMetricOperationalStatus_list_Standby
                      `onFail` do literal "entered-in-error"; return DeviceMetricOperationalStatus_list_Entered_in_error
                      
    simpleTypeText DeviceMetricOperationalStatus_list_On = "on"
    simpleTypeText DeviceMetricOperationalStatus_list_Off = "off"
    simpleTypeText DeviceMetricOperationalStatus_list_Standby = "standby"
    simpleTypeText DeviceMetricOperationalStatus_list_Entered_in_error = "entered-in-error"
 
data DeviceMetricOperationalStatus = DeviceMetricOperationalStatus
        { deviceMetricOperationalStatus_id :: Maybe String_primitive
        , deviceMetricOperationalStatus_value :: Maybe DeviceMetricOperationalStatus_list
        , deviceMetricOperationalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricOperationalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricOperationalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricOperationalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricOperationalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricOperationalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricOperationalStatus_extension x
            ]
instance Extension DeviceMetricOperationalStatus Element where
    supertype (DeviceMetricOperationalStatus a0 a1 e0) =
               Element a0 e0
 
data DeviceMetricCategory_list
    = DeviceMetricCategory_list_Measurement
      -- ^ Measurement
    | DeviceMetricCategory_list_Setting
      -- ^ Setting
    | DeviceMetricCategory_list_Calculation
      -- ^ Calculation
    | DeviceMetricCategory_list_Unspecified
      -- ^ Unspecified
    deriving (Eq,Show,Enum)
instance SchemaType DeviceMetricCategory_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceMetricCategory_list where
    acceptingParser =  do literal "measurement"; return DeviceMetricCategory_list_Measurement
                      `onFail` do literal "setting"; return DeviceMetricCategory_list_Setting
                      `onFail` do literal "calculation"; return DeviceMetricCategory_list_Calculation
                      `onFail` do literal "unspecified"; return DeviceMetricCategory_list_Unspecified
                      
    simpleTypeText DeviceMetricCategory_list_Measurement = "measurement"
    simpleTypeText DeviceMetricCategory_list_Setting = "setting"
    simpleTypeText DeviceMetricCategory_list_Calculation = "calculation"
    simpleTypeText DeviceMetricCategory_list_Unspecified = "unspecified"
 
data DeviceMetricCategory = DeviceMetricCategory
        { deviceMetricCategory_id :: Maybe String_primitive
        , deviceMetricCategory_value :: Maybe DeviceMetricCategory_list
        , deviceMetricCategory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceMetricCategory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceMetricCategory a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceMetricCategory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceMetricCategory_id x
                       , maybe [] (toXMLAttribute "value") $ deviceMetricCategory_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceMetricCategory_extension x
            ]
instance Extension DeviceMetricCategory Element where
    supertype (DeviceMetricCategory a0 a1 e0) =
               Element a0 e0
 
-- | Represents a request for a patient to employ a medical 
--   device. The device may be an implantable device, or an 
--   external assistive device, such as a walker.
elementDeviceRequest :: XMLParser DeviceRequest
elementDeviceRequest = parseSchemaType "DeviceRequest"
elementToXMLDeviceRequest :: DeviceRequest -> [Content ()]
elementToXMLDeviceRequest = schemaTypeToXML "DeviceRequest"
 
data DeviceRequest = DeviceRequest
        { deviceRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceRequest_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order by the orderer or by the 
          --   receiver.
        , deviceRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request. For 
          --   example: The proposed act must be performed if the 
          --   indicated conditions occur, e.g.., shortness of breath, 
          --   SpO2 less than x%.
        , deviceRequest_basedOn :: [Reference]
          -- ^ Plan/proposal/order fulfilled by this request.
        , deviceRequest_priorRequest :: [Reference]
          -- ^ The request takes the place of the referenced completed or 
          --   terminated request(s).
        , deviceRequest_groupIdentifier :: Maybe Identifier
          -- ^ Composite request this is part of.
        , deviceRequest_status :: Maybe RequestStatus
          -- ^ The status of the request.
        , deviceRequest_intent :: CodeableConcept
          -- ^ Whether the request is a proposal, plan, an original order 
          --   or a reflex order.
        , deviceRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the {{title}} should be addressed 
          --   with respect to other requests.
        , deviceRequest_choice16 :: OneOf2 Reference CodeableConcept
          -- ^ The details of the device to be used.
          --   
          --   Choice between:
          --   
          --   (1) codeReference
          --   
          --   (2) codeCodeableConcept
        , deviceRequest_subject :: Reference
          -- ^ The patient who will use the device.
        , deviceRequest_context :: Maybe Reference
          -- ^ An encounter that provides additional context in which this 
          --   request is made.
        , deviceRequest_choice19 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The timing schedule for the use of the device. The Schedule 
          --   data type allows many different expressions, for example. 
          --   &quot;Every 8 hours&quot;; &quot;Three times a day&quot;; 
          --   &quot;1/2 an hour before breakfast for 10 days from 23-Dec 
          --   2011:&quot;; &quot;15 Oct 2013, 17 Oct 2013 and 1 Nov 
          --   2013&quot;.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , deviceRequest_authoredOn :: Maybe DateTime
          -- ^ When the request transitioned to being actionable.
        , deviceRequest_requester :: Maybe DeviceRequestRequester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , deviceRequest_performerType :: Maybe CodeableConcept
          -- ^ Desired type of performer for doing the diagnostic testing.
        , deviceRequest_performer :: Maybe Reference
          -- ^ The desired perfomer for doing the diagnostic testing.
        , deviceRequest_reasonCode :: [CodeableConcept]
          -- ^ Reason or justification for the use of this device.
        , deviceRequest_reasonReference :: [Reference]
          -- ^ Reason or justification for the use of this device.
        , deviceRequest_supportingInfo :: [Reference]
          -- ^ Additional clinical information about the patient that may 
          --   influence the request fulfilment. For example, this may 
          --   includes body where on the subject's the device will be 
          --   used ( i.e. the target site).
        , deviceRequest_note :: [Annotation]
          -- ^ Details about this request that were not represented at all 
          --   or sufficiently in one of the attributes provided in a 
          --   class. These may include for example a comment, an 
          --   instruction, or a note associated with the statement.
        , deviceRequest_relevantHistory :: [Reference]
          -- ^ Key events in the history of the request.
        }
        deriving (Eq,Show)
instance SchemaType DeviceRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "priorRequest")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` oneOf' [ ("Reference", fmap OneOf2 (parseSchemaType "codeReference"))
                           , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "codeCodeableConcept"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "performer")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@DeviceRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceRequest_language x
            , maybe [] (schemaTypeToXML "text") $ deviceRequest_text x
            , concatMap (schemaTypeToXML "contained") $ deviceRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ deviceRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ deviceRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ deviceRequest_basedOn x
            , concatMap (schemaTypeToXML "priorRequest") $ deviceRequest_priorRequest x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ deviceRequest_groupIdentifier x
            , maybe [] (schemaTypeToXML "status") $ deviceRequest_status x
            , schemaTypeToXML "intent" $ deviceRequest_intent x
            , maybe [] (schemaTypeToXML "priority") $ deviceRequest_priority x
            , foldOneOf2  (schemaTypeToXML "codeReference")
                          (schemaTypeToXML "codeCodeableConcept")
                          $ deviceRequest_choice16 x
            , schemaTypeToXML "subject" $ deviceRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ deviceRequest_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ deviceRequest_choice19 x
            , maybe [] (schemaTypeToXML "authoredOn") $ deviceRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ deviceRequest_requester x
            , maybe [] (schemaTypeToXML "performerType") $ deviceRequest_performerType x
            , maybe [] (schemaTypeToXML "performer") $ deviceRequest_performer x
            , concatMap (schemaTypeToXML "reasonCode") $ deviceRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ deviceRequest_reasonReference x
            , concatMap (schemaTypeToXML "supportingInfo") $ deviceRequest_supportingInfo x
            , concatMap (schemaTypeToXML "note") $ deviceRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ deviceRequest_relevantHistory x
            ]
instance Extension DeviceRequest DomainResource where
    supertype (DeviceRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceRequest -> DomainResource)
              
 
-- | Represents a request for a patient to employ a medical 
--   device. The device may be an implantable device, or an 
--   external assistive device, such as a walker.
data DeviceRequestRequester = DeviceRequestRequester
        { deviceRequestRequester_id :: Maybe String_primitive
        , deviceRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceRequestRequester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , deviceRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType DeviceRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DeviceRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@DeviceRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ deviceRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ deviceRequestRequester_onBehalfOf x
            ]
instance Extension DeviceRequestRequester BackboneElement where
    supertype (DeviceRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DeviceRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DeviceRequestRequester -> BackboneElement)
              
 
-- | A record of a device being used by a patient where the 
--   record is the result of a report from the patient or 
--   another clinician.
elementDeviceUseStatement :: XMLParser DeviceUseStatement
elementDeviceUseStatement = parseSchemaType "DeviceUseStatement"
elementToXMLDeviceUseStatement :: DeviceUseStatement -> [Content ()]
elementToXMLDeviceUseStatement = schemaTypeToXML "DeviceUseStatement"
 
data DeviceUseStatement = DeviceUseStatement
        { deviceUseStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , deviceUseStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , deviceUseStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , deviceUseStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , deviceUseStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , deviceUseStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , deviceUseStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , deviceUseStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , deviceUseStatement_identifier :: [Identifier]
          -- ^ An external identifier for this statement such as an IRI.
        , deviceUseStatement_status :: DeviceUseStatementStatus
          -- ^ A code representing the patient or other source's judgment 
          --   about the state of the device used that this statement is 
          --   about. Generally this will be active or completed.
        , deviceUseStatement_subject :: Reference
          -- ^ The patient who used the device.
        , deviceUseStatement_whenUsed :: Maybe Period
          -- ^ The time period over which the device was used.
        , deviceUseStatement_choice12 :: (Maybe (OneOf3 Timing Period DateTime))
          -- ^ How often the device was used.
          --   
          --   Choice between:
          --   
          --   (1) timingTiming
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDateTime
        , deviceUseStatement_recordedOn :: Maybe DateTime
          -- ^ The time at which the statement was made/recorded.
        , deviceUseStatement_source :: Maybe Reference
          -- ^ Who reported the device was being used by the patient.
        , deviceUseStatement_device :: Reference
          -- ^ The details of the device used.
        , deviceUseStatement_indication :: [CodeableConcept]
          -- ^ Reason or justification for the use of the device.
        , deviceUseStatement_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the device 
          --   was used ( i.e. the target site).
        , deviceUseStatement_note :: [Annotation]
          -- ^ Details about the device statement that were not 
          --   represented at all or sufficiently in one of the attributes 
          --   provided in a class. These may include for example a 
          --   comment, an instruction, or a note associated with the 
          --   statement.
        }
        deriving (Eq,Show)
instance SchemaType DeviceUseStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DeviceUseStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "whenUsed")
            `apply` optional (oneOf' [ ("Timing", fmap OneOf3 (parseSchemaType "timingTiming"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "timingPeriod"))
                                     , ("DateTime", fmap ThreeOf3 (parseSchemaType "timingDateTime"))
                                     ])
            `apply` optional (parseSchemaType "recordedOn")
            `apply` optional (parseSchemaType "source")
            `apply` parseSchemaType "device"
            `apply` many (parseSchemaType "indication")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@DeviceUseStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ deviceUseStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ deviceUseStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ deviceUseStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ deviceUseStatement_language x
            , maybe [] (schemaTypeToXML "text") $ deviceUseStatement_text x
            , concatMap (schemaTypeToXML "contained") $ deviceUseStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ deviceUseStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ deviceUseStatement_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ deviceUseStatement_identifier x
            , schemaTypeToXML "status" $ deviceUseStatement_status x
            , schemaTypeToXML "subject" $ deviceUseStatement_subject x
            , maybe [] (schemaTypeToXML "whenUsed") $ deviceUseStatement_whenUsed x
            , maybe [] (foldOneOf3  (schemaTypeToXML "timingTiming")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDateTime")
                                   ) $ deviceUseStatement_choice12 x
            , maybe [] (schemaTypeToXML "recordedOn") $ deviceUseStatement_recordedOn x
            , maybe [] (schemaTypeToXML "source") $ deviceUseStatement_source x
            , schemaTypeToXML "device" $ deviceUseStatement_device x
            , concatMap (schemaTypeToXML "indication") $ deviceUseStatement_indication x
            , maybe [] (schemaTypeToXML "bodySite") $ deviceUseStatement_bodySite x
            , concatMap (schemaTypeToXML "note") $ deviceUseStatement_note x
            ]
instance Extension DeviceUseStatement DomainResource where
    supertype (DeviceUseStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DeviceUseStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DeviceUseStatement -> DomainResource)
              
 
data DeviceUseStatementStatus_list
    = DeviceUseStatementStatus_list_Active
      -- ^ Active
    | DeviceUseStatementStatus_list_Completed
      -- ^ Completed
    | DeviceUseStatementStatus_list_Entered_in_error
      -- ^ Entered in Error
    | DeviceUseStatementStatus_list_Intended
      -- ^ Intended
    | DeviceUseStatementStatus_list_Stopped
      -- ^ Stopped
    | DeviceUseStatementStatus_list_On_hold
      -- ^ On Hold
    deriving (Eq,Show,Enum)
instance SchemaType DeviceUseStatementStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DeviceUseStatementStatus_list where
    acceptingParser =  do literal "active"; return DeviceUseStatementStatus_list_Active
                      `onFail` do literal "completed"; return DeviceUseStatementStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return DeviceUseStatementStatus_list_Entered_in_error
                      `onFail` do literal "intended"; return DeviceUseStatementStatus_list_Intended
                      `onFail` do literal "stopped"; return DeviceUseStatementStatus_list_Stopped
                      `onFail` do literal "on-hold"; return DeviceUseStatementStatus_list_On_hold
                      
    simpleTypeText DeviceUseStatementStatus_list_Active = "active"
    simpleTypeText DeviceUseStatementStatus_list_Completed = "completed"
    simpleTypeText DeviceUseStatementStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText DeviceUseStatementStatus_list_Intended = "intended"
    simpleTypeText DeviceUseStatementStatus_list_Stopped = "stopped"
    simpleTypeText DeviceUseStatementStatus_list_On_hold = "on-hold"
 
data DeviceUseStatementStatus = DeviceUseStatementStatus
        { deviceUseStatementStatus_id :: Maybe String_primitive
        , deviceUseStatementStatus_value :: Maybe DeviceUseStatementStatus_list
        , deviceUseStatementStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DeviceUseStatementStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DeviceUseStatementStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DeviceUseStatementStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ deviceUseStatementStatus_id x
                       , maybe [] (toXMLAttribute "value") $ deviceUseStatementStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ deviceUseStatementStatus_extension x
            ]
instance Extension DeviceUseStatementStatus Element where
    supertype (DeviceUseStatementStatus a0 a1 e0) =
               Element a0 e0
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
elementDiagnosticReport :: XMLParser DiagnosticReport
elementDiagnosticReport = parseSchemaType "DiagnosticReport"
elementToXMLDiagnosticReport :: DiagnosticReport -> [Content ()]
elementToXMLDiagnosticReport = schemaTypeToXML "DiagnosticReport"
 
data DiagnosticReport = DiagnosticReport
        { diagnosticReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , diagnosticReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , diagnosticReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , diagnosticReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , diagnosticReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , diagnosticReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , diagnosticReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReport_identifier :: [Identifier]
          -- ^ Identifiers assigned to this report by the performer or 
          --   other systems.
        , diagnosticReport_basedOn :: [Reference]
          -- ^ Details concerning a test or procedure requested.
        , diagnosticReport_status :: DiagnosticReportStatus
          -- ^ The status of the diagnostic report as a whole.
        , diagnosticReport_category :: Maybe CodeableConcept
          -- ^ A code that classifies the clinical discipline, department 
          --   or diagnostic service that created the report (e.g. 
          --   cardiology, biochemistry, hematology, MRI). This is used 
          --   for searching, sorting and display purposes.
        , diagnosticReport_code :: CodeableConcept
          -- ^ A code or name that describes this diagnostic report.
        , diagnosticReport_subject :: Maybe Reference
          -- ^ The subject of the report. Usually, but not always, this is 
          --   a patient. However diagnostic services also perform 
          --   analyses on specimens collected from a variety of other 
          --   sources.
        , diagnosticReport_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) which this DiagnosticReport per is 
          --   about.
        , diagnosticReport_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time or time-period the observed values are related to. 
          --   When the subject of the report is a patient, this is 
          --   usually either the time of the procedure or of specimen 
          --   collection(s), but very often the source of the date/time 
          --   is not known, only the date/time itself.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , diagnosticReport_issued :: Maybe Instant
          -- ^ The date and time that this version of the report was 
          --   released from the source diagnostic service.
        , diagnosticReport_performer :: [DiagnosticReportPerformer]
          -- ^ Indicates who or what participated in producing the report.
        , diagnosticReport_specimen :: [Reference]
          -- ^ Details about the specimens on which this diagnostic report 
          --   is based.
        , diagnosticReport_result :: [Reference]
          -- ^ Observations that are part of this diagnostic report. 
          --   Observations can be simple name/value pairs (e.g. 
          --   &quot;atomic&quot; results), or they can be grouping 
          --   observations that include references to other members of 
          --   the group (e.g. &quot;panels&quot;).
        , diagnosticReport_imagingStudy :: [Reference]
          -- ^ One or more links to full details of any imaging performed 
          --   during the diagnostic investigation. Typically, this is 
          --   imaging performed by DICOM enabled modalities, but this is 
          --   not required. A fully enabled PACS viewer can use this 
          --   information to provide views of the source images.
        , diagnosticReport_image :: [DiagnosticReportImage]
          -- ^ A list of key images associated with this report. The 
          --   images are generally created during the diagnostic process, 
          --   and may be directly of the patient, or of treated specimens 
          --   (i.e. slides of interest).
        , diagnosticReport_conclusion :: Maybe Xsd.XsdString
          -- ^ Concise and clinically contextualized impression / summary 
          --   of the diagnostic report.
        , diagnosticReport_codedDiagnosis :: [CodeableConcept]
          -- ^ Codes for the conclusion.
        , diagnosticReport_presentedForm :: [Attachment]
          -- ^ Rich text representation of the entire result as issued by 
          --   the diagnostic service. Multiple formats are allowed but 
          --   they SHALL be semantically equivalent.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DiagnosticReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "specimen")
            `apply` many (parseSchemaType "result")
            `apply` many (parseSchemaType "imagingStudy")
            `apply` many (parseSchemaType "image")
            `apply` optional (parseSchemaType "conclusion")
            `apply` many (parseSchemaType "codedDiagnosis")
            `apply` many (parseSchemaType "presentedForm")
    schemaTypeToXML s x@DiagnosticReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ diagnosticReport_id x
            , maybe [] (schemaTypeToXML "meta") $ diagnosticReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ diagnosticReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ diagnosticReport_language x
            , maybe [] (schemaTypeToXML "text") $ diagnosticReport_text x
            , concatMap (schemaTypeToXML "contained") $ diagnosticReport_contained x
            , concatMap (schemaTypeToXML "extension") $ diagnosticReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReport_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ diagnosticReport_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ diagnosticReport_basedOn x
            , schemaTypeToXML "status" $ diagnosticReport_status x
            , maybe [] (schemaTypeToXML "category") $ diagnosticReport_category x
            , schemaTypeToXML "code" $ diagnosticReport_code x
            , maybe [] (schemaTypeToXML "subject") $ diagnosticReport_subject x
            , maybe [] (schemaTypeToXML "context") $ diagnosticReport_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ diagnosticReport_choice15 x
            , maybe [] (schemaTypeToXML "issued") $ diagnosticReport_issued x
            , concatMap (schemaTypeToXML "performer") $ diagnosticReport_performer x
            , concatMap (schemaTypeToXML "specimen") $ diagnosticReport_specimen x
            , concatMap (schemaTypeToXML "result") $ diagnosticReport_result x
            , concatMap (schemaTypeToXML "imagingStudy") $ diagnosticReport_imagingStudy x
            , concatMap (schemaTypeToXML "image") $ diagnosticReport_image x
            , maybe [] (schemaTypeToXML "conclusion") $ diagnosticReport_conclusion x
            , concatMap (schemaTypeToXML "codedDiagnosis") $ diagnosticReport_codedDiagnosis x
            , concatMap (schemaTypeToXML "presentedForm") $ diagnosticReport_presentedForm x
            ]
instance Extension DiagnosticReport DomainResource where
    supertype (DiagnosticReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DiagnosticReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DiagnosticReport -> DomainResource)
              
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
data DiagnosticReportPerformer = DiagnosticReportPerformer
        { diagnosticReportPerformer_id :: Maybe String_primitive
        , diagnosticReportPerformer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReportPerformer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReportPerformer_role :: Maybe CodeableConcept
          -- ^ Describes the type of participation (e.g. a responsible 
          --   party, author, or verifier).
        , diagnosticReportPerformer_actor :: Reference
          -- ^ The reference to the practitioner or organization involved 
          --   in producing the report. For example, the diagnostic 
          --   service that is responsible for issuing the report.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReportPerformer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DiagnosticReportPerformer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@DiagnosticReportPerformer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReportPerformer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReportPerformer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReportPerformer_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ diagnosticReportPerformer_role x
            , schemaTypeToXML "actor" $ diagnosticReportPerformer_actor x
            ]
instance Extension DiagnosticReportPerformer BackboneElement where
    supertype (DiagnosticReportPerformer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DiagnosticReportPerformer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DiagnosticReportPerformer -> BackboneElement)
              
 
-- | The findings and interpretation of diagnostic tests 
--   performed on patients, groups of patients, devices, and 
--   locations, and/or specimens derived from these. The report 
--   includes clinical context such as requesting and provider 
--   information, and some mix of atomic results, images, 
--   textual and coded interpretations, and formatted 
--   representation of diagnostic reports.
data DiagnosticReportImage = DiagnosticReportImage
        { diagnosticReportImage_id :: Maybe String_primitive
        , diagnosticReportImage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , diagnosticReportImage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , diagnosticReportImage_comment :: Maybe Xsd.XsdString
          -- ^ A comment about the image. Typically, this is used to 
          --   provide an explanation for why the image is included, or to 
          --   draw the viewer's attention to important features.
        , diagnosticReportImage_link :: Reference
          -- ^ Reference to the image source.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReportImage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DiagnosticReportImage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "comment")
            `apply` parseSchemaType "link"
    schemaTypeToXML s x@DiagnosticReportImage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReportImage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReportImage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ diagnosticReportImage_modifierExtension x
            , maybe [] (schemaTypeToXML "comment") $ diagnosticReportImage_comment x
            , schemaTypeToXML "link" $ diagnosticReportImage_link x
            ]
instance Extension DiagnosticReportImage BackboneElement where
    supertype (DiagnosticReportImage a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DiagnosticReportImage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DiagnosticReportImage -> BackboneElement)
              
 
data DiagnosticReportStatus_list
    = DiagnosticReportStatus_list_Registered
      -- ^ Registered
    | DiagnosticReportStatus_list_Partial
      -- ^ Partial
    | DiagnosticReportStatus_list_Preliminary
      -- ^ Preliminary
    | DiagnosticReportStatus_list_Final
      -- ^ Final
    | DiagnosticReportStatus_list_Amended
      -- ^ Amended
    | DiagnosticReportStatus_list_Corrected
      -- ^ Corrected
    | DiagnosticReportStatus_list_Appended
      -- ^ Appended
    | DiagnosticReportStatus_list_Cancelled
      -- ^ Cancelled
    | DiagnosticReportStatus_list_Entered_in_error
      -- ^ Entered in Error
    | DiagnosticReportStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType DiagnosticReportStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DiagnosticReportStatus_list where
    acceptingParser =  do literal "registered"; return DiagnosticReportStatus_list_Registered
                      `onFail` do literal "partial"; return DiagnosticReportStatus_list_Partial
                      `onFail` do literal "preliminary"; return DiagnosticReportStatus_list_Preliminary
                      `onFail` do literal "final"; return DiagnosticReportStatus_list_Final
                      `onFail` do literal "amended"; return DiagnosticReportStatus_list_Amended
                      `onFail` do literal "corrected"; return DiagnosticReportStatus_list_Corrected
                      `onFail` do literal "appended"; return DiagnosticReportStatus_list_Appended
                      `onFail` do literal "cancelled"; return DiagnosticReportStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return DiagnosticReportStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return DiagnosticReportStatus_list_Unknown
                      
    simpleTypeText DiagnosticReportStatus_list_Registered = "registered"
    simpleTypeText DiagnosticReportStatus_list_Partial = "partial"
    simpleTypeText DiagnosticReportStatus_list_Preliminary = "preliminary"
    simpleTypeText DiagnosticReportStatus_list_Final = "final"
    simpleTypeText DiagnosticReportStatus_list_Amended = "amended"
    simpleTypeText DiagnosticReportStatus_list_Corrected = "corrected"
    simpleTypeText DiagnosticReportStatus_list_Appended = "appended"
    simpleTypeText DiagnosticReportStatus_list_Cancelled = "cancelled"
    simpleTypeText DiagnosticReportStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText DiagnosticReportStatus_list_Unknown = "unknown"
 
data DiagnosticReportStatus = DiagnosticReportStatus
        { diagnosticReportStatus_id :: Maybe String_primitive
        , diagnosticReportStatus_value :: Maybe DiagnosticReportStatus_list
        , diagnosticReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DiagnosticReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DiagnosticReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DiagnosticReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ diagnosticReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ diagnosticReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ diagnosticReportStatus_extension x
            ]
instance Extension DiagnosticReportStatus Element where
    supertype (DiagnosticReportStatus a0 a1 e0) =
               Element a0 e0
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
elementDocumentManifest :: XMLParser DocumentManifest
elementDocumentManifest = parseSchemaType "DocumentManifest"
elementToXMLDocumentManifest :: DocumentManifest -> [Content ()]
elementToXMLDocumentManifest = schemaTypeToXML "DocumentManifest"
 
data DocumentManifest = DocumentManifest
        { documentManifest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , documentManifest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , documentManifest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , documentManifest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , documentManifest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , documentManifest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , documentManifest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifest_masterIdentifier :: Maybe Identifier
          -- ^ A single identifier that uniquely identifies this manifest. 
          --   Principally used to refer to the manifest in non-FHIR 
          --   contexts.
        , documentManifest_identifier :: [Identifier]
          -- ^ Other identifiers associated with the document manifest, 
          --   including version independent identifiers.
        , documentManifest_status :: DocumentReferenceStatus
          -- ^ The status of this document manifest.
        , documentManifest_type :: Maybe CodeableConcept
          -- ^ Specifies the kind of this set of documents (e.g. Patient 
          --   Summary, Discharge Summary, Prescription, etc.). The type 
          --   of a set of documents may be the same as one of the 
          --   documents in it - especially if there is only one - but it 
          --   may be wider.
        , documentManifest_subject :: Maybe Reference
          -- ^ Who or what the set of documents is about. The documents 
          --   can be about a person, (patient or healthcare 
          --   practitioner), a device (i.e. machine) or even a group of 
          --   subjects (such as a document about a herd of farm animals, 
          --   or a set of patients that share a common exposure). If the 
          --   documents cross more than one subject, then more than one 
          --   subject is allowed here (unusual use case).
        , documentManifest_created :: Maybe DateTime
          -- ^ When the document manifest was created for submission to 
          --   the server (not necessarily the same thing as the actual 
          --   resource last modified time, since it may be modified, 
          --   replicated, etc.).
        , documentManifest_author :: [Reference]
          -- ^ Identifies who is responsible for creating the manifest, 
          --   and adding documents to it.
        , documentManifest_recipient :: [Reference]
          -- ^ A patient, practitioner, or organization for which this set 
          --   of documents is intended.
        , documentManifest_source :: Maybe Uri
          -- ^ Identifies the source system, application, or software that 
          --   produced the document manifest.
        , documentManifest_description :: Maybe Xsd.XsdString
          -- ^ Human-readable description of the source document. This is 
          --   sometimes known as the &quot;title&quot;.
        , documentManifest_content :: [DocumentManifestContent]
          -- ^ The list of Documents included in the manifest.
        , documentManifest_related :: [DocumentManifestRelated]
          -- ^ Related identifiers or resources associated with the 
          --   DocumentManifest.
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DocumentManifest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "masterIdentifier")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` many (parseSchemaType "author")
            `apply` many (parseSchemaType "recipient")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "content")
            `apply` many (parseSchemaType "related")
    schemaTypeToXML s x@DocumentManifest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ documentManifest_id x
            , maybe [] (schemaTypeToXML "meta") $ documentManifest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ documentManifest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ documentManifest_language x
            , maybe [] (schemaTypeToXML "text") $ documentManifest_text x
            , concatMap (schemaTypeToXML "contained") $ documentManifest_contained x
            , concatMap (schemaTypeToXML "extension") $ documentManifest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifest_modifierExtension x
            , maybe [] (schemaTypeToXML "masterIdentifier") $ documentManifest_masterIdentifier x
            , concatMap (schemaTypeToXML "identifier") $ documentManifest_identifier x
            , schemaTypeToXML "status" $ documentManifest_status x
            , maybe [] (schemaTypeToXML "type") $ documentManifest_type x
            , maybe [] (schemaTypeToXML "subject") $ documentManifest_subject x
            , maybe [] (schemaTypeToXML "created") $ documentManifest_created x
            , concatMap (schemaTypeToXML "author") $ documentManifest_author x
            , concatMap (schemaTypeToXML "recipient") $ documentManifest_recipient x
            , maybe [] (schemaTypeToXML "source") $ documentManifest_source x
            , maybe [] (schemaTypeToXML "description") $ documentManifest_description x
            , concatMap (schemaTypeToXML "content") $ documentManifest_content x
            , concatMap (schemaTypeToXML "related") $ documentManifest_related x
            ]
instance Extension DocumentManifest DomainResource where
    supertype (DocumentManifest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DocumentManifest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DocumentManifest -> DomainResource)
              
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
data DocumentManifestContent = DocumentManifestContent
        { documentManifestContent_id :: Maybe String_primitive
        , documentManifestContent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifestContent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifestContent_choice2 :: OneOf2 Attachment Reference
          -- ^ The list of references to document content, or Attachment 
          --   that consist of the parts of this document manifest. 
          --   Usually, these would be document references, but direct 
          --   references to Media or Attachments are also allowed.
          --   
          --   Choice between:
          --   
          --   (1) pAttachment
          --   
          --   (2) pReference
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifestContent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentManifestContent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Attachment", fmap OneOf2 (parseSchemaType "pAttachment"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "pReference"))
                           ]
    schemaTypeToXML s x@DocumentManifestContent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentManifestContent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentManifestContent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifestContent_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "pAttachment")
                          (schemaTypeToXML "pReference")
                          $ documentManifestContent_choice2 x
            ]
instance Extension DocumentManifestContent BackboneElement where
    supertype (DocumentManifestContent a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension DocumentManifestContent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentManifestContent -> BackboneElement)
              
 
-- | A collection of documents compiled for a purpose together 
--   with metadata that applies to the collection.
data DocumentManifestRelated = DocumentManifestRelated
        { documentManifestRelated_id :: Maybe String_primitive
        , documentManifestRelated_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentManifestRelated_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentManifestRelated_identifier :: Maybe Identifier
          -- ^ Related identifier to this DocumentManifest. For example, 
          --   Order numbers, accession numbers, XDW workflow numbers.
        , documentManifestRelated_ref :: Maybe Reference
          -- ^ Related Resource to this DocumentManifest. For example, 
          --   Order, ProcedureRequest, Procedure, EligibilityRequest, 
          --   etc.
        }
        deriving (Eq,Show)
instance SchemaType DocumentManifestRelated where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentManifestRelated a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "ref")
    schemaTypeToXML s x@DocumentManifestRelated{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentManifestRelated_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentManifestRelated_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentManifestRelated_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ documentManifestRelated_identifier x
            , maybe [] (schemaTypeToXML "ref") $ documentManifestRelated_ref x
            ]
instance Extension DocumentManifestRelated BackboneElement where
    supertype (DocumentManifestRelated a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentManifestRelated Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentManifestRelated -> BackboneElement)
              
 
-- | A reference to a document.
elementDocumentReference :: XMLParser DocumentReference
elementDocumentReference = parseSchemaType "DocumentReference"
elementToXMLDocumentReference :: DocumentReference -> [Content ()]
elementToXMLDocumentReference = schemaTypeToXML "DocumentReference"
 
data DocumentReference = DocumentReference
        { documentReference_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , documentReference_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , documentReference_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , documentReference_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , documentReference_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , documentReference_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , documentReference_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReference_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReference_masterIdentifier :: Maybe Identifier
          -- ^ Document identifier as assigned by the source of the 
          --   document. This identifier is specific to this version of 
          --   the document. This unique identifier may be used elsewhere 
          --   to identify this version of the document.
        , documentReference_identifier :: [Identifier]
          -- ^ Other identifiers associated with the document, including 
          --   version independent identifiers.
        , documentReference_status :: DocumentReferenceStatus
          -- ^ The status of this document reference.
        , documentReference_docStatus :: Maybe CompositionStatus
          -- ^ The status of the underlying document.
        , documentReference_type :: CodeableConcept
          -- ^ Specifies the particular kind of document referenced (e.g. 
          --   History and Physical, Discharge Summary, Progress Note). 
          --   This usually equates to the purpose of making the document 
          --   referenced.
        , documentReference_class :: Maybe CodeableConcept
          -- ^ A categorization for the type of document referenced - 
          --   helps for indexing and searching. This may be implied by or 
          --   derived from the code specified in the 
          --   DocumentReference.type.
        , documentReference_subject :: Maybe Reference
          -- ^ Who or what the document is about. The document can be 
          --   about a person, (patient or healthcare practitioner), a 
          --   device (e.g. a machine) or even a group of subjects (such 
          --   as a document about a herd of farm animals, or a set of 
          --   patients that share a common exposure).
        , documentReference_created :: Maybe DateTime
          -- ^ When the document was created.
        , documentReference_indexed :: Instant
          -- ^ When the document reference was created.
        , documentReference_author :: [Reference]
          -- ^ Identifies who is responsible for adding the information to 
          --   the document.
        , documentReference_authenticator :: Maybe Reference
          -- ^ Which person or organization authenticates that this 
          --   document is valid.
        , documentReference_custodian :: Maybe Reference
          -- ^ Identifies the organization or group who is responsible for 
          --   ongoing maintenance of and access to the document.
        , documentReference_relatesTo :: [DocumentReferenceRelatesTo]
          -- ^ Relationships that this document has with other document 
          --   references that already exist.
        , documentReference_description :: Maybe Xsd.XsdString
          -- ^ Human-readable description of the source document. This is 
          --   sometimes known as the &quot;title&quot;.
        , documentReference_securityLabel :: [CodeableConcept]
          -- ^ A set of Security-Tag codes specifying the level of 
          --   privacy/security of the Document. Note that 
          --   DocumentReference.meta.security contains the security 
          --   labels of the &quot;reference&quot; to the document, while 
          --   DocumentReference.securityLabel contains a snapshot of the 
          --   security labels on the document the reference refers to.
        , documentReference_content :: [DocumentReferenceContent]
          -- ^ The document and format referenced. There may be multiple 
          --   content element repetitions, each with a different format.
        , documentReference_context :: Maybe DocumentReferenceContext
          -- ^ The clinical context in which the document was prepared.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReference where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return DocumentReference
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "masterIdentifier")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "docStatus")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "class")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "created")
            `apply` parseSchemaType "indexed"
            `apply` many (parseSchemaType "author")
            `apply` optional (parseSchemaType "authenticator")
            `apply` optional (parseSchemaType "custodian")
            `apply` many (parseSchemaType "relatesTo")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "securityLabel")
            `apply` many1 (parseSchemaType "content")
            `apply` optional (parseSchemaType "context")
    schemaTypeToXML s x@DocumentReference{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ documentReference_id x
            , maybe [] (schemaTypeToXML "meta") $ documentReference_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ documentReference_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ documentReference_language x
            , maybe [] (schemaTypeToXML "text") $ documentReference_text x
            , concatMap (schemaTypeToXML "contained") $ documentReference_contained x
            , concatMap (schemaTypeToXML "extension") $ documentReference_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReference_modifierExtension x
            , maybe [] (schemaTypeToXML "masterIdentifier") $ documentReference_masterIdentifier x
            , concatMap (schemaTypeToXML "identifier") $ documentReference_identifier x
            , schemaTypeToXML "status" $ documentReference_status x
            , maybe [] (schemaTypeToXML "docStatus") $ documentReference_docStatus x
            , schemaTypeToXML "type" $ documentReference_type x
            , maybe [] (schemaTypeToXML "class") $ documentReference_class x
            , maybe [] (schemaTypeToXML "subject") $ documentReference_subject x
            , maybe [] (schemaTypeToXML "created") $ documentReference_created x
            , schemaTypeToXML "indexed" $ documentReference_indexed x
            , concatMap (schemaTypeToXML "author") $ documentReference_author x
            , maybe [] (schemaTypeToXML "authenticator") $ documentReference_authenticator x
            , maybe [] (schemaTypeToXML "custodian") $ documentReference_custodian x
            , concatMap (schemaTypeToXML "relatesTo") $ documentReference_relatesTo x
            , maybe [] (schemaTypeToXML "description") $ documentReference_description x
            , concatMap (schemaTypeToXML "securityLabel") $ documentReference_securityLabel x
            , concatMap (schemaTypeToXML "content") $ documentReference_content x
            , maybe [] (schemaTypeToXML "context") $ documentReference_context x
            ]
instance Extension DocumentReference DomainResource where
    supertype (DocumentReference e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension DocumentReference Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: DocumentReference -> DomainResource)
              
 
-- | A reference to a document.
data DocumentReferenceRelatesTo = DocumentReferenceRelatesTo
        { documentReferenceRelatesTo_id :: Maybe String_primitive
        , documentReferenceRelatesTo_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReferenceRelatesTo_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReferenceRelatesTo_code :: DocumentRelationshipType
          -- ^ The type of relationship that this document has with anther 
          --   document.
        , documentReferenceRelatesTo_target :: Reference
          -- ^ The target document of this relationship.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceRelatesTo where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReferenceRelatesTo a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "target"
    schemaTypeToXML s x@DocumentReferenceRelatesTo{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceRelatesTo_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceRelatesTo_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReferenceRelatesTo_modifierExtension x
            , schemaTypeToXML "code" $ documentReferenceRelatesTo_code x
            , schemaTypeToXML "target" $ documentReferenceRelatesTo_target x
            ]
instance Extension DocumentReferenceRelatesTo BackboneElement where
    supertype (DocumentReferenceRelatesTo a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReferenceRelatesTo Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReferenceRelatesTo -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReferenceContent = DocumentReferenceContent
        { documentReferenceContent_id :: Maybe String_primitive
        , documentReferenceContent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReferenceContent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReferenceContent_attachment :: Attachment
          -- ^ The document or URL of the document along with critical 
          --   metadata to prove content has integrity.
        , documentReferenceContent_format :: Maybe Coding
          -- ^ An identifier of the document encoding, structure, and 
          --   template that the document conforms to beyond the base 
          --   format indicated in the mimeType.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceContent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReferenceContent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "attachment"
            `apply` optional (parseSchemaType "format")
    schemaTypeToXML s x@DocumentReferenceContent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceContent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceContent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReferenceContent_modifierExtension x
            , schemaTypeToXML "attachment" $ documentReferenceContent_attachment x
            , maybe [] (schemaTypeToXML "format") $ documentReferenceContent_format x
            ]
instance Extension DocumentReferenceContent BackboneElement where
    supertype (DocumentReferenceContent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReferenceContent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReferenceContent -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReferenceContext = DocumentReferenceContext
        { documentReferenceContext_id :: Maybe String_primitive
        , documentReferenceContext_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReferenceContext_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReferenceContext_encounter :: Maybe Reference
          -- ^ Describes the clinical encounter or type of care that the 
          --   document content is associated with.
        , documentReferenceContext_event :: [CodeableConcept]
          -- ^ This list of codes represents the main clinical acts, such 
          --   as a colonoscopy or an appendectomy, being documented. In 
          --   some cases, the event is inherent in the typeCode, such as 
          --   a &quot;History and Physical Report&quot; in which the 
          --   procedure being documented is necessarily a &quot;History 
          --   and Physical&quot; act.
        , documentReferenceContext_period :: Maybe Period
          -- ^ The time period over which the service that is described by 
          --   the document was provided.
        , documentReferenceContext_facilityType :: Maybe CodeableConcept
          -- ^ The kind of facility where the patient was seen.
        , documentReferenceContext_practiceSetting :: Maybe CodeableConcept
          -- ^ This property may convey specifics about the practice 
          --   setting where the content was created, often reflecting the 
          --   clinical specialty.
        , documentReferenceContext_sourcePatientInfo :: Maybe Reference
          -- ^ The Patient Information as known when the document was 
          --   published. May be a reference to a version specific, or 
          --   contained.
        , documentReferenceContext_related :: [DocumentReferenceRelated]
          -- ^ Related identifiers or resources associated with the 
          --   DocumentReference.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceContext where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReferenceContext a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "encounter")
            `apply` many (parseSchemaType "event")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "facilityType")
            `apply` optional (parseSchemaType "practiceSetting")
            `apply` optional (parseSchemaType "sourcePatientInfo")
            `apply` many (parseSchemaType "related")
    schemaTypeToXML s x@DocumentReferenceContext{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceContext_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceContext_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReferenceContext_modifierExtension x
            , maybe [] (schemaTypeToXML "encounter") $ documentReferenceContext_encounter x
            , concatMap (schemaTypeToXML "event") $ documentReferenceContext_event x
            , maybe [] (schemaTypeToXML "period") $ documentReferenceContext_period x
            , maybe [] (schemaTypeToXML "facilityType") $ documentReferenceContext_facilityType x
            , maybe [] (schemaTypeToXML "practiceSetting") $ documentReferenceContext_practiceSetting x
            , maybe [] (schemaTypeToXML "sourcePatientInfo") $ documentReferenceContext_sourcePatientInfo x
            , concatMap (schemaTypeToXML "related") $ documentReferenceContext_related x
            ]
instance Extension DocumentReferenceContext BackboneElement where
    supertype (DocumentReferenceContext a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension DocumentReferenceContext Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReferenceContext -> BackboneElement)
              
 
-- | A reference to a document.
data DocumentReferenceRelated = DocumentReferenceRelated
        { documentReferenceRelated_id :: Maybe String_primitive
        , documentReferenceRelated_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , documentReferenceRelated_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , documentReferenceRelated_identifier :: Maybe Identifier
          -- ^ Related identifier to this DocumentReference. If both id 
          --   and ref are present they shall refer to the same thing.
        , documentReferenceRelated_ref :: Maybe Reference
          -- ^ Related Resource to this DocumentReference. If both id and 
          --   ref are present they shall refer to the same thing.
        }
        deriving (Eq,Show)
instance SchemaType DocumentReferenceRelated where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (DocumentReferenceRelated a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "ref")
    schemaTypeToXML s x@DocumentReferenceRelated{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ documentReferenceRelated_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ documentReferenceRelated_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ documentReferenceRelated_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ documentReferenceRelated_identifier x
            , maybe [] (schemaTypeToXML "ref") $ documentReferenceRelated_ref x
            ]
instance Extension DocumentReferenceRelated BackboneElement where
    supertype (DocumentReferenceRelated a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension DocumentReferenceRelated Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: DocumentReferenceRelated -> BackboneElement)
              
 
-- | The EligibilityRequest provides patient and insurance 
--   coverage information to an insurer for them to respond, in 
--   the form of an EligibilityResponse, with information 
--   regarding whether the stated coverage is valid and in-force 
--   and optionally to provide the insurance details of the 
--   policy.
elementEligibilityRequest :: XMLParser EligibilityRequest
elementEligibilityRequest = parseSchemaType "EligibilityRequest"
elementToXMLEligibilityRequest :: EligibilityRequest -> [Content ()]
elementToXMLEligibilityRequest = schemaTypeToXML "EligibilityRequest"
 
data EligibilityRequest = EligibilityRequest
        { eligibilityRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , eligibilityRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , eligibilityRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , eligibilityRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , eligibilityRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , eligibilityRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , eligibilityRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityRequest_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , eligibilityRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , eligibilityRequest_priority :: Maybe CodeableConcept
          -- ^ Immediate (STAT), best effort (NORMAL), deferred (DEFER).
        , eligibilityRequest_patient :: Maybe Reference
          -- ^ Patient Resource.
        , eligibilityRequest_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , eligibilityRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , eligibilityRequest_enterer :: Maybe Reference
          -- ^ Person who created the invoice/claim/pre-determination or 
          --   pre-authorization.
        , eligibilityRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , eligibilityRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , eligibilityRequest_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , eligibilityRequest_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , eligibilityRequest_coverage :: Maybe Reference
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , eligibilityRequest_businessArrangement :: Maybe Xsd.XsdString
          -- ^ The contract number of a business agreement which describes 
          --   the terms and conditions.
        , eligibilityRequest_benefitCategory :: Maybe CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , eligibilityRequest_benefitSubCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EligibilityRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "facility")
            `apply` optional (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "businessArrangement")
            `apply` optional (parseSchemaType "benefitCategory")
            `apply` optional (parseSchemaType "benefitSubCategory")
    schemaTypeToXML s x@EligibilityRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ eligibilityRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ eligibilityRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ eligibilityRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ eligibilityRequest_language x
            , maybe [] (schemaTypeToXML "text") $ eligibilityRequest_text x
            , concatMap (schemaTypeToXML "contained") $ eligibilityRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ eligibilityRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ eligibilityRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ eligibilityRequest_status x
            , maybe [] (schemaTypeToXML "priority") $ eligibilityRequest_priority x
            , maybe [] (schemaTypeToXML "patient") $ eligibilityRequest_patient x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ eligibilityRequest_choice12 x
            , maybe [] (schemaTypeToXML "created") $ eligibilityRequest_created x
            , maybe [] (schemaTypeToXML "enterer") $ eligibilityRequest_enterer x
            , maybe [] (schemaTypeToXML "provider") $ eligibilityRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ eligibilityRequest_organization x
            , maybe [] (schemaTypeToXML "insurer") $ eligibilityRequest_insurer x
            , maybe [] (schemaTypeToXML "facility") $ eligibilityRequest_facility x
            , maybe [] (schemaTypeToXML "coverage") $ eligibilityRequest_coverage x
            , maybe [] (schemaTypeToXML "businessArrangement") $ eligibilityRequest_businessArrangement x
            , maybe [] (schemaTypeToXML "benefitCategory") $ eligibilityRequest_benefitCategory x
            , maybe [] (schemaTypeToXML "benefitSubCategory") $ eligibilityRequest_benefitSubCategory x
            ]
instance Extension EligibilityRequest DomainResource where
    supertype (EligibilityRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EligibilityRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EligibilityRequest -> DomainResource)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
elementEligibilityResponse :: XMLParser EligibilityResponse
elementEligibilityResponse = parseSchemaType "EligibilityResponse"
elementToXMLEligibilityResponse :: EligibilityResponse -> [Content ()]
elementToXMLEligibilityResponse = schemaTypeToXML "EligibilityResponse"
 
data EligibilityResponse = EligibilityResponse
        { eligibilityResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , eligibilityResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , eligibilityResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , eligibilityResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , eligibilityResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , eligibilityResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , eligibilityResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , eligibilityResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , eligibilityResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , eligibilityResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , eligibilityResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , eligibilityResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , eligibilityResponse_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete.
        , eligibilityResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , eligibilityResponse_insurer :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , eligibilityResponse_inforce :: Maybe Boolean
          -- ^ Flag indicating if the coverage provided is inforce 
          --   currently if no service date(s) specified or for the whole 
          --   duration of the service dates.
        , eligibilityResponse_insurance :: [EligibilityResponseInsurance]
          -- ^ The insurer may provide both the details for the requested 
          --   coverage as well as details for additional coverages known 
          --   to the insurer.
        , eligibilityResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , eligibilityResponse_error :: [EligibilityResponseError]
          -- ^ Mutually exclusive with Services Provided (Item).
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EligibilityResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "inforce")
            `apply` many (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "error")
    schemaTypeToXML s x@EligibilityResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ eligibilityResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ eligibilityResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ eligibilityResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ eligibilityResponse_language x
            , maybe [] (schemaTypeToXML "text") $ eligibilityResponse_text x
            , concatMap (schemaTypeToXML "contained") $ eligibilityResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ eligibilityResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ eligibilityResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ eligibilityResponse_status x
            , maybe [] (schemaTypeToXML "created") $ eligibilityResponse_created x
            , maybe [] (schemaTypeToXML "requestProvider") $ eligibilityResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ eligibilityResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "request") $ eligibilityResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ eligibilityResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ eligibilityResponse_disposition x
            , maybe [] (schemaTypeToXML "insurer") $ eligibilityResponse_insurer x
            , maybe [] (schemaTypeToXML "inforce") $ eligibilityResponse_inforce x
            , concatMap (schemaTypeToXML "insurance") $ eligibilityResponse_insurance x
            , maybe [] (schemaTypeToXML "form") $ eligibilityResponse_form x
            , concatMap (schemaTypeToXML "error") $ eligibilityResponse_error x
            ]
instance Extension EligibilityResponse DomainResource where
    supertype (EligibilityResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EligibilityResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EligibilityResponse -> DomainResource)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponseInsurance = EligibilityResponseInsurance
        { eligibilityResponseInsurance_id :: Maybe String_primitive
        , eligibilityResponseInsurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponseInsurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponseInsurance_coverage :: Maybe Reference
          -- ^ A suite of updated or additional Coverages from the 
          --   Insurer.
        , eligibilityResponseInsurance_contract :: Maybe Reference
          -- ^ The contract resource which may provide more detailed 
          --   information.
        , eligibilityResponseInsurance_benefitBalance :: [EligibilityResponseBenefitBalance]
          -- ^ Benefits and optionally current balances by Category.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponseInsurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponseInsurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "coverage")
            `apply` optional (parseSchemaType "contract")
            `apply` many (parseSchemaType "benefitBalance")
    schemaTypeToXML s x@EligibilityResponseInsurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponseInsurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponseInsurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponseInsurance_modifierExtension x
            , maybe [] (schemaTypeToXML "coverage") $ eligibilityResponseInsurance_coverage x
            , maybe [] (schemaTypeToXML "contract") $ eligibilityResponseInsurance_contract x
            , concatMap (schemaTypeToXML "benefitBalance") $ eligibilityResponseInsurance_benefitBalance x
            ]
instance Extension EligibilityResponseInsurance BackboneElement where
    supertype (EligibilityResponseInsurance a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponseInsurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponseInsurance -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponseBenefitBalance = EligibilityResponseBenefitBalance
        { eligibilityResponseBenefitBalance_id :: Maybe String_primitive
        , eligibilityResponseBenefitBalance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponseBenefitBalance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponseBenefitBalance_category :: CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , eligibilityResponseBenefitBalance_subCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        , eligibilityResponseBenefitBalance_excluded :: Maybe Boolean
          -- ^ True if the indicated class of service is excluded from the 
          --   plan, missing or False indicated the service is included in 
          --   the coverage.
        , eligibilityResponseBenefitBalance_name :: Maybe Xsd.XsdString
          -- ^ A short name or tag for the benefit, for example MED01, or 
          --   DENT2.
        , eligibilityResponseBenefitBalance_description :: Maybe Xsd.XsdString
          -- ^ A richer description of the benefit, for example 'DENT2 
          --   covers 100% of basic, 50% of major but exclused Ortho, 
          --   Implants and Costmetic services'.
        , eligibilityResponseBenefitBalance_network :: Maybe CodeableConcept
          -- ^ Network designation.
        , eligibilityResponseBenefitBalance_unit :: Maybe CodeableConcept
          -- ^ Unit designation: individual or family.
        , eligibilityResponseBenefitBalance_term :: Maybe CodeableConcept
          -- ^ The term or period of the values such as 'maximum lifetime 
          --   benefit' or 'maximum annual vistis'.
        , eligibilityResponseBenefitBalance_financial :: [EligibilityResponseFinancial]
          -- ^ Benefits Used to date.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponseBenefitBalance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponseBenefitBalance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "subCategory")
            `apply` optional (parseSchemaType "excluded")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "network")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "term")
            `apply` many (parseSchemaType "financial")
    schemaTypeToXML s x@EligibilityResponseBenefitBalance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponseBenefitBalance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponseBenefitBalance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponseBenefitBalance_modifierExtension x
            , schemaTypeToXML "category" $ eligibilityResponseBenefitBalance_category x
            , maybe [] (schemaTypeToXML "subCategory") $ eligibilityResponseBenefitBalance_subCategory x
            , maybe [] (schemaTypeToXML "excluded") $ eligibilityResponseBenefitBalance_excluded x
            , maybe [] (schemaTypeToXML "name") $ eligibilityResponseBenefitBalance_name x
            , maybe [] (schemaTypeToXML "description") $ eligibilityResponseBenefitBalance_description x
            , maybe [] (schemaTypeToXML "network") $ eligibilityResponseBenefitBalance_network x
            , maybe [] (schemaTypeToXML "unit") $ eligibilityResponseBenefitBalance_unit x
            , maybe [] (schemaTypeToXML "term") $ eligibilityResponseBenefitBalance_term x
            , concatMap (schemaTypeToXML "financial") $ eligibilityResponseBenefitBalance_financial x
            ]
instance Extension EligibilityResponseBenefitBalance BackboneElement where
    supertype (EligibilityResponseBenefitBalance a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponseBenefitBalance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponseBenefitBalance -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponseFinancial = EligibilityResponseFinancial
        { eligibilityResponseFinancial_id :: Maybe String_primitive
        , eligibilityResponseFinancial_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponseFinancial_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponseFinancial_type :: CodeableConcept
          -- ^ Deductable, visits, benefit amount.
        , eligibilityResponseFinancial_choice3 :: (Maybe (OneOf3 UnsignedInt Xsd.XsdString Money))
          -- ^ Benefits allowed.
          --   
          --   Choice between:
          --   
          --   (1) allowedUnsignedInt
          --   
          --   (2) allowedString
          --   
          --   (3) allowedMoney
        , eligibilityResponseFinancial_choice4 :: (Maybe (OneOf2 UnsignedInt Money))
          -- ^ Benefits used.
          --   
          --   Choice between:
          --   
          --   (1) usedUnsignedInt
          --   
          --   (2) usedMoney
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponseFinancial where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponseFinancial a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf3 (parseSchemaType "allowedUnsignedInt"))
                                     , ("Xsd.XsdString", fmap TwoOf3 (parseSchemaType "allowedString"))
                                     , ("Money", fmap ThreeOf3 (parseSchemaType "allowedMoney"))
                                     ])
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf2 (parseSchemaType "usedUnsignedInt"))
                                     , ("Money", fmap TwoOf2 (parseSchemaType "usedMoney"))
                                     ])
    schemaTypeToXML s x@EligibilityResponseFinancial{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponseFinancial_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponseFinancial_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponseFinancial_modifierExtension x
            , schemaTypeToXML "type" $ eligibilityResponseFinancial_type x
            , maybe [] (foldOneOf3  (schemaTypeToXML "allowedUnsignedInt")
                                    (schemaTypeToXML "allowedString")
                                    (schemaTypeToXML "allowedMoney")
                                   ) $ eligibilityResponseFinancial_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "usedUnsignedInt")
                                    (schemaTypeToXML "usedMoney")
                                   ) $ eligibilityResponseFinancial_choice4 x
            ]
instance Extension EligibilityResponseFinancial BackboneElement where
    supertype (EligibilityResponseFinancial a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponseFinancial Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponseFinancial -> BackboneElement)
              
 
-- | This resource provides eligibility and plan details from 
--   the processing of an Eligibility resource.
data EligibilityResponseError = EligibilityResponseError
        { eligibilityResponseError_id :: Maybe String_primitive
        , eligibilityResponseError_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , eligibilityResponseError_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , eligibilityResponseError_code :: CodeableConcept
          -- ^ An error code,from a specified code system, which details 
          --   why the eligibility check could not be performed.
        }
        deriving (Eq,Show)
instance SchemaType EligibilityResponseError where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EligibilityResponseError a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
    schemaTypeToXML s x@EligibilityResponseError{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ eligibilityResponseError_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ eligibilityResponseError_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ eligibilityResponseError_modifierExtension x
            , schemaTypeToXML "code" $ eligibilityResponseError_code x
            ]
instance Extension EligibilityResponseError BackboneElement where
    supertype (EligibilityResponseError a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension EligibilityResponseError Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EligibilityResponseError -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
elementEncounter :: XMLParser Encounter
elementEncounter = parseSchemaType "Encounter"
elementToXMLEncounter :: Encounter -> [Content ()]
elementToXMLEncounter = schemaTypeToXML "Encounter"
 
data Encounter = Encounter
        { encounter_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , encounter_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , encounter_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , encounter_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , encounter_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , encounter_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , encounter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounter_identifier :: [Identifier]
          -- ^ Identifier(s) by which this encounter is known.
        , encounter_status :: EncounterStatus
          -- ^ planned | arrived | triaged | in-progress | onleave | 
          --   finished | cancelled +.
        , encounter_statusHistory :: [EncounterStatusHistory]
          -- ^ The status history permits the encounter resource to 
          --   contain the status history without needing to read through 
          --   the historical versions of the resource, or even have the 
          --   server store them.
        , encounter_class :: Maybe Coding
          -- ^ inpatient | outpatient | ambulatory | emergency +.
        , encounter_classHistory :: [EncounterClassHistory]
          -- ^ The class history permits the tracking of the encounters 
          --   transitions without needing to go through the resource 
          --   history. This would be used for a case where an admission 
          --   starts of as an emergency encounter, then transisions into 
          --   an inpatient scenario. Doing this and not restarting a new 
          --   encounter ensures that any lab/diagnostic results can more 
          --   easily follow the patient and not require re-processing and 
          --   not get lost or cancelled during a kindof discharge from 
          --   emergency to inpatient.
        , encounter_type :: [CodeableConcept]
          -- ^ Specific type of encounter (e.g. e-mail consultation, 
          --   surgical day-care, skilled nursing, rehabilitation).
        , encounter_priority :: Maybe CodeableConcept
          -- ^ Indicates the urgency of the encounter.
        , encounter_subject :: Maybe Reference
          -- ^ The patient ro group present at the encounter.
        , encounter_episodeOfCare :: [Reference]
          -- ^ Where a specific encounter should be classified as a part 
          --   of a specific episode(s) of care this field should be used. 
          --   This association can facilitate grouping of related 
          --   encounters together for a specific purpose, such as 
          --   government reporting, issue tracking, association via a 
          --   common problem. The association is recorded on the 
          --   encounter as these are typically created after the episode 
          --   of care, and grouped on entry rather than editing the 
          --   episode of care to append another encounter to it (the 
          --   episode of care could span years).
        , encounter_incomingReferral :: [Reference]
          -- ^ The referral request this encounter satisfies (incoming 
          --   referral).
        , encounter_participant :: [EncounterParticipant]
          -- ^ The list of people responsible for providing the service.
        , encounter_appointment :: Maybe Reference
          -- ^ The appointment that scheduled this encounter.
        , encounter_period :: Maybe Period
          -- ^ The start and end time of the encounter.
        , encounter_length :: Maybe Duration
          -- ^ Quantity of time the encounter lasted. This excludes the 
          --   time during leaves of absence.
        , encounter_reason :: [CodeableConcept]
          -- ^ Reason the encounter takes place, expressed as a code. For 
          --   admissions, this can be used for a coded admission 
          --   diagnosis.
        , encounter_diagnosis :: [EncounterDiagnosis]
          -- ^ The list of diagnosis relevant to this encounter.
        , encounter_account :: [Reference]
          -- ^ The set of accounts that may be used for billing for this 
          --   Encounter.
        , encounter_hospitalization :: Maybe EncounterHospitalization
          -- ^ Details about the admission to a healthcare service.
        , encounter_location :: [EncounterLocation]
          -- ^ List of locations where the patient has been during this 
          --   encounter.
        , encounter_serviceProvider :: Maybe Reference
          -- ^ An organization that is in charge of maintaining the 
          --   information of this Encounter (e.g. who maintains the 
          --   report or the master service catalog item, etc.). This MAY 
          --   be the same as the organization on the Patient record, 
          --   however it could be different. This MAY not be not the 
          --   Service Delivery Location's Organization.
        , encounter_partOf :: Maybe Reference
          -- ^ Another Encounter of which this encounter is a part of 
          --   (administratively or in time).
        }
        deriving (Eq,Show)
instance SchemaType Encounter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Encounter
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "statusHistory")
            `apply` optional (parseSchemaType "class")
            `apply` many (parseSchemaType "classHistory")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "episodeOfCare")
            `apply` many (parseSchemaType "incomingReferral")
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "appointment")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "length")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "account")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "location")
            `apply` optional (parseSchemaType "serviceProvider")
            `apply` optional (parseSchemaType "partOf")
    schemaTypeToXML s x@Encounter{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ encounter_id x
            , maybe [] (schemaTypeToXML "meta") $ encounter_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ encounter_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ encounter_language x
            , maybe [] (schemaTypeToXML "text") $ encounter_text x
            , concatMap (schemaTypeToXML "contained") $ encounter_contained x
            , concatMap (schemaTypeToXML "extension") $ encounter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounter_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ encounter_identifier x
            , schemaTypeToXML "status" $ encounter_status x
            , concatMap (schemaTypeToXML "statusHistory") $ encounter_statusHistory x
            , maybe [] (schemaTypeToXML "class") $ encounter_class x
            , concatMap (schemaTypeToXML "classHistory") $ encounter_classHistory x
            , concatMap (schemaTypeToXML "type") $ encounter_type x
            , maybe [] (schemaTypeToXML "priority") $ encounter_priority x
            , maybe [] (schemaTypeToXML "subject") $ encounter_subject x
            , concatMap (schemaTypeToXML "episodeOfCare") $ encounter_episodeOfCare x
            , concatMap (schemaTypeToXML "incomingReferral") $ encounter_incomingReferral x
            , concatMap (schemaTypeToXML "participant") $ encounter_participant x
            , maybe [] (schemaTypeToXML "appointment") $ encounter_appointment x
            , maybe [] (schemaTypeToXML "period") $ encounter_period x
            , maybe [] (schemaTypeToXML "length") $ encounter_length x
            , concatMap (schemaTypeToXML "reason") $ encounter_reason x
            , concatMap (schemaTypeToXML "diagnosis") $ encounter_diagnosis x
            , concatMap (schemaTypeToXML "account") $ encounter_account x
            , maybe [] (schemaTypeToXML "hospitalization") $ encounter_hospitalization x
            , concatMap (schemaTypeToXML "location") $ encounter_location x
            , maybe [] (schemaTypeToXML "serviceProvider") $ encounter_serviceProvider x
            , maybe [] (schemaTypeToXML "partOf") $ encounter_partOf x
            ]
instance Extension Encounter DomainResource where
    supertype (Encounter e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Encounter Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Encounter -> DomainResource)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterStatusHistory = EncounterStatusHistory
        { encounterStatusHistory_id :: Maybe String_primitive
        , encounterStatusHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterStatusHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterStatusHistory_status :: EncounterStatus
          -- ^ planned | arrived | triaged | in-progress | onleave | 
          --   finished | cancelled +.
        , encounterStatusHistory_period :: Period
          -- ^ The time that the episode was in the specified status.
        }
        deriving (Eq,Show)
instance SchemaType EncounterStatusHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterStatusHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@EncounterStatusHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterStatusHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterStatusHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterStatusHistory_modifierExtension x
            , schemaTypeToXML "status" $ encounterStatusHistory_status x
            , schemaTypeToXML "period" $ encounterStatusHistory_period x
            ]
instance Extension EncounterStatusHistory BackboneElement where
    supertype (EncounterStatusHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension EncounterStatusHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterStatusHistory -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterClassHistory = EncounterClassHistory
        { encounterClassHistory_id :: Maybe String_primitive
        , encounterClassHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterClassHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterClassHistory_class :: Coding
          -- ^ inpatient | outpatient | ambulatory | emergency +.
        , encounterClassHistory_period :: Period
          -- ^ The time that the episode was in the specified class.
        }
        deriving (Eq,Show)
instance SchemaType EncounterClassHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterClassHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "class"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@EncounterClassHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterClassHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterClassHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterClassHistory_modifierExtension x
            , schemaTypeToXML "class" $ encounterClassHistory_class x
            , schemaTypeToXML "period" $ encounterClassHistory_period x
            ]
instance Extension EncounterClassHistory BackboneElement where
    supertype (EncounterClassHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension EncounterClassHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterClassHistory -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterParticipant = EncounterParticipant
        { encounterParticipant_id :: Maybe String_primitive
        , encounterParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterParticipant_type :: [CodeableConcept]
          -- ^ Role of participant in encounter.
        , encounterParticipant_period :: Maybe Period
          -- ^ The period of time that the specified participant 
          --   participated in the encounter. These can overlap or be 
          --   sub-sets of the overall encounter's period.
        , encounterParticipant_individual :: Maybe Reference
          -- ^ Persons involved in the encounter other than the patient.
        }
        deriving (Eq,Show)
instance SchemaType EncounterParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "individual")
    schemaTypeToXML s x@EncounterParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterParticipant_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ encounterParticipant_type x
            , maybe [] (schemaTypeToXML "period") $ encounterParticipant_period x
            , maybe [] (schemaTypeToXML "individual") $ encounterParticipant_individual x
            ]
instance Extension EncounterParticipant BackboneElement where
    supertype (EncounterParticipant a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EncounterParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterParticipant -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterDiagnosis = EncounterDiagnosis
        { encounterDiagnosis_id :: Maybe String_primitive
        , encounterDiagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterDiagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterDiagnosis_condition :: Reference
          -- ^ Reason the encounter takes place, as specified using 
          --   information from another resource. For admissions, this is 
          --   the admission diagnosis. The indication will typically be a 
          --   Condition (with other resources referenced in the 
          --   evidence.detail), or a Procedure.
        , encounterDiagnosis_role :: Maybe CodeableConcept
          -- ^ Role that this diagnosis has within the encounter (e.g. 
          --   admission, billing, discharge â€¦).
        , encounterDiagnosis_rank :: Maybe PositiveInt
          -- ^ Ranking of the diagnosis (for each role type).
        }
        deriving (Eq,Show)
instance SchemaType EncounterDiagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterDiagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "condition"
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "rank")
    schemaTypeToXML s x@EncounterDiagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterDiagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterDiagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterDiagnosis_modifierExtension x
            , schemaTypeToXML "condition" $ encounterDiagnosis_condition x
            , maybe [] (schemaTypeToXML "role") $ encounterDiagnosis_role x
            , maybe [] (schemaTypeToXML "rank") $ encounterDiagnosis_rank x
            ]
instance Extension EncounterDiagnosis BackboneElement where
    supertype (EncounterDiagnosis a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EncounterDiagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterDiagnosis -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterHospitalization = EncounterHospitalization
        { encounterHospitalization_id :: Maybe String_primitive
        , encounterHospitalization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterHospitalization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterHospitalization_preAdmissionIdentifier :: Maybe Identifier
          -- ^ Pre-admission identifier.
        , encounterHospitalization_origin :: Maybe Reference
          -- ^ The location from which the patient came before admission.
        , encounterHospitalization_admitSource :: Maybe CodeableConcept
          -- ^ From where patient was admitted (physician referral, 
          --   transfer).
        , encounterHospitalization_reAdmission :: Maybe CodeableConcept
          -- ^ Whether this hospitalization is a readmission and why if 
          --   known.
        , encounterHospitalization_dietPreference :: [CodeableConcept]
          -- ^ Diet preferences reported by the patient.
        , encounterHospitalization_specialCourtesy :: [CodeableConcept]
          -- ^ Special courtesies (VIP, board member).
        , encounterHospitalization_specialArrangement :: [CodeableConcept]
          -- ^ Any special requests that have been made for this 
          --   hospitalization encounter, such as the provision of 
          --   specific equipment or other things.
        , encounterHospitalization_destination :: Maybe Reference
          -- ^ Location to which the patient is discharged.
        , encounterHospitalization_dischargeDisposition :: Maybe CodeableConcept
          -- ^ Category or kind of location after discharge.
        }
        deriving (Eq,Show)
instance SchemaType EncounterHospitalization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterHospitalization a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "preAdmissionIdentifier")
            `apply` optional (parseSchemaType "origin")
            `apply` optional (parseSchemaType "admitSource")
            `apply` optional (parseSchemaType "reAdmission")
            `apply` many (parseSchemaType "dietPreference")
            `apply` many (parseSchemaType "specialCourtesy")
            `apply` many (parseSchemaType "specialArrangement")
            `apply` optional (parseSchemaType "destination")
            `apply` optional (parseSchemaType "dischargeDisposition")
    schemaTypeToXML s x@EncounterHospitalization{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterHospitalization_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterHospitalization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterHospitalization_modifierExtension x
            , maybe [] (schemaTypeToXML "preAdmissionIdentifier") $ encounterHospitalization_preAdmissionIdentifier x
            , maybe [] (schemaTypeToXML "origin") $ encounterHospitalization_origin x
            , maybe [] (schemaTypeToXML "admitSource") $ encounterHospitalization_admitSource x
            , maybe [] (schemaTypeToXML "reAdmission") $ encounterHospitalization_reAdmission x
            , concatMap (schemaTypeToXML "dietPreference") $ encounterHospitalization_dietPreference x
            , concatMap (schemaTypeToXML "specialCourtesy") $ encounterHospitalization_specialCourtesy x
            , concatMap (schemaTypeToXML "specialArrangement") $ encounterHospitalization_specialArrangement x
            , maybe [] (schemaTypeToXML "destination") $ encounterHospitalization_destination x
            , maybe [] (schemaTypeToXML "dischargeDisposition") $ encounterHospitalization_dischargeDisposition x
            ]
instance Extension EncounterHospitalization BackboneElement where
    supertype (EncounterHospitalization a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension EncounterHospitalization Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterHospitalization -> BackboneElement)
              
 
-- | An interaction between a patient and healthcare provider(s) 
--   for the purpose of providing healthcare service(s) or 
--   assessing the health status of a patient.
data EncounterLocation = EncounterLocation
        { encounterLocation_id :: Maybe String_primitive
        , encounterLocation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , encounterLocation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , encounterLocation_location :: Reference
          -- ^ The location where the encounter takes place.
        , encounterLocation_status :: Maybe EncounterLocationStatus
          -- ^ The status of the participants' presence at the specified 
          --   location during the period specified. If the participant is 
          --   is no longer at the location, then the period will have an 
          --   end date/time.
        , encounterLocation_period :: Maybe Period
          -- ^ Time period during which the patient was present at the 
          --   location.
        }
        deriving (Eq,Show)
instance SchemaType EncounterLocation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EncounterLocation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "location"
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@EncounterLocation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterLocation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterLocation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ encounterLocation_modifierExtension x
            , schemaTypeToXML "location" $ encounterLocation_location x
            , maybe [] (schemaTypeToXML "status") $ encounterLocation_status x
            , maybe [] (schemaTypeToXML "period") $ encounterLocation_period x
            ]
instance Extension EncounterLocation BackboneElement where
    supertype (EncounterLocation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EncounterLocation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EncounterLocation -> BackboneElement)
              
 
data EncounterLocationStatus_list
    = EncounterLocationStatus_list_Planned
      -- ^ Planned
    | EncounterLocationStatus_list_Active
      -- ^ Active
    | EncounterLocationStatus_list_Reserved
      -- ^ Reserved
    | EncounterLocationStatus_list_Completed
      -- ^ Completed
    deriving (Eq,Show,Enum)
instance SchemaType EncounterLocationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EncounterLocationStatus_list where
    acceptingParser =  do literal "planned"; return EncounterLocationStatus_list_Planned
                      `onFail` do literal "active"; return EncounterLocationStatus_list_Active
                      `onFail` do literal "reserved"; return EncounterLocationStatus_list_Reserved
                      `onFail` do literal "completed"; return EncounterLocationStatus_list_Completed
                      
    simpleTypeText EncounterLocationStatus_list_Planned = "planned"
    simpleTypeText EncounterLocationStatus_list_Active = "active"
    simpleTypeText EncounterLocationStatus_list_Reserved = "reserved"
    simpleTypeText EncounterLocationStatus_list_Completed = "completed"
 
data EncounterLocationStatus = EncounterLocationStatus
        { encounterLocationStatus_id :: Maybe String_primitive
        , encounterLocationStatus_value :: Maybe EncounterLocationStatus_list
        , encounterLocationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EncounterLocationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EncounterLocationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EncounterLocationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterLocationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ encounterLocationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterLocationStatus_extension x
            ]
instance Extension EncounterLocationStatus Element where
    supertype (EncounterLocationStatus a0 a1 e0) =
               Element a0 e0
 
data EncounterStatus_list
    = EncounterStatus_list_Planned
      -- ^ Planned
    | EncounterStatus_list_Arrived
      -- ^ Arrived
    | EncounterStatus_list_Triaged
      -- ^ Triaged
    | EncounterStatus_list_In_progress
      -- ^ In Progress
    | EncounterStatus_list_Onleave
      -- ^ On Leave
    | EncounterStatus_list_Finished
      -- ^ Finished
    | EncounterStatus_list_Cancelled
      -- ^ Cancelled
    | EncounterStatus_list_Entered_in_error
      -- ^ Entered in Error
    | EncounterStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType EncounterStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EncounterStatus_list where
    acceptingParser =  do literal "planned"; return EncounterStatus_list_Planned
                      `onFail` do literal "arrived"; return EncounterStatus_list_Arrived
                      `onFail` do literal "triaged"; return EncounterStatus_list_Triaged
                      `onFail` do literal "in-progress"; return EncounterStatus_list_In_progress
                      `onFail` do literal "onleave"; return EncounterStatus_list_Onleave
                      `onFail` do literal "finished"; return EncounterStatus_list_Finished
                      `onFail` do literal "cancelled"; return EncounterStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return EncounterStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return EncounterStatus_list_Unknown
                      
    simpleTypeText EncounterStatus_list_Planned = "planned"
    simpleTypeText EncounterStatus_list_Arrived = "arrived"
    simpleTypeText EncounterStatus_list_Triaged = "triaged"
    simpleTypeText EncounterStatus_list_In_progress = "in-progress"
    simpleTypeText EncounterStatus_list_Onleave = "onleave"
    simpleTypeText EncounterStatus_list_Finished = "finished"
    simpleTypeText EncounterStatus_list_Cancelled = "cancelled"
    simpleTypeText EncounterStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText EncounterStatus_list_Unknown = "unknown"
 
data EncounterStatus = EncounterStatus
        { encounterStatus_id :: Maybe String_primitive
        , encounterStatus_value :: Maybe EncounterStatus_list
        , encounterStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EncounterStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EncounterStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EncounterStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ encounterStatus_id x
                       , maybe [] (toXMLAttribute "value") $ encounterStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ encounterStatus_extension x
            ]
instance Extension EncounterStatus Element where
    supertype (EncounterStatus a0 a1 e0) =
               Element a0 e0
 
-- | The technical details of an endpoint that can be used for 
--   electronic services, such as for web services providing 
--   XDS.b or a REST endpoint for another FHIR server. This may 
--   include any security context information.
elementEndpoint :: XMLParser Endpoint
elementEndpoint = parseSchemaType "Endpoint"
elementToXMLEndpoint :: Endpoint -> [Content ()]
elementToXMLEndpoint = schemaTypeToXML "Endpoint"
 
data Endpoint = Endpoint
        { endpoint_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , endpoint_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , endpoint_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , endpoint_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , endpoint_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , endpoint_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , endpoint_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , endpoint_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , endpoint_identifier :: [Identifier]
          -- ^ Identifier for the organization that is used to identify 
          --   the endpoint across multiple disparate systems.
        , endpoint_status :: EndpointStatus
          -- ^ active | suspended | error | off | test.
        , endpoint_connectionType :: Coding
          -- ^ A coded value that represents the technical details of the 
          --   usage of this endpoint, such as what WSDLs should be used 
          --   in what way. (e.g. XDS.b/DICOM/cds-hook).
        , endpoint_name :: Maybe Xsd.XsdString
          -- ^ A friendly name that this endpoint can be referred to with.
        , endpoint_managingOrganization :: Maybe Reference
          -- ^ The organization that manages this endpoint (even if 
          --   technically another organisation is hosting this in the 
          --   cloud, it is the organisation associated with the data).
        , endpoint_contact :: [ContactPoint]
          -- ^ Contact details for a human to contact about the 
          --   subscription. The primary use of this for system 
          --   administrator troubleshooting.
        , endpoint_period :: Maybe Period
          -- ^ The interval during which the endpoint is expected to be 
          --   operational.
        , endpoint_payloadType :: [CodeableConcept]
          -- ^ The payload type describes the acceptable content that can 
          --   be communicated on the endpoint.
        , endpoint_payloadMimeType :: [Code]
          -- ^ The mime type to send the payload in - e.g. 
          --   application/fhir+xml, application/fhir+json. If the mime 
          --   type is not specified, then the sender could send any 
          --   content (including no content depending on the 
          --   connectionType).
        , endpoint_address :: Uri
          -- ^ The uri that describes the actual end-point to connect to.
        , endpoint_header :: [Xsd.XsdString]
          -- ^ Additional headers / information to send as part of the 
          --   notification.
        }
        deriving (Eq,Show)
instance SchemaType Endpoint where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Endpoint
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "connectionType"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "period")
            `apply` many1 (parseSchemaType "payloadType")
            `apply` many (parseSchemaType "payloadMimeType")
            `apply` parseSchemaType "address"
            `apply` many (parseSchemaType "header")
    schemaTypeToXML s x@Endpoint{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ endpoint_id x
            , maybe [] (schemaTypeToXML "meta") $ endpoint_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ endpoint_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ endpoint_language x
            , maybe [] (schemaTypeToXML "text") $ endpoint_text x
            , concatMap (schemaTypeToXML "contained") $ endpoint_contained x
            , concatMap (schemaTypeToXML "extension") $ endpoint_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ endpoint_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ endpoint_identifier x
            , schemaTypeToXML "status" $ endpoint_status x
            , schemaTypeToXML "connectionType" $ endpoint_connectionType x
            , maybe [] (schemaTypeToXML "name") $ endpoint_name x
            , maybe [] (schemaTypeToXML "managingOrganization") $ endpoint_managingOrganization x
            , concatMap (schemaTypeToXML "contact") $ endpoint_contact x
            , maybe [] (schemaTypeToXML "period") $ endpoint_period x
            , concatMap (schemaTypeToXML "payloadType") $ endpoint_payloadType x
            , concatMap (schemaTypeToXML "payloadMimeType") $ endpoint_payloadMimeType x
            , schemaTypeToXML "address" $ endpoint_address x
            , concatMap (schemaTypeToXML "header") $ endpoint_header x
            ]
instance Extension Endpoint DomainResource where
    supertype (Endpoint e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Endpoint Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Endpoint -> DomainResource)
              
 
data EndpointStatus_list
    = EndpointStatus_list_Active
      -- ^ Active
    | EndpointStatus_list_Suspended
      -- ^ Suspended
    | EndpointStatus_list_Error
      -- ^ Error
    | EndpointStatus_list_Off
      -- ^ Off
    | EndpointStatus_list_Entered_in_error
      -- ^ Entered in error
    | EndpointStatus_list_Test
      -- ^ Test
    deriving (Eq,Show,Enum)
instance SchemaType EndpointStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EndpointStatus_list where
    acceptingParser =  do literal "active"; return EndpointStatus_list_Active
                      `onFail` do literal "suspended"; return EndpointStatus_list_Suspended
                      `onFail` do literal "error"; return EndpointStatus_list_Error
                      `onFail` do literal "off"; return EndpointStatus_list_Off
                      `onFail` do literal "entered-in-error"; return EndpointStatus_list_Entered_in_error
                      `onFail` do literal "test"; return EndpointStatus_list_Test
                      
    simpleTypeText EndpointStatus_list_Active = "active"
    simpleTypeText EndpointStatus_list_Suspended = "suspended"
    simpleTypeText EndpointStatus_list_Error = "error"
    simpleTypeText EndpointStatus_list_Off = "off"
    simpleTypeText EndpointStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText EndpointStatus_list_Test = "test"
 
data EndpointStatus = EndpointStatus
        { endpointStatus_id :: Maybe String_primitive
        , endpointStatus_value :: Maybe EndpointStatus_list
        , endpointStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EndpointStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EndpointStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EndpointStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ endpointStatus_id x
                       , maybe [] (toXMLAttribute "value") $ endpointStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ endpointStatus_extension x
            ]
instance Extension EndpointStatus Element where
    supertype (EndpointStatus a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the insurance enrollment details to 
--   the insurer regarding a specified coverage.
elementEnrollmentRequest :: XMLParser EnrollmentRequest
elementEnrollmentRequest = parseSchemaType "EnrollmentRequest"
elementToXMLEnrollmentRequest :: EnrollmentRequest -> [Content ()]
elementToXMLEnrollmentRequest = schemaTypeToXML "EnrollmentRequest"
 
data EnrollmentRequest = EnrollmentRequest
        { enrollmentRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , enrollmentRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , enrollmentRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , enrollmentRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , enrollmentRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , enrollmentRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , enrollmentRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , enrollmentRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , enrollmentRequest_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , enrollmentRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , enrollmentRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , enrollmentRequest_insurer :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , enrollmentRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , enrollmentRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , enrollmentRequest_subject :: Maybe Reference
          -- ^ Patient Resource.
        , enrollmentRequest_coverage :: Maybe Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        }
        deriving (Eq,Show)
instance SchemaType EnrollmentRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EnrollmentRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "coverage")
    schemaTypeToXML s x@EnrollmentRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ enrollmentRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ enrollmentRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ enrollmentRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ enrollmentRequest_language x
            , maybe [] (schemaTypeToXML "text") $ enrollmentRequest_text x
            , concatMap (schemaTypeToXML "contained") $ enrollmentRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ enrollmentRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ enrollmentRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ enrollmentRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ enrollmentRequest_status x
            , maybe [] (schemaTypeToXML "created") $ enrollmentRequest_created x
            , maybe [] (schemaTypeToXML "insurer") $ enrollmentRequest_insurer x
            , maybe [] (schemaTypeToXML "provider") $ enrollmentRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ enrollmentRequest_organization x
            , maybe [] (schemaTypeToXML "subject") $ enrollmentRequest_subject x
            , maybe [] (schemaTypeToXML "coverage") $ enrollmentRequest_coverage x
            ]
instance Extension EnrollmentRequest DomainResource where
    supertype (EnrollmentRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EnrollmentRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EnrollmentRequest -> DomainResource)
              
 
-- | This resource provides enrollment and plan details from the 
--   processing of an Enrollment resource.
elementEnrollmentResponse :: XMLParser EnrollmentResponse
elementEnrollmentResponse = parseSchemaType "EnrollmentResponse"
elementToXMLEnrollmentResponse :: EnrollmentResponse -> [Content ()]
elementToXMLEnrollmentResponse = schemaTypeToXML "EnrollmentResponse"
 
data EnrollmentResponse = EnrollmentResponse
        { enrollmentResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , enrollmentResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , enrollmentResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , enrollmentResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , enrollmentResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , enrollmentResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , enrollmentResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , enrollmentResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , enrollmentResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , enrollmentResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , enrollmentResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , enrollmentResponse_outcome :: Maybe CodeableConcept
          -- ^ Processing status: error, complete.
        , enrollmentResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , enrollmentResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , enrollmentResponse_organization :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , enrollmentResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , enrollmentResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        }
        deriving (Eq,Show)
instance SchemaType EnrollmentResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EnrollmentResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
    schemaTypeToXML s x@EnrollmentResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ enrollmentResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ enrollmentResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ enrollmentResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ enrollmentResponse_language x
            , maybe [] (schemaTypeToXML "text") $ enrollmentResponse_text x
            , concatMap (schemaTypeToXML "contained") $ enrollmentResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ enrollmentResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ enrollmentResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ enrollmentResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ enrollmentResponse_status x
            , maybe [] (schemaTypeToXML "request") $ enrollmentResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ enrollmentResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ enrollmentResponse_disposition x
            , maybe [] (schemaTypeToXML "created") $ enrollmentResponse_created x
            , maybe [] (schemaTypeToXML "organization") $ enrollmentResponse_organization x
            , maybe [] (schemaTypeToXML "requestProvider") $ enrollmentResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ enrollmentResponse_requestOrganization x
            ]
instance Extension EnrollmentResponse DomainResource where
    supertype (EnrollmentResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EnrollmentResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EnrollmentResponse -> DomainResource)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
elementEpisodeOfCare :: XMLParser EpisodeOfCare
elementEpisodeOfCare = parseSchemaType "EpisodeOfCare"
elementToXMLEpisodeOfCare :: EpisodeOfCare -> [Content ()]
elementToXMLEpisodeOfCare = schemaTypeToXML "EpisodeOfCare"
 
data EpisodeOfCare = EpisodeOfCare
        { episodeOfCare_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , episodeOfCare_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , episodeOfCare_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , episodeOfCare_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , episodeOfCare_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , episodeOfCare_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , episodeOfCare_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCare_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCare_identifier :: [Identifier]
          -- ^ The EpisodeOfCare may be known by different identifiers for 
          --   different contexts of use, such as when an external agency 
          --   is tracking the Episode for funding purposes.
        , episodeOfCare_status :: EpisodeOfCareStatus
          -- ^ planned | waitlist | active | onhold | finished | 
          --   cancelled.
        , episodeOfCare_statusHistory :: [EpisodeOfCareStatusHistory]
          -- ^ The history of statuses that the EpisodeOfCare has been 
          --   through (without requiring processing the history of the 
          --   resource).
        , episodeOfCare_type :: [CodeableConcept]
          -- ^ A classification of the type of episode of care; e.g. 
          --   specialist referral, disease management, type of funded 
          --   care.
        , episodeOfCare_diagnosis :: [EpisodeOfCareDiagnosis]
          -- ^ The list of diagnosis relevant to this episode of care.
        , episodeOfCare_patient :: Reference
          -- ^ The patient who is the focus of this episode of care.
        , episodeOfCare_managingOrganization :: Maybe Reference
          -- ^ The organization that has assumed the specific 
          --   responsibilities for the specified duration.
        , episodeOfCare_period :: Maybe Period
          -- ^ The interval during which the managing organization assumes 
          --   the defined responsibility.
        , episodeOfCare_referralRequest :: [Reference]
          -- ^ Referral Request(s) that are fulfilled by this 
          --   EpisodeOfCare, incoming referrals.
        , episodeOfCare_careManager :: Maybe Reference
          -- ^ The practitioner that is the care manager/care co-ordinator 
          --   for this patient.
        , episodeOfCare_team :: [Reference]
          -- ^ The list of practitioners that may be facilitating this 
          --   episode of care for specific purposes.
        , episodeOfCare_account :: [Reference]
          -- ^ The set of accounts that may be used for billing for this 
          --   EpisodeOfCare.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCare where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return EpisodeOfCare
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "statusHistory")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "diagnosis")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "referralRequest")
            `apply` optional (parseSchemaType "careManager")
            `apply` many (parseSchemaType "team")
            `apply` many (parseSchemaType "account")
    schemaTypeToXML s x@EpisodeOfCare{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ episodeOfCare_id x
            , maybe [] (schemaTypeToXML "meta") $ episodeOfCare_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ episodeOfCare_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ episodeOfCare_language x
            , maybe [] (schemaTypeToXML "text") $ episodeOfCare_text x
            , concatMap (schemaTypeToXML "contained") $ episodeOfCare_contained x
            , concatMap (schemaTypeToXML "extension") $ episodeOfCare_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCare_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ episodeOfCare_identifier x
            , schemaTypeToXML "status" $ episodeOfCare_status x
            , concatMap (schemaTypeToXML "statusHistory") $ episodeOfCare_statusHistory x
            , concatMap (schemaTypeToXML "type") $ episodeOfCare_type x
            , concatMap (schemaTypeToXML "diagnosis") $ episodeOfCare_diagnosis x
            , schemaTypeToXML "patient" $ episodeOfCare_patient x
            , maybe [] (schemaTypeToXML "managingOrganization") $ episodeOfCare_managingOrganization x
            , maybe [] (schemaTypeToXML "period") $ episodeOfCare_period x
            , concatMap (schemaTypeToXML "referralRequest") $ episodeOfCare_referralRequest x
            , maybe [] (schemaTypeToXML "careManager") $ episodeOfCare_careManager x
            , concatMap (schemaTypeToXML "team") $ episodeOfCare_team x
            , concatMap (schemaTypeToXML "account") $ episodeOfCare_account x
            ]
instance Extension EpisodeOfCare DomainResource where
    supertype (EpisodeOfCare e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension EpisodeOfCare Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: EpisodeOfCare -> DomainResource)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
data EpisodeOfCareStatusHistory = EpisodeOfCareStatusHistory
        { episodeOfCareStatusHistory_id :: Maybe String_primitive
        , episodeOfCareStatusHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCareStatusHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCareStatusHistory_status :: EpisodeOfCareStatus
          -- ^ planned | waitlist | active | onhold | finished | 
          --   cancelled.
        , episodeOfCareStatusHistory_period :: Period
          -- ^ The period during this EpisodeOfCare that the specific 
          --   status applied.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCareStatusHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EpisodeOfCareStatusHistory a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "period"
    schemaTypeToXML s x@EpisodeOfCareStatusHistory{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCareStatusHistory_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCareStatusHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCareStatusHistory_modifierExtension x
            , schemaTypeToXML "status" $ episodeOfCareStatusHistory_status x
            , schemaTypeToXML "period" $ episodeOfCareStatusHistory_period x
            ]
instance Extension EpisodeOfCareStatusHistory BackboneElement where
    supertype (EpisodeOfCareStatusHistory a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension EpisodeOfCareStatusHistory Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EpisodeOfCareStatusHistory -> BackboneElement)
              
 
-- | An association between a patient and an organization / 
--   healthcare provider(s) during which time encounters may 
--   occur. The managing organization assumes a level of 
--   responsibility for the patient during this time.
data EpisodeOfCareDiagnosis = EpisodeOfCareDiagnosis
        { episodeOfCareDiagnosis_id :: Maybe String_primitive
        , episodeOfCareDiagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , episodeOfCareDiagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , episodeOfCareDiagnosis_condition :: Reference
          -- ^ A list of conditions/problems/diagnoses that this episode 
          --   of care is intended to be providing care for.
        , episodeOfCareDiagnosis_role :: Maybe CodeableConcept
          -- ^ Role that this diagnosis has within the episode of care 
          --   (e.g. admission, billing, discharge â€¦).
        , episodeOfCareDiagnosis_rank :: Maybe PositiveInt
          -- ^ Ranking of the diagnosis (for each role type).
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCareDiagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (EpisodeOfCareDiagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "condition"
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "rank")
    schemaTypeToXML s x@EpisodeOfCareDiagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCareDiagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCareDiagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ episodeOfCareDiagnosis_modifierExtension x
            , schemaTypeToXML "condition" $ episodeOfCareDiagnosis_condition x
            , maybe [] (schemaTypeToXML "role") $ episodeOfCareDiagnosis_role x
            , maybe [] (schemaTypeToXML "rank") $ episodeOfCareDiagnosis_rank x
            ]
instance Extension EpisodeOfCareDiagnosis BackboneElement where
    supertype (EpisodeOfCareDiagnosis a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension EpisodeOfCareDiagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: EpisodeOfCareDiagnosis -> BackboneElement)
              
 
data EpisodeOfCareStatus_list
    = EpisodeOfCareStatus_list_Planned
      -- ^ Planned
    | EpisodeOfCareStatus_list_Waitlist
      -- ^ Waitlist
    | EpisodeOfCareStatus_list_Active
      -- ^ Active
    | EpisodeOfCareStatus_list_Onhold
      -- ^ On Hold
    | EpisodeOfCareStatus_list_Finished
      -- ^ Finished
    | EpisodeOfCareStatus_list_Cancelled
      -- ^ Cancelled
    | EpisodeOfCareStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType EpisodeOfCareStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType EpisodeOfCareStatus_list where
    acceptingParser =  do literal "planned"; return EpisodeOfCareStatus_list_Planned
                      `onFail` do literal "waitlist"; return EpisodeOfCareStatus_list_Waitlist
                      `onFail` do literal "active"; return EpisodeOfCareStatus_list_Active
                      `onFail` do literal "onhold"; return EpisodeOfCareStatus_list_Onhold
                      `onFail` do literal "finished"; return EpisodeOfCareStatus_list_Finished
                      `onFail` do literal "cancelled"; return EpisodeOfCareStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return EpisodeOfCareStatus_list_Entered_in_error
                      
    simpleTypeText EpisodeOfCareStatus_list_Planned = "planned"
    simpleTypeText EpisodeOfCareStatus_list_Waitlist = "waitlist"
    simpleTypeText EpisodeOfCareStatus_list_Active = "active"
    simpleTypeText EpisodeOfCareStatus_list_Onhold = "onhold"
    simpleTypeText EpisodeOfCareStatus_list_Finished = "finished"
    simpleTypeText EpisodeOfCareStatus_list_Cancelled = "cancelled"
    simpleTypeText EpisodeOfCareStatus_list_Entered_in_error = "entered-in-error"
 
data EpisodeOfCareStatus = EpisodeOfCareStatus
        { episodeOfCareStatus_id :: Maybe String_primitive
        , episodeOfCareStatus_value :: Maybe EpisodeOfCareStatus_list
        , episodeOfCareStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType EpisodeOfCareStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (EpisodeOfCareStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@EpisodeOfCareStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ episodeOfCareStatus_id x
                       , maybe [] (toXMLAttribute "value") $ episodeOfCareStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ episodeOfCareStatus_extension x
            ]
instance Extension EpisodeOfCareStatus Element where
    supertype (EpisodeOfCareStatus a0 a1 e0) =
               Element a0 e0
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
elementExpansionProfile :: XMLParser ExpansionProfile
elementExpansionProfile = parseSchemaType "ExpansionProfile"
elementToXMLExpansionProfile :: ExpansionProfile -> [Content ()]
elementToXMLExpansionProfile = schemaTypeToXML "ExpansionProfile"
 
data ExpansionProfile = ExpansionProfile
        { expansionProfile_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , expansionProfile_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , expansionProfile_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , expansionProfile_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , expansionProfile_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , expansionProfile_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , expansionProfile_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfile_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfile_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this expansion 
          --   profile when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   expansion profile is (or will be) published. The URL SHOULD 
          --   include the major version of the expansion profile. For 
          --   more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , expansionProfile_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this expansion 
          --   profile when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , expansionProfile_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   expansion profile when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the expansion profile author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , expansionProfile_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the expansion profile. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , expansionProfile_status :: PublicationStatus
          -- ^ The status of this expansion profile. Enables tracking the 
          --   life-cycle of the content.
        , expansionProfile_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this expansion profile is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , expansionProfile_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the expansion profile 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the expansion profile changes.
        , expansionProfile_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the expansion profile.
        , expansionProfile_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , expansionProfile_description :: Maybe Markdown
          -- ^ A free text natural language description of the expansion 
          --   profile from a consumer's perspective.
        , expansionProfile_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   expansion profile instances.
        , expansionProfile_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the expansion profile 
          --   is intended to be used.
        , expansionProfile_fixedVersion :: [ExpansionProfileFixedVersion]
          -- ^ Fix use of a particular code system to a particular 
          --   version.
        , expansionProfile_excludedSystem :: Maybe ExpansionProfileExcludedSystem
          -- ^ Code system, or a particular version of a code system to be 
          --   excluded from value set expansions.
        , expansionProfile_includeDesignations :: Maybe Boolean
          -- ^ Controls whether concept designations are to be included or 
          --   excluded in value set expansions.
        , expansionProfile_designation :: Maybe ExpansionProfileDesignation
          -- ^ A set of criteria that provide the constraints imposed on 
          --   the value set expansion by including or excluding 
          --   designations.
        , expansionProfile_includeDefinition :: Maybe Boolean
          -- ^ Controls whether the value set definition is included or 
          --   excluded in value set expansions.
        , expansionProfile_activeOnly :: Maybe Boolean
          -- ^ Controls whether inactive concepts are included or excluded 
          --   in value set expansions.
        , expansionProfile_excludeNested :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion nests codes 
          --   or not (i.e. ValueSet.expansion.contains.contains).
        , expansionProfile_excludeNotForUI :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion includes 
          --   codes which cannot be displayed in user interfaces.
        , expansionProfile_excludePostCoordinated :: Maybe Boolean
          -- ^ Controls whether or not the value set expansion includes 
          --   post coordinated codes.
        , expansionProfile_displayLanguage :: Maybe Code
          -- ^ Specifies the language to be used for description in the 
          --   expansions i.e. the language to be used for 
          --   ValueSet.expansion.contains.display.
        , expansionProfile_limitedExpansion :: Maybe Boolean
          -- ^ If the value set being expanded is incomplete (because it 
          --   is too big to expand), return a limited expansion (a 
          --   subset) with an indicator that expansion is incomplete, 
          --   using the extension 
          --   [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html).
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfile where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ExpansionProfile
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "fixedVersion")
            `apply` optional (parseSchemaType "excludedSystem")
            `apply` optional (parseSchemaType "includeDesignations")
            `apply` optional (parseSchemaType "designation")
            `apply` optional (parseSchemaType "includeDefinition")
            `apply` optional (parseSchemaType "activeOnly")
            `apply` optional (parseSchemaType "excludeNested")
            `apply` optional (parseSchemaType "excludeNotForUI")
            `apply` optional (parseSchemaType "excludePostCoordinated")
            `apply` optional (parseSchemaType "displayLanguage")
            `apply` optional (parseSchemaType "limitedExpansion")
    schemaTypeToXML s x@ExpansionProfile{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ expansionProfile_id x
            , maybe [] (schemaTypeToXML "meta") $ expansionProfile_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ expansionProfile_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ expansionProfile_language x
            , maybe [] (schemaTypeToXML "text") $ expansionProfile_text x
            , concatMap (schemaTypeToXML "contained") $ expansionProfile_contained x
            , concatMap (schemaTypeToXML "extension") $ expansionProfile_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfile_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ expansionProfile_url x
            , maybe [] (schemaTypeToXML "identifier") $ expansionProfile_identifier x
            , maybe [] (schemaTypeToXML "version") $ expansionProfile_version x
            , maybe [] (schemaTypeToXML "name") $ expansionProfile_name x
            , schemaTypeToXML "status" $ expansionProfile_status x
            , maybe [] (schemaTypeToXML "experimental") $ expansionProfile_experimental x
            , maybe [] (schemaTypeToXML "date") $ expansionProfile_date x
            , maybe [] (schemaTypeToXML "publisher") $ expansionProfile_publisher x
            , concatMap (schemaTypeToXML "contact") $ expansionProfile_contact x
            , maybe [] (schemaTypeToXML "description") $ expansionProfile_description x
            , concatMap (schemaTypeToXML "useContext") $ expansionProfile_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ expansionProfile_jurisdiction x
            , concatMap (schemaTypeToXML "fixedVersion") $ expansionProfile_fixedVersion x
            , maybe [] (schemaTypeToXML "excludedSystem") $ expansionProfile_excludedSystem x
            , maybe [] (schemaTypeToXML "includeDesignations") $ expansionProfile_includeDesignations x
            , maybe [] (schemaTypeToXML "designation") $ expansionProfile_designation x
            , maybe [] (schemaTypeToXML "includeDefinition") $ expansionProfile_includeDefinition x
            , maybe [] (schemaTypeToXML "activeOnly") $ expansionProfile_activeOnly x
            , maybe [] (schemaTypeToXML "excludeNested") $ expansionProfile_excludeNested x
            , maybe [] (schemaTypeToXML "excludeNotForUI") $ expansionProfile_excludeNotForUI x
            , maybe [] (schemaTypeToXML "excludePostCoordinated") $ expansionProfile_excludePostCoordinated x
            , maybe [] (schemaTypeToXML "displayLanguage") $ expansionProfile_displayLanguage x
            , maybe [] (schemaTypeToXML "limitedExpansion") $ expansionProfile_limitedExpansion x
            ]
instance Extension ExpansionProfile DomainResource where
    supertype (ExpansionProfile e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ExpansionProfile Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ExpansionProfile -> DomainResource)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileFixedVersion = ExpansionProfileFixedVersion
        { expansionProfileFixedVersion_id :: Maybe String_primitive
        , expansionProfileFixedVersion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileFixedVersion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileFixedVersion_system :: Uri
          -- ^ The specific system for which to fix the version.
        , expansionProfileFixedVersion_version :: Xsd.XsdString
          -- ^ The version of the code system from which codes in the 
          --   expansion should be included.
        , expansionProfileFixedVersion_mode :: SystemVersionProcessingMode
          -- ^ How to manage the intersection between a fixed version in a 
          --   value set, and this fixed version of the system in the 
          --   expansion profile.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileFixedVersion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileFixedVersion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "system"
            `apply` parseSchemaType "version"
            `apply` parseSchemaType "mode"
    schemaTypeToXML s x@ExpansionProfileFixedVersion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileFixedVersion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileFixedVersion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileFixedVersion_modifierExtension x
            , schemaTypeToXML "system" $ expansionProfileFixedVersion_system x
            , schemaTypeToXML "version" $ expansionProfileFixedVersion_version x
            , schemaTypeToXML "mode" $ expansionProfileFixedVersion_mode x
            ]
instance Extension ExpansionProfileFixedVersion BackboneElement where
    supertype (ExpansionProfileFixedVersion a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileFixedVersion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileFixedVersion -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileExcludedSystem = ExpansionProfileExcludedSystem
        { expansionProfileExcludedSystem_id :: Maybe String_primitive
        , expansionProfileExcludedSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileExcludedSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileExcludedSystem_system :: Uri
          -- ^ An absolute URI which is the code system to be excluded.
        , expansionProfileExcludedSystem_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system from which codes in the 
          --   expansion should be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileExcludedSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileExcludedSystem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "system"
            `apply` optional (parseSchemaType "version")
    schemaTypeToXML s x@ExpansionProfileExcludedSystem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileExcludedSystem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileExcludedSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileExcludedSystem_modifierExtension x
            , schemaTypeToXML "system" $ expansionProfileExcludedSystem_system x
            , maybe [] (schemaTypeToXML "version") $ expansionProfileExcludedSystem_version x
            ]
instance Extension ExpansionProfileExcludedSystem BackboneElement where
    supertype (ExpansionProfileExcludedSystem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileExcludedSystem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileExcludedSystem -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileDesignation = ExpansionProfileDesignation
        { expansionProfileDesignation_id :: Maybe String_primitive
        , expansionProfileDesignation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileDesignation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileDesignation_include :: Maybe ExpansionProfileInclude
          -- ^ Designations to be included.
        , expansionProfileDesignation_exclude :: Maybe ExpansionProfileExclude
          -- ^ Designations to be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileDesignation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileDesignation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "include")
            `apply` optional (parseSchemaType "exclude")
    schemaTypeToXML s x@ExpansionProfileDesignation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileDesignation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileDesignation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileDesignation_modifierExtension x
            , maybe [] (schemaTypeToXML "include") $ expansionProfileDesignation_include x
            , maybe [] (schemaTypeToXML "exclude") $ expansionProfileDesignation_exclude x
            ]
instance Extension ExpansionProfileDesignation BackboneElement where
    supertype (ExpansionProfileDesignation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileDesignation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileDesignation -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileInclude = ExpansionProfileInclude
        { expansionProfileInclude_id :: Maybe String_primitive
        , expansionProfileInclude_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileInclude_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileInclude_designation :: [ExpansionProfileDesignation1]
          -- ^ A data group for each designation to be included.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileInclude where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileInclude a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ExpansionProfileInclude{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileInclude_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileInclude_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileInclude_modifierExtension x
            , concatMap (schemaTypeToXML "designation") $ expansionProfileInclude_designation x
            ]
instance Extension ExpansionProfileInclude BackboneElement where
    supertype (ExpansionProfileInclude a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileInclude Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileInclude -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileDesignation1 = ExpansionProfileDesignation1
        { expansionProfileDesignation1_id :: Maybe String_primitive
        , expansionProfileDesignation1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileDesignation1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileDesignation1_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , expansionProfileDesignation1_use :: Maybe Coding
          -- ^ Which kinds of designation to include in the expansion.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileDesignation1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileDesignation1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
    schemaTypeToXML s x@ExpansionProfileDesignation1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileDesignation1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileDesignation1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileDesignation1_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ expansionProfileDesignation1_language x
            , maybe [] (schemaTypeToXML "use") $ expansionProfileDesignation1_use x
            ]
instance Extension ExpansionProfileDesignation1 BackboneElement where
    supertype (ExpansionProfileDesignation1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileDesignation1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileDesignation1 -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileExclude = ExpansionProfileExclude
        { expansionProfileExclude_id :: Maybe String_primitive
        , expansionProfileExclude_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileExclude_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileExclude_designation :: [ExpansionProfileDesignation2]
          -- ^ A data group for each designation to be excluded.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileExclude where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileExclude a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ExpansionProfileExclude{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileExclude_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileExclude_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileExclude_modifierExtension x
            , concatMap (schemaTypeToXML "designation") $ expansionProfileExclude_designation x
            ]
instance Extension ExpansionProfileExclude BackboneElement where
    supertype (ExpansionProfileExclude a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileExclude Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileExclude -> BackboneElement)
              
 
-- | Resource to define constraints on the Expansion of a FHIR 
--   ValueSet.
data ExpansionProfileDesignation2 = ExpansionProfileDesignation2
        { expansionProfileDesignation2_id :: Maybe String_primitive
        , expansionProfileDesignation2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , expansionProfileDesignation2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , expansionProfileDesignation2_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , expansionProfileDesignation2_use :: Maybe Coding
          -- ^ Which kinds of designation to exclude from the expansion.
        }
        deriving (Eq,Show)
instance SchemaType ExpansionProfileDesignation2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExpansionProfileDesignation2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
    schemaTypeToXML s x@ExpansionProfileDesignation2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ expansionProfileDesignation2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ expansionProfileDesignation2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ expansionProfileDesignation2_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ expansionProfileDesignation2_language x
            , maybe [] (schemaTypeToXML "use") $ expansionProfileDesignation2_use x
            ]
instance Extension ExpansionProfileDesignation2 BackboneElement where
    supertype (ExpansionProfileDesignation2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExpansionProfileDesignation2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExpansionProfileDesignation2 -> BackboneElement)
              
 
data SystemVersionProcessingMode_list
    = SystemVersionProcessingMode_list_Default
      -- ^ Default Version
    | SystemVersionProcessingMode_list_Check
      -- ^ Check ValueSet Version
    | SystemVersionProcessingMode_list_Override
      -- ^ Override ValueSet Version
    deriving (Eq,Show,Enum)
instance SchemaType SystemVersionProcessingMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SystemVersionProcessingMode_list where
    acceptingParser =  do literal "default"; return SystemVersionProcessingMode_list_Default
                      `onFail` do literal "check"; return SystemVersionProcessingMode_list_Check
                      `onFail` do literal "override"; return SystemVersionProcessingMode_list_Override
                      
    simpleTypeText SystemVersionProcessingMode_list_Default = "default"
    simpleTypeText SystemVersionProcessingMode_list_Check = "check"
    simpleTypeText SystemVersionProcessingMode_list_Override = "override"
 
data SystemVersionProcessingMode = SystemVersionProcessingMode
        { systemVersionProcessingMode_id :: Maybe String_primitive
        , systemVersionProcessingMode_value :: Maybe SystemVersionProcessingMode_list
        , systemVersionProcessingMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SystemVersionProcessingMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SystemVersionProcessingMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SystemVersionProcessingMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ systemVersionProcessingMode_id x
                       , maybe [] (toXMLAttribute "value") $ systemVersionProcessingMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ systemVersionProcessingMode_extension x
            ]
instance Extension SystemVersionProcessingMode Element where
    supertype (SystemVersionProcessingMode a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
elementExplanationOfBenefit :: XMLParser ExplanationOfBenefit
elementExplanationOfBenefit = parseSchemaType "ExplanationOfBenefit"
elementToXMLExplanationOfBenefit :: ExplanationOfBenefit -> [Content ()]
elementToXMLExplanationOfBenefit = schemaTypeToXML "ExplanationOfBenefit"
 
data ExplanationOfBenefit = ExplanationOfBenefit
        { explanationOfBenefit_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , explanationOfBenefit_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , explanationOfBenefit_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , explanationOfBenefit_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , explanationOfBenefit_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , explanationOfBenefit_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , explanationOfBenefit_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefit_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefit_identifier :: [Identifier]
          -- ^ The EOB Business Identifier.
        , explanationOfBenefit_status :: Maybe ExplanationOfBenefitStatus
          -- ^ The status of the resource instance.
        , explanationOfBenefit_type :: Maybe CodeableConcept
          -- ^ The category of claim, eg, oral, pharmacy, vision, 
          --   insitutional, professional.
        , explanationOfBenefit_subType :: [CodeableConcept]
          -- ^ A finer grained suite of claim subtype codes which may 
          --   convey Inpatient vs Outpatient and/or a specialty service. 
          --   In the US the BillType.
        , explanationOfBenefit_patient :: Maybe Reference
          -- ^ Patient Resource.
        , explanationOfBenefit_billablePeriod :: Maybe Period
          -- ^ The billable period for which charges are being submitted.
        , explanationOfBenefit_created :: Maybe DateTime
          -- ^ The date when the EOB was created.
        , explanationOfBenefit_enterer :: Maybe Reference
          -- ^ The person who created the explanation of benefit.
        , explanationOfBenefit_insurer :: Maybe Reference
          -- ^ The insurer which is responsible for the explanation of 
          --   benefit.
        , explanationOfBenefit_provider :: Maybe Reference
          -- ^ The provider which is responsible for the claim.
        , explanationOfBenefit_organization :: Maybe Reference
          -- ^ The provider which is responsible for the claim.
        , explanationOfBenefit_referral :: Maybe Reference
          -- ^ The referral resource which lists the date, practitioner, 
          --   reason and other supporting information.
        , explanationOfBenefit_facility :: Maybe Reference
          -- ^ Facility where the services were provided.
        , explanationOfBenefit_claim :: Maybe Reference
          -- ^ The business identifier for the instance: invoice number, 
          --   claim number, pre-determination or pre-authorization 
          --   number.
        , explanationOfBenefit_claimResponse :: Maybe Reference
          -- ^ The business identifier for the instance: invoice number, 
          --   claim number, pre-determination or pre-authorization 
          --   number.
        , explanationOfBenefit_outcome :: Maybe CodeableConcept
          -- ^ Processing outcome errror, partial or complete processing.
        , explanationOfBenefit_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , explanationOfBenefit_related :: [ExplanationOfBenefitRelated]
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , explanationOfBenefit_prescription :: Maybe Reference
          -- ^ Prescription to support the dispensing of Pharmacy or 
          --   Vision products.
        , explanationOfBenefit_originalPrescription :: Maybe Reference
          -- ^ Original prescription which has been superceded by this 
          --   prescription to support the dispensing of pharmacy 
          --   services, medications or products. For example, a physician 
          --   may prescribe a medication which the pharmacy determines is 
          --   contraindicated, or for which the patient has an 
          --   intolerance, and therefor issues a new precription for an 
          --   alternate medication which has the same theraputic intent. 
          --   The prescription from the pharmacy becomes the 
          --   'prescription' and that from the physician becomes the 
          --   'original prescription'.
        , explanationOfBenefit_payee :: Maybe ExplanationOfBenefitPayee
          -- ^ The party to be reimbursed for the services.
        , explanationOfBenefit_information :: [ExplanationOfBenefitInformation]
          -- ^ Additional information codes regarding exceptions, special 
          --   considerations, the condition, situation, prior or 
          --   concurrent issues. Often there are mutiple jurisdiction 
          --   specific valuesets which are required.
        , explanationOfBenefit_careTeam :: [ExplanationOfBenefitCareTeam]
          -- ^ The members of the team who provided the overall service as 
          --   well as their role and whether responsible and 
          --   qualifications.
        , explanationOfBenefit_diagnosis :: [ExplanationOfBenefitDiagnosis]
          -- ^ Ordered list of patient diagnosis for which care is sought.
        , explanationOfBenefit_procedure :: [ExplanationOfBenefitProcedure]
          -- ^ Ordered list of patient procedures performed to support the 
          --   adjudication.
        , explanationOfBenefit_precedence :: Maybe PositiveInt
          -- ^ Precedence (primary, secondary, etc.).
        , explanationOfBenefit_insurance :: Maybe ExplanationOfBenefitInsurance
          -- ^ Financial instrument by which payment information for 
          --   health care.
        , explanationOfBenefit_accident :: Maybe ExplanationOfBenefitAccident
          -- ^ An accident which resulted in the need for healthcare 
          --   services.
        , explanationOfBenefit_employmentImpacted :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   precluded from working due to the treatable condition(s).
        , explanationOfBenefit_hospitalization :: Maybe Period
          -- ^ The start and optional end dates of when the patient was 
          --   confined to a treatment center.
        , explanationOfBenefit_item :: [ExplanationOfBenefitItem]
          -- ^ First tier of goods and services.
        , explanationOfBenefit_addItem :: [ExplanationOfBenefitAddItem]
          -- ^ The first tier service adjudications for payor added 
          --   services.
        , explanationOfBenefit_totalCost :: Maybe Money
          -- ^ The total cost of the services reported.
        , explanationOfBenefit_unallocDeductable :: Maybe Money
          -- ^ The amount of deductable applied which was not allocated to 
          --   any particular service line.
        , explanationOfBenefit_totalBenefit :: Maybe Money
          -- ^ Total amount of benefit payable (Equal to sum of the 
          --   Benefit amounts from all detail lines and additions less 
          --   the Unallocated Deductable).
        , explanationOfBenefit_payment :: Maybe ExplanationOfBenefitPayment
          -- ^ Payment details for the claim if the claim has been paid.
        , explanationOfBenefit_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , explanationOfBenefit_processNote :: [ExplanationOfBenefitProcessNote]
          -- ^ Note text.
        , explanationOfBenefit_benefitBalance :: [ExplanationOfBenefitBenefitBalance]
          -- ^ Balance by Benefit Category.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefit where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ExplanationOfBenefit
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "subType")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "billablePeriod")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "insurer")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "referral")
            `apply` optional (parseSchemaType "facility")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "claimResponse")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` many (parseSchemaType "related")
            `apply` optional (parseSchemaType "prescription")
            `apply` optional (parseSchemaType "originalPrescription")
            `apply` optional (parseSchemaType "payee")
            `apply` many (parseSchemaType "information")
            `apply` many (parseSchemaType "careTeam")
            `apply` many (parseSchemaType "diagnosis")
            `apply` many (parseSchemaType "procedure")
            `apply` optional (parseSchemaType "precedence")
            `apply` optional (parseSchemaType "insurance")
            `apply` optional (parseSchemaType "accident")
            `apply` optional (parseSchemaType "employmentImpacted")
            `apply` optional (parseSchemaType "hospitalization")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "addItem")
            `apply` optional (parseSchemaType "totalCost")
            `apply` optional (parseSchemaType "unallocDeductable")
            `apply` optional (parseSchemaType "totalBenefit")
            `apply` optional (parseSchemaType "payment")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "benefitBalance")
    schemaTypeToXML s x@ExplanationOfBenefit{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ explanationOfBenefit_id x
            , maybe [] (schemaTypeToXML "meta") $ explanationOfBenefit_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ explanationOfBenefit_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ explanationOfBenefit_language x
            , maybe [] (schemaTypeToXML "text") $ explanationOfBenefit_text x
            , concatMap (schemaTypeToXML "contained") $ explanationOfBenefit_contained x
            , concatMap (schemaTypeToXML "extension") $ explanationOfBenefit_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefit_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ explanationOfBenefit_identifier x
            , maybe [] (schemaTypeToXML "status") $ explanationOfBenefit_status x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefit_type x
            , concatMap (schemaTypeToXML "subType") $ explanationOfBenefit_subType x
            , maybe [] (schemaTypeToXML "patient") $ explanationOfBenefit_patient x
            , maybe [] (schemaTypeToXML "billablePeriod") $ explanationOfBenefit_billablePeriod x
            , maybe [] (schemaTypeToXML "created") $ explanationOfBenefit_created x
            , maybe [] (schemaTypeToXML "enterer") $ explanationOfBenefit_enterer x
            , maybe [] (schemaTypeToXML "insurer") $ explanationOfBenefit_insurer x
            , maybe [] (schemaTypeToXML "provider") $ explanationOfBenefit_provider x
            , maybe [] (schemaTypeToXML "organization") $ explanationOfBenefit_organization x
            , maybe [] (schemaTypeToXML "referral") $ explanationOfBenefit_referral x
            , maybe [] (schemaTypeToXML "facility") $ explanationOfBenefit_facility x
            , maybe [] (schemaTypeToXML "claim") $ explanationOfBenefit_claim x
            , maybe [] (schemaTypeToXML "claimResponse") $ explanationOfBenefit_claimResponse x
            , maybe [] (schemaTypeToXML "outcome") $ explanationOfBenefit_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ explanationOfBenefit_disposition x
            , concatMap (schemaTypeToXML "related") $ explanationOfBenefit_related x
            , maybe [] (schemaTypeToXML "prescription") $ explanationOfBenefit_prescription x
            , maybe [] (schemaTypeToXML "originalPrescription") $ explanationOfBenefit_originalPrescription x
            , maybe [] (schemaTypeToXML "payee") $ explanationOfBenefit_payee x
            , concatMap (schemaTypeToXML "information") $ explanationOfBenefit_information x
            , concatMap (schemaTypeToXML "careTeam") $ explanationOfBenefit_careTeam x
            , concatMap (schemaTypeToXML "diagnosis") $ explanationOfBenefit_diagnosis x
            , concatMap (schemaTypeToXML "procedure") $ explanationOfBenefit_procedure x
            , maybe [] (schemaTypeToXML "precedence") $ explanationOfBenefit_precedence x
            , maybe [] (schemaTypeToXML "insurance") $ explanationOfBenefit_insurance x
            , maybe [] (schemaTypeToXML "accident") $ explanationOfBenefit_accident x
            , maybe [] (schemaTypeToXML "employmentImpacted") $ explanationOfBenefit_employmentImpacted x
            , maybe [] (schemaTypeToXML "hospitalization") $ explanationOfBenefit_hospitalization x
            , concatMap (schemaTypeToXML "item") $ explanationOfBenefit_item x
            , concatMap (schemaTypeToXML "addItem") $ explanationOfBenefit_addItem x
            , maybe [] (schemaTypeToXML "totalCost") $ explanationOfBenefit_totalCost x
            , maybe [] (schemaTypeToXML "unallocDeductable") $ explanationOfBenefit_unallocDeductable x
            , maybe [] (schemaTypeToXML "totalBenefit") $ explanationOfBenefit_totalBenefit x
            , maybe [] (schemaTypeToXML "payment") $ explanationOfBenefit_payment x
            , maybe [] (schemaTypeToXML "form") $ explanationOfBenefit_form x
            , concatMap (schemaTypeToXML "processNote") $ explanationOfBenefit_processNote x
            , concatMap (schemaTypeToXML "benefitBalance") $ explanationOfBenefit_benefitBalance x
            ]
instance Extension ExplanationOfBenefit DomainResource where
    supertype (ExplanationOfBenefit e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41 e42 e43 e44 e45 e46) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ExplanationOfBenefit Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ExplanationOfBenefit -> DomainResource)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitRelated = ExplanationOfBenefitRelated
        { explanationOfBenefitRelated_id :: Maybe String_primitive
        , explanationOfBenefitRelated_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitRelated_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitRelated_claim :: Maybe Reference
          -- ^ Other claims which are related to this claim such as prior 
          --   claim versions or for related services.
        , explanationOfBenefitRelated_relationship :: Maybe CodeableConcept
          -- ^ For example prior or umbrella.
        , explanationOfBenefitRelated_reference :: Maybe Identifier
          -- ^ An alternate organizational reference to the case or file 
          --   to which this particular claim pertains - eg 
          --   Property/Casualy insurer claim # or Workers Compensation 
          --   case # .
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitRelated where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitRelated a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "claim")
            `apply` optional (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "reference")
    schemaTypeToXML s x@ExplanationOfBenefitRelated{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitRelated_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitRelated_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitRelated_modifierExtension x
            , maybe [] (schemaTypeToXML "claim") $ explanationOfBenefitRelated_claim x
            , maybe [] (schemaTypeToXML "relationship") $ explanationOfBenefitRelated_relationship x
            , maybe [] (schemaTypeToXML "reference") $ explanationOfBenefitRelated_reference x
            ]
instance Extension ExplanationOfBenefitRelated BackboneElement where
    supertype (ExplanationOfBenefitRelated a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitRelated Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitRelated -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitPayee = ExplanationOfBenefitPayee
        { explanationOfBenefitPayee_id :: Maybe String_primitive
        , explanationOfBenefitPayee_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitPayee_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitPayee_type :: Maybe CodeableConcept
          -- ^ Type of Party to be reimbursed: Subscriber, provider, 
          --   other.
        , explanationOfBenefitPayee_resourceType :: Maybe CodeableConcept
          -- ^ organization | patient | practitioner | relatedperson.
        , explanationOfBenefitPayee_party :: Maybe Reference
          -- ^ Party to be reimbursed: Subscriber, provider, other.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitPayee where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitPayee a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "resourceType")
            `apply` optional (parseSchemaType "party")
    schemaTypeToXML s x@ExplanationOfBenefitPayee{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitPayee_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitPayee_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitPayee_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefitPayee_type x
            , maybe [] (schemaTypeToXML "resourceType") $ explanationOfBenefitPayee_resourceType x
            , maybe [] (schemaTypeToXML "party") $ explanationOfBenefitPayee_party x
            ]
instance Extension ExplanationOfBenefitPayee BackboneElement where
    supertype (ExplanationOfBenefitPayee a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitPayee Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitPayee -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitInformation = ExplanationOfBenefitInformation
        { explanationOfBenefitInformation_id :: Maybe String_primitive
        , explanationOfBenefitInformation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitInformation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitInformation_sequence :: PositiveInt
          -- ^ Sequence of the information element which serves to provide 
          --   a link.
        , explanationOfBenefitInformation_category :: CodeableConcept
          -- ^ The general class of the information supplied: information; 
          --   exception; accident, employment; onset, etc.
        , explanationOfBenefitInformation_code :: Maybe CodeableConcept
          -- ^ System and code pertaining to the specific information 
          --   regarding special conditions relating to the setting, 
          --   treatment or patient for which care is sought which may 
          --   influence the adjudication.
        , explanationOfBenefitInformation_choice5 :: (Maybe (OneOf2 Date Period))
          -- ^ The date when or period to which this information refers.
          --   
          --   Choice between:
          --   
          --   (1) timingDate
          --   
          --   (2) timingPeriod
        , explanationOfBenefitInformation_choice6 :: (Maybe (OneOf4 Xsd.XsdString Quantity Attachment Reference))
          -- ^ Additional data or information such as resources, 
          --   documents, images etc. including references to the data or 
          --   the actual inclusion of the data.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueQuantity
          --   
          --   (3) valueAttachment
          --   
          --   (4) valueReference
        , explanationOfBenefitInformation_reason :: Maybe Coding
          -- ^ For example, provides the reason for: the additional stay, 
          --   or missing tooth or any other situation where a reason code 
          --   is required in addition to the content.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitInformation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitInformation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "code")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "timingDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timingPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf4 (parseSchemaType "valueString"))
                                     , ("Quantity", fmap TwoOf4 (parseSchemaType "valueQuantity"))
                                     , ("Attachment", fmap ThreeOf4 (parseSchemaType "valueAttachment"))
                                     , ("Reference", fmap FourOf4 (parseSchemaType "valueReference"))
                                     ])
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@ExplanationOfBenefitInformation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitInformation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitInformation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitInformation_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitInformation_sequence x
            , schemaTypeToXML "category" $ explanationOfBenefitInformation_category x
            , maybe [] (schemaTypeToXML "code") $ explanationOfBenefitInformation_code x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timingDate")
                                    (schemaTypeToXML "timingPeriod")
                                   ) $ explanationOfBenefitInformation_choice5 x
            , maybe [] (foldOneOf4  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueQuantity")
                                    (schemaTypeToXML "valueAttachment")
                                    (schemaTypeToXML "valueReference")
                                   ) $ explanationOfBenefitInformation_choice6 x
            , maybe [] (schemaTypeToXML "reason") $ explanationOfBenefitInformation_reason x
            ]
instance Extension ExplanationOfBenefitInformation BackboneElement where
    supertype (ExplanationOfBenefitInformation a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitInformation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitInformation -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitCareTeam = ExplanationOfBenefitCareTeam
        { explanationOfBenefitCareTeam_id :: Maybe String_primitive
        , explanationOfBenefitCareTeam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitCareTeam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitCareTeam_sequence :: PositiveInt
          -- ^ Sequence of careteam which serves to order and provide a 
          --   link.
        , explanationOfBenefitCareTeam_provider :: Reference
          -- ^ The members of the team who provided the overall service.
        , explanationOfBenefitCareTeam_responsible :: Maybe Boolean
          -- ^ The practitioner who is billing and responsible for the 
          --   claimed services rendered to the patient.
        , explanationOfBenefitCareTeam_role :: Maybe CodeableConcept
          -- ^ The lead, assisting or supervising practitioner and their 
          --   discipline if a multidisiplinary team.
        , explanationOfBenefitCareTeam_qualification :: Maybe CodeableConcept
          -- ^ The qualification which is applicable for this service.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitCareTeam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitCareTeam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "provider"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "role")
            `apply` optional (parseSchemaType "qualification")
    schemaTypeToXML s x@ExplanationOfBenefitCareTeam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitCareTeam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitCareTeam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitCareTeam_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitCareTeam_sequence x
            , schemaTypeToXML "provider" $ explanationOfBenefitCareTeam_provider x
            , maybe [] (schemaTypeToXML "responsible") $ explanationOfBenefitCareTeam_responsible x
            , maybe [] (schemaTypeToXML "role") $ explanationOfBenefitCareTeam_role x
            , maybe [] (schemaTypeToXML "qualification") $ explanationOfBenefitCareTeam_qualification x
            ]
instance Extension ExplanationOfBenefitCareTeam BackboneElement where
    supertype (ExplanationOfBenefitCareTeam a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitCareTeam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitCareTeam -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitDiagnosis = ExplanationOfBenefitDiagnosis
        { explanationOfBenefitDiagnosis_id :: Maybe String_primitive
        , explanationOfBenefitDiagnosis_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitDiagnosis_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitDiagnosis_sequence :: PositiveInt
          -- ^ Sequence of diagnosis which serves to provide a link.
        , explanationOfBenefitDiagnosis_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ The diagnosis.
          --   
          --   Choice between:
          --   
          --   (1) diagnosisCodeableConcept
          --   
          --   (2) diagnosisReference
        , explanationOfBenefitDiagnosis_type :: [CodeableConcept]
          -- ^ The type of the Diagnosis, for example: admitting, primary, 
          --   secondary, discharge.
        , explanationOfBenefitDiagnosis_packageCode :: Maybe CodeableConcept
          -- ^ The package billing code, for example DRG, based on the 
          --   assigned grouping code system.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitDiagnosis where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitDiagnosis a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "diagnosisCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "diagnosisReference"))
                           ]
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "packageCode")
    schemaTypeToXML s x@ExplanationOfBenefitDiagnosis{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitDiagnosis_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitDiagnosis_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitDiagnosis_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitDiagnosis_sequence x
            , foldOneOf2  (schemaTypeToXML "diagnosisCodeableConcept")
                          (schemaTypeToXML "diagnosisReference")
                          $ explanationOfBenefitDiagnosis_choice3 x
            , concatMap (schemaTypeToXML "type") $ explanationOfBenefitDiagnosis_type x
            , maybe [] (schemaTypeToXML "packageCode") $ explanationOfBenefitDiagnosis_packageCode x
            ]
instance Extension ExplanationOfBenefitDiagnosis BackboneElement where
    supertype (ExplanationOfBenefitDiagnosis a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitDiagnosis Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitDiagnosis -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitProcedure = ExplanationOfBenefitProcedure
        { explanationOfBenefitProcedure_id :: Maybe String_primitive
        , explanationOfBenefitProcedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitProcedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitProcedure_sequence :: PositiveInt
          -- ^ Sequence of procedures which serves to order and provide a 
          --   link.
        , explanationOfBenefitProcedure_date :: Maybe DateTime
          -- ^ Date and optionally time the procedure was performed .
        , explanationOfBenefitProcedure_choice4 :: OneOf2 CodeableConcept Reference
          -- ^ The procedure code.
          --   
          --   Choice between:
          --   
          --   (1) procedureCodeableConcept
          --   
          --   (2) procedureReference
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitProcedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitProcedure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` optional (parseSchemaType "date")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "procedureCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "procedureReference"))
                           ]
    schemaTypeToXML s x@ExplanationOfBenefitProcedure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitProcedure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitProcedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitProcedure_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitProcedure_sequence x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefitProcedure_date x
            , foldOneOf2  (schemaTypeToXML "procedureCodeableConcept")
                          (schemaTypeToXML "procedureReference")
                          $ explanationOfBenefitProcedure_choice4 x
            ]
instance Extension ExplanationOfBenefitProcedure BackboneElement where
    supertype (ExplanationOfBenefitProcedure a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitProcedure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitProcedure -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitInsurance = ExplanationOfBenefitInsurance
        { explanationOfBenefitInsurance_id :: Maybe String_primitive
        , explanationOfBenefitInsurance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitInsurance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitInsurance_coverage :: Maybe Reference
          -- ^ Reference to the program or plan identification, 
          --   underwriter or payor.
        , explanationOfBenefitInsurance_preAuthRef :: [Xsd.XsdString]
          -- ^ A list of references from the Insurer to which these 
          --   services pertain.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitInsurance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitInsurance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "coverage")
            `apply` many (parseSchemaType "preAuthRef")
    schemaTypeToXML s x@ExplanationOfBenefitInsurance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitInsurance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitInsurance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitInsurance_modifierExtension x
            , maybe [] (schemaTypeToXML "coverage") $ explanationOfBenefitInsurance_coverage x
            , concatMap (schemaTypeToXML "preAuthRef") $ explanationOfBenefitInsurance_preAuthRef x
            ]
instance Extension ExplanationOfBenefitInsurance BackboneElement where
    supertype (ExplanationOfBenefitInsurance a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitInsurance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitInsurance -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitAccident = ExplanationOfBenefitAccident
        { explanationOfBenefitAccident_id :: Maybe String_primitive
        , explanationOfBenefitAccident_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitAccident_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitAccident_date :: Maybe Date
          -- ^ Date of an accident which these services are addressing.
        , explanationOfBenefitAccident_type :: Maybe CodeableConcept
          -- ^ Type of accident: work, auto, etc.
        , explanationOfBenefitAccident_choice4 :: (Maybe (OneOf2 Address Reference))
          -- ^ Where the accident occurred.
          --   
          --   Choice between:
          --   
          --   (1) locationAddress
          --   
          --   (2) locationReference
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitAccident where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitAccident a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Address", fmap OneOf2 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "locationReference"))
                                     ])
    schemaTypeToXML s x@ExplanationOfBenefitAccident{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitAccident_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitAccident_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitAccident_modifierExtension x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefitAccident_date x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefitAccident_type x
            , maybe [] (foldOneOf2  (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ explanationOfBenefitAccident_choice4 x
            ]
instance Extension ExplanationOfBenefitAccident BackboneElement where
    supertype (ExplanationOfBenefitAccident a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitAccident Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitAccident -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitItem = ExplanationOfBenefitItem
        { explanationOfBenefitItem_id :: Maybe String_primitive
        , explanationOfBenefitItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitItem_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefitItem_careTeamLinkId :: [PositiveInt]
          -- ^ Careteam applicable for this service or product line.
        , explanationOfBenefitItem_diagnosisLinkId :: [PositiveInt]
          -- ^ Diagnosis applicable for this service or product line.
        , explanationOfBenefitItem_procedureLinkId :: [PositiveInt]
          -- ^ Procedures applicable for this service or product line.
        , explanationOfBenefitItem_informationLinkId :: [PositiveInt]
          -- ^ Exceptions, special conditions and supporting information 
          --   pplicable for this service or product line.
        , explanationOfBenefitItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefitItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefitItem_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefitItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefitItem_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefitItem_choice12 :: (Maybe (OneOf2 Date Period))
          -- ^ The date or dates when the enclosed suite of services were 
          --   performed or completed.
          --   
          --   Choice between:
          --   
          --   (1) servicedDate
          --   
          --   (2) servicedPeriod
        , explanationOfBenefitItem_choice13 :: (Maybe (OneOf3 CodeableConcept Address Reference))
          -- ^ Where the service was provided.
          --   
          --   Choice between:
          --   
          --   (1) locationCodeableConcept
          --   
          --   (2) locationAddress
          --   
          --   (3) locationReference
        , explanationOfBenefitItem_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefitItem_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , explanationOfBenefitItem_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefitItem_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefitItem_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefitItem_bodySite :: Maybe CodeableConcept
          -- ^ Physical service site on the patient (limb, tooth, etc).
        , explanationOfBenefitItem_subSite :: [CodeableConcept]
          -- ^ A region or surface of the site, eg. limb region or tooth 
          --   surface(s).
        , explanationOfBenefitItem_encounter :: [Reference]
          -- ^ A billed item may include goods or services provided in 
          --   multiple encounters.
        , explanationOfBenefitItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefitItem_adjudication :: [ExplanationOfBenefitAdjudication]
          -- ^ The adjudications results.
        , explanationOfBenefitItem_detail :: [ExplanationOfBenefitDetail]
          -- ^ Second tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` many (parseSchemaType "careTeamLinkId")
            `apply` many (parseSchemaType "diagnosisLinkId")
            `apply` many (parseSchemaType "procedureLinkId")
            `apply` many (parseSchemaType "informationLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "servicedDate"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "servicedPeriod"))
                                     ])
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf3 (parseSchemaType "locationCodeableConcept"))
                                     , ("Address", fmap TwoOf3 (parseSchemaType "locationAddress"))
                                     , ("Reference", fmap ThreeOf3 (parseSchemaType "locationReference"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` optional (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "subSite")
            `apply` many (parseSchemaType "encounter")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ExplanationOfBenefitItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitItem_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitItem_sequence x
            , concatMap (schemaTypeToXML "careTeamLinkId") $ explanationOfBenefitItem_careTeamLinkId x
            , concatMap (schemaTypeToXML "diagnosisLinkId") $ explanationOfBenefitItem_diagnosisLinkId x
            , concatMap (schemaTypeToXML "procedureLinkId") $ explanationOfBenefitItem_procedureLinkId x
            , concatMap (schemaTypeToXML "informationLinkId") $ explanationOfBenefitItem_informationLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefitItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefitItem_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefitItem_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefitItem_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefitItem_programCode x
            , maybe [] (foldOneOf2  (schemaTypeToXML "servicedDate")
                                    (schemaTypeToXML "servicedPeriod")
                                   ) $ explanationOfBenefitItem_choice12 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "locationCodeableConcept")
                                    (schemaTypeToXML "locationAddress")
                                    (schemaTypeToXML "locationReference")
                                   ) $ explanationOfBenefitItem_choice13 x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefitItem_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefitItem_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefitItem_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefitItem_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefitItem_udi x
            , maybe [] (schemaTypeToXML "bodySite") $ explanationOfBenefitItem_bodySite x
            , concatMap (schemaTypeToXML "subSite") $ explanationOfBenefitItem_subSite x
            , concatMap (schemaTypeToXML "encounter") $ explanationOfBenefitItem_encounter x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefitItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefitItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ explanationOfBenefitItem_detail x
            ]
instance Extension ExplanationOfBenefitItem BackboneElement where
    supertype (ExplanationOfBenefitItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitItem -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitAdjudication = ExplanationOfBenefitAdjudication
        { explanationOfBenefitAdjudication_id :: Maybe String_primitive
        , explanationOfBenefitAdjudication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitAdjudication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitAdjudication_category :: CodeableConcept
          -- ^ Code indicating: Co-Pay, deductable, elegible, benefit, 
          --   tax, etc.
        , explanationOfBenefitAdjudication_reason :: Maybe CodeableConcept
          -- ^ Adjudication reason such as limit reached.
        , explanationOfBenefitAdjudication_amount :: Maybe Money
          -- ^ Monitory amount associated with the code.
        , explanationOfBenefitAdjudication_value :: Maybe Decimal
          -- ^ A non-monetary value for example a percentage. Mutually 
          --   exclusive to the amount element above.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitAdjudication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitAdjudication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@ExplanationOfBenefitAdjudication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitAdjudication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitAdjudication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitAdjudication_modifierExtension x
            , schemaTypeToXML "category" $ explanationOfBenefitAdjudication_category x
            , maybe [] (schemaTypeToXML "reason") $ explanationOfBenefitAdjudication_reason x
            , maybe [] (schemaTypeToXML "amount") $ explanationOfBenefitAdjudication_amount x
            , maybe [] (schemaTypeToXML "value") $ explanationOfBenefitAdjudication_value x
            ]
instance Extension ExplanationOfBenefitAdjudication BackboneElement where
    supertype (ExplanationOfBenefitAdjudication a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitAdjudication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitAdjudication -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitDetail = ExplanationOfBenefitDetail
        { explanationOfBenefitDetail_id :: Maybe String_primitive
        , explanationOfBenefitDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefitDetail_type :: CodeableConcept
          -- ^ The type of product or service.
        , explanationOfBenefitDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefitDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefitDetail_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefitDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefitDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefitDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefitDetail_unitPrice :: Maybe Money
          -- ^ If the item is a node then this is the fee for the product 
          --   or service, otherwise this is the total of the fees for the 
          --   children of the group.
        , explanationOfBenefitDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefitDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefitDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefitDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefitDetail_adjudication :: [ExplanationOfBenefitAdjudication]
          -- ^ The adjudications results.
        , explanationOfBenefitDetail_subDetail :: [ExplanationOfBenefitSubDetail]
          -- ^ Third tier of goods and services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "subDetail")
    schemaTypeToXML s x@ExplanationOfBenefitDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitDetail_sequence x
            , schemaTypeToXML "type" $ explanationOfBenefitDetail_type x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefitDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefitDetail_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefitDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefitDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefitDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefitDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefitDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefitDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefitDetail_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefitDetail_udi x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefitDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefitDetail_adjudication x
            , concatMap (schemaTypeToXML "subDetail") $ explanationOfBenefitDetail_subDetail x
            ]
instance Extension ExplanationOfBenefitDetail BackboneElement where
    supertype (ExplanationOfBenefitDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitDetail -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitSubDetail = ExplanationOfBenefitSubDetail
        { explanationOfBenefitSubDetail_id :: Maybe String_primitive
        , explanationOfBenefitSubDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitSubDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitSubDetail_sequence :: PositiveInt
          -- ^ A service line number.
        , explanationOfBenefitSubDetail_type :: CodeableConcept
          -- ^ The type of product or service.
        , explanationOfBenefitSubDetail_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefitSubDetail_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefitSubDetail_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , explanationOfBenefitSubDetail_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefitSubDetail_programCode :: [CodeableConcept]
          -- ^ For programs which require reson codes for the inclusion, 
          --   covering, of this billed item under the program or 
          --   sub-program.
        , explanationOfBenefitSubDetail_quantity :: Maybe Quantity
          -- ^ The number of repetitions of a service or product.
        , explanationOfBenefitSubDetail_unitPrice :: Maybe Money
          -- ^ The fee for an addittional service or product or charge.
        , explanationOfBenefitSubDetail_factor :: Maybe Decimal
          -- ^ A real number that represents a multiplier used in 
          --   determining the overall value of services delivered and/or 
          --   goods received. The concept of a Factor allows for a 
          --   discount or surcharge multiplier to be applied to a 
          --   monetary amount.
        , explanationOfBenefitSubDetail_net :: Maybe Money
          -- ^ The quantity times the unit price for an addittional 
          --   service or product or charge. For example, the formula: 
          --   unit Quantity * unit Price (Cost per Point) * factor Number 
          --   * points = net Amount. Quantity, factor and points are 
          --   assumed to be 1 if not supplied.
        , explanationOfBenefitSubDetail_udi :: [Reference]
          -- ^ List of Unique Device Identifiers associated with this line 
          --   item.
        , explanationOfBenefitSubDetail_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefitSubDetail_adjudication :: [ExplanationOfBenefitAdjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitSubDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitSubDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequence"
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "programCode")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "unitPrice")
            `apply` optional (parseSchemaType "factor")
            `apply` optional (parseSchemaType "net")
            `apply` many (parseSchemaType "udi")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ExplanationOfBenefitSubDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitSubDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitSubDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitSubDetail_modifierExtension x
            , schemaTypeToXML "sequence" $ explanationOfBenefitSubDetail_sequence x
            , schemaTypeToXML "type" $ explanationOfBenefitSubDetail_type x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefitSubDetail_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefitSubDetail_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefitSubDetail_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefitSubDetail_modifier x
            , concatMap (schemaTypeToXML "programCode") $ explanationOfBenefitSubDetail_programCode x
            , maybe [] (schemaTypeToXML "quantity") $ explanationOfBenefitSubDetail_quantity x
            , maybe [] (schemaTypeToXML "unitPrice") $ explanationOfBenefitSubDetail_unitPrice x
            , maybe [] (schemaTypeToXML "factor") $ explanationOfBenefitSubDetail_factor x
            , maybe [] (schemaTypeToXML "net") $ explanationOfBenefitSubDetail_net x
            , concatMap (schemaTypeToXML "udi") $ explanationOfBenefitSubDetail_udi x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefitSubDetail_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefitSubDetail_adjudication x
            ]
instance Extension ExplanationOfBenefitSubDetail BackboneElement where
    supertype (ExplanationOfBenefitSubDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitSubDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitSubDetail -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitAddItem = ExplanationOfBenefitAddItem
        { explanationOfBenefitAddItem_id :: Maybe String_primitive
        , explanationOfBenefitAddItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitAddItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitAddItem_sequenceLinkId :: [PositiveInt]
          -- ^ List of input service items which this service line is 
          --   intended to replace.
        , explanationOfBenefitAddItem_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefitAddItem_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefitAddItem_service :: Maybe CodeableConcept
          -- ^ If this is an actual service or product line, ie. not a 
          --   Group, then use code to indicate the Professional Service 
          --   or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, 
          --   NCPDP,DIN,ACHI,CCI). If a grouping item then use a group 
          --   code to indicate the type of thing being grouped eg. 
          --   'glasses' or 'compound'.
        , explanationOfBenefitAddItem_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefitAddItem_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product.
        , explanationOfBenefitAddItem_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefitAddItem_adjudication :: [ExplanationOfBenefitAdjudication]
          -- ^ The adjudications results.
        , explanationOfBenefitAddItem_detail :: [ExplanationOfBenefitDetail1]
          -- ^ The second tier service adjudications for payor added 
          --   services.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitAddItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitAddItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "sequenceLinkId")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
            `apply` many (parseSchemaType "detail")
    schemaTypeToXML s x@ExplanationOfBenefitAddItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitAddItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitAddItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitAddItem_modifierExtension x
            , concatMap (schemaTypeToXML "sequenceLinkId") $ explanationOfBenefitAddItem_sequenceLinkId x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefitAddItem_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefitAddItem_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefitAddItem_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefitAddItem_modifier x
            , maybe [] (schemaTypeToXML "fee") $ explanationOfBenefitAddItem_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefitAddItem_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefitAddItem_adjudication x
            , concatMap (schemaTypeToXML "detail") $ explanationOfBenefitAddItem_detail x
            ]
instance Extension ExplanationOfBenefitAddItem BackboneElement where
    supertype (ExplanationOfBenefitAddItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitAddItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitAddItem -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitDetail1 = ExplanationOfBenefitDetail1
        { explanationOfBenefitDetail1_id :: Maybe String_primitive
        , explanationOfBenefitDetail1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitDetail1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitDetail1_revenue :: Maybe CodeableConcept
          -- ^ The type of reveneu or cost center providing the product 
          --   and/or service.
        , explanationOfBenefitDetail1_category :: Maybe CodeableConcept
          -- ^ Health Care Service Type Codes to identify the 
          --   classification of service or benefits.
        , explanationOfBenefitDetail1_service :: Maybe CodeableConcept
          -- ^ A code to indicate the Professional Service or Product 
          --   supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
        , explanationOfBenefitDetail1_modifier :: [CodeableConcept]
          -- ^ Item typification or modifiers codes, eg for Oral whether 
          --   the treatment is cosmetic or associated with TMJ, or for 
          --   medical whether the treatment was outside the clinic or out 
          --   of office hours.
        , explanationOfBenefitDetail1_fee :: Maybe Money
          -- ^ The fee charged for the professional service or product.
        , explanationOfBenefitDetail1_noteNumber :: [PositiveInt]
          -- ^ A list of note references to the notes provided below.
        , explanationOfBenefitDetail1_adjudication :: [ExplanationOfBenefitAdjudication]
          -- ^ The adjudications results.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitDetail1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitDetail1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "revenue")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "service")
            `apply` many (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "fee")
            `apply` many (parseSchemaType "noteNumber")
            `apply` many (parseSchemaType "adjudication")
    schemaTypeToXML s x@ExplanationOfBenefitDetail1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitDetail1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitDetail1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitDetail1_modifierExtension x
            , maybe [] (schemaTypeToXML "revenue") $ explanationOfBenefitDetail1_revenue x
            , maybe [] (schemaTypeToXML "category") $ explanationOfBenefitDetail1_category x
            , maybe [] (schemaTypeToXML "service") $ explanationOfBenefitDetail1_service x
            , concatMap (schemaTypeToXML "modifier") $ explanationOfBenefitDetail1_modifier x
            , maybe [] (schemaTypeToXML "fee") $ explanationOfBenefitDetail1_fee x
            , concatMap (schemaTypeToXML "noteNumber") $ explanationOfBenefitDetail1_noteNumber x
            , concatMap (schemaTypeToXML "adjudication") $ explanationOfBenefitDetail1_adjudication x
            ]
instance Extension ExplanationOfBenefitDetail1 BackboneElement where
    supertype (ExplanationOfBenefitDetail1 a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitDetail1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitDetail1 -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitPayment = ExplanationOfBenefitPayment
        { explanationOfBenefitPayment_id :: Maybe String_primitive
        , explanationOfBenefitPayment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitPayment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitPayment_type :: Maybe CodeableConcept
          -- ^ Whether this represents partial or complete payment of the 
          --   claim.
        , explanationOfBenefitPayment_adjustment :: Maybe Money
          -- ^ Adjustment to the payment of this transaction which is not 
          --   related to adjudication of this transaction.
        , explanationOfBenefitPayment_adjustmentReason :: Maybe CodeableConcept
          -- ^ Reason for the payment adjustment.
        , explanationOfBenefitPayment_date :: Maybe Date
          -- ^ Estimated payment date.
        , explanationOfBenefitPayment_amount :: Maybe Money
          -- ^ Payable less any payment adjustment.
        , explanationOfBenefitPayment_identifier :: Maybe Identifier
          -- ^ Payment identifer.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitPayment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitPayment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "adjustment")
            `apply` optional (parseSchemaType "adjustmentReason")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
            `apply` optional (parseSchemaType "identifier")
    schemaTypeToXML s x@ExplanationOfBenefitPayment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitPayment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitPayment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitPayment_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefitPayment_type x
            , maybe [] (schemaTypeToXML "adjustment") $ explanationOfBenefitPayment_adjustment x
            , maybe [] (schemaTypeToXML "adjustmentReason") $ explanationOfBenefitPayment_adjustmentReason x
            , maybe [] (schemaTypeToXML "date") $ explanationOfBenefitPayment_date x
            , maybe [] (schemaTypeToXML "amount") $ explanationOfBenefitPayment_amount x
            , maybe [] (schemaTypeToXML "identifier") $ explanationOfBenefitPayment_identifier x
            ]
instance Extension ExplanationOfBenefitPayment BackboneElement where
    supertype (ExplanationOfBenefitPayment a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitPayment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitPayment -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitProcessNote = ExplanationOfBenefitProcessNote
        { explanationOfBenefitProcessNote_id :: Maybe String_primitive
        , explanationOfBenefitProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitProcessNote_number :: Maybe PositiveInt
          -- ^ An integer associated with each note which may be referred 
          --   to from each service line item.
        , explanationOfBenefitProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , explanationOfBenefitProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        , explanationOfBenefitProcessNote_language :: Maybe CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "number")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "language")
    schemaTypeToXML s x@ExplanationOfBenefitProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "number") $ explanationOfBenefitProcessNote_number x
            , maybe [] (schemaTypeToXML "type") $ explanationOfBenefitProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ explanationOfBenefitProcessNote_text x
            , maybe [] (schemaTypeToXML "language") $ explanationOfBenefitProcessNote_language x
            ]
instance Extension ExplanationOfBenefitProcessNote BackboneElement where
    supertype (ExplanationOfBenefitProcessNote a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitProcessNote -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitBenefitBalance = ExplanationOfBenefitBenefitBalance
        { explanationOfBenefitBenefitBalance_id :: Maybe String_primitive
        , explanationOfBenefitBenefitBalance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitBenefitBalance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitBenefitBalance_category :: CodeableConcept
          -- ^ Dental, Vision, Medical, Pharmacy, Rehab etc.
        , explanationOfBenefitBenefitBalance_subCategory :: Maybe CodeableConcept
          -- ^ Dental: basic, major, ortho; Vision exam, glasses, 
          --   contacts; etc.
        , explanationOfBenefitBenefitBalance_excluded :: Maybe Boolean
          -- ^ True if the indicated class of service is excluded from the 
          --   plan, missing or False indicated the service is included in 
          --   the coverage.
        , explanationOfBenefitBenefitBalance_name :: Maybe Xsd.XsdString
          -- ^ A short name or tag for the benefit, for example MED01, or 
          --   DENT2.
        , explanationOfBenefitBenefitBalance_description :: Maybe Xsd.XsdString
          -- ^ A richer description of the benefit, for example 'DENT2 
          --   covers 100% of basic, 50% of major but exclused Ortho, 
          --   Implants and Costmetic services'.
        , explanationOfBenefitBenefitBalance_network :: Maybe CodeableConcept
          -- ^ Network designation.
        , explanationOfBenefitBenefitBalance_unit :: Maybe CodeableConcept
          -- ^ Unit designation: individual or family.
        , explanationOfBenefitBenefitBalance_term :: Maybe CodeableConcept
          -- ^ The term or period of the values such as 'maximum lifetime 
          --   benefit' or 'maximum annual vistis'.
        , explanationOfBenefitBenefitBalance_financial :: [ExplanationOfBenefitFinancial]
          -- ^ Benefits Used to date.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitBenefitBalance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitBenefitBalance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "category"
            `apply` optional (parseSchemaType "subCategory")
            `apply` optional (parseSchemaType "excluded")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "network")
            `apply` optional (parseSchemaType "unit")
            `apply` optional (parseSchemaType "term")
            `apply` many (parseSchemaType "financial")
    schemaTypeToXML s x@ExplanationOfBenefitBenefitBalance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitBenefitBalance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitBenefitBalance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitBenefitBalance_modifierExtension x
            , schemaTypeToXML "category" $ explanationOfBenefitBenefitBalance_category x
            , maybe [] (schemaTypeToXML "subCategory") $ explanationOfBenefitBenefitBalance_subCategory x
            , maybe [] (schemaTypeToXML "excluded") $ explanationOfBenefitBenefitBalance_excluded x
            , maybe [] (schemaTypeToXML "name") $ explanationOfBenefitBenefitBalance_name x
            , maybe [] (schemaTypeToXML "description") $ explanationOfBenefitBenefitBalance_description x
            , maybe [] (schemaTypeToXML "network") $ explanationOfBenefitBenefitBalance_network x
            , maybe [] (schemaTypeToXML "unit") $ explanationOfBenefitBenefitBalance_unit x
            , maybe [] (schemaTypeToXML "term") $ explanationOfBenefitBenefitBalance_term x
            , concatMap (schemaTypeToXML "financial") $ explanationOfBenefitBenefitBalance_financial x
            ]
instance Extension ExplanationOfBenefitBenefitBalance BackboneElement where
    supertype (ExplanationOfBenefitBenefitBalance a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitBenefitBalance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitBenefitBalance -> BackboneElement)
              
 
-- | This resource provides: the claim details; adjudication 
--   details from the processing of a Claim; and optionally 
--   account balance information, for informing the subscriber 
--   of the benefits provided.
data ExplanationOfBenefitFinancial = ExplanationOfBenefitFinancial
        { explanationOfBenefitFinancial_id :: Maybe String_primitive
        , explanationOfBenefitFinancial_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , explanationOfBenefitFinancial_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , explanationOfBenefitFinancial_type :: CodeableConcept
          -- ^ Deductable, visits, benefit amount.
        , explanationOfBenefitFinancial_choice3 :: (Maybe (OneOf3 UnsignedInt Xsd.XsdString Money))
          -- ^ Benefits allowed.
          --   
          --   Choice between:
          --   
          --   (1) allowedUnsignedInt
          --   
          --   (2) allowedString
          --   
          --   (3) allowedMoney
        , explanationOfBenefitFinancial_choice4 :: (Maybe (OneOf2 UnsignedInt Money))
          -- ^ Benefits used.
          --   
          --   Choice between:
          --   
          --   (1) usedUnsignedInt
          --   
          --   (2) usedMoney
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitFinancial where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ExplanationOfBenefitFinancial a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf3 (parseSchemaType "allowedUnsignedInt"))
                                     , ("Xsd.XsdString", fmap TwoOf3 (parseSchemaType "allowedString"))
                                     , ("Money", fmap ThreeOf3 (parseSchemaType "allowedMoney"))
                                     ])
            `apply` optional (oneOf' [ ("UnsignedInt", fmap OneOf2 (parseSchemaType "usedUnsignedInt"))
                                     , ("Money", fmap TwoOf2 (parseSchemaType "usedMoney"))
                                     ])
    schemaTypeToXML s x@ExplanationOfBenefitFinancial{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitFinancial_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitFinancial_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ explanationOfBenefitFinancial_modifierExtension x
            , schemaTypeToXML "type" $ explanationOfBenefitFinancial_type x
            , maybe [] (foldOneOf3  (schemaTypeToXML "allowedUnsignedInt")
                                    (schemaTypeToXML "allowedString")
                                    (schemaTypeToXML "allowedMoney")
                                   ) $ explanationOfBenefitFinancial_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "usedUnsignedInt")
                                    (schemaTypeToXML "usedMoney")
                                   ) $ explanationOfBenefitFinancial_choice4 x
            ]
instance Extension ExplanationOfBenefitFinancial BackboneElement where
    supertype (ExplanationOfBenefitFinancial a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ExplanationOfBenefitFinancial Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ExplanationOfBenefitFinancial -> BackboneElement)
              
 
data ExplanationOfBenefitStatus_list
    = ExplanationOfBenefitStatus_list_Active
      -- ^ Active
    | ExplanationOfBenefitStatus_list_Cancelled
      -- ^ Cancelled
    | ExplanationOfBenefitStatus_list_Draft
      -- ^ Draft
    | ExplanationOfBenefitStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType ExplanationOfBenefitStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ExplanationOfBenefitStatus_list where
    acceptingParser =  do literal "active"; return ExplanationOfBenefitStatus_list_Active
                      `onFail` do literal "cancelled"; return ExplanationOfBenefitStatus_list_Cancelled
                      `onFail` do literal "draft"; return ExplanationOfBenefitStatus_list_Draft
                      `onFail` do literal "entered-in-error"; return ExplanationOfBenefitStatus_list_Entered_in_error
                      
    simpleTypeText ExplanationOfBenefitStatus_list_Active = "active"
    simpleTypeText ExplanationOfBenefitStatus_list_Cancelled = "cancelled"
    simpleTypeText ExplanationOfBenefitStatus_list_Draft = "draft"
    simpleTypeText ExplanationOfBenefitStatus_list_Entered_in_error = "entered-in-error"
 
data ExplanationOfBenefitStatus = ExplanationOfBenefitStatus
        { explanationOfBenefitStatus_id :: Maybe String_primitive
        , explanationOfBenefitStatus_value :: Maybe ExplanationOfBenefitStatus_list
        , explanationOfBenefitStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ExplanationOfBenefitStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ExplanationOfBenefitStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ExplanationOfBenefitStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ explanationOfBenefitStatus_id x
                       , maybe [] (toXMLAttribute "value") $ explanationOfBenefitStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ explanationOfBenefitStatus_extension x
            ]
instance Extension ExplanationOfBenefitStatus Element where
    supertype (ExplanationOfBenefitStatus a0 a1 e0) =
               Element a0 e0
 
-- | Significant health events and conditions for a person 
--   related to the patient relevant in the context of care for 
--   the patient.
elementFamilyMemberHistory :: XMLParser FamilyMemberHistory
elementFamilyMemberHistory = parseSchemaType "FamilyMemberHistory"
elementToXMLFamilyMemberHistory :: FamilyMemberHistory -> [Content ()]
elementToXMLFamilyMemberHistory = schemaTypeToXML "FamilyMemberHistory"
 
data FamilyMemberHistory = FamilyMemberHistory
        { familyMemberHistory_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , familyMemberHistory_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , familyMemberHistory_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , familyMemberHistory_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , familyMemberHistory_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , familyMemberHistory_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , familyMemberHistory_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , familyMemberHistory_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , familyMemberHistory_identifier :: [Identifier]
          -- ^ This records identifiers associated with this family member 
          --   history record that are defined by business processes and/ 
          --   or used to refer to it when a direct URL reference to the 
          --   resource itself is not appropriate (e.g. in CDA documents, 
          --   or in written / printed documentation).
        , familyMemberHistory_definition :: [Reference]
          -- ^ A protocol or questionnaire that was adhered to in whole or 
          --   in part by this event.
        , familyMemberHistory_status :: FamilyHistoryStatus
          -- ^ A code specifying the status of the record of the family 
          --   history of a specific family member.
        , familyMemberHistory_notDone :: Maybe Boolean
          -- ^ If true, indicates the taking of an individual family 
          --   member's history did not occur. The notDone element should 
          --   not be used to document negated conditions, such as a 
          --   family member that did not have a condition.
        , familyMemberHistory_notDoneReason :: Maybe CodeableConcept
          -- ^ Describes why the family member's history is absent.
        , familyMemberHistory_patient :: Reference
          -- ^ The person who this history concerns.
        , familyMemberHistory_date :: Maybe DateTime
          -- ^ The date (and possibly time) when the family member history 
          --   was taken.
        , familyMemberHistory_name :: Maybe Xsd.XsdString
          -- ^ This will either be a name or a description; e.g. 
          --   &quot;Aunt Susan&quot;, &quot;my cousin with the red 
          --   hair&quot;.
        , familyMemberHistory_relationship :: CodeableConcept
          -- ^ The type of relationship this person has to the patient 
          --   (father, mother, brother etc.).
        , familyMemberHistory_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the relative is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , familyMemberHistory_choice18 :: (Maybe (OneOf3 Period Date Xsd.XsdString))
          -- ^ The actual or approximate date of birth of the relative.
          --   
          --   Choice between:
          --   
          --   (1) bornPeriod
          --   
          --   (2) bornDate
          --   
          --   (3) bornString
        , familyMemberHistory_choice19 :: (Maybe (OneOf3 Age Range Xsd.XsdString))
          -- ^ The age of the relative at the time the family member 
          --   history is recorded.
          --   
          --   Choice between:
          --   
          --   (1) ageAge
          --   
          --   (2) ageRange
          --   
          --   (3) ageString
        , familyMemberHistory_estimatedAge :: Maybe Boolean
          -- ^ If true, indicates that the age value specified is an 
          --   estimated value.
        , familyMemberHistory_choice21 :: (Maybe (OneOf5 Boolean Age Range Date Xsd.XsdString))
          -- ^ Deceased flag or the actual or approximate age of the 
          --   relative at the time of death for the family member history 
          --   record.
          --   
          --   Choice between:
          --   
          --   (1) deceasedBoolean
          --   
          --   (2) deceasedAge
          --   
          --   (3) deceasedRange
          --   
          --   (4) deceasedDate
          --   
          --   (5) deceasedString
        , familyMemberHistory_reasonCode :: [CodeableConcept]
          -- ^ Describes why the family member history occurred in coded 
          --   or textual form.
        , familyMemberHistory_reasonReference :: [Reference]
          -- ^ Indicates a Condition, Observation, AllergyIntolerance, or 
          --   QuestionnaireResponse that justifies this family member 
          --   history event.
        , familyMemberHistory_note :: [Annotation]
          -- ^ This property allows a non condition-specific note to the 
          --   made about the related person. Ideally, the note would be 
          --   in the condition property, but this is not always possible.
        , familyMemberHistory_condition :: [FamilyMemberHistoryCondition]
          -- ^ The significant Conditions (or condition) that the family 
          --   member had. This is a repeating section to allow a system 
          --   to represent more than one condition per resource, though 
          --   there is nothing stopping multiple resources - one per 
          --   condition.
        }
        deriving (Eq,Show)
instance SchemaType FamilyMemberHistory where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return FamilyMemberHistory
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "relationship"
            `apply` optional (parseSchemaType "gender")
            `apply` optional (oneOf' [ ("Period", fmap OneOf3 (parseSchemaType "bornPeriod"))
                                     , ("Date", fmap TwoOf3 (parseSchemaType "bornDate"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "bornString"))
                                     ])
            `apply` optional (oneOf' [ ("Age", fmap OneOf3 (parseSchemaType "ageAge"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "ageRange"))
                                     , ("Xsd.XsdString", fmap ThreeOf3 (parseSchemaType "ageString"))
                                     ])
            `apply` optional (parseSchemaType "estimatedAge")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf5 (parseSchemaType "deceasedBoolean"))
                                     , ("Age", fmap TwoOf5 (parseSchemaType "deceasedAge"))
                                     , ("Range", fmap ThreeOf5 (parseSchemaType "deceasedRange"))
                                     , ("Date", fmap FourOf5 (parseSchemaType "deceasedDate"))
                                     , ("Xsd.XsdString", fmap FiveOf5 (parseSchemaType "deceasedString"))
                                     ])
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "condition")
    schemaTypeToXML s x@FamilyMemberHistory{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ familyMemberHistory_id x
            , maybe [] (schemaTypeToXML "meta") $ familyMemberHistory_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ familyMemberHistory_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ familyMemberHistory_language x
            , maybe [] (schemaTypeToXML "text") $ familyMemberHistory_text x
            , concatMap (schemaTypeToXML "contained") $ familyMemberHistory_contained x
            , concatMap (schemaTypeToXML "extension") $ familyMemberHistory_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ familyMemberHistory_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ familyMemberHistory_identifier x
            , concatMap (schemaTypeToXML "definition") $ familyMemberHistory_definition x
            , schemaTypeToXML "status" $ familyMemberHistory_status x
            , maybe [] (schemaTypeToXML "notDone") $ familyMemberHistory_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ familyMemberHistory_notDoneReason x
            , schemaTypeToXML "patient" $ familyMemberHistory_patient x
            , maybe [] (schemaTypeToXML "date") $ familyMemberHistory_date x
            , maybe [] (schemaTypeToXML "name") $ familyMemberHistory_name x
            , schemaTypeToXML "relationship" $ familyMemberHistory_relationship x
            , maybe [] (schemaTypeToXML "gender") $ familyMemberHistory_gender x
            , maybe [] (foldOneOf3  (schemaTypeToXML "bornPeriod")
                                    (schemaTypeToXML "bornDate")
                                    (schemaTypeToXML "bornString")
                                   ) $ familyMemberHistory_choice18 x
            , maybe [] (foldOneOf3  (schemaTypeToXML "ageAge")
                                    (schemaTypeToXML "ageRange")
                                    (schemaTypeToXML "ageString")
                                   ) $ familyMemberHistory_choice19 x
            , maybe [] (schemaTypeToXML "estimatedAge") $ familyMemberHistory_estimatedAge x
            , maybe [] (foldOneOf5  (schemaTypeToXML "deceasedBoolean")
                                    (schemaTypeToXML "deceasedAge")
                                    (schemaTypeToXML "deceasedRange")
                                    (schemaTypeToXML "deceasedDate")
                                    (schemaTypeToXML "deceasedString")
                                   ) $ familyMemberHistory_choice21 x
            , concatMap (schemaTypeToXML "reasonCode") $ familyMemberHistory_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ familyMemberHistory_reasonReference x
            , concatMap (schemaTypeToXML "note") $ familyMemberHistory_note x
            , concatMap (schemaTypeToXML "condition") $ familyMemberHistory_condition x
            ]
instance Extension FamilyMemberHistory DomainResource where
    supertype (FamilyMemberHistory e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension FamilyMemberHistory Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: FamilyMemberHistory -> DomainResource)
              
 
-- | Significant health events and conditions for a person 
--   related to the patient relevant in the context of care for 
--   the patient.
data FamilyMemberHistoryCondition = FamilyMemberHistoryCondition
        { familyMemberHistoryCondition_id :: Maybe String_primitive
        , familyMemberHistoryCondition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , familyMemberHistoryCondition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , familyMemberHistoryCondition_code :: CodeableConcept
          -- ^ The actual condition specified. Could be a coded condition 
          --   (like MI or Diabetes) or a less specific string like 
          --   'cancer' depending on how much is known about the condition 
          --   and the capabilities of the creating system.
        , familyMemberHistoryCondition_outcome :: Maybe CodeableConcept
          -- ^ Indicates what happened as a result of this condition. If 
          --   the condition resulted in death, deceased date is captured 
          --   on the relation.
        , familyMemberHistoryCondition_choice4 :: (Maybe (OneOf4 Age Range Period Xsd.XsdString))
          -- ^ Either the age of onset, range of approximate age or 
          --   descriptive string can be recorded. For conditions with 
          --   multiple occurrences, this describes the first known 
          --   occurrence.
          --   
          --   Choice between:
          --   
          --   (1) onsetAge
          --   
          --   (2) onsetRange
          --   
          --   (3) onsetPeriod
          --   
          --   (4) onsetString
        , familyMemberHistoryCondition_note :: [Annotation]
          -- ^ An area where general notes can be placed about this 
          --   specific condition.
        }
        deriving (Eq,Show)
instance SchemaType FamilyMemberHistoryCondition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (FamilyMemberHistoryCondition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (oneOf' [ ("Age", fmap OneOf4 (parseSchemaType "onsetAge"))
                                     , ("Range", fmap TwoOf4 (parseSchemaType "onsetRange"))
                                     , ("Period", fmap ThreeOf4 (parseSchemaType "onsetPeriod"))
                                     , ("Xsd.XsdString", fmap FourOf4 (parseSchemaType "onsetString"))
                                     ])
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@FamilyMemberHistoryCondition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ familyMemberHistoryCondition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ familyMemberHistoryCondition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ familyMemberHistoryCondition_modifierExtension x
            , schemaTypeToXML "code" $ familyMemberHistoryCondition_code x
            , maybe [] (schemaTypeToXML "outcome") $ familyMemberHistoryCondition_outcome x
            , maybe [] (foldOneOf4  (schemaTypeToXML "onsetAge")
                                    (schemaTypeToXML "onsetRange")
                                    (schemaTypeToXML "onsetPeriod")
                                    (schemaTypeToXML "onsetString")
                                   ) $ familyMemberHistoryCondition_choice4 x
            , concatMap (schemaTypeToXML "note") $ familyMemberHistoryCondition_note x
            ]
instance Extension FamilyMemberHistoryCondition BackboneElement where
    supertype (FamilyMemberHistoryCondition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension FamilyMemberHistoryCondition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: FamilyMemberHistoryCondition -> BackboneElement)
              
 
data FamilyHistoryStatus_list
    = FamilyHistoryStatus_list_Partial
      -- ^ Partial
    | FamilyHistoryStatus_list_Completed
      -- ^ Completed
    | FamilyHistoryStatus_list_Entered_in_error
      -- ^ Entered in error
    | FamilyHistoryStatus_list_Health_unknown
      -- ^ Health unknown
    deriving (Eq,Show,Enum)
instance SchemaType FamilyHistoryStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FamilyHistoryStatus_list where
    acceptingParser =  do literal "partial"; return FamilyHistoryStatus_list_Partial
                      `onFail` do literal "completed"; return FamilyHistoryStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return FamilyHistoryStatus_list_Entered_in_error
                      `onFail` do literal "health-unknown"; return FamilyHistoryStatus_list_Health_unknown
                      
    simpleTypeText FamilyHistoryStatus_list_Partial = "partial"
    simpleTypeText FamilyHistoryStatus_list_Completed = "completed"
    simpleTypeText FamilyHistoryStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText FamilyHistoryStatus_list_Health_unknown = "health-unknown"
 
data FamilyHistoryStatus = FamilyHistoryStatus
        { familyHistoryStatus_id :: Maybe String_primitive
        , familyHistoryStatus_value :: Maybe FamilyHistoryStatus_list
        , familyHistoryStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FamilyHistoryStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FamilyHistoryStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FamilyHistoryStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ familyHistoryStatus_id x
                       , maybe [] (toXMLAttribute "value") $ familyHistoryStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ familyHistoryStatus_extension x
            ]
instance Extension FamilyHistoryStatus Element where
    supertype (FamilyHistoryStatus a0 a1 e0) =
               Element a0 e0
 
-- | Prospective warnings of potential issues when providing 
--   care to the patient.
elementFlag :: XMLParser Flag
elementFlag = parseSchemaType "Flag"
elementToXMLFlag :: Flag -> [Content ()]
elementToXMLFlag = schemaTypeToXML "Flag"
 
data Flag = Flag
        { flag_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , flag_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , flag_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , flag_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , flag_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , flag_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , flag_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , flag_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , flag_identifier :: [Identifier]
          -- ^ Identifier assigned to the flag for external use (outside 
          --   the FHIR environment).
        , flag_status :: FlagStatus
          -- ^ Supports basic workflow.
        , flag_category :: Maybe CodeableConcept
          -- ^ Allows an flag to be divided into different categories like 
          --   clinical, administrative etc. Intended to be used as a 
          --   means of filtering which flags are displayed to particular 
          --   user or in a given context.
        , flag_code :: CodeableConcept
          -- ^ The coded value or textual component of the flag to display 
          --   to the user.
        , flag_subject :: Reference
          -- ^ The patient, location, group , organization , or 
          --   practitioner, etc. this is about record this flag is 
          --   associated with.
        , flag_period :: Maybe Period
          -- ^ The period of time from the activation of the flag to 
          --   inactivation of the flag. If the flag is active, the end of 
          --   the period should be unspecified.
        , flag_encounter :: Maybe Reference
          -- ^ This alert is only relevant during the encounter.
        , flag_author :: Maybe Reference
          -- ^ The person, organization or device that created the flag.
        }
        deriving (Eq,Show)
instance SchemaType Flag where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Flag
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "author")
    schemaTypeToXML s x@Flag{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ flag_id x
            , maybe [] (schemaTypeToXML "meta") $ flag_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ flag_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ flag_language x
            , maybe [] (schemaTypeToXML "text") $ flag_text x
            , concatMap (schemaTypeToXML "contained") $ flag_contained x
            , concatMap (schemaTypeToXML "extension") $ flag_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ flag_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ flag_identifier x
            , schemaTypeToXML "status" $ flag_status x
            , maybe [] (schemaTypeToXML "category") $ flag_category x
            , schemaTypeToXML "code" $ flag_code x
            , schemaTypeToXML "subject" $ flag_subject x
            , maybe [] (schemaTypeToXML "period") $ flag_period x
            , maybe [] (schemaTypeToXML "encounter") $ flag_encounter x
            , maybe [] (schemaTypeToXML "author") $ flag_author x
            ]
instance Extension Flag DomainResource where
    supertype (Flag e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Flag Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Flag -> DomainResource)
              
 
data FlagStatus_list
    = FlagStatus_list_Active
      -- ^ Active
    | FlagStatus_list_Inactive
      -- ^ Inactive
    | FlagStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FlagStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FlagStatus_list where
    acceptingParser =  do literal "active"; return FlagStatus_list_Active
                      `onFail` do literal "inactive"; return FlagStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return FlagStatus_list_Entered_in_error
                      
    simpleTypeText FlagStatus_list_Active = "active"
    simpleTypeText FlagStatus_list_Inactive = "inactive"
    simpleTypeText FlagStatus_list_Entered_in_error = "entered-in-error"
 
data FlagStatus = FlagStatus
        { flagStatus_id :: Maybe String_primitive
        , flagStatus_value :: Maybe FlagStatus_list
        , flagStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FlagStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FlagStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FlagStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ flagStatus_id x
                       , maybe [] (toXMLAttribute "value") $ flagStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ flagStatus_extension x
            ]
instance Extension FlagStatus Element where
    supertype (FlagStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the intended objective(s) for a patient, group or 
--   organization care, for example, weight loss, restoring an 
--   activity of daily living, obtaining herd immunity via 
--   immunization, meeting a process improvement objective, etc.
elementGoal :: XMLParser Goal
elementGoal = parseSchemaType "Goal"
elementToXMLGoal :: Goal -> [Content ()]
elementToXMLGoal = schemaTypeToXML "Goal"
 
data Goal = Goal
        { goal_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , goal_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , goal_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , goal_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , goal_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , goal_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , goal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , goal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , goal_identifier :: [Identifier]
          -- ^ This records identifiers associated with this care plan 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , goal_status :: GoalStatus
          -- ^ Indicates whether the goal has been reached and is still 
          --   considered relevant.
        , goal_category :: [CodeableConcept]
          -- ^ Indicates a category the goal falls within.
        , goal_priority :: Maybe CodeableConcept
          -- ^ Identifies the mutually agreed level of importance 
          --   associated with reaching/sustaining the goal.
        , goal_description :: CodeableConcept
          -- ^ Human-readable and/or coded description of a specific 
          --   desired objective of care, such as &quot;control blood 
          --   pressure&quot; or &quot;negotiate an obstacle course&quot; 
          --   or &quot;dance with child at wedding&quot;.
        , goal_subject :: Maybe Reference
          -- ^ Identifies the patient, group or organization for whom the 
          --   goal is being established.
        , goal_choice14 :: (Maybe (OneOf2 Date CodeableConcept))
          -- ^ The date or event after which the goal should begin being 
          --   pursued.
          --   
          --   Choice between:
          --   
          --   (1) startDate
          --   
          --   (2) startCodeableConcept
        , goal_target :: Maybe GoalTarget
          -- ^ Indicates what should be done by when.
        , goal_statusDate :: Maybe Date
          -- ^ Identifies when the current status. I.e. When initially 
          --   created, when achieved, when cancelled, etc.
        , goal_statusReason :: Maybe Xsd.XsdString
          -- ^ Captures the reason for the current status.
        , goal_expressedBy :: Maybe Reference
          -- ^ Indicates whose goal this is - patient goal, practitioner 
          --   goal, etc.
        , goal_addresses :: [Reference]
          -- ^ The identified conditions and other health record elements 
          --   that are intended to be addressed by the goal.
        , goal_note :: [Annotation]
          -- ^ Any comments related to the goal.
        , goal_outcomeCode :: [CodeableConcept]
          -- ^ Identifies the change (or lack of change) at the point when 
          --   the status of the goal is assessed.
        , goal_outcomeReference :: [Reference]
          -- ^ Details of what's changed (or not changed).
        }
        deriving (Eq,Show)
instance SchemaType Goal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Goal
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "startDate"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "startCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "statusDate")
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "expressedBy")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "outcomeCode")
            `apply` many (parseSchemaType "outcomeReference")
    schemaTypeToXML s x@Goal{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ goal_id x
            , maybe [] (schemaTypeToXML "meta") $ goal_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ goal_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ goal_language x
            , maybe [] (schemaTypeToXML "text") $ goal_text x
            , concatMap (schemaTypeToXML "contained") $ goal_contained x
            , concatMap (schemaTypeToXML "extension") $ goal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ goal_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ goal_identifier x
            , schemaTypeToXML "status" $ goal_status x
            , concatMap (schemaTypeToXML "category") $ goal_category x
            , maybe [] (schemaTypeToXML "priority") $ goal_priority x
            , schemaTypeToXML "description" $ goal_description x
            , maybe [] (schemaTypeToXML "subject") $ goal_subject x
            , maybe [] (foldOneOf2  (schemaTypeToXML "startDate")
                                    (schemaTypeToXML "startCodeableConcept")
                                   ) $ goal_choice14 x
            , maybe [] (schemaTypeToXML "target") $ goal_target x
            , maybe [] (schemaTypeToXML "statusDate") $ goal_statusDate x
            , maybe [] (schemaTypeToXML "statusReason") $ goal_statusReason x
            , maybe [] (schemaTypeToXML "expressedBy") $ goal_expressedBy x
            , concatMap (schemaTypeToXML "addresses") $ goal_addresses x
            , concatMap (schemaTypeToXML "note") $ goal_note x
            , concatMap (schemaTypeToXML "outcomeCode") $ goal_outcomeCode x
            , concatMap (schemaTypeToXML "outcomeReference") $ goal_outcomeReference x
            ]
instance Extension Goal DomainResource where
    supertype (Goal e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Goal Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Goal -> DomainResource)
              
 
-- | Describes the intended objective(s) for a patient, group or 
--   organization care, for example, weight loss, restoring an 
--   activity of daily living, obtaining herd immunity via 
--   immunization, meeting a process improvement objective, etc.
data GoalTarget = GoalTarget
        { goalTarget_id :: Maybe String_primitive
        , goalTarget_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , goalTarget_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , goalTarget_measure :: Maybe CodeableConcept
          -- ^ The parameter whose value is being tracked, e.g. body 
          --   weight, blood pressure, or hemoglobin A1c level.
        , goalTarget_choice3 :: (Maybe (OneOf3 Quantity Range CodeableConcept))
          -- ^ The target value of the focus to be achieved to signify the 
          --   fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the 
          --   high or low or both values of the range can be specified. 
          --   When a low value is missing, it indicates that the goal is 
          --   achieved at any focus value at or below the high value. 
          --   Similarly, if the high value is missing, it indicates that 
          --   the goal is achieved at any focus value at or above the low 
          --   value.
          --   
          --   Choice between:
          --   
          --   (1) detailQuantity
          --   
          --   (2) detailRange
          --   
          --   (3) detailCodeableConcept
        , goalTarget_choice4 :: (Maybe (OneOf2 Date Duration))
          -- ^ Indicates either the date or the duration after start by 
          --   which the goal should be met.
          --   
          --   Choice between:
          --   
          --   (1) dueDate
          --   
          --   (2) dueDuration
        }
        deriving (Eq,Show)
instance SchemaType GoalTarget where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GoalTarget a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "measure")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf3 (parseSchemaType "detailQuantity"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "detailRange"))
                                     , ("CodeableConcept", fmap ThreeOf3 (parseSchemaType "detailCodeableConcept"))
                                     ])
            `apply` optional (oneOf' [ ("Date", fmap OneOf2 (parseSchemaType "dueDate"))
                                     , ("Duration", fmap TwoOf2 (parseSchemaType "dueDuration"))
                                     ])
    schemaTypeToXML s x@GoalTarget{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ goalTarget_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ goalTarget_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ goalTarget_modifierExtension x
            , maybe [] (schemaTypeToXML "measure") $ goalTarget_measure x
            , maybe [] (foldOneOf3  (schemaTypeToXML "detailQuantity")
                                    (schemaTypeToXML "detailRange")
                                    (schemaTypeToXML "detailCodeableConcept")
                                   ) $ goalTarget_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "dueDate")
                                    (schemaTypeToXML "dueDuration")
                                   ) $ goalTarget_choice4 x
            ]
instance Extension GoalTarget BackboneElement where
    supertype (GoalTarget a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension GoalTarget Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GoalTarget -> BackboneElement)
              
 
data GoalStatus_list
    = GoalStatus_list_Proposed
      -- ^ Proposed
    | GoalStatus_list_Accepted
      -- ^ Accepted
    | GoalStatus_list_Planned
      -- ^ Planned
    | GoalStatus_list_In_progress
      -- ^ In Progress
    | GoalStatus_list_On_target
      -- ^ On Target
    | GoalStatus_list_Ahead_of_target
      -- ^ Ahead of Target
    | GoalStatus_list_Behind_target
      -- ^ Behind Target
    | GoalStatus_list_Sustaining
      -- ^ Sustaining
    | GoalStatus_list_Achieved
      -- ^ Achieved
    | GoalStatus_list_On_hold
      -- ^ On Hold
    | GoalStatus_list_Cancelled
      -- ^ Cancelled
    | GoalStatus_list_Entered_in_error
      -- ^ Entered In Error
    | GoalStatus_list_Rejected
      -- ^ Rejected
    deriving (Eq,Show,Enum)
instance SchemaType GoalStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GoalStatus_list where
    acceptingParser =  do literal "proposed"; return GoalStatus_list_Proposed
                      `onFail` do literal "accepted"; return GoalStatus_list_Accepted
                      `onFail` do literal "planned"; return GoalStatus_list_Planned
                      `onFail` do literal "in-progress"; return GoalStatus_list_In_progress
                      `onFail` do literal "on-target"; return GoalStatus_list_On_target
                      `onFail` do literal "ahead-of-target"; return GoalStatus_list_Ahead_of_target
                      `onFail` do literal "behind-target"; return GoalStatus_list_Behind_target
                      `onFail` do literal "sustaining"; return GoalStatus_list_Sustaining
                      `onFail` do literal "achieved"; return GoalStatus_list_Achieved
                      `onFail` do literal "on-hold"; return GoalStatus_list_On_hold
                      `onFail` do literal "cancelled"; return GoalStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return GoalStatus_list_Entered_in_error
                      `onFail` do literal "rejected"; return GoalStatus_list_Rejected
                      
    simpleTypeText GoalStatus_list_Proposed = "proposed"
    simpleTypeText GoalStatus_list_Accepted = "accepted"
    simpleTypeText GoalStatus_list_Planned = "planned"
    simpleTypeText GoalStatus_list_In_progress = "in-progress"
    simpleTypeText GoalStatus_list_On_target = "on-target"
    simpleTypeText GoalStatus_list_Ahead_of_target = "ahead-of-target"
    simpleTypeText GoalStatus_list_Behind_target = "behind-target"
    simpleTypeText GoalStatus_list_Sustaining = "sustaining"
    simpleTypeText GoalStatus_list_Achieved = "achieved"
    simpleTypeText GoalStatus_list_On_hold = "on-hold"
    simpleTypeText GoalStatus_list_Cancelled = "cancelled"
    simpleTypeText GoalStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText GoalStatus_list_Rejected = "rejected"
 
data GoalStatus = GoalStatus
        { goalStatus_id :: Maybe String_primitive
        , goalStatus_value :: Maybe GoalStatus_list
        , goalStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GoalStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GoalStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GoalStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ goalStatus_id x
                       , maybe [] (toXMLAttribute "value") $ goalStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ goalStatus_extension x
            ]
instance Extension GoalStatus Element where
    supertype (GoalStatus a0 a1 e0) =
               Element a0 e0
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
elementGraphDefinition :: XMLParser GraphDefinition
elementGraphDefinition = parseSchemaType "GraphDefinition"
elementToXMLGraphDefinition :: GraphDefinition -> [Content ()]
elementToXMLGraphDefinition = schemaTypeToXML "GraphDefinition"
 
data GraphDefinition = GraphDefinition
        { graphDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , graphDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , graphDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , graphDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , graphDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , graphDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , graphDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this graph 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   graph definition is (or will be) published. The URL SHOULD 
          --   include the major version of the graph definition. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , graphDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   graph definition when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the graph definition author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , graphDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the graph definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , graphDefinition_status :: PublicationStatus
          -- ^ The status of this graph definition. Enables tracking the 
          --   life-cycle of the content.
        , graphDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this graph definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , graphDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the graph definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the graph definition changes.
        , graphDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the graph definition.
        , graphDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , graphDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the graph 
          --   definition from a consumer's perspective.
        , graphDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   graph definition instances.
        , graphDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the graph definition 
          --   is intended to be used.
        , graphDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this graph definition is needed and why 
          --   it has been designed as it has.
        , graphDefinition_start :: ResourceType
          -- ^ The type of FHIR resource at which instances of this graph 
          --   start.
        , graphDefinition_profile :: Maybe Uri
          -- ^ The profile that describes the use of the base resource.
        , graphDefinition_link :: [GraphDefinitionLink]
          -- ^ Links this graph makes rules about.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return GraphDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` parseSchemaType "start"
            `apply` optional (parseSchemaType "profile")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@GraphDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ graphDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ graphDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ graphDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ graphDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ graphDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ graphDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ graphDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ graphDefinition_url x
            , maybe [] (schemaTypeToXML "version") $ graphDefinition_version x
            , schemaTypeToXML "name" $ graphDefinition_name x
            , schemaTypeToXML "status" $ graphDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ graphDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ graphDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ graphDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ graphDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ graphDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ graphDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ graphDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ graphDefinition_purpose x
            , schemaTypeToXML "start" $ graphDefinition_start x
            , maybe [] (schemaTypeToXML "profile") $ graphDefinition_profile x
            , concatMap (schemaTypeToXML "link") $ graphDefinition_link x
            ]
instance Extension GraphDefinition DomainResource where
    supertype (GraphDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension GraphDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: GraphDefinition -> DomainResource)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinitionLink = GraphDefinitionLink
        { graphDefinitionLink_id :: Maybe String_primitive
        , graphDefinitionLink_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinitionLink_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinitionLink_path :: Xsd.XsdString
          -- ^ Path in the resource that contains the link.
        , graphDefinitionLink_sliceName :: Maybe Xsd.XsdString
          -- ^ Which slice (if profiled).
        , graphDefinitionLink_min :: Maybe Integer
          -- ^ Minimum occurrences for this link.
        , graphDefinitionLink_max :: Maybe Xsd.XsdString
          -- ^ Maximum occurrences for this link.
        , graphDefinitionLink_description :: Maybe Xsd.XsdString
          -- ^ Information about why this link is of interest in this 
          --   graph definition.
        , graphDefinitionLink_target :: [GraphDefinitionTarget]
          -- ^ Potential target for the link.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinitionLink where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinitionLink a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "path"
            `apply` optional (parseSchemaType "sliceName")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "target")
    schemaTypeToXML s x@GraphDefinitionLink{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinitionLink_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinitionLink_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinitionLink_modifierExtension x
            , schemaTypeToXML "path" $ graphDefinitionLink_path x
            , maybe [] (schemaTypeToXML "sliceName") $ graphDefinitionLink_sliceName x
            , maybe [] (schemaTypeToXML "min") $ graphDefinitionLink_min x
            , maybe [] (schemaTypeToXML "max") $ graphDefinitionLink_max x
            , maybe [] (schemaTypeToXML "description") $ graphDefinitionLink_description x
            , concatMap (schemaTypeToXML "target") $ graphDefinitionLink_target x
            ]
instance Extension GraphDefinitionLink BackboneElement where
    supertype (GraphDefinitionLink a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinitionLink Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinitionLink -> BackboneElement)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinitionTarget = GraphDefinitionTarget
        { graphDefinitionTarget_id :: Maybe String_primitive
        , graphDefinitionTarget_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinitionTarget_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinitionTarget_type :: ResourceType
          -- ^ Type of resource this link refers to.
        , graphDefinitionTarget_profile :: Maybe Uri
          -- ^ Profile for the target resource.
        , graphDefinitionTarget_compartment :: [GraphDefinitionCompartment]
          -- ^ Compartment Consistency Rules.
        , graphDefinitionTarget_link :: [GraphDefinitionLink]
          -- ^ Additional links from target resource.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinitionTarget where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinitionTarget a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "profile")
            `apply` many (parseSchemaType "compartment")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@GraphDefinitionTarget{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinitionTarget_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinitionTarget_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinitionTarget_modifierExtension x
            , schemaTypeToXML "type" $ graphDefinitionTarget_type x
            , maybe [] (schemaTypeToXML "profile") $ graphDefinitionTarget_profile x
            , concatMap (schemaTypeToXML "compartment") $ graphDefinitionTarget_compartment x
            , concatMap (schemaTypeToXML "link") $ graphDefinitionTarget_link x
            ]
instance Extension GraphDefinitionTarget BackboneElement where
    supertype (GraphDefinitionTarget a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinitionTarget Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinitionTarget -> BackboneElement)
              
 
-- | A formal computable definition of a graph of resources - 
--   that is, a coherent set of resources that form a graph by 
--   following references. The Graph Definition resource defines 
--   a set and makes rules about the set.
data GraphDefinitionCompartment = GraphDefinitionCompartment
        { graphDefinitionCompartment_id :: Maybe String_primitive
        , graphDefinitionCompartment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , graphDefinitionCompartment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , graphDefinitionCompartment_code :: CompartmentType
          -- ^ Identifies the compartment.
        , graphDefinitionCompartment_rule :: GraphCompartmentRule
          -- ^ identical | matching | different | no-rule | custom.
        , graphDefinitionCompartment_expression :: Maybe Xsd.XsdString
          -- ^ Custom rule, as a FHIRPath expression.
        , graphDefinitionCompartment_description :: Maybe Xsd.XsdString
          -- ^ Documentation for FHIRPath expression.
        }
        deriving (Eq,Show)
instance SchemaType GraphDefinitionCompartment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GraphDefinitionCompartment a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "rule"
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@GraphDefinitionCompartment{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphDefinitionCompartment_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphDefinitionCompartment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ graphDefinitionCompartment_modifierExtension x
            , schemaTypeToXML "code" $ graphDefinitionCompartment_code x
            , schemaTypeToXML "rule" $ graphDefinitionCompartment_rule x
            , maybe [] (schemaTypeToXML "expression") $ graphDefinitionCompartment_expression x
            , maybe [] (schemaTypeToXML "description") $ graphDefinitionCompartment_description x
            ]
instance Extension GraphDefinitionCompartment BackboneElement where
    supertype (GraphDefinitionCompartment a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension GraphDefinitionCompartment Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GraphDefinitionCompartment -> BackboneElement)
              
 
data GraphCompartmentRule_list
    = GraphCompartmentRule_list_Identical
      -- ^ Identical
    | GraphCompartmentRule_list_Matching
      -- ^ Matching
    | GraphCompartmentRule_list_Different
      -- ^ Different
    | GraphCompartmentRule_list_Custom
      -- ^ Custom
    deriving (Eq,Show,Enum)
instance SchemaType GraphCompartmentRule_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GraphCompartmentRule_list where
    acceptingParser =  do literal "identical"; return GraphCompartmentRule_list_Identical
                      `onFail` do literal "matching"; return GraphCompartmentRule_list_Matching
                      `onFail` do literal "different"; return GraphCompartmentRule_list_Different
                      `onFail` do literal "custom"; return GraphCompartmentRule_list_Custom
                      
    simpleTypeText GraphCompartmentRule_list_Identical = "identical"
    simpleTypeText GraphCompartmentRule_list_Matching = "matching"
    simpleTypeText GraphCompartmentRule_list_Different = "different"
    simpleTypeText GraphCompartmentRule_list_Custom = "custom"
 
data GraphCompartmentRule = GraphCompartmentRule
        { graphCompartmentRule_id :: Maybe String_primitive
        , graphCompartmentRule_value :: Maybe GraphCompartmentRule_list
        , graphCompartmentRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GraphCompartmentRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GraphCompartmentRule a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GraphCompartmentRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ graphCompartmentRule_id x
                       , maybe [] (toXMLAttribute "value") $ graphCompartmentRule_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ graphCompartmentRule_extension x
            ]
instance Extension GraphCompartmentRule Element where
    supertype (GraphCompartmentRule a0 a1 e0) =
               Element a0 e0
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
elementGroup :: XMLParser Group
elementGroup = parseSchemaType "Group"
elementToXMLGroup :: Group -> [Content ()]
elementToXMLGroup = schemaTypeToXML "Group"
 
data Group = Group
        { group_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , group_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , group_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , group_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , group_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , group_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , group_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , group_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , group_identifier :: [Identifier]
          -- ^ A unique business identifier for this group.
        , group_active :: Maybe Boolean
          -- ^ Indicates whether the record for the group is available for 
          --   use or is merely being retained for historical purposes.
        , group_type :: GroupType
          -- ^ Identifies the broad classification of the kind of 
          --   resources the group includes.
        , group_actual :: Boolean
          -- ^ If true, indicates that the resource refers to a specific 
          --   group of real individuals. If false, the group defines a 
          --   set of intended individuals.
        , group_code :: Maybe CodeableConcept
          -- ^ Provides a specific type of resource the group includes; 
          --   e.g. &quot;cow&quot;, &quot;syringe&quot;, etc.
        , group_name :: Maybe Xsd.XsdString
          -- ^ A label assigned to the group for human identification and 
          --   communication.
        , group_quantity :: Maybe UnsignedInt
          -- ^ A count of the number of resource instances that are part 
          --   of the group.
        , group_characteristic :: [GroupCharacteristic]
          -- ^ Identifies the traits shared by members of the group.
        , group_member :: [GroupMember]
          -- ^ Identifies the resource instances that are members of the 
          --   group.
        }
        deriving (Eq,Show)
instance SchemaType Group where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Group
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "actual"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "quantity")
            `apply` many (parseSchemaType "characteristic")
            `apply` many (parseSchemaType "member")
    schemaTypeToXML s x@Group{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ group_id x
            , maybe [] (schemaTypeToXML "meta") $ group_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ group_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ group_language x
            , maybe [] (schemaTypeToXML "text") $ group_text x
            , concatMap (schemaTypeToXML "contained") $ group_contained x
            , concatMap (schemaTypeToXML "extension") $ group_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ group_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ group_identifier x
            , maybe [] (schemaTypeToXML "active") $ group_active x
            , schemaTypeToXML "type" $ group_type x
            , schemaTypeToXML "actual" $ group_actual x
            , maybe [] (schemaTypeToXML "code") $ group_code x
            , maybe [] (schemaTypeToXML "name") $ group_name x
            , maybe [] (schemaTypeToXML "quantity") $ group_quantity x
            , concatMap (schemaTypeToXML "characteristic") $ group_characteristic x
            , concatMap (schemaTypeToXML "member") $ group_member x
            ]
instance Extension Group DomainResource where
    supertype (Group e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Group Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Group -> DomainResource)
              
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
data GroupCharacteristic = GroupCharacteristic
        { groupCharacteristic_id :: Maybe String_primitive
        , groupCharacteristic_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , groupCharacteristic_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , groupCharacteristic_code :: CodeableConcept
          -- ^ A code that identifies the kind of trait being asserted.
        , groupCharacteristic_choice3 :: OneOf4 CodeableConcept Boolean Quantity Range
          -- ^ The value of the trait that holds (or does not hold - see 
          --   'exclude') for members of the group.
          --   
          --   Choice between:
          --   
          --   (1) valueCodeableConcept
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueQuantity
          --   
          --   (4) valueRange
        , groupCharacteristic_exclude :: Boolean
          -- ^ If true, indicates the characteristic is one that is NOT 
          --   held by members of the group.
        , groupCharacteristic_period :: Maybe Period
          -- ^ The period over which the characteristic is tested; e.g. 
          --   the patient had an operation during the month of June.
        }
        deriving (Eq,Show)
instance SchemaType GroupCharacteristic where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GroupCharacteristic a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf4 (parseSchemaType "valueCodeableConcept"))
                           , ("Boolean", fmap TwoOf4 (parseSchemaType "valueBoolean"))
                           , ("Quantity", fmap ThreeOf4 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap FourOf4 (parseSchemaType "valueRange"))
                           ]
            `apply` parseSchemaType "exclude"
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@GroupCharacteristic{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ groupCharacteristic_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ groupCharacteristic_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ groupCharacteristic_modifierExtension x
            , schemaTypeToXML "code" $ groupCharacteristic_code x
            , foldOneOf4  (schemaTypeToXML "valueCodeableConcept")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueQuantity")
                          (schemaTypeToXML "valueRange")
                          $ groupCharacteristic_choice3 x
            , schemaTypeToXML "exclude" $ groupCharacteristic_exclude x
            , maybe [] (schemaTypeToXML "period") $ groupCharacteristic_period x
            ]
instance Extension GroupCharacteristic BackboneElement where
    supertype (GroupCharacteristic a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension GroupCharacteristic Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GroupCharacteristic -> BackboneElement)
              
 
-- | Represents a defined collection of entities that may be 
--   discussed or acted upon collectively but which are not 
--   expected to act collectively and are not formally or 
--   legally recognized; i.e. a collection of entities that 
--   isn't an Organization.
data GroupMember = GroupMember
        { groupMember_id :: Maybe String_primitive
        , groupMember_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , groupMember_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , groupMember_entity :: Reference
          -- ^ A reference to the entity that is a member of the group. 
          --   Must be consistent with Group.type.
        , groupMember_period :: Maybe Period
          -- ^ The period that the member was in the group, if known.
        , groupMember_inactive :: Maybe Boolean
          -- ^ A flag to indicate that the member is no longer in the 
          --   group, but previously may have been a member.
        }
        deriving (Eq,Show)
instance SchemaType GroupMember where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (GroupMember a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "entity"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "inactive")
    schemaTypeToXML s x@GroupMember{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ groupMember_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ groupMember_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ groupMember_modifierExtension x
            , schemaTypeToXML "entity" $ groupMember_entity x
            , maybe [] (schemaTypeToXML "period") $ groupMember_period x
            , maybe [] (schemaTypeToXML "inactive") $ groupMember_inactive x
            ]
instance Extension GroupMember BackboneElement where
    supertype (GroupMember a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension GroupMember Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: GroupMember -> BackboneElement)
              
 
data GroupType_list
    = GroupType_list_Person
      -- ^ Person
    | GroupType_list_Animal
      -- ^ Animal
    | GroupType_list_Practitioner
      -- ^ Practitioner
    | GroupType_list_Device
      -- ^ Device
    | GroupType_list_Medication
      -- ^ Medication
    | GroupType_list_Substance
      -- ^ Substance
    deriving (Eq,Show,Enum)
instance SchemaType GroupType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GroupType_list where
    acceptingParser =  do literal "person"; return GroupType_list_Person
                      `onFail` do literal "animal"; return GroupType_list_Animal
                      `onFail` do literal "practitioner"; return GroupType_list_Practitioner
                      `onFail` do literal "device"; return GroupType_list_Device
                      `onFail` do literal "medication"; return GroupType_list_Medication
                      `onFail` do literal "substance"; return GroupType_list_Substance
                      
    simpleTypeText GroupType_list_Person = "person"
    simpleTypeText GroupType_list_Animal = "animal"
    simpleTypeText GroupType_list_Practitioner = "practitioner"
    simpleTypeText GroupType_list_Device = "device"
    simpleTypeText GroupType_list_Medication = "medication"
    simpleTypeText GroupType_list_Substance = "substance"
 
data GroupType = GroupType
        { groupType_id :: Maybe String_primitive
        , groupType_value :: Maybe GroupType_list
        , groupType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GroupType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GroupType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GroupType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ groupType_id x
                       , maybe [] (toXMLAttribute "value") $ groupType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ groupType_extension x
            ]
instance Extension GroupType Element where
    supertype (GroupType a0 a1 e0) =
               Element a0 e0
 
-- | A guidance response is the formal response to a guidance 
--   request, including any output parameters returned by the 
--   evaluation, as well as the description of any proposed 
--   actions to be taken.
elementGuidanceResponse :: XMLParser GuidanceResponse
elementGuidanceResponse = parseSchemaType "GuidanceResponse"
elementToXMLGuidanceResponse :: GuidanceResponse -> [Content ()]
elementToXMLGuidanceResponse = schemaTypeToXML "GuidanceResponse"
 
data GuidanceResponse = GuidanceResponse
        { guidanceResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , guidanceResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , guidanceResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , guidanceResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , guidanceResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , guidanceResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , guidanceResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , guidanceResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , guidanceResponse_requestId :: Maybe Id
          -- ^ The id of the request associated with this response. If an 
          --   id was given as part of the request, it will be reproduced 
          --   here to enable the requester to more easily identify the 
          --   response in a multi-request scenario.
        , guidanceResponse_identifier :: Maybe Identifier
          -- ^ Allows a service to provide a unique, business identifier 
          --   for the response.
        , guidanceResponse_module :: Reference
          -- ^ A reference to the knowledge module that was invoked.
        , guidanceResponse_status :: GuidanceResponseStatus
          -- ^ The status of the response. If the evaluation is completed 
          --   successfully, the status will indicate success. However, in 
          --   order to complete the evaluation, the engine may require 
          --   more information. In this case, the status will be 
          --   data-required, and the response will contain a description 
          --   of the additional required information. If the evaluation 
          --   completed successfully, but the engine determines that a 
          --   potentially more accurate response could be provided if 
          --   more data was available, the status will be data-requested, 
          --   and the response will contain a description of the 
          --   additional requested information.
        , guidanceResponse_subject :: Maybe Reference
          -- ^ The patient for which the request was processed.
        , guidanceResponse_context :: Maybe Reference
          -- ^ Allows the context of the guidance response to be provided 
          --   if available. In a service context, this would likely be 
          --   unavailable.
        , guidanceResponse_occurrenceDateTime :: Maybe DateTime
          -- ^ Indicates when the guidance response was processed.
        , guidanceResponse_performer :: Maybe Reference
          -- ^ Provides a reference to the device that performed the 
          --   guidance.
        , guidanceResponse_choice16 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason the request was initiated. This is 
          --   typically provided as a parameter to the evaluation and 
          --   echoed by the service, although for some use cases, such as 
          --   subscription- or event-based scenarios, it may provide an 
          --   indication of the cause for the response.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , guidanceResponse_note :: [Annotation]
          -- ^ Provides a mechanism to communicate additional information 
          --   about the response.
        , guidanceResponse_evaluationMessage :: [Reference]
          -- ^ Messages resulting from the evaluation of the artifact or 
          --   artifacts. As part of evaluating the request, the engine 
          --   may produce informational or warning messages. These 
          --   messages will be provided by this element.
        , guidanceResponse_outputParameters :: Maybe Reference
          -- ^ The output parameters of the evaluation, if any. Many 
          --   modules will result in the return of specific resources 
          --   such as procedure or communication requests that are 
          --   returned as part of the operation result. However, modules 
          --   may define specific outputs that would be returned as the 
          --   result of the evaluation, and these would be returned in 
          --   this element.
        , guidanceResponse_result :: Maybe Reference
          -- ^ The actions, if any, produced by the evaluation of the 
          --   artifact.
        , guidanceResponse_dataRequirement :: [DataRequirement]
          -- ^ If the evaluation could not be completed due to lack of 
          --   information, or additional information would potentially 
          --   result in a more accurate response, this element will a 
          --   description of the data required in order to proceed with 
          --   the evaluation. A subsequent request to the service should 
          --   include this data.
        }
        deriving (Eq,Show)
instance SchemaType GuidanceResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return GuidanceResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "requestId")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "module"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "occurrenceDateTime")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "evaluationMessage")
            `apply` optional (parseSchemaType "outputParameters")
            `apply` optional (parseSchemaType "result")
            `apply` many (parseSchemaType "dataRequirement")
    schemaTypeToXML s x@GuidanceResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ guidanceResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ guidanceResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ guidanceResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ guidanceResponse_language x
            , maybe [] (schemaTypeToXML "text") $ guidanceResponse_text x
            , concatMap (schemaTypeToXML "contained") $ guidanceResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ guidanceResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ guidanceResponse_modifierExtension x
            , maybe [] (schemaTypeToXML "requestId") $ guidanceResponse_requestId x
            , maybe [] (schemaTypeToXML "identifier") $ guidanceResponse_identifier x
            , schemaTypeToXML "module" $ guidanceResponse_module x
            , schemaTypeToXML "status" $ guidanceResponse_status x
            , maybe [] (schemaTypeToXML "subject") $ guidanceResponse_subject x
            , maybe [] (schemaTypeToXML "context") $ guidanceResponse_context x
            , maybe [] (schemaTypeToXML "occurrenceDateTime") $ guidanceResponse_occurrenceDateTime x
            , maybe [] (schemaTypeToXML "performer") $ guidanceResponse_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ guidanceResponse_choice16 x
            , concatMap (schemaTypeToXML "note") $ guidanceResponse_note x
            , concatMap (schemaTypeToXML "evaluationMessage") $ guidanceResponse_evaluationMessage x
            , maybe [] (schemaTypeToXML "outputParameters") $ guidanceResponse_outputParameters x
            , maybe [] (schemaTypeToXML "result") $ guidanceResponse_result x
            , concatMap (schemaTypeToXML "dataRequirement") $ guidanceResponse_dataRequirement x
            ]
instance Extension GuidanceResponse DomainResource where
    supertype (GuidanceResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension GuidanceResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: GuidanceResponse -> DomainResource)
              
 
data GuidanceResponseStatus_list
    = GuidanceResponseStatus_list_Success
      -- ^ Success
    | GuidanceResponseStatus_list_Data_requested
      -- ^ Data Requested
    | GuidanceResponseStatus_list_Data_required
      -- ^ Data Required
    | GuidanceResponseStatus_list_In_progress
      -- ^ In Progress
    | GuidanceResponseStatus_list_Failure
      -- ^ Failure
    | GuidanceResponseStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType GuidanceResponseStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuidanceResponseStatus_list where
    acceptingParser =  do literal "success"; return GuidanceResponseStatus_list_Success
                      `onFail` do literal "data-requested"; return GuidanceResponseStatus_list_Data_requested
                      `onFail` do literal "data-required"; return GuidanceResponseStatus_list_Data_required
                      `onFail` do literal "in-progress"; return GuidanceResponseStatus_list_In_progress
                      `onFail` do literal "failure"; return GuidanceResponseStatus_list_Failure
                      `onFail` do literal "entered-in-error"; return GuidanceResponseStatus_list_Entered_in_error
                      
    simpleTypeText GuidanceResponseStatus_list_Success = "success"
    simpleTypeText GuidanceResponseStatus_list_Data_requested = "data-requested"
    simpleTypeText GuidanceResponseStatus_list_Data_required = "data-required"
    simpleTypeText GuidanceResponseStatus_list_In_progress = "in-progress"
    simpleTypeText GuidanceResponseStatus_list_Failure = "failure"
    simpleTypeText GuidanceResponseStatus_list_Entered_in_error = "entered-in-error"
 
data GuidanceResponseStatus = GuidanceResponseStatus
        { guidanceResponseStatus_id :: Maybe String_primitive
        , guidanceResponseStatus_value :: Maybe GuidanceResponseStatus_list
        , guidanceResponseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuidanceResponseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuidanceResponseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuidanceResponseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guidanceResponseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ guidanceResponseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guidanceResponseStatus_extension x
            ]
instance Extension GuidanceResponseStatus Element where
    supertype (GuidanceResponseStatus a0 a1 e0) =
               Element a0 e0
 
-- | The details of a healthcare service available at a 
--   location.
elementHealthcareService :: XMLParser HealthcareService
elementHealthcareService = parseSchemaType "HealthcareService"
elementToXMLHealthcareService :: HealthcareService -> [Content ()]
elementToXMLHealthcareService = schemaTypeToXML "HealthcareService"
 
data HealthcareService = HealthcareService
        { healthcareService_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , healthcareService_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , healthcareService_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , healthcareService_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , healthcareService_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , healthcareService_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , healthcareService_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareService_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareService_identifier :: [Identifier]
          -- ^ External identifiers for this item.
        , healthcareService_active :: Maybe Boolean
          -- ^ Whether this healthcareservice record is in active use.
        , healthcareService_providedBy :: Maybe Reference
          -- ^ The organization that provides this healthcare service.
        , healthcareService_category :: Maybe CodeableConcept
          -- ^ Identifies the broad category of service being performed or 
          --   delivered.
        , healthcareService_type :: [CodeableConcept]
          -- ^ The specific type of service that may be delivered or 
          --   performed.
        , healthcareService_specialty :: [CodeableConcept]
          -- ^ Collection of specialties handled by the service site. This 
          --   is more of a medical term.
        , healthcareService_location :: [Reference]
          -- ^ The location(s) where this healthcare service may be 
          --   provided.
        , healthcareService_name :: Maybe Xsd.XsdString
          -- ^ Further description of the service as it would be presented 
          --   to a consumer while searching.
        , healthcareService_comment :: Maybe Xsd.XsdString
          -- ^ Any additional description of the service and/or any 
          --   specific issues not covered by the other attributes, which 
          --   can be displayed as further detail under the serviceName.
        , healthcareService_extraDetails :: Maybe Xsd.XsdString
          -- ^ Extra details about the service that can't be placed in the 
          --   other fields.
        , healthcareService_photo :: Maybe Attachment
          -- ^ If there is a photo/symbol associated with this 
          --   HealthcareService, it may be included here to facilitate 
          --   quick identification of the service in a list.
        , healthcareService_telecom :: [ContactPoint]
          -- ^ List of contacts related to this specific healthcare 
          --   service.
        , healthcareService_coverageArea :: [Reference]
          -- ^ The location(s) that this service is available to (not 
          --   where the service is provided).
        , healthcareService_serviceProvisionCode :: [CodeableConcept]
          -- ^ The code(s) that detail the conditions under which the 
          --   healthcare service is available/offered.
        , healthcareService_eligibility :: Maybe CodeableConcept
          -- ^ Does this service have specific eligibility requirements 
          --   that need to be met in order to use the service?
        , healthcareService_eligibilityNote :: Maybe Xsd.XsdString
          -- ^ Describes the eligibility conditions for the service.
        , healthcareService_programName :: [Xsd.XsdString]
          -- ^ Program Names that can be used to categorize the service.
        , healthcareService_characteristic :: [CodeableConcept]
          -- ^ Collection of characteristics (attributes).
        , healthcareService_referralMethod :: [CodeableConcept]
          -- ^ Ways that the service accepts referrals, if this is not 
          --   provided then it is implied that no referral is required.
        , healthcareService_appointmentRequired :: Maybe Boolean
          -- ^ Indicates whether or not a prospective consumer will 
          --   require an appointment for a particular service at a site 
          --   to be provided by the Organization. Indicates if an 
          --   appointment is required for access to this service.
        , healthcareService_availableTime :: [HealthcareServiceAvailableTime]
          -- ^ A collection of times that the Service Site is available.
        , healthcareService_notAvailable :: [HealthcareServiceNotAvailable]
          -- ^ The HealthcareService is not available during this period 
          --   of time due to the provided reason.
        , healthcareService_availabilityExceptions :: Maybe Xsd.XsdString
          -- ^ A description of site availability exceptions, e.g. public 
          --   holiday availability. Succinctly describing all possible 
          --   exceptions to normal site availability as details in the 
          --   available Times and not available Times.
        , healthcareService_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the specific healthcare services defined at this 
          --   resource.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareService where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return HealthcareService
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "providedBy")
            `apply` optional (parseSchemaType "category")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "specialty")
            `apply` many (parseSchemaType "location")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "extraDetails")
            `apply` optional (parseSchemaType "photo")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "coverageArea")
            `apply` many (parseSchemaType "serviceProvisionCode")
            `apply` optional (parseSchemaType "eligibility")
            `apply` optional (parseSchemaType "eligibilityNote")
            `apply` many (parseSchemaType "programName")
            `apply` many (parseSchemaType "characteristic")
            `apply` many (parseSchemaType "referralMethod")
            `apply` optional (parseSchemaType "appointmentRequired")
            `apply` many (parseSchemaType "availableTime")
            `apply` many (parseSchemaType "notAvailable")
            `apply` optional (parseSchemaType "availabilityExceptions")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@HealthcareService{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ healthcareService_id x
            , maybe [] (schemaTypeToXML "meta") $ healthcareService_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ healthcareService_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ healthcareService_language x
            , maybe [] (schemaTypeToXML "text") $ healthcareService_text x
            , concatMap (schemaTypeToXML "contained") $ healthcareService_contained x
            , concatMap (schemaTypeToXML "extension") $ healthcareService_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareService_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ healthcareService_identifier x
            , maybe [] (schemaTypeToXML "active") $ healthcareService_active x
            , maybe [] (schemaTypeToXML "providedBy") $ healthcareService_providedBy x
            , maybe [] (schemaTypeToXML "category") $ healthcareService_category x
            , concatMap (schemaTypeToXML "type") $ healthcareService_type x
            , concatMap (schemaTypeToXML "specialty") $ healthcareService_specialty x
            , concatMap (schemaTypeToXML "location") $ healthcareService_location x
            , maybe [] (schemaTypeToXML "name") $ healthcareService_name x
            , maybe [] (schemaTypeToXML "comment") $ healthcareService_comment x
            , maybe [] (schemaTypeToXML "extraDetails") $ healthcareService_extraDetails x
            , maybe [] (schemaTypeToXML "photo") $ healthcareService_photo x
            , concatMap (schemaTypeToXML "telecom") $ healthcareService_telecom x
            , concatMap (schemaTypeToXML "coverageArea") $ healthcareService_coverageArea x
            , concatMap (schemaTypeToXML "serviceProvisionCode") $ healthcareService_serviceProvisionCode x
            , maybe [] (schemaTypeToXML "eligibility") $ healthcareService_eligibility x
            , maybe [] (schemaTypeToXML "eligibilityNote") $ healthcareService_eligibilityNote x
            , concatMap (schemaTypeToXML "programName") $ healthcareService_programName x
            , concatMap (schemaTypeToXML "characteristic") $ healthcareService_characteristic x
            , concatMap (schemaTypeToXML "referralMethod") $ healthcareService_referralMethod x
            , maybe [] (schemaTypeToXML "appointmentRequired") $ healthcareService_appointmentRequired x
            , concatMap (schemaTypeToXML "availableTime") $ healthcareService_availableTime x
            , concatMap (schemaTypeToXML "notAvailable") $ healthcareService_notAvailable x
            , maybe [] (schemaTypeToXML "availabilityExceptions") $ healthcareService_availabilityExceptions x
            , concatMap (schemaTypeToXML "endpoint") $ healthcareService_endpoint x
            ]
instance Extension HealthcareService DomainResource where
    supertype (HealthcareService e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension HealthcareService Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: HealthcareService -> DomainResource)
              
 
-- | The details of a healthcare service available at a 
--   location.
data HealthcareServiceAvailableTime = HealthcareServiceAvailableTime
        { healthcareServiceAvailableTime_id :: Maybe String_primitive
        , healthcareServiceAvailableTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareServiceAvailableTime_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareServiceAvailableTime_daysOfWeek :: [DaysOfWeek]
          -- ^ Indicates which days of the week are available between the 
          --   start and end Times.
        , healthcareServiceAvailableTime_allDay :: Maybe Boolean
          -- ^ Is this always available? (hence times are irrelevant) e.g. 
          --   24 hour service.
        , healthcareServiceAvailableTime_availableStartTime :: Maybe Time
          -- ^ The opening time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        , healthcareServiceAvailableTime_availableEndTime :: Maybe Time
          -- ^ The closing time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareServiceAvailableTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HealthcareServiceAvailableTime a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "daysOfWeek")
            `apply` optional (parseSchemaType "allDay")
            `apply` optional (parseSchemaType "availableStartTime")
            `apply` optional (parseSchemaType "availableEndTime")
    schemaTypeToXML s x@HealthcareServiceAvailableTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ healthcareServiceAvailableTime_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ healthcareServiceAvailableTime_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareServiceAvailableTime_modifierExtension x
            , concatMap (schemaTypeToXML "daysOfWeek") $ healthcareServiceAvailableTime_daysOfWeek x
            , maybe [] (schemaTypeToXML "allDay") $ healthcareServiceAvailableTime_allDay x
            , maybe [] (schemaTypeToXML "availableStartTime") $ healthcareServiceAvailableTime_availableStartTime x
            , maybe [] (schemaTypeToXML "availableEndTime") $ healthcareServiceAvailableTime_availableEndTime x
            ]
instance Extension HealthcareServiceAvailableTime BackboneElement where
    supertype (HealthcareServiceAvailableTime a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension HealthcareServiceAvailableTime Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: HealthcareServiceAvailableTime -> BackboneElement)
              
 
-- | The details of a healthcare service available at a 
--   location.
data HealthcareServiceNotAvailable = HealthcareServiceNotAvailable
        { healthcareServiceNotAvailable_id :: Maybe String_primitive
        , healthcareServiceNotAvailable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , healthcareServiceNotAvailable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , healthcareServiceNotAvailable_description :: Xsd.XsdString
          -- ^ The reason that can be presented to the user as to why this 
          --   time is not available.
        , healthcareServiceNotAvailable_during :: Maybe Period
          -- ^ Service is not available (seasonally or for a public 
          --   holiday) from this date.
        }
        deriving (Eq,Show)
instance SchemaType HealthcareServiceNotAvailable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (HealthcareServiceNotAvailable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "during")
    schemaTypeToXML s x@HealthcareServiceNotAvailable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ healthcareServiceNotAvailable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ healthcareServiceNotAvailable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ healthcareServiceNotAvailable_modifierExtension x
            , schemaTypeToXML "description" $ healthcareServiceNotAvailable_description x
            , maybe [] (schemaTypeToXML "during") $ healthcareServiceNotAvailable_during x
            ]
instance Extension HealthcareServiceNotAvailable BackboneElement where
    supertype (HealthcareServiceNotAvailable a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension HealthcareServiceNotAvailable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: HealthcareServiceNotAvailable -> BackboneElement)
              
 
data DaysOfWeek_list
    = DaysOfWeek_list_Mon
      -- ^ Monday
    | DaysOfWeek_list_Tue
      -- ^ Tuesday
    | DaysOfWeek_list_Wed
      -- ^ Wednesday
    | DaysOfWeek_list_Thu
      -- ^ Thursday
    | DaysOfWeek_list_Fri
      -- ^ Friday
    | DaysOfWeek_list_Sat
      -- ^ Saturday
    | DaysOfWeek_list_Sun
      -- ^ Sunday
    deriving (Eq,Show,Enum)
instance SchemaType DaysOfWeek_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DaysOfWeek_list where
    acceptingParser =  do literal "mon"; return DaysOfWeek_list_Mon
                      `onFail` do literal "tue"; return DaysOfWeek_list_Tue
                      `onFail` do literal "wed"; return DaysOfWeek_list_Wed
                      `onFail` do literal "thu"; return DaysOfWeek_list_Thu
                      `onFail` do literal "fri"; return DaysOfWeek_list_Fri
                      `onFail` do literal "sat"; return DaysOfWeek_list_Sat
                      `onFail` do literal "sun"; return DaysOfWeek_list_Sun
                      
    simpleTypeText DaysOfWeek_list_Mon = "mon"
    simpleTypeText DaysOfWeek_list_Tue = "tue"
    simpleTypeText DaysOfWeek_list_Wed = "wed"
    simpleTypeText DaysOfWeek_list_Thu = "thu"
    simpleTypeText DaysOfWeek_list_Fri = "fri"
    simpleTypeText DaysOfWeek_list_Sat = "sat"
    simpleTypeText DaysOfWeek_list_Sun = "sun"
 
data DaysOfWeek = DaysOfWeek
        { daysOfWeek_id :: Maybe String_primitive
        , daysOfWeek_value :: Maybe DaysOfWeek_list
        , daysOfWeek_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DaysOfWeek where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DaysOfWeek a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DaysOfWeek{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ daysOfWeek_id x
                       , maybe [] (toXMLAttribute "value") $ daysOfWeek_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ daysOfWeek_extension x
            ]
instance Extension DaysOfWeek Element where
    supertype (DaysOfWeek a0 a1 e0) =
               Element a0 e0
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
elementImagingManifest :: XMLParser ImagingManifest
elementImagingManifest = parseSchemaType "ImagingManifest"
elementToXMLImagingManifest :: ImagingManifest -> [Content ()]
elementToXMLImagingManifest = schemaTypeToXML "ImagingManifest"
 
data ImagingManifest = ImagingManifest
        { imagingManifest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , imagingManifest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , imagingManifest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , imagingManifest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , imagingManifest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , imagingManifest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , imagingManifest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifest_identifier :: Maybe Identifier
          -- ^ Unique identifier of the DICOM Key Object Selection (KOS) 
          --   that this resource represents.
        , imagingManifest_patient :: Reference
          -- ^ A patient resource reference which is the patient subject 
          --   of all DICOM SOP Instances in this ImagingManifest.
        , imagingManifest_authoringTime :: Maybe DateTime
          -- ^ Date and time when the selection of the referenced 
          --   instances were made. It is (typically) different from the 
          --   creation date of the selection resource, and from dates 
          --   associated with the referenced instances (e.g. capture time 
          --   of the referenced image).
        , imagingManifest_author :: Maybe Reference
          -- ^ Author of ImagingManifest. It can be a human author or a 
          --   device which made the decision of the SOP instances 
          --   selected. For example, a radiologist selected a set of 
          --   imaging SOP instances to attach in a diagnostic report, and 
          --   a CAD application may author a selection to describe SOP 
          --   instances it used to generate a detection conclusion.
        , imagingManifest_description :: Maybe Xsd.XsdString
          -- ^ Free text narrative description of the ImagingManifest. The 
          --   value may be derived from the DICOM Standard Part 16, 
          --   CID-7010 descriptions (e.g. Best in Set, Complete Study 
          --   Content). Note that those values cover the wide range of 
          --   uses of the DICOM Key Object Selection object, several of 
          --   which are not supported by ImagingManifest. Specifically, 
          --   there is no expected behavior associated with descriptions 
          --   that suggest referenced images be removed or not used.
        , imagingManifest_study :: [ImagingManifestStudy]
          -- ^ Study identity and locating information of the DICOM SOP 
          --   instances in the selection.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImagingManifest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "authoringTime")
            `apply` optional (parseSchemaType "author")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "study")
    schemaTypeToXML s x@ImagingManifest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ imagingManifest_id x
            , maybe [] (schemaTypeToXML "meta") $ imagingManifest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ imagingManifest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ imagingManifest_language x
            , maybe [] (schemaTypeToXML "text") $ imagingManifest_text x
            , concatMap (schemaTypeToXML "contained") $ imagingManifest_contained x
            , concatMap (schemaTypeToXML "extension") $ imagingManifest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifest_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ imagingManifest_identifier x
            , schemaTypeToXML "patient" $ imagingManifest_patient x
            , maybe [] (schemaTypeToXML "authoringTime") $ imagingManifest_authoringTime x
            , maybe [] (schemaTypeToXML "author") $ imagingManifest_author x
            , maybe [] (schemaTypeToXML "description") $ imagingManifest_description x
            , concatMap (schemaTypeToXML "study") $ imagingManifest_study x
            ]
instance Extension ImagingManifest DomainResource where
    supertype (ImagingManifest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImagingManifest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImagingManifest -> DomainResource)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifestStudy = ImagingManifestStudy
        { imagingManifestStudy_id :: Maybe String_primitive
        , imagingManifestStudy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifestStudy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifestStudy_uid :: Oid
          -- ^ Study instance UID of the SOP instances in the selection.
        , imagingManifestStudy_imagingStudy :: Maybe Reference
          -- ^ Reference to the Imaging Study in FHIR form.
        , imagingManifestStudy_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for the study. See implementation notes for 
          --   information about using DICOM endpoints. A study-level 
          --   endpoint applies to each series in the study, unless 
          --   overridden by a series-level endpoint with the same 
          --   Endpoint.type.
        , imagingManifestStudy_series :: [ImagingManifestSeries]
          -- ^ Series identity and locating information of the DICOM SOP 
          --   instances in the selection.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifestStudy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifestStudy a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "imagingStudy")
            `apply` many (parseSchemaType "endpoint")
            `apply` many1 (parseSchemaType "series")
    schemaTypeToXML s x@ImagingManifestStudy{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifestStudy_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifestStudy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifestStudy_modifierExtension x
            , schemaTypeToXML "uid" $ imagingManifestStudy_uid x
            , maybe [] (schemaTypeToXML "imagingStudy") $ imagingManifestStudy_imagingStudy x
            , concatMap (schemaTypeToXML "endpoint") $ imagingManifestStudy_endpoint x
            , concatMap (schemaTypeToXML "series") $ imagingManifestStudy_series x
            ]
instance Extension ImagingManifestStudy BackboneElement where
    supertype (ImagingManifestStudy a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifestStudy Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifestStudy -> BackboneElement)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifestSeries = ImagingManifestSeries
        { imagingManifestSeries_id :: Maybe String_primitive
        , imagingManifestSeries_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifestSeries_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifestSeries_uid :: Oid
          -- ^ Series instance UID of the SOP instances in the selection.
        , imagingManifestSeries_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for this series. See implementation notes for 
          --   information about using DICOM endpoints. A series-level 
          --   endpoint, if present, has precedence over a study-level 
          --   endpoint with the same Endpoint.type.
        , imagingManifestSeries_instance :: [ImagingManifestInstance]
          -- ^ Identity and locating information of the selected DICOM SOP 
          --   instances.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifestSeries where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifestSeries a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` many (parseSchemaType "endpoint")
            `apply` many1 (parseSchemaType "instance")
    schemaTypeToXML s x@ImagingManifestSeries{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifestSeries_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifestSeries_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifestSeries_modifierExtension x
            , schemaTypeToXML "uid" $ imagingManifestSeries_uid x
            , concatMap (schemaTypeToXML "endpoint") $ imagingManifestSeries_endpoint x
            , concatMap (schemaTypeToXML "instance") $ imagingManifestSeries_instance x
            ]
instance Extension ImagingManifestSeries BackboneElement where
    supertype (ImagingManifestSeries a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifestSeries Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifestSeries -> BackboneElement)
              
 
-- | A text description of the DICOM SOP instances selected in 
--   the ImagingManifest; or the reason for, or significance of, 
--   the selection.
data ImagingManifestInstance = ImagingManifestInstance
        { imagingManifestInstance_id :: Maybe String_primitive
        , imagingManifestInstance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingManifestInstance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingManifestInstance_sopClass :: Oid
          -- ^ SOP class UID of the selected instance.
        , imagingManifestInstance_uid :: Oid
          -- ^ SOP Instance UID of the selected instance.
        }
        deriving (Eq,Show)
instance SchemaType ImagingManifestInstance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingManifestInstance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sopClass"
            `apply` parseSchemaType "uid"
    schemaTypeToXML s x@ImagingManifestInstance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingManifestInstance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingManifestInstance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingManifestInstance_modifierExtension x
            , schemaTypeToXML "sopClass" $ imagingManifestInstance_sopClass x
            , schemaTypeToXML "uid" $ imagingManifestInstance_uid x
            ]
instance Extension ImagingManifestInstance BackboneElement where
    supertype (ImagingManifestInstance a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImagingManifestInstance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingManifestInstance -> BackboneElement)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
elementImagingStudy :: XMLParser ImagingStudy
elementImagingStudy = parseSchemaType "ImagingStudy"
elementToXMLImagingStudy :: ImagingStudy -> [Content ()]
elementToXMLImagingStudy = schemaTypeToXML "ImagingStudy"
 
data ImagingStudy = ImagingStudy
        { imagingStudy_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , imagingStudy_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , imagingStudy_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , imagingStudy_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , imagingStudy_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , imagingStudy_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , imagingStudy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudy_uid :: Oid
          -- ^ Formal identifier for the study.
        , imagingStudy_accession :: Maybe Identifier
          -- ^ Accession Number is an identifier related to some aspect of 
          --   imaging workflow and data management. Usage may vary across 
          --   different institutions. See for instance [IHE Radiology 
          --   Technical Framework Volume 1 Appendix 
          --   A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf).
        , imagingStudy_identifier :: [Identifier]
          -- ^ Other identifiers for the study.
        , imagingStudy_availability :: Maybe InstanceAvailability
          -- ^ Availability of study (online, offline, or nearline).
        , imagingStudy_modalityList :: [Coding]
          -- ^ A list of all the Series.ImageModality values that are 
          --   actual acquisition modalities, i.e. those in the DICOM 
          --   Context Group 29 (value set OID 1.2.840.10008.6.1.19).
        , imagingStudy_patient :: Reference
          -- ^ The patient imaged in the study.
        , imagingStudy_context :: Maybe Reference
          -- ^ The encounter or episode at which the request is initiated.
        , imagingStudy_started :: Maybe DateTime
          -- ^ Date and time the study started.
        , imagingStudy_basedOn :: [Reference]
          -- ^ A list of the diagnostic requests that resulted in this 
          --   imaging study being performed.
        , imagingStudy_referrer :: Maybe Reference
          -- ^ The requesting/referring physician.
        , imagingStudy_interpreter :: [Reference]
          -- ^ Who read the study and interpreted the images or other 
          --   content.
        , imagingStudy_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for the study. See implementation notes for 
          --   information about using DICOM endpoints. A study-level 
          --   endpoint applies to each series in the study, unless 
          --   overridden by a series-level endpoint with the same 
          --   Endpoint.type.
        , imagingStudy_numberOfSeries :: Maybe UnsignedInt
          -- ^ Number of Series in the Study. This value given may be 
          --   larger than the number of series elements this Resource 
          --   contains due to resource availability, security, or other 
          --   factors. This element should be present if any series 
          --   elements are present.
        , imagingStudy_numberOfInstances :: Maybe UnsignedInt
          -- ^ Number of SOP Instances in Study. This value given may be 
          --   larger than the number of instance elements this resource 
          --   contains due to resource availability, security, or other 
          --   factors. This element should be present if any instance 
          --   elements are present.
        , imagingStudy_procedureReference :: [Reference]
          -- ^ A reference to the performed Procedure.
        , imagingStudy_procedureCode :: [CodeableConcept]
          -- ^ The code for the performed procedure type.
        , imagingStudy_reason :: Maybe CodeableConcept
          -- ^ Description of clinical condition indicating why the 
          --   ImagingStudy was requested.
        , imagingStudy_description :: Maybe Xsd.XsdString
          -- ^ Institution-generated description or classification of the 
          --   Study performed.
        , imagingStudy_series :: [ImagingStudySeries]
          -- ^ Each study has one or more series of images or other 
          --   content.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImagingStudy
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "accession")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "availability")
            `apply` many (parseSchemaType "modalityList")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "started")
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "referrer")
            `apply` many (parseSchemaType "interpreter")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "numberOfSeries")
            `apply` optional (parseSchemaType "numberOfInstances")
            `apply` many (parseSchemaType "procedureReference")
            `apply` many (parseSchemaType "procedureCode")
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "series")
    schemaTypeToXML s x@ImagingStudy{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ imagingStudy_id x
            , maybe [] (schemaTypeToXML "meta") $ imagingStudy_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ imagingStudy_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ imagingStudy_language x
            , maybe [] (schemaTypeToXML "text") $ imagingStudy_text x
            , concatMap (schemaTypeToXML "contained") $ imagingStudy_contained x
            , concatMap (schemaTypeToXML "extension") $ imagingStudy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudy_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudy_uid x
            , maybe [] (schemaTypeToXML "accession") $ imagingStudy_accession x
            , concatMap (schemaTypeToXML "identifier") $ imagingStudy_identifier x
            , maybe [] (schemaTypeToXML "availability") $ imagingStudy_availability x
            , concatMap (schemaTypeToXML "modalityList") $ imagingStudy_modalityList x
            , schemaTypeToXML "patient" $ imagingStudy_patient x
            , maybe [] (schemaTypeToXML "context") $ imagingStudy_context x
            , maybe [] (schemaTypeToXML "started") $ imagingStudy_started x
            , concatMap (schemaTypeToXML "basedOn") $ imagingStudy_basedOn x
            , maybe [] (schemaTypeToXML "referrer") $ imagingStudy_referrer x
            , concatMap (schemaTypeToXML "interpreter") $ imagingStudy_interpreter x
            , concatMap (schemaTypeToXML "endpoint") $ imagingStudy_endpoint x
            , maybe [] (schemaTypeToXML "numberOfSeries") $ imagingStudy_numberOfSeries x
            , maybe [] (schemaTypeToXML "numberOfInstances") $ imagingStudy_numberOfInstances x
            , concatMap (schemaTypeToXML "procedureReference") $ imagingStudy_procedureReference x
            , concatMap (schemaTypeToXML "procedureCode") $ imagingStudy_procedureCode x
            , maybe [] (schemaTypeToXML "reason") $ imagingStudy_reason x
            , maybe [] (schemaTypeToXML "description") $ imagingStudy_description x
            , concatMap (schemaTypeToXML "series") $ imagingStudy_series x
            ]
instance Extension ImagingStudy DomainResource where
    supertype (ImagingStudy e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImagingStudy Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImagingStudy -> DomainResource)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
data ImagingStudySeries = ImagingStudySeries
        { imagingStudySeries_id :: Maybe String_primitive
        , imagingStudySeries_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudySeries_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudySeries_uid :: Oid
          -- ^ Formal identifier for this series.
        , imagingStudySeries_number :: Maybe UnsignedInt
          -- ^ The numeric identifier of this series in the study.
        , imagingStudySeries_modality :: Coding
          -- ^ The modality of this series sequence.
        , imagingStudySeries_description :: Maybe Xsd.XsdString
          -- ^ A description of the series.
        , imagingStudySeries_numberOfInstances :: Maybe UnsignedInt
          -- ^ Number of SOP Instances in the Study. The value given may 
          --   be larger than the number of instance elements this 
          --   resource contains due to resource availability, security, 
          --   or other factors. This element should be present if any 
          --   instance elements are present.
        , imagingStudySeries_availability :: Maybe InstanceAvailability
          -- ^ Availability of series (online, offline or nearline).
        , imagingStudySeries_endpoint :: [Reference]
          -- ^ The network service providing access (e.g., query, view, or 
          --   retrieval) for this series. See implementation notes for 
          --   information about using DICOM endpoints. A series-level 
          --   endpoint, if present, has precedence over a study-level 
          --   endpoint with the same Endpoint.type.
        , imagingStudySeries_bodySite :: Maybe Coding
          -- ^ The anatomic structures examined. See DICOM Part 16 Annex L 
          --   (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) 
          --   for DICOM to SNOMED-CT mappings. The bodySite may indicate 
          --   the laterality of body part imaged; if so, it shall be 
          --   consistent with any content of 
          --   ImagingStudy.series.laterality.
        , imagingStudySeries_laterality :: Maybe Coding
          -- ^ The laterality of the (possibly paired) anatomic structures 
          --   examined. E.g., the left knee, both lungs, or unpaired 
          --   abdomen. If present, shall be consistent with any 
          --   laterality information indicated in 
          --   ImagingStudy.series.bodySite.
        , imagingStudySeries_started :: Maybe DateTime
          -- ^ The date and time the series was started.
        , imagingStudySeries_performer :: [Reference]
          -- ^ The physician or operator (often the radiology technician) 
          --   who performed the series. The performer is recorded at the 
          --   series level, since each series in a study may be performed 
          --   by a different practitioner, at different times, and using 
          --   different devices. A series may be performed by multiple 
          --   practitioners.
        , imagingStudySeries_instance :: [ImagingStudyInstance]
          -- ^ A single SOP instance within the series, e.g. an image, or 
          --   presentation state.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudySeries where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingStudySeries a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "number")
            `apply` parseSchemaType "modality"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "numberOfInstances")
            `apply` optional (parseSchemaType "availability")
            `apply` many (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "laterality")
            `apply` optional (parseSchemaType "started")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "instance")
    schemaTypeToXML s x@ImagingStudySeries{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingStudySeries_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingStudySeries_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudySeries_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudySeries_uid x
            , maybe [] (schemaTypeToXML "number") $ imagingStudySeries_number x
            , schemaTypeToXML "modality" $ imagingStudySeries_modality x
            , maybe [] (schemaTypeToXML "description") $ imagingStudySeries_description x
            , maybe [] (schemaTypeToXML "numberOfInstances") $ imagingStudySeries_numberOfInstances x
            , maybe [] (schemaTypeToXML "availability") $ imagingStudySeries_availability x
            , concatMap (schemaTypeToXML "endpoint") $ imagingStudySeries_endpoint x
            , maybe [] (schemaTypeToXML "bodySite") $ imagingStudySeries_bodySite x
            , maybe [] (schemaTypeToXML "laterality") $ imagingStudySeries_laterality x
            , maybe [] (schemaTypeToXML "started") $ imagingStudySeries_started x
            , concatMap (schemaTypeToXML "performer") $ imagingStudySeries_performer x
            , concatMap (schemaTypeToXML "instance") $ imagingStudySeries_instance x
            ]
instance Extension ImagingStudySeries BackboneElement where
    supertype (ImagingStudySeries a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13) =
               BackboneElement a0 e0 e1
instance Extension ImagingStudySeries Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingStudySeries -> BackboneElement)
              
 
-- | Representation of the content produced in a DICOM imaging 
--   study. A study comprises a set of series, each of which 
--   includes a set of Service-Object Pair Instances (SOP 
--   Instances - images or other data) acquired or produced in a 
--   common context. A series is of only one modality (e.g. 
--   X-ray, CT, MR, ultrasound), but a study may have multiple 
--   series of different modalities.
data ImagingStudyInstance = ImagingStudyInstance
        { imagingStudyInstance_id :: Maybe String_primitive
        , imagingStudyInstance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , imagingStudyInstance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , imagingStudyInstance_uid :: Oid
          -- ^ Formal identifier for this image or other content.
        , imagingStudyInstance_number :: Maybe UnsignedInt
          -- ^ The number of instance in the series.
        , imagingStudyInstance_sopClass :: Oid
          -- ^ DICOM instance type.
        , imagingStudyInstance_title :: Maybe Xsd.XsdString
          -- ^ The description of the instance.
        }
        deriving (Eq,Show)
instance SchemaType ImagingStudyInstance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImagingStudyInstance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "uid"
            `apply` optional (parseSchemaType "number")
            `apply` parseSchemaType "sopClass"
            `apply` optional (parseSchemaType "title")
    schemaTypeToXML s x@ImagingStudyInstance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ imagingStudyInstance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ imagingStudyInstance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ imagingStudyInstance_modifierExtension x
            , schemaTypeToXML "uid" $ imagingStudyInstance_uid x
            , maybe [] (schemaTypeToXML "number") $ imagingStudyInstance_number x
            , schemaTypeToXML "sopClass" $ imagingStudyInstance_sopClass x
            , maybe [] (schemaTypeToXML "title") $ imagingStudyInstance_title x
            ]
instance Extension ImagingStudyInstance BackboneElement where
    supertype (ImagingStudyInstance a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImagingStudyInstance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImagingStudyInstance -> BackboneElement)
              
 
data InstanceAvailability_list
    = InstanceAvailability_list_ONLINE
      -- ^ Online
    | InstanceAvailability_list_OFFLINE
      -- ^ Offline
    | InstanceAvailability_list_NEARLINE
      -- ^ Nearline
    | InstanceAvailability_list_UNAVAILABLE
      -- ^ Unavailable
    deriving (Eq,Show,Enum)
instance SchemaType InstanceAvailability_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType InstanceAvailability_list where
    acceptingParser =  do literal "ONLINE"; return InstanceAvailability_list_ONLINE
                      `onFail` do literal "OFFLINE"; return InstanceAvailability_list_OFFLINE
                      `onFail` do literal "NEARLINE"; return InstanceAvailability_list_NEARLINE
                      `onFail` do literal "UNAVAILABLE"; return InstanceAvailability_list_UNAVAILABLE
                      
    simpleTypeText InstanceAvailability_list_ONLINE = "ONLINE"
    simpleTypeText InstanceAvailability_list_OFFLINE = "OFFLINE"
    simpleTypeText InstanceAvailability_list_NEARLINE = "NEARLINE"
    simpleTypeText InstanceAvailability_list_UNAVAILABLE = "UNAVAILABLE"
 
data InstanceAvailability = InstanceAvailability
        { instanceAvailability_id :: Maybe String_primitive
        , instanceAvailability_value :: Maybe InstanceAvailability_list
        , instanceAvailability_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType InstanceAvailability where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (InstanceAvailability a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@InstanceAvailability{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ instanceAvailability_id x
                       , maybe [] (toXMLAttribute "value") $ instanceAvailability_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ instanceAvailability_extension x
            ]
instance Extension InstanceAvailability Element where
    supertype (InstanceAvailability a0 a1 e0) =
               Element a0 e0
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
elementImmunization :: XMLParser Immunization
elementImmunization = parseSchemaType "Immunization"
elementToXMLImmunization :: Immunization -> [Content ()]
elementToXMLImmunization = schemaTypeToXML "Immunization"
 
data Immunization = Immunization
        { immunization_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , immunization_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , immunization_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , immunization_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , immunization_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , immunization_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , immunization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunization_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this immunization record.
        , immunization_status :: ImmunizationStatusCodes
          -- ^ Indicates the current status of the vaccination event.
        , immunization_notGiven :: Boolean
          -- ^ Indicates if the vaccination was or was not given.
        , immunization_vaccineCode :: CodeableConcept
          -- ^ Vaccine that was administered or was to be administered.
        , immunization_patient :: Reference
          -- ^ The patient who either received or did not receive the 
          --   immunization.
        , immunization_encounter :: Maybe Reference
          -- ^ The visit or admission or other contact between patient and 
          --   health care provider the immunization was performed as part 
          --   of.
        , immunization_date :: Maybe DateTime
          -- ^ Date vaccine administered or was to be administered.
        , immunization_primarySource :: Boolean
          -- ^ An indication that the content of the record is based on 
          --   information from the person who administered the vaccine. 
          --   This reflects the context under which the data was 
          --   originally recorded.
        , immunization_reportOrigin :: Maybe CodeableConcept
          -- ^ The source of the data when the report of the immunization 
          --   event is not based on information from the person who 
          --   administered the vaccine.
        , immunization_location :: Maybe Reference
          -- ^ The service delivery location where the vaccine 
          --   administration occurred.
        , immunization_manufacturer :: Maybe Reference
          -- ^ Name of vaccine manufacturer.
        , immunization_lotNumber :: Maybe Xsd.XsdString
          -- ^ Lot number of the vaccine product.
        , immunization_expirationDate :: Maybe Date
          -- ^ Date vaccine batch expires.
        , immunization_site :: Maybe CodeableConcept
          -- ^ Body site where vaccine was administered.
        , immunization_route :: Maybe CodeableConcept
          -- ^ The path by which the vaccine product is taken into the 
          --   body.
        , immunization_doseQuantity :: Maybe Quantity
          -- ^ The quantity of vaccine product that was administered.
        , immunization_practitioner :: [ImmunizationPractitioner]
          -- ^ Indicates who or what performed the event.
        , immunization_note :: [Annotation]
          -- ^ Extra information about the immunization that is not 
          --   conveyed by the other attributes.
        , immunization_explanation :: Maybe ImmunizationExplanation
          -- ^ Reasons why a vaccine was or was not administered.
        , immunization_reaction :: [ImmunizationReaction]
          -- ^ Categorical data indicating that an adverse event is 
          --   associated in time to an immunization.
        , immunization_vaccinationProtocol :: [ImmunizationVaccinationProtocol]
          -- ^ Contains information about the protocol(s) under which the 
          --   vaccine was administered.
        }
        deriving (Eq,Show)
instance SchemaType Immunization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Immunization
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "notGiven"
            `apply` parseSchemaType "vaccineCode"
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "date")
            `apply` parseSchemaType "primarySource"
            `apply` optional (parseSchemaType "reportOrigin")
            `apply` optional (parseSchemaType "location")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "expirationDate")
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "doseQuantity")
            `apply` many (parseSchemaType "practitioner")
            `apply` many (parseSchemaType "note")
            `apply` optional (parseSchemaType "explanation")
            `apply` many (parseSchemaType "reaction")
            `apply` many (parseSchemaType "vaccinationProtocol")
    schemaTypeToXML s x@Immunization{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ immunization_id x
            , maybe [] (schemaTypeToXML "meta") $ immunization_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ immunization_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ immunization_language x
            , maybe [] (schemaTypeToXML "text") $ immunization_text x
            , concatMap (schemaTypeToXML "contained") $ immunization_contained x
            , concatMap (schemaTypeToXML "extension") $ immunization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunization_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ immunization_identifier x
            , schemaTypeToXML "status" $ immunization_status x
            , schemaTypeToXML "notGiven" $ immunization_notGiven x
            , schemaTypeToXML "vaccineCode" $ immunization_vaccineCode x
            , schemaTypeToXML "patient" $ immunization_patient x
            , maybe [] (schemaTypeToXML "encounter") $ immunization_encounter x
            , maybe [] (schemaTypeToXML "date") $ immunization_date x
            , schemaTypeToXML "primarySource" $ immunization_primarySource x
            , maybe [] (schemaTypeToXML "reportOrigin") $ immunization_reportOrigin x
            , maybe [] (schemaTypeToXML "location") $ immunization_location x
            , maybe [] (schemaTypeToXML "manufacturer") $ immunization_manufacturer x
            , maybe [] (schemaTypeToXML "lotNumber") $ immunization_lotNumber x
            , maybe [] (schemaTypeToXML "expirationDate") $ immunization_expirationDate x
            , maybe [] (schemaTypeToXML "site") $ immunization_site x
            , maybe [] (schemaTypeToXML "route") $ immunization_route x
            , maybe [] (schemaTypeToXML "doseQuantity") $ immunization_doseQuantity x
            , concatMap (schemaTypeToXML "practitioner") $ immunization_practitioner x
            , concatMap (schemaTypeToXML "note") $ immunization_note x
            , maybe [] (schemaTypeToXML "explanation") $ immunization_explanation x
            , concatMap (schemaTypeToXML "reaction") $ immunization_reaction x
            , concatMap (schemaTypeToXML "vaccinationProtocol") $ immunization_vaccinationProtocol x
            ]
instance Extension Immunization DomainResource where
    supertype (Immunization e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Immunization Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Immunization -> DomainResource)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data ImmunizationPractitioner = ImmunizationPractitioner
        { immunizationPractitioner_id :: Maybe String_primitive
        , immunizationPractitioner_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationPractitioner_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationPractitioner_role :: Maybe CodeableConcept
          -- ^ Describes the type of performance (e.g. ordering provider, 
          --   administering provider, etc.).
        , immunizationPractitioner_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationPractitioner where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationPractitioner a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
    schemaTypeToXML s x@ImmunizationPractitioner{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationPractitioner_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationPractitioner_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationPractitioner_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ immunizationPractitioner_role x
            , schemaTypeToXML "actor" $ immunizationPractitioner_actor x
            ]
instance Extension ImmunizationPractitioner BackboneElement where
    supertype (ImmunizationPractitioner a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationPractitioner Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationPractitioner -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data ImmunizationExplanation = ImmunizationExplanation
        { immunizationExplanation_id :: Maybe String_primitive
        , immunizationExplanation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationExplanation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationExplanation_reason :: [CodeableConcept]
          -- ^ Reasons why a vaccine was administered.
        , immunizationExplanation_reasonNotGiven :: [CodeableConcept]
          -- ^ Reason why a vaccine was not administered.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationExplanation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationExplanation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "reasonNotGiven")
    schemaTypeToXML s x@ImmunizationExplanation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationExplanation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationExplanation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationExplanation_modifierExtension x
            , concatMap (schemaTypeToXML "reason") $ immunizationExplanation_reason x
            , concatMap (schemaTypeToXML "reasonNotGiven") $ immunizationExplanation_reasonNotGiven x
            ]
instance Extension ImmunizationExplanation BackboneElement where
    supertype (ImmunizationExplanation a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationExplanation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationExplanation -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data ImmunizationReaction = ImmunizationReaction
        { immunizationReaction_id :: Maybe String_primitive
        , immunizationReaction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationReaction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationReaction_date :: Maybe DateTime
          -- ^ Date of reaction to the immunization.
        , immunizationReaction_detail :: Maybe Reference
          -- ^ Details of the reaction.
        , immunizationReaction_reported :: Maybe Boolean
          -- ^ Self-reported indicator.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationReaction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationReaction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "detail")
            `apply` optional (parseSchemaType "reported")
    schemaTypeToXML s x@ImmunizationReaction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationReaction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationReaction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationReaction_modifierExtension x
            , maybe [] (schemaTypeToXML "date") $ immunizationReaction_date x
            , maybe [] (schemaTypeToXML "detail") $ immunizationReaction_detail x
            , maybe [] (schemaTypeToXML "reported") $ immunizationReaction_reported x
            ]
instance Extension ImmunizationReaction BackboneElement where
    supertype (ImmunizationReaction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationReaction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationReaction -> BackboneElement)
              
 
-- | Describes the event of a patient being administered a 
--   vaccination or a record of a vaccination as reported by a 
--   patient, a clinician or another party and may include 
--   vaccine reaction information and what vaccination protocol 
--   was followed.
data ImmunizationVaccinationProtocol = ImmunizationVaccinationProtocol
        { immunizationVaccinationProtocol_id :: Maybe String_primitive
        , immunizationVaccinationProtocol_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationVaccinationProtocol_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationVaccinationProtocol_doseSequence :: Maybe PositiveInt
          -- ^ Nominal position in a series.
        , immunizationVaccinationProtocol_description :: Maybe Xsd.XsdString
          -- ^ Contains the description about the protocol under which the 
          --   vaccine was administered.
        , immunizationVaccinationProtocol_authority :: Maybe Reference
          -- ^ Indicates the authority who published the protocol. E.g. 
          --   ACIP.
        , immunizationVaccinationProtocol_series :: Maybe Xsd.XsdString
          -- ^ One possible path to achieve presumed immunity against a 
          --   disease - within the context of an authority.
        , immunizationVaccinationProtocol_seriesDoses :: Maybe PositiveInt
          -- ^ The recommended number of doses to achieve immunity.
        , immunizationVaccinationProtocol_targetDisease :: [CodeableConcept]
          -- ^ The targeted disease.
        , immunizationVaccinationProtocol_doseStatus :: CodeableConcept
          -- ^ Indicates if the immunization event should 
          --   &quot;count&quot; against the protocol.
        , immunizationVaccinationProtocol_doseStatusReason :: Maybe CodeableConcept
          -- ^ Provides an explanation as to why an immunization event 
          --   should or should not count against the protocol.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationVaccinationProtocol where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationVaccinationProtocol a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "doseSequence")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "series")
            `apply` optional (parseSchemaType "seriesDoses")
            `apply` many1 (parseSchemaType "targetDisease")
            `apply` parseSchemaType "doseStatus"
            `apply` optional (parseSchemaType "doseStatusReason")
    schemaTypeToXML s x@ImmunizationVaccinationProtocol{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationVaccinationProtocol_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationVaccinationProtocol_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationVaccinationProtocol_modifierExtension x
            , maybe [] (schemaTypeToXML "doseSequence") $ immunizationVaccinationProtocol_doseSequence x
            , maybe [] (schemaTypeToXML "description") $ immunizationVaccinationProtocol_description x
            , maybe [] (schemaTypeToXML "authority") $ immunizationVaccinationProtocol_authority x
            , maybe [] (schemaTypeToXML "series") $ immunizationVaccinationProtocol_series x
            , maybe [] (schemaTypeToXML "seriesDoses") $ immunizationVaccinationProtocol_seriesDoses x
            , concatMap (schemaTypeToXML "targetDisease") $ immunizationVaccinationProtocol_targetDisease x
            , schemaTypeToXML "doseStatus" $ immunizationVaccinationProtocol_doseStatus x
            , maybe [] (schemaTypeToXML "doseStatusReason") $ immunizationVaccinationProtocol_doseStatusReason x
            ]
instance Extension ImmunizationVaccinationProtocol BackboneElement where
    supertype (ImmunizationVaccinationProtocol a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationVaccinationProtocol Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationVaccinationProtocol -> BackboneElement)
              
 
data ImmunizationStatusCodes_list
    = ImmunizationStatusCodes_list_Completed
      -- ^ Completed
    | ImmunizationStatusCodes_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType ImmunizationStatusCodes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ImmunizationStatusCodes_list where
    acceptingParser =  do literal "completed"; return ImmunizationStatusCodes_list_Completed
                      `onFail` do literal "entered-in-error"; return ImmunizationStatusCodes_list_Entered_in_error
                      
    simpleTypeText ImmunizationStatusCodes_list_Completed = "completed"
    simpleTypeText ImmunizationStatusCodes_list_Entered_in_error = "entered-in-error"
 
data ImmunizationStatusCodes = ImmunizationStatusCodes
        { immunizationStatusCodes_id :: Maybe String_primitive
        , immunizationStatusCodes_value :: Maybe ImmunizationStatusCodes_list
        , immunizationStatusCodes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationStatusCodes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ImmunizationStatusCodes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ImmunizationStatusCodes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationStatusCodes_id x
                       , maybe [] (toXMLAttribute "value") $ immunizationStatusCodes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationStatusCodes_extension x
            ]
instance Extension ImmunizationStatusCodes Element where
    supertype (ImmunizationStatusCodes a0 a1 e0) =
               Element a0 e0
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
elementImmunizationRecommendation :: XMLParser ImmunizationRecommendation
elementImmunizationRecommendation = parseSchemaType "ImmunizationRecommendation"
elementToXMLImmunizationRecommendation :: ImmunizationRecommendation -> [Content ()]
elementToXMLImmunizationRecommendation = schemaTypeToXML "ImmunizationRecommendation"
 
data ImmunizationRecommendation = ImmunizationRecommendation
        { immunizationRecommendation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , immunizationRecommendation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , immunizationRecommendation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , immunizationRecommendation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , immunizationRecommendation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , immunizationRecommendation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , immunizationRecommendation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendation_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this particular 
          --   recommendation record.
        , immunizationRecommendation_patient :: Reference
          -- ^ The patient the recommendations are for.
        , immunizationRecommendation_recommendation :: [ImmunizationRecommendationRecommendation]
          -- ^ Vaccine administration recommendations.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImmunizationRecommendation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "patient"
            `apply` many1 (parseSchemaType "recommendation")
    schemaTypeToXML s x@ImmunizationRecommendation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ immunizationRecommendation_id x
            , maybe [] (schemaTypeToXML "meta") $ immunizationRecommendation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ immunizationRecommendation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ immunizationRecommendation_language x
            , maybe [] (schemaTypeToXML "text") $ immunizationRecommendation_text x
            , concatMap (schemaTypeToXML "contained") $ immunizationRecommendation_contained x
            , concatMap (schemaTypeToXML "extension") $ immunizationRecommendation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ immunizationRecommendation_identifier x
            , schemaTypeToXML "patient" $ immunizationRecommendation_patient x
            , concatMap (schemaTypeToXML "recommendation") $ immunizationRecommendation_recommendation x
            ]
instance Extension ImmunizationRecommendation DomainResource where
    supertype (ImmunizationRecommendation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImmunizationRecommendation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImmunizationRecommendation -> DomainResource)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendationRecommendation = ImmunizationRecommendationRecommendation
        { immunizationRecommendationRecommendation_id :: Maybe String_primitive
        , immunizationRecommendationRecommendation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendationRecommendation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendationRecommendation_date :: DateTime
          -- ^ The date the immunization recommendation was created.
        , immunizationRecommendationRecommendation_vaccineCode :: Maybe CodeableConcept
          -- ^ Vaccine that pertains to the recommendation.
        , immunizationRecommendationRecommendation_targetDisease :: Maybe CodeableConcept
          -- ^ The targeted disease for the recommendation.
        , immunizationRecommendationRecommendation_doseNumber :: Maybe PositiveInt
          -- ^ The next recommended dose number (e.g. dose 2 is the next 
          --   recommended dose).
        , immunizationRecommendationRecommendation_forecastStatus :: CodeableConcept
          -- ^ Vaccine administration status.
        , immunizationRecommendationRecommendation_dateCriterion :: [ImmunizationRecommendationDateCriterion]
          -- ^ Vaccine date recommendations. For example, earliest date to 
          --   administer, latest date to administer, etc.
        , immunizationRecommendationRecommendation_protocol :: Maybe ImmunizationRecommendationProtocol
          -- ^ Contains information about the protocol under which the 
          --   vaccine was administered.
        , immunizationRecommendationRecommendation_supportingImmunization :: [Reference]
          -- ^ Immunization event history that supports the status and 
          --   recommendation.
        , immunizationRecommendationRecommendation_supportingPatientInformation :: [Reference]
          -- ^ Patient Information that supports the status and 
          --   recommendation. This includes patient observations, adverse 
          --   reactions and allergy/intolerance information.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendationRecommendation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendationRecommendation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "vaccineCode")
            `apply` optional (parseSchemaType "targetDisease")
            `apply` optional (parseSchemaType "doseNumber")
            `apply` parseSchemaType "forecastStatus"
            `apply` many (parseSchemaType "dateCriterion")
            `apply` optional (parseSchemaType "protocol")
            `apply` many (parseSchemaType "supportingImmunization")
            `apply` many (parseSchemaType "supportingPatientInformation")
    schemaTypeToXML s x@ImmunizationRecommendationRecommendation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendationRecommendation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendationRecommendation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendationRecommendation_modifierExtension x
            , schemaTypeToXML "date" $ immunizationRecommendationRecommendation_date x
            , maybe [] (schemaTypeToXML "vaccineCode") $ immunizationRecommendationRecommendation_vaccineCode x
            , maybe [] (schemaTypeToXML "targetDisease") $ immunizationRecommendationRecommendation_targetDisease x
            , maybe [] (schemaTypeToXML "doseNumber") $ immunizationRecommendationRecommendation_doseNumber x
            , schemaTypeToXML "forecastStatus" $ immunizationRecommendationRecommendation_forecastStatus x
            , concatMap (schemaTypeToXML "dateCriterion") $ immunizationRecommendationRecommendation_dateCriterion x
            , maybe [] (schemaTypeToXML "protocol") $ immunizationRecommendationRecommendation_protocol x
            , concatMap (schemaTypeToXML "supportingImmunization") $ immunizationRecommendationRecommendation_supportingImmunization x
            , concatMap (schemaTypeToXML "supportingPatientInformation") $ immunizationRecommendationRecommendation_supportingPatientInformation x
            ]
instance Extension ImmunizationRecommendationRecommendation BackboneElement where
    supertype (ImmunizationRecommendationRecommendation a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendationRecommendation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendationRecommendation -> BackboneElement)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendationDateCriterion = ImmunizationRecommendationDateCriterion
        { immunizationRecommendationDateCriterion_id :: Maybe String_primitive
        , immunizationRecommendationDateCriterion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendationDateCriterion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendationDateCriterion_code :: CodeableConcept
          -- ^ Date classification of recommendation. For example, 
          --   earliest date to give, latest date to give, etc.
        , immunizationRecommendationDateCriterion_value :: DateTime
          -- ^ The date whose meaning is specified by dateCriterion.code.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendationDateCriterion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendationDateCriterion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ImmunizationRecommendationDateCriterion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendationDateCriterion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendationDateCriterion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendationDateCriterion_modifierExtension x
            , schemaTypeToXML "code" $ immunizationRecommendationDateCriterion_code x
            , schemaTypeToXML "value" $ immunizationRecommendationDateCriterion_value x
            ]
instance Extension ImmunizationRecommendationDateCriterion BackboneElement where
    supertype (ImmunizationRecommendationDateCriterion a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendationDateCriterion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendationDateCriterion -> BackboneElement)
              
 
-- | A patient's point-in-time immunization and recommendation 
--   (i.e. forecasting a patient's immunization eligibility 
--   according to a published schedule) with optional supporting 
--   justification.
data ImmunizationRecommendationProtocol = ImmunizationRecommendationProtocol
        { immunizationRecommendationProtocol_id :: Maybe String_primitive
        , immunizationRecommendationProtocol_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , immunizationRecommendationProtocol_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , immunizationRecommendationProtocol_doseSequence :: Maybe PositiveInt
          -- ^ Indicates the nominal position in a series of the next 
          --   dose. This is the recommended dose number as per a 
          --   specified protocol.
        , immunizationRecommendationProtocol_description :: Maybe Xsd.XsdString
          -- ^ Contains the description about the protocol under which the 
          --   vaccine was administered.
        , immunizationRecommendationProtocol_authority :: Maybe Reference
          -- ^ Indicates the authority who published the protocol. For 
          --   example, ACIP.
        , immunizationRecommendationProtocol_series :: Maybe Xsd.XsdString
          -- ^ One possible path to achieve presumed immunity against a 
          --   disease - within the context of an authority.
        }
        deriving (Eq,Show)
instance SchemaType ImmunizationRecommendationProtocol where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImmunizationRecommendationProtocol a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "doseSequence")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "authority")
            `apply` optional (parseSchemaType "series")
    schemaTypeToXML s x@ImmunizationRecommendationProtocol{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ immunizationRecommendationProtocol_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ immunizationRecommendationProtocol_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ immunizationRecommendationProtocol_modifierExtension x
            , maybe [] (schemaTypeToXML "doseSequence") $ immunizationRecommendationProtocol_doseSequence x
            , maybe [] (schemaTypeToXML "description") $ immunizationRecommendationProtocol_description x
            , maybe [] (schemaTypeToXML "authority") $ immunizationRecommendationProtocol_authority x
            , maybe [] (schemaTypeToXML "series") $ immunizationRecommendationProtocol_series x
            ]
instance Extension ImmunizationRecommendationProtocol BackboneElement where
    supertype (ImmunizationRecommendationProtocol a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ImmunizationRecommendationProtocol Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImmunizationRecommendationProtocol -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
elementImplementationGuide :: XMLParser ImplementationGuide
elementImplementationGuide = parseSchemaType "ImplementationGuide"
elementToXMLImplementationGuide :: ImplementationGuide -> [Content ()]
elementToXMLImplementationGuide = schemaTypeToXML "ImplementationGuide"
 
data ImplementationGuide = ImplementationGuide
        { implementationGuide_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , implementationGuide_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , implementationGuide_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , implementationGuide_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , implementationGuide_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , implementationGuide_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , implementationGuide_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuide_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuide_url :: Uri
          -- ^ An absolute URI that is used to identify this 
          --   implementation guide when it is referenced in a 
          --   specification, model, design or an instance. This SHALL be 
          --   a URL, SHOULD be globally unique, and SHOULD be an address 
          --   at which this implementation guide is (or will be) 
          --   published. The URL SHOULD include the major version of the 
          --   implementation guide. For more information see [Technical 
          --   and Business Versions](resource.html#versions).
        , implementationGuide_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   implementation guide when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the implementation guide author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , implementationGuide_name :: Xsd.XsdString
          -- ^ A natural language name identifying the implementation 
          --   guide. This name should be usable as an identifier for the 
          --   module by machine processing applications such as code 
          --   generation.
        , implementationGuide_status :: PublicationStatus
          -- ^ The status of this implementation guide. Enables tracking 
          --   the life-cycle of the content.
        , implementationGuide_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this implementation guide 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , implementationGuide_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the implementation 
          --   guide was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the implementation guide changes.
        , implementationGuide_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the implementation guide.
        , implementationGuide_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , implementationGuide_description :: Maybe Markdown
          -- ^ A free text natural language description of the 
          --   implementation guide from a consumer's perspective.
        , implementationGuide_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   implementation guide instances.
        , implementationGuide_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the implementation 
          --   guide is intended to be used.
        , implementationGuide_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the implementation guide 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   implementation guide.
        , implementationGuide_fhirVersion :: Maybe Id
          -- ^ The version of the FHIR specification on which this 
          --   ImplementationGuide is based - this is the formal version 
          --   of the specification, without the revision number, e.g. 
          --   [publication].[major].[minor], which is 3.0.1 for this 
          --   version.
        , implementationGuide_dependency :: [ImplementationGuideDependency]
          -- ^ Another implementation guide that this implementation 
          --   depends on. Typically, an implementation guide uses value 
          --   sets, profiles etc.defined in other implementation guides.
        , implementationGuide_package :: [ImplementationGuidePackage]
          -- ^ A logical group of resources. Logical groups can be used 
          --   when building pages.
        , implementationGuide_global :: [ImplementationGuideGlobal]
          -- ^ A set of profiles that all resources covered by this 
          --   implementation guide must conform to.
        , implementationGuide_binary :: [Uri]
          -- ^ A binary file that is included in the implementation guide 
          --   when it is published.
        , implementationGuide_page :: Maybe ImplementationGuidePage
          -- ^ A page / section in the implementation guide. The root page 
          --   is the implementation guide home page.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuide where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ImplementationGuide
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "fhirVersion")
            `apply` many (parseSchemaType "dependency")
            `apply` many (parseSchemaType "package")
            `apply` many (parseSchemaType "global")
            `apply` many (parseSchemaType "binary")
            `apply` optional (parseSchemaType "page")
    schemaTypeToXML s x@ImplementationGuide{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ implementationGuide_id x
            , maybe [] (schemaTypeToXML "meta") $ implementationGuide_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ implementationGuide_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ implementationGuide_language x
            , maybe [] (schemaTypeToXML "text") $ implementationGuide_text x
            , concatMap (schemaTypeToXML "contained") $ implementationGuide_contained x
            , concatMap (schemaTypeToXML "extension") $ implementationGuide_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuide_modifierExtension x
            , schemaTypeToXML "url" $ implementationGuide_url x
            , maybe [] (schemaTypeToXML "version") $ implementationGuide_version x
            , schemaTypeToXML "name" $ implementationGuide_name x
            , schemaTypeToXML "status" $ implementationGuide_status x
            , maybe [] (schemaTypeToXML "experimental") $ implementationGuide_experimental x
            , maybe [] (schemaTypeToXML "date") $ implementationGuide_date x
            , maybe [] (schemaTypeToXML "publisher") $ implementationGuide_publisher x
            , concatMap (schemaTypeToXML "contact") $ implementationGuide_contact x
            , maybe [] (schemaTypeToXML "description") $ implementationGuide_description x
            , concatMap (schemaTypeToXML "useContext") $ implementationGuide_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ implementationGuide_jurisdiction x
            , maybe [] (schemaTypeToXML "copyright") $ implementationGuide_copyright x
            , maybe [] (schemaTypeToXML "fhirVersion") $ implementationGuide_fhirVersion x
            , concatMap (schemaTypeToXML "dependency") $ implementationGuide_dependency x
            , concatMap (schemaTypeToXML "package") $ implementationGuide_package x
            , concatMap (schemaTypeToXML "global") $ implementationGuide_global x
            , concatMap (schemaTypeToXML "binary") $ implementationGuide_binary x
            , maybe [] (schemaTypeToXML "page") $ implementationGuide_page x
            ]
instance Extension ImplementationGuide DomainResource where
    supertype (ImplementationGuide e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ImplementationGuide Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ImplementationGuide -> DomainResource)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuideDependency = ImplementationGuideDependency
        { implementationGuideDependency_id :: Maybe String_primitive
        , implementationGuideDependency_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuideDependency_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuideDependency_type :: GuideDependencyType
          -- ^ How the dependency is represented when the guide is 
          --   published.
        , implementationGuideDependency_uri :: Uri
          -- ^ Where the dependency is located.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuideDependency where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuideDependency a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "uri"
    schemaTypeToXML s x@ImplementationGuideDependency{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuideDependency_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuideDependency_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuideDependency_modifierExtension x
            , schemaTypeToXML "type" $ implementationGuideDependency_type x
            , schemaTypeToXML "uri" $ implementationGuideDependency_uri x
            ]
instance Extension ImplementationGuideDependency BackboneElement where
    supertype (ImplementationGuideDependency a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuideDependency Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuideDependency -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuidePackage = ImplementationGuidePackage
        { implementationGuidePackage_id :: Maybe String_primitive
        , implementationGuidePackage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuidePackage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuidePackage_name :: Xsd.XsdString
          -- ^ The name for the group, as used in page.package.
        , implementationGuidePackage_description :: Maybe Xsd.XsdString
          -- ^ Human readable text describing the package.
        , implementationGuidePackage_resource :: [ImplementationGuideResource]
          -- ^ A resource that is part of the implementation guide. 
          --   Conformance resources (value set, structure definition, 
          --   capability statements etc.) are obvious candidates for 
          --   inclusion, but any kind of resource can be included as an 
          --   example resource.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuidePackage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuidePackage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "resource")
    schemaTypeToXML s x@ImplementationGuidePackage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuidePackage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuidePackage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuidePackage_modifierExtension x
            , schemaTypeToXML "name" $ implementationGuidePackage_name x
            , maybe [] (schemaTypeToXML "description") $ implementationGuidePackage_description x
            , concatMap (schemaTypeToXML "resource") $ implementationGuidePackage_resource x
            ]
instance Extension ImplementationGuidePackage BackboneElement where
    supertype (ImplementationGuidePackage a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuidePackage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuidePackage -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuideResource = ImplementationGuideResource
        { implementationGuideResource_id :: Maybe String_primitive
        , implementationGuideResource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuideResource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuideResource_example :: Boolean
          -- ^ Whether a resource is included in the guide as part of the 
          --   rules defined by the guide, or just as an example of a 
          --   resource that conforms to the rules and/or help 
          --   implementers understand the intent of the guide.
        , implementationGuideResource_name :: Maybe Xsd.XsdString
          -- ^ A human assigned name for the resource. All resources 
          --   SHOULD have a name, but the name may be extracted from the 
          --   resource (e.g. ValueSet.name).
        , implementationGuideResource_description :: Maybe Xsd.XsdString
          -- ^ A description of the reason that a resource has been 
          --   included in the implementation guide.
        , implementationGuideResource_acronym :: Maybe Xsd.XsdString
          -- ^ A short code that may be used to identify the resource 
          --   throughout the implementation guide.
        , implementationGuideResource_choice6 :: OneOf2 Uri Reference
          -- ^ Where this resource is found.
          --   
          --   Choice between:
          --   
          --   (1) sourceUri
          --   
          --   (2) sourceReference
        , implementationGuideResource_exampleFor :: Maybe Reference
          -- ^ Another resource that this resource is an example for. This 
          --   is mostly used for resources that are included as examples 
          --   of StructureDefinitions.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuideResource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuideResource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "example"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "acronym")
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "sourceUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "sourceReference"))
                           ]
            `apply` optional (parseSchemaType "exampleFor")
    schemaTypeToXML s x@ImplementationGuideResource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuideResource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuideResource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuideResource_modifierExtension x
            , schemaTypeToXML "example" $ implementationGuideResource_example x
            , maybe [] (schemaTypeToXML "name") $ implementationGuideResource_name x
            , maybe [] (schemaTypeToXML "description") $ implementationGuideResource_description x
            , maybe [] (schemaTypeToXML "acronym") $ implementationGuideResource_acronym x
            , foldOneOf2  (schemaTypeToXML "sourceUri")
                          (schemaTypeToXML "sourceReference")
                          $ implementationGuideResource_choice6 x
            , maybe [] (schemaTypeToXML "exampleFor") $ implementationGuideResource_exampleFor x
            ]
instance Extension ImplementationGuideResource BackboneElement where
    supertype (ImplementationGuideResource a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuideResource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuideResource -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuideGlobal = ImplementationGuideGlobal
        { implementationGuideGlobal_id :: Maybe String_primitive
        , implementationGuideGlobal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuideGlobal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuideGlobal_type :: ResourceType
          -- ^ The type of resource that all instances must conform to.
        , implementationGuideGlobal_profile :: Reference
          -- ^ A reference to the profile that all instances must conform 
          --   to.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuideGlobal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuideGlobal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@ImplementationGuideGlobal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuideGlobal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuideGlobal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuideGlobal_modifierExtension x
            , schemaTypeToXML "type" $ implementationGuideGlobal_type x
            , schemaTypeToXML "profile" $ implementationGuideGlobal_profile x
            ]
instance Extension ImplementationGuideGlobal BackboneElement where
    supertype (ImplementationGuideGlobal a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuideGlobal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuideGlobal -> BackboneElement)
              
 
-- | A set of rules of how FHIR is used to solve a particular 
--   problem. This resource is used to gather all the parts of 
--   an implementation guide into a logical whole and to publish 
--   a computable definition of all the parts.
data ImplementationGuidePage = ImplementationGuidePage
        { implementationGuidePage_id :: Maybe String_primitive
        , implementationGuidePage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , implementationGuidePage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , implementationGuidePage_source :: Uri
          -- ^ The source address for the page.
        , implementationGuidePage_title :: Xsd.XsdString
          -- ^ A short title used to represent this page in navigational 
          --   structures such as table of contents, bread crumbs, etc.
        , implementationGuidePage_kind :: GuidePageKind
          -- ^ The kind of page that this is. Some pages are autogenerated 
          --   (list, example), and other kinds are of interest so that 
          --   tools can navigate the user to the page of interest.
        , implementationGuidePage_type :: [ResourceType]
          -- ^ For constructed pages, what kind of resources to include in 
          --   the list.
        , implementationGuidePage_package :: [Xsd.XsdString]
          -- ^ For constructed pages, a list of packages to include in the 
          --   page (or else empty for everything).
        , implementationGuidePage_format :: Maybe Code
          -- ^ The format of the page.
        , implementationGuidePage_page :: [ImplementationGuidePage]
          -- ^ Nested Pages/Sections under this page.
        }
        deriving (Eq,Show)
instance SchemaType ImplementationGuidePage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ImplementationGuidePage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "source"
            `apply` parseSchemaType "title"
            `apply` parseSchemaType "kind"
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "package")
            `apply` optional (parseSchemaType "format")
            `apply` many (parseSchemaType "page")
    schemaTypeToXML s x@ImplementationGuidePage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ implementationGuidePage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ implementationGuidePage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ implementationGuidePage_modifierExtension x
            , schemaTypeToXML "source" $ implementationGuidePage_source x
            , schemaTypeToXML "title" $ implementationGuidePage_title x
            , schemaTypeToXML "kind" $ implementationGuidePage_kind x
            , concatMap (schemaTypeToXML "type") $ implementationGuidePage_type x
            , concatMap (schemaTypeToXML "package") $ implementationGuidePage_package x
            , maybe [] (schemaTypeToXML "format") $ implementationGuidePage_format x
            , concatMap (schemaTypeToXML "page") $ implementationGuidePage_page x
            ]
instance Extension ImplementationGuidePage BackboneElement where
    supertype (ImplementationGuidePage a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension ImplementationGuidePage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ImplementationGuidePage -> BackboneElement)
              
 
data GuideDependencyType_list
    = GuideDependencyType_list_Reference
      -- ^ Reference
    | GuideDependencyType_list_Inclusion
      -- ^ Inclusion
    deriving (Eq,Show,Enum)
instance SchemaType GuideDependencyType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuideDependencyType_list where
    acceptingParser =  do literal "reference"; return GuideDependencyType_list_Reference
                      `onFail` do literal "inclusion"; return GuideDependencyType_list_Inclusion
                      
    simpleTypeText GuideDependencyType_list_Reference = "reference"
    simpleTypeText GuideDependencyType_list_Inclusion = "inclusion"
 
data GuideDependencyType = GuideDependencyType
        { guideDependencyType_id :: Maybe String_primitive
        , guideDependencyType_value :: Maybe GuideDependencyType_list
        , guideDependencyType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuideDependencyType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuideDependencyType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuideDependencyType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guideDependencyType_id x
                       , maybe [] (toXMLAttribute "value") $ guideDependencyType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guideDependencyType_extension x
            ]
instance Extension GuideDependencyType Element where
    supertype (GuideDependencyType a0 a1 e0) =
               Element a0 e0
 
data GuidePageKind_list
    = GuidePageKind_list_Page
      -- ^ Page
    | GuidePageKind_list_Example
      -- ^ Example
    | GuidePageKind_list_List
      -- ^ List
    | GuidePageKind_list_Include
      -- ^ Include
    | GuidePageKind_list_Directory
      -- ^ Directory
    | GuidePageKind_list_Dictionary
      -- ^ Dictionary
    | GuidePageKind_list_Toc
      -- ^ Table Of Contents
    | GuidePageKind_list_Resource
      -- ^ Resource
    deriving (Eq,Show,Enum)
instance SchemaType GuidePageKind_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType GuidePageKind_list where
    acceptingParser =  do literal "page"; return GuidePageKind_list_Page
                      `onFail` do literal "example"; return GuidePageKind_list_Example
                      `onFail` do literal "list"; return GuidePageKind_list_List
                      `onFail` do literal "include"; return GuidePageKind_list_Include
                      `onFail` do literal "directory"; return GuidePageKind_list_Directory
                      `onFail` do literal "dictionary"; return GuidePageKind_list_Dictionary
                      `onFail` do literal "toc"; return GuidePageKind_list_Toc
                      `onFail` do literal "resource"; return GuidePageKind_list_Resource
                      
    simpleTypeText GuidePageKind_list_Page = "page"
    simpleTypeText GuidePageKind_list_Example = "example"
    simpleTypeText GuidePageKind_list_List = "list"
    simpleTypeText GuidePageKind_list_Include = "include"
    simpleTypeText GuidePageKind_list_Directory = "directory"
    simpleTypeText GuidePageKind_list_Dictionary = "dictionary"
    simpleTypeText GuidePageKind_list_Toc = "toc"
    simpleTypeText GuidePageKind_list_Resource = "resource"
 
data GuidePageKind = GuidePageKind
        { guidePageKind_id :: Maybe String_primitive
        , guidePageKind_value :: Maybe GuidePageKind_list
        , guidePageKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType GuidePageKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (GuidePageKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@GuidePageKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ guidePageKind_id x
                       , maybe [] (toXMLAttribute "value") $ guidePageKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ guidePageKind_extension x
            ]
instance Extension GuidePageKind Element where
    supertype (GuidePageKind a0 a1 e0) =
               Element a0 e0
 
-- | The Library resource is a general-purpose container for 
--   knowledge asset definitions. It can be used to describe and 
--   expose existing knowledge assets such as logic libraries 
--   and information model descriptions, as well as to describe 
--   a collection of knowledge assets.
elementLibrary :: XMLParser Library
elementLibrary = parseSchemaType "Library"
elementToXMLLibrary :: Library -> [Content ()]
elementToXMLLibrary = schemaTypeToXML "Library"
 
data Library = Library
        { library_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , library_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , library_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , library_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , library_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , library_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , library_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , library_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , library_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this library when 
          --   it is referenced in a specification, model, design or an 
          --   instance. This SHALL be a URL, SHOULD be globally unique, 
          --   and SHOULD be an address at which this library is (or will 
          --   be) published. The URL SHOULD include the major version of 
          --   the library. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , library_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this library 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance. e.g. CMS or 
          --   NQF identifiers for a measure artifact. Note that at least 
          --   one identifier is required for non-experimental active 
          --   artifacts.
        , library_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   library when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the library author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , library_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the library. This name 
          --   should be usable as an identifier for the module by machine 
          --   processing applications such as code generation.
        , library_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the library.
        , library_status :: PublicationStatus
          -- ^ The status of this library. Enables tracking the life-cycle 
          --   of the content.
        , library_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this library is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , library_type :: CodeableConcept
          -- ^ Identifies the type of library such as a Logic Library, 
          --   Model Definition, Asset Collection, or Module Definition.
        , library_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the library was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the library changes.
        , library_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the library.
        , library_description :: Maybe Markdown
          -- ^ A free text natural language description of the library 
          --   from a consumer's perspective.
        , library_purpose :: Maybe Markdown
          -- ^ Explaination of why this library is needed and why it has 
          --   been designed as it has.
        , library_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the library is used from a 
          --   clinical perspective.
        , library_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , library_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , library_effectivePeriod :: Maybe Period
          -- ^ The period during which the library content was or is 
          --   planned to be in active use.
        , library_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   library instances.
        , library_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the library is 
          --   intended to be used.
        , library_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the library. 
          --   Topics provide a high-level categorization of the library 
          --   that can be useful for filtering and searching.
        , library_contributor :: [Contributor]
          -- ^ A contributor to the content of the library, including 
          --   authors, editors, reviewers, and endorsers.
        , library_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , library_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the library and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the library.
        , library_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , library_parameter :: [ParameterDefinition]
          -- ^ The parameter element defines parameters used by the 
          --   library.
        , library_dataRequirement :: [DataRequirement]
          -- ^ Describes a set of data that must be provided in order to 
          --   be able to successfully perform the computations defined by 
          --   the library.
        , library_content :: [Attachment]
          -- ^ The content of the library as an Attachment. The content 
          --   may be a reference to a url, or may be directly embedded as 
          --   a base-64 string. Either way, the contentType of the 
          --   attachment determines how to interpret the content.
        }
        deriving (Eq,Show)
instance SchemaType Library where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Library
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "dataRequirement")
            `apply` many (parseSchemaType "content")
    schemaTypeToXML s x@Library{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ library_id x
            , maybe [] (schemaTypeToXML "meta") $ library_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ library_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ library_language x
            , maybe [] (schemaTypeToXML "text") $ library_text x
            , concatMap (schemaTypeToXML "contained") $ library_contained x
            , concatMap (schemaTypeToXML "extension") $ library_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ library_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ library_url x
            , concatMap (schemaTypeToXML "identifier") $ library_identifier x
            , maybe [] (schemaTypeToXML "version") $ library_version x
            , maybe [] (schemaTypeToXML "name") $ library_name x
            , maybe [] (schemaTypeToXML "title") $ library_title x
            , schemaTypeToXML "status" $ library_status x
            , maybe [] (schemaTypeToXML "experimental") $ library_experimental x
            , schemaTypeToXML "type" $ library_type x
            , maybe [] (schemaTypeToXML "date") $ library_date x
            , maybe [] (schemaTypeToXML "publisher") $ library_publisher x
            , maybe [] (schemaTypeToXML "description") $ library_description x
            , maybe [] (schemaTypeToXML "purpose") $ library_purpose x
            , maybe [] (schemaTypeToXML "usage") $ library_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ library_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ library_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ library_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ library_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ library_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ library_topic x
            , concatMap (schemaTypeToXML "contributor") $ library_contributor x
            , concatMap (schemaTypeToXML "contact") $ library_contact x
            , maybe [] (schemaTypeToXML "copyright") $ library_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ library_relatedArtifact x
            , concatMap (schemaTypeToXML "parameter") $ library_parameter x
            , concatMap (schemaTypeToXML "dataRequirement") $ library_dataRequirement x
            , concatMap (schemaTypeToXML "content") $ library_content x
            ]
instance Extension Library DomainResource where
    supertype (Library e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Library Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Library -> DomainResource)
              
 
-- | Identifies two or more records (resource instances) that 
--   are referring to the same real-world 
--   &quot;occurrence&quot;.
elementLinkage :: XMLParser Linkage
elementLinkage = parseSchemaType "Linkage"
elementToXMLLinkage :: Linkage -> [Content ()]
elementToXMLLinkage = schemaTypeToXML "Linkage"
 
data Linkage = Linkage
        { linkage_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , linkage_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , linkage_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , linkage_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , linkage_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , linkage_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , linkage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , linkage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , linkage_active :: Maybe Boolean
          -- ^ Indicates whether the asserted set of linkages are 
          --   considered to be &quot;in effect&quot;.
        , linkage_author :: Maybe Reference
          -- ^ Identifies the user or organization responsible for 
          --   asserting the linkages and who establishes the context for 
          --   evaluating the nature of each linkage.
        , linkage_item :: [LinkageItem]
          -- ^ Identifies one of the records that is considered to refer 
          --   to the same real-world occurrence as well as how the items 
          --   hould be evaluated within the collection of linked items.
        }
        deriving (Eq,Show)
instance SchemaType Linkage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Linkage
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "author")
            `apply` many1 (parseSchemaType "item")
    schemaTypeToXML s x@Linkage{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ linkage_id x
            , maybe [] (schemaTypeToXML "meta") $ linkage_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ linkage_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ linkage_language x
            , maybe [] (schemaTypeToXML "text") $ linkage_text x
            , concatMap (schemaTypeToXML "contained") $ linkage_contained x
            , concatMap (schemaTypeToXML "extension") $ linkage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ linkage_modifierExtension x
            , maybe [] (schemaTypeToXML "active") $ linkage_active x
            , maybe [] (schemaTypeToXML "author") $ linkage_author x
            , concatMap (schemaTypeToXML "item") $ linkage_item x
            ]
instance Extension Linkage DomainResource where
    supertype (Linkage e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Linkage Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Linkage -> DomainResource)
              
 
-- | Identifies two or more records (resource instances) that 
--   are referring to the same real-world 
--   &quot;occurrence&quot;.
data LinkageItem = LinkageItem
        { linkageItem_id :: Maybe String_primitive
        , linkageItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , linkageItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , linkageItem_type :: LinkageType
          -- ^ Distinguishes which item is &quot;source of truth&quot; (if 
          --   any) and which items are no longer considered to be current 
          --   representations.
        , linkageItem_resource :: Reference
          -- ^ The resource instance being linked as part of the group.
        }
        deriving (Eq,Show)
instance SchemaType LinkageItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (LinkageItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "resource"
    schemaTypeToXML s x@LinkageItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkageItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkageItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ linkageItem_modifierExtension x
            , schemaTypeToXML "type" $ linkageItem_type x
            , schemaTypeToXML "resource" $ linkageItem_resource x
            ]
instance Extension LinkageItem BackboneElement where
    supertype (LinkageItem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension LinkageItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: LinkageItem -> BackboneElement)
              
 
data LinkageType_list
    = LinkageType_list_Source
      -- ^ Source of truth
    | LinkageType_list_Alternate
      -- ^ Alternate record
    | LinkageType_list_Historical
      -- ^ Historical/obsolete record
    deriving (Eq,Show,Enum)
instance SchemaType LinkageType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LinkageType_list where
    acceptingParser =  do literal "source"; return LinkageType_list_Source
                      `onFail` do literal "alternate"; return LinkageType_list_Alternate
                      `onFail` do literal "historical"; return LinkageType_list_Historical
                      
    simpleTypeText LinkageType_list_Source = "source"
    simpleTypeText LinkageType_list_Alternate = "alternate"
    simpleTypeText LinkageType_list_Historical = "historical"
 
data LinkageType = LinkageType
        { linkageType_id :: Maybe String_primitive
        , linkageType_value :: Maybe LinkageType_list
        , linkageType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LinkageType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LinkageType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LinkageType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkageType_id x
                       , maybe [] (toXMLAttribute "value") $ linkageType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkageType_extension x
            ]
instance Extension LinkageType Element where
    supertype (LinkageType a0 a1 e0) =
               Element a0 e0
 
-- | A set of information summarized from a list of other 
--   resources.
elementList :: XMLParser List
elementList = parseSchemaType "List"
elementToXMLList :: List -> [Content ()]
elementToXMLList = schemaTypeToXML "List"
 
data List = List
        { list_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , list_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , list_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , list_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , list_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , list_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , list_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , list_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , list_identifier :: [Identifier]
          -- ^ Identifier for the List assigned for business purposes 
          --   outside the context of FHIR.
        , list_status :: ListStatus
          -- ^ Indicates the current state of this list.
        , list_mode :: ListMode
          -- ^ How this list was prepared - whether it is a working list 
          --   that is suitable for being maintained on an ongoing basis, 
          --   or if it represents a snapshot of a list of items from 
          --   another source, or whether it is a prepared list where 
          --   items may be marked as added, modified or deleted.
        , list_title :: Maybe Xsd.XsdString
          -- ^ A label for the list assigned by the author.
        , list_code :: Maybe CodeableConcept
          -- ^ This code defines the purpose of the list - why it was 
          --   created.
        , list_subject :: Maybe Reference
          -- ^ The common subject (or patient) of the resources that are 
          --   in the list, if there is one.
        , list_encounter :: Maybe Reference
          -- ^ The encounter that is the context in which this list was 
          --   created.
        , list_date :: Maybe DateTime
          -- ^ The date that the list was prepared.
        , list_source :: Maybe Reference
          -- ^ The entity responsible for deciding what the contents of 
          --   the list were. Where the list was created by a human, this 
          --   is the same as the author of the list.
        , list_orderedBy :: Maybe CodeableConcept
          -- ^ What order applies to the items in the list.
        , list_note :: [Annotation]
          -- ^ Comments that apply to the overall list.
        , list_entry :: [ListEntry]
          -- ^ Entries in this list.
        , list_emptyReason :: Maybe CodeableConcept
          -- ^ If the list is empty, why the list is empty.
        }
        deriving (Eq,Show)
instance SchemaType List where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return List
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "source")
            `apply` optional (parseSchemaType "orderedBy")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "entry")
            `apply` optional (parseSchemaType "emptyReason")
    schemaTypeToXML s x@List{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ list_id x
            , maybe [] (schemaTypeToXML "meta") $ list_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ list_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ list_language x
            , maybe [] (schemaTypeToXML "text") $ list_text x
            , concatMap (schemaTypeToXML "contained") $ list_contained x
            , concatMap (schemaTypeToXML "extension") $ list_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ list_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ list_identifier x
            , schemaTypeToXML "status" $ list_status x
            , schemaTypeToXML "mode" $ list_mode x
            , maybe [] (schemaTypeToXML "title") $ list_title x
            , maybe [] (schemaTypeToXML "code") $ list_code x
            , maybe [] (schemaTypeToXML "subject") $ list_subject x
            , maybe [] (schemaTypeToXML "encounter") $ list_encounter x
            , maybe [] (schemaTypeToXML "date") $ list_date x
            , maybe [] (schemaTypeToXML "source") $ list_source x
            , maybe [] (schemaTypeToXML "orderedBy") $ list_orderedBy x
            , concatMap (schemaTypeToXML "note") $ list_note x
            , concatMap (schemaTypeToXML "entry") $ list_entry x
            , maybe [] (schemaTypeToXML "emptyReason") $ list_emptyReason x
            ]
instance Extension List DomainResource where
    supertype (List e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension List Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: List -> DomainResource)
              
 
-- | A set of information summarized from a list of other 
--   resources.
data ListEntry = ListEntry
        { listEntry_id :: Maybe String_primitive
        , listEntry_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , listEntry_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , listEntry_flag :: Maybe CodeableConcept
          -- ^ The flag allows the system constructing the list to 
          --   indicate the role and significance of the item in the list.
        , listEntry_deleted :: Maybe Boolean
          -- ^ True if this item is marked as deleted in the list.
        , listEntry_date :: Maybe DateTime
          -- ^ When this item was added to the list.
        , listEntry_item :: Reference
          -- ^ A reference to the actual resource from which data was 
          --   derived.
        }
        deriving (Eq,Show)
instance SchemaType ListEntry where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ListEntry a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "flag")
            `apply` optional (parseSchemaType "deleted")
            `apply` optional (parseSchemaType "date")
            `apply` parseSchemaType "item"
    schemaTypeToXML s x@ListEntry{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ listEntry_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ listEntry_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ listEntry_modifierExtension x
            , maybe [] (schemaTypeToXML "flag") $ listEntry_flag x
            , maybe [] (schemaTypeToXML "deleted") $ listEntry_deleted x
            , maybe [] (schemaTypeToXML "date") $ listEntry_date x
            , schemaTypeToXML "item" $ listEntry_item x
            ]
instance Extension ListEntry BackboneElement where
    supertype (ListEntry a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ListEntry Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ListEntry -> BackboneElement)
              
 
data ListStatus_list
    = ListStatus_list_Current
      -- ^ Current
    | ListStatus_list_Retired
      -- ^ Retired
    | ListStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType ListStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ListStatus_list where
    acceptingParser =  do literal "current"; return ListStatus_list_Current
                      `onFail` do literal "retired"; return ListStatus_list_Retired
                      `onFail` do literal "entered-in-error"; return ListStatus_list_Entered_in_error
                      
    simpleTypeText ListStatus_list_Current = "current"
    simpleTypeText ListStatus_list_Retired = "retired"
    simpleTypeText ListStatus_list_Entered_in_error = "entered-in-error"
 
data ListStatus = ListStatus
        { listStatus_id :: Maybe String_primitive
        , listStatus_value :: Maybe ListStatus_list
        , listStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ListStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ListStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ListStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ listStatus_id x
                       , maybe [] (toXMLAttribute "value") $ listStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ listStatus_extension x
            ]
instance Extension ListStatus Element where
    supertype (ListStatus a0 a1 e0) =
               Element a0 e0
 
-- | Details and position information for a physical place where 
--   services are provided and resources and participants may be 
--   stored, found, contained or accommodated.
elementLocation :: XMLParser Location
elementLocation = parseSchemaType "Location"
elementToXMLLocation :: Location -> [Content ()]
elementToXMLLocation = schemaTypeToXML "Location"
 
data Location = Location
        { location_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , location_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , location_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , location_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , location_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , location_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , location_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , location_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , location_identifier :: [Identifier]
          -- ^ Unique code or number identifying the location to its 
          --   users.
        , location_status :: Maybe LocationStatus
          -- ^ The status property covers the general availability of the 
          --   resource, not the current value which may be covered by the 
          --   operationStatus, or by a schedule/slots if they are 
          --   configured for the location.
        , location_operationalStatus :: Maybe Coding
          -- ^ The Operational status covers operation values most 
          --   relevant to beds (but can also apply to 
          --   rooms/units/chair/etc such as an isolation unit/dialisys 
          --   chair). This typically covers concepts such as 
          --   contamination, housekeeping and other activities like 
          --   maintenance.
        , location_name :: Maybe Xsd.XsdString
          -- ^ Name of the location as used by humans. Does not need to be 
          --   unique.
        , location_alias :: [Xsd.XsdString]
          -- ^ A list of alternate names that the location is known as, or 
          --   was known as in the past.
        , location_description :: Maybe Xsd.XsdString
          -- ^ Description of the Location, which helps in finding or 
          --   referencing the place.
        , location_mode :: Maybe LocationMode
          -- ^ Indicates whether a resource instance represents a specific 
          --   location or a class of locations.
        , location_type :: Maybe CodeableConcept
          -- ^ Indicates the type of function performed at the location.
        , location_telecom :: [ContactPoint]
          -- ^ The contact details of communication devices available at 
          --   the location. This can include phone numbers, fax numbers, 
          --   mobile numbers, email addresses and web sites.
        , location_address :: Maybe Address
          -- ^ Physical location.
        , location_physicalType :: Maybe CodeableConcept
          -- ^ Physical form of the location, e.g. building, room, 
          --   vehicle, road.
        , location_position :: Maybe LocationPosition
          -- ^ The absolute geographic location of the Location, expressed 
          --   using the WGS84 datum (This is the same co-ordinate system 
          --   used in KML).
        , location_managingOrganization :: Maybe Reference
          -- ^ The organization responsible for the provisioning and 
          --   upkeep of the location.
        , location_partOf :: Maybe Reference
          -- ^ Another Location which this Location is physically part of.
        , location_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the location.
        }
        deriving (Eq,Show)
instance SchemaType Location where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Location
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "operationalStatus")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "alias")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "mode")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "physicalType")
            `apply` optional (parseSchemaType "position")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "partOf")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@Location{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ location_id x
            , maybe [] (schemaTypeToXML "meta") $ location_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ location_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ location_language x
            , maybe [] (schemaTypeToXML "text") $ location_text x
            , concatMap (schemaTypeToXML "contained") $ location_contained x
            , concatMap (schemaTypeToXML "extension") $ location_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ location_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ location_identifier x
            , maybe [] (schemaTypeToXML "status") $ location_status x
            , maybe [] (schemaTypeToXML "operationalStatus") $ location_operationalStatus x
            , maybe [] (schemaTypeToXML "name") $ location_name x
            , concatMap (schemaTypeToXML "alias") $ location_alias x
            , maybe [] (schemaTypeToXML "description") $ location_description x
            , maybe [] (schemaTypeToXML "mode") $ location_mode x
            , maybe [] (schemaTypeToXML "type") $ location_type x
            , concatMap (schemaTypeToXML "telecom") $ location_telecom x
            , maybe [] (schemaTypeToXML "address") $ location_address x
            , maybe [] (schemaTypeToXML "physicalType") $ location_physicalType x
            , maybe [] (schemaTypeToXML "position") $ location_position x
            , maybe [] (schemaTypeToXML "managingOrganization") $ location_managingOrganization x
            , maybe [] (schemaTypeToXML "partOf") $ location_partOf x
            , concatMap (schemaTypeToXML "endpoint") $ location_endpoint x
            ]
instance Extension Location DomainResource where
    supertype (Location e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Location Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Location -> DomainResource)
              
 
-- | Details and position information for a physical place where 
--   services are provided and resources and participants may be 
--   stored, found, contained or accommodated.
data LocationPosition = LocationPosition
        { locationPosition_id :: Maybe String_primitive
        , locationPosition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , locationPosition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , locationPosition_longitude :: Decimal
          -- ^ Longitude. The value domain and the interpretation are the 
          --   same as for the text of the longitude element in KML (see 
          --   notes below).
        , locationPosition_latitude :: Decimal
          -- ^ Latitude. The value domain and the interpretation are the 
          --   same as for the text of the latitude element in KML (see 
          --   notes below).
        , locationPosition_altitude :: Maybe Decimal
          -- ^ Altitude. The value domain and the interpretation are the 
          --   same as for the text of the altitude element in KML (see 
          --   notes below).
        }
        deriving (Eq,Show)
instance SchemaType LocationPosition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (LocationPosition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "longitude"
            `apply` parseSchemaType "latitude"
            `apply` optional (parseSchemaType "altitude")
    schemaTypeToXML s x@LocationPosition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ locationPosition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ locationPosition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ locationPosition_modifierExtension x
            , schemaTypeToXML "longitude" $ locationPosition_longitude x
            , schemaTypeToXML "latitude" $ locationPosition_latitude x
            , maybe [] (schemaTypeToXML "altitude") $ locationPosition_altitude x
            ]
instance Extension LocationPosition BackboneElement where
    supertype (LocationPosition a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension LocationPosition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: LocationPosition -> BackboneElement)
              
 
data LocationMode_list
    = LocationMode_list_Instance
      -- ^ Instance
    | LocationMode_list_Kind
      -- ^ Kind
    deriving (Eq,Show,Enum)
instance SchemaType LocationMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LocationMode_list where
    acceptingParser =  do literal "instance"; return LocationMode_list_Instance
                      `onFail` do literal "kind"; return LocationMode_list_Kind
                      
    simpleTypeText LocationMode_list_Instance = "instance"
    simpleTypeText LocationMode_list_Kind = "kind"
 
data LocationMode = LocationMode
        { locationMode_id :: Maybe String_primitive
        , locationMode_value :: Maybe LocationMode_list
        , locationMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LocationMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LocationMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LocationMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ locationMode_id x
                       , maybe [] (toXMLAttribute "value") $ locationMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ locationMode_extension x
            ]
instance Extension LocationMode Element where
    supertype (LocationMode a0 a1 e0) =
               Element a0 e0
 
data LocationStatus_list
    = LocationStatus_list_Active
      -- ^ Active
    | LocationStatus_list_Suspended
      -- ^ Suspended
    | LocationStatus_list_Inactive
      -- ^ Inactive
    deriving (Eq,Show,Enum)
instance SchemaType LocationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LocationStatus_list where
    acceptingParser =  do literal "active"; return LocationStatus_list_Active
                      `onFail` do literal "suspended"; return LocationStatus_list_Suspended
                      `onFail` do literal "inactive"; return LocationStatus_list_Inactive
                      
    simpleTypeText LocationStatus_list_Active = "active"
    simpleTypeText LocationStatus_list_Suspended = "suspended"
    simpleTypeText LocationStatus_list_Inactive = "inactive"
 
data LocationStatus = LocationStatus
        { locationStatus_id :: Maybe String_primitive
        , locationStatus_value :: Maybe LocationStatus_list
        , locationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LocationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LocationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LocationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ locationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ locationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ locationStatus_extension x
            ]
instance Extension LocationStatus Element where
    supertype (LocationStatus a0 a1 e0) =
               Element a0 e0
 
-- | The Measure resource provides the definition of a quality 
--   measure.
elementMeasure :: XMLParser Measure
elementMeasure = parseSchemaType "Measure"
elementToXMLMeasure :: Measure -> [Content ()]
elementToXMLMeasure = schemaTypeToXML "Measure"
 
data Measure = Measure
        { measure_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , measure_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , measure_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , measure_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , measure_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , measure_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , measure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measure_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this measure when 
          --   it is referenced in a specification, model, design or an 
          --   instance. This SHALL be a URL, SHOULD be globally unique, 
          --   and SHOULD be an address at which this measure is (or will 
          --   be) published. The URL SHOULD include the major version of 
          --   the measure. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , measure_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this measure 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , measure_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   measure when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the measure author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , measure_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the measure. This name 
          --   should be usable as an identifier for the module by machine 
          --   processing applications such as code generation.
        , measure_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the measure.
        , measure_status :: PublicationStatus
          -- ^ The status of this measure. Enables tracking the life-cycle 
          --   of the content.
        , measure_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this measure is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , measure_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the measure was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the measure changes.
        , measure_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the measure.
        , measure_description :: Maybe Markdown
          -- ^ A free text natural language description of the measure 
          --   from a consumer's perspective.
        , measure_purpose :: Maybe Markdown
          -- ^ Explaination of why this measure is needed and why it has 
          --   been designed as it has.
        , measure_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the measure is used from a 
          --   clinical perspective.
        , measure_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , measure_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , measure_effectivePeriod :: Maybe Period
          -- ^ The period during which the measure content was or is 
          --   planned to be in active use.
        , measure_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   measure instances.
        , measure_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the measure is 
          --   intended to be used.
        , measure_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the measure. 
          --   Topics provide a high-level categorization of the type of 
          --   the measure that can be useful for filtering and searching.
        , measure_contributor :: [Contributor]
          -- ^ A contributor to the content of the measure, including 
          --   authors, editors, reviewers, and endorsers.
        , measure_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , measure_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the measure and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the measure.
        , measure_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , measure_library :: [Reference]
          -- ^ A reference to a Library resource containing the formal 
          --   logic used by the measure.
        , measure_disclaimer :: Maybe Markdown
          -- ^ Notices and disclaimers regarding the use of the measure, 
          --   or related to intellectual property (such as code systems) 
          --   referenced by the measure.
        , measure_scoring :: Maybe CodeableConcept
          -- ^ Indicates how the calculation is performed for the measure, 
          --   including proportion, ratio, continuous variable, and 
          --   cohort. The value set is extensible, allowing additional 
          --   measure scoring types to be represented.
        , measure_compositeScoring :: Maybe CodeableConcept
          -- ^ If this is a composite measure, the scoring method used to 
          --   combine the component measures to determine the composite 
          --   score.
        , measure_type :: [CodeableConcept]
          -- ^ Indicates whether the measure is used to examine a process, 
          --   an outcome over time, a patient-reported outcome, or a 
          --   structure measure such as utilization.
        , measure_riskAdjustment :: Maybe Xsd.XsdString
          -- ^ A description of the risk adjustment factors that may 
          --   impact the resulting score for the measure and how they may 
          --   be accounted for when computing and reporting measure 
          --   results.
        , measure_rateAggregation :: Maybe Xsd.XsdString
          -- ^ Describes how to combine the information calculated, based 
          --   on logic in each of several populations, into one 
          --   summarized result.
        , measure_rationale :: Maybe Markdown
          -- ^ Provides a succint statement of the need for the measure. 
          --   Usually includes statements pertaining to importance 
          --   criterion: impact, gap in care, and evidence.
        , measure_clinicalRecommendationStatement :: Maybe Markdown
          -- ^ Provides a summary of relevant clinical guidelines or other 
          --   clinical recommendations supporting the measure.
        , measure_improvementNotation :: Maybe Xsd.XsdString
          -- ^ Information on whether an increase or decrease in score is 
          --   the preferred result (e.g., a higher score indicates better 
          --   quality OR a lower score indicates better quality OR 
          --   quality is whthin a range).
        , measure_definition :: [Markdown]
          -- ^ Provides a description of an individual term used within 
          --   the measure.
        , measure_guidance :: Maybe Markdown
          -- ^ Additional guidance for the measure including how it can be 
          --   used in a clinical context, and the intent of the measure.
        , measure_set :: Maybe Xsd.XsdString
          -- ^ The measure set, e.g. Preventive Care and Screening.
        , measure_group :: [MeasureGroup]
          -- ^ A group of population criteria for the measure.
        , measure_supplementalData :: [MeasureSupplementalData]
          -- ^ The supplemental data criteria for the measure report, 
          --   specified as either the name of a valid CQL expression 
          --   within a referenced library, or a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType Measure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Measure
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` optional (parseSchemaType "disclaimer")
            `apply` optional (parseSchemaType "scoring")
            `apply` optional (parseSchemaType "compositeScoring")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "riskAdjustment")
            `apply` optional (parseSchemaType "rateAggregation")
            `apply` optional (parseSchemaType "rationale")
            `apply` optional (parseSchemaType "clinicalRecommendationStatement")
            `apply` optional (parseSchemaType "improvementNotation")
            `apply` many (parseSchemaType "definition")
            `apply` optional (parseSchemaType "guidance")
            `apply` optional (parseSchemaType "set")
            `apply` many (parseSchemaType "group")
            `apply` many (parseSchemaType "supplementalData")
    schemaTypeToXML s x@Measure{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ measure_id x
            , maybe [] (schemaTypeToXML "meta") $ measure_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ measure_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ measure_language x
            , maybe [] (schemaTypeToXML "text") $ measure_text x
            , concatMap (schemaTypeToXML "contained") $ measure_contained x
            , concatMap (schemaTypeToXML "extension") $ measure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measure_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ measure_url x
            , concatMap (schemaTypeToXML "identifier") $ measure_identifier x
            , maybe [] (schemaTypeToXML "version") $ measure_version x
            , maybe [] (schemaTypeToXML "name") $ measure_name x
            , maybe [] (schemaTypeToXML "title") $ measure_title x
            , schemaTypeToXML "status" $ measure_status x
            , maybe [] (schemaTypeToXML "experimental") $ measure_experimental x
            , maybe [] (schemaTypeToXML "date") $ measure_date x
            , maybe [] (schemaTypeToXML "publisher") $ measure_publisher x
            , maybe [] (schemaTypeToXML "description") $ measure_description x
            , maybe [] (schemaTypeToXML "purpose") $ measure_purpose x
            , maybe [] (schemaTypeToXML "usage") $ measure_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ measure_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ measure_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ measure_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ measure_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ measure_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ measure_topic x
            , concatMap (schemaTypeToXML "contributor") $ measure_contributor x
            , concatMap (schemaTypeToXML "contact") $ measure_contact x
            , maybe [] (schemaTypeToXML "copyright") $ measure_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ measure_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ measure_library x
            , maybe [] (schemaTypeToXML "disclaimer") $ measure_disclaimer x
            , maybe [] (schemaTypeToXML "scoring") $ measure_scoring x
            , maybe [] (schemaTypeToXML "compositeScoring") $ measure_compositeScoring x
            , concatMap (schemaTypeToXML "type") $ measure_type x
            , maybe [] (schemaTypeToXML "riskAdjustment") $ measure_riskAdjustment x
            , maybe [] (schemaTypeToXML "rateAggregation") $ measure_rateAggregation x
            , maybe [] (schemaTypeToXML "rationale") $ measure_rationale x
            , maybe [] (schemaTypeToXML "clinicalRecommendationStatement") $ measure_clinicalRecommendationStatement x
            , maybe [] (schemaTypeToXML "improvementNotation") $ measure_improvementNotation x
            , concatMap (schemaTypeToXML "definition") $ measure_definition x
            , maybe [] (schemaTypeToXML "guidance") $ measure_guidance x
            , maybe [] (schemaTypeToXML "set") $ measure_set x
            , concatMap (schemaTypeToXML "group") $ measure_group x
            , concatMap (schemaTypeToXML "supplementalData") $ measure_supplementalData x
            ]
instance Extension Measure DomainResource where
    supertype (Measure e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35 e36 e37 e38 e39 e40 e41 e42 e43 e44) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Measure Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Measure -> DomainResource)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data MeasureGroup = MeasureGroup
        { measureGroup_id :: Maybe String_primitive
        , measureGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureGroup_identifier :: Identifier
          -- ^ A unique identifier for the group. This identifier will 
          --   used to report data for the group in the measure report.
        , measureGroup_name :: Maybe Xsd.XsdString
          -- ^ Optional name or short description of this group.
        , measureGroup_description :: Maybe Xsd.XsdString
          -- ^ The human readable description of this population group.
        , measureGroup_population :: [MeasurePopulation]
          -- ^ A population criteria for the measure.
        , measureGroup_stratifier :: [MeasureStratifier]
          -- ^ The stratifier criteria for the measure report, specified 
          --   as either the name of a valid CQL expression defined within 
          --   a referenced library, or a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType MeasureGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureGroup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "population")
            `apply` many (parseSchemaType "stratifier")
    schemaTypeToXML s x@MeasureGroup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureGroup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureGroup_modifierExtension x
            , schemaTypeToXML "identifier" $ measureGroup_identifier x
            , maybe [] (schemaTypeToXML "name") $ measureGroup_name x
            , maybe [] (schemaTypeToXML "description") $ measureGroup_description x
            , concatMap (schemaTypeToXML "population") $ measureGroup_population x
            , concatMap (schemaTypeToXML "stratifier") $ measureGroup_stratifier x
            ]
instance Extension MeasureGroup BackboneElement where
    supertype (MeasureGroup a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MeasureGroup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureGroup -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data MeasurePopulation = MeasurePopulation
        { measurePopulation_id :: Maybe String_primitive
        , measurePopulation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measurePopulation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measurePopulation_identifier :: Maybe Identifier
          -- ^ A unique identifier for the population criteria. This 
          --   identifier is used to report data against this criteria 
          --   within the measure report.
        , measurePopulation_code :: Maybe CodeableConcept
          -- ^ The type of population criteria.
        , measurePopulation_name :: Maybe Xsd.XsdString
          -- ^ Optional name or short description of this population.
        , measurePopulation_description :: Maybe Xsd.XsdString
          -- ^ The human readable description of this population criteria.
        , measurePopulation_criteria :: Xsd.XsdString
          -- ^ The name of a valid referenced CQL expression (may be 
          --   namespaced) that defines this population criteria.
        }
        deriving (Eq,Show)
instance SchemaType MeasurePopulation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasurePopulation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` parseSchemaType "criteria"
    schemaTypeToXML s x@MeasurePopulation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measurePopulation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measurePopulation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measurePopulation_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measurePopulation_identifier x
            , maybe [] (schemaTypeToXML "code") $ measurePopulation_code x
            , maybe [] (schemaTypeToXML "name") $ measurePopulation_name x
            , maybe [] (schemaTypeToXML "description") $ measurePopulation_description x
            , schemaTypeToXML "criteria" $ measurePopulation_criteria x
            ]
instance Extension MeasurePopulation BackboneElement where
    supertype (MeasurePopulation a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MeasurePopulation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasurePopulation -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data MeasureStratifier = MeasureStratifier
        { measureStratifier_id :: Maybe String_primitive
        , measureStratifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureStratifier_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureStratifier_identifier :: Maybe Identifier
          -- ^ The identifier for the stratifier used to coordinate the 
          --   reported data back to this stratifier.
        , measureStratifier_criteria :: Maybe Xsd.XsdString
          -- ^ The criteria for the stratifier. This must be the name of 
          --   an expression defined within a referenced library.
        , measureStratifier_path :: Maybe Xsd.XsdString
          -- ^ The path to an element that defines the stratifier, 
          --   specified as a valid FHIR resource path.
        }
        deriving (Eq,Show)
instance SchemaType MeasureStratifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureStratifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "criteria")
            `apply` optional (parseSchemaType "path")
    schemaTypeToXML s x@MeasureStratifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureStratifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureStratifier_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureStratifier_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureStratifier_identifier x
            , maybe [] (schemaTypeToXML "criteria") $ measureStratifier_criteria x
            , maybe [] (schemaTypeToXML "path") $ measureStratifier_path x
            ]
instance Extension MeasureStratifier BackboneElement where
    supertype (MeasureStratifier a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MeasureStratifier Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureStratifier -> BackboneElement)
              
 
-- | The Measure resource provides the definition of a quality 
--   measure.
data MeasureSupplementalData = MeasureSupplementalData
        { measureSupplementalData_id :: Maybe String_primitive
        , measureSupplementalData_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureSupplementalData_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureSupplementalData_identifier :: Maybe Identifier
          -- ^ An identifier for the supplemental data.
        , measureSupplementalData_usage :: [CodeableConcept]
          -- ^ An indicator of the intended usage for the supplemental 
          --   data element. Supplemental data indicates the data is 
          --   additional information requested to augment the measure 
          --   information. Risk adjustment factor indicates the data is 
          --   additional information used to calculate risk adjustment 
          --   factors when applying a risk model to the measure 
          --   calculation.
        , measureSupplementalData_criteria :: Maybe Xsd.XsdString
          -- ^ The criteria for the supplemental data. This must be the 
          --   name of a valid expression defined within a referenced 
          --   library, and defines the data to be returned for this 
          --   element.
        , measureSupplementalData_path :: Maybe Xsd.XsdString
          -- ^ The supplemental data to be supplied as part of the measure 
          --   response, specified as a valid FHIR Resource Path.
        }
        deriving (Eq,Show)
instance SchemaType MeasureSupplementalData where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureSupplementalData a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "usage")
            `apply` optional (parseSchemaType "criteria")
            `apply` optional (parseSchemaType "path")
    schemaTypeToXML s x@MeasureSupplementalData{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureSupplementalData_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureSupplementalData_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureSupplementalData_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureSupplementalData_identifier x
            , concatMap (schemaTypeToXML "usage") $ measureSupplementalData_usage x
            , maybe [] (schemaTypeToXML "criteria") $ measureSupplementalData_criteria x
            , maybe [] (schemaTypeToXML "path") $ measureSupplementalData_path x
            ]
instance Extension MeasureSupplementalData BackboneElement where
    supertype (MeasureSupplementalData a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureSupplementalData Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureSupplementalData -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
elementMeasureReport :: XMLParser MeasureReport
elementMeasureReport = parseSchemaType "MeasureReport"
elementToXMLMeasureReport :: MeasureReport -> [Content ()]
elementToXMLMeasureReport = schemaTypeToXML "MeasureReport"
 
data MeasureReport = MeasureReport
        { measureReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , measureReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , measureReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , measureReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , measureReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , measureReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , measureReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReport_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this report 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , measureReport_status :: MeasureReportStatus
          -- ^ The report status. No data will be available until the 
          --   report status is complete.
        , measureReport_type :: MeasureReportType
          -- ^ The type of measure report. This may be an individual 
          --   report, which provides a single patient's score for the 
          --   measure; a patient listing, which returns the list of 
          --   patients that meet the various criteria in the measure; or 
          --   a summary report, which returns a population count for each 
          --   of the criteria in the measure.
        , measureReport_measure :: Reference
          -- ^ A reference to the Measure that was evaluated to produce 
          --   this report.
        , measureReport_patient :: Maybe Reference
          -- ^ Optional Patient if the report was requested for a single 
          --   patient.
        , measureReport_date :: Maybe DateTime
          -- ^ The date this measure report was generated.
        , measureReport_reportingOrganization :: Maybe Reference
          -- ^ Reporting Organization.
        , measureReport_period :: Period
          -- ^ The reporting period for which the report was calculated.
        , measureReport_group :: [MeasureReportGroup]
          -- ^ The results of the calculation, one for each population 
          --   group in the measure.
        , measureReport_evaluatedResources :: Maybe Reference
          -- ^ A reference to a Bundle containing the Resources that were 
          --   used in the evaluation of this report.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MeasureReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "measure"
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "reportingOrganization")
            `apply` parseSchemaType "period"
            `apply` many (parseSchemaType "group")
            `apply` optional (parseSchemaType "evaluatedResources")
    schemaTypeToXML s x@MeasureReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ measureReport_id x
            , maybe [] (schemaTypeToXML "meta") $ measureReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ measureReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ measureReport_language x
            , maybe [] (schemaTypeToXML "text") $ measureReport_text x
            , concatMap (schemaTypeToXML "contained") $ measureReport_contained x
            , concatMap (schemaTypeToXML "extension") $ measureReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReport_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReport_identifier x
            , schemaTypeToXML "status" $ measureReport_status x
            , schemaTypeToXML "type" $ measureReport_type x
            , schemaTypeToXML "measure" $ measureReport_measure x
            , maybe [] (schemaTypeToXML "patient") $ measureReport_patient x
            , maybe [] (schemaTypeToXML "date") $ measureReport_date x
            , maybe [] (schemaTypeToXML "reportingOrganization") $ measureReport_reportingOrganization x
            , schemaTypeToXML "period" $ measureReport_period x
            , concatMap (schemaTypeToXML "group") $ measureReport_group x
            , maybe [] (schemaTypeToXML "evaluatedResources") $ measureReport_evaluatedResources x
            ]
instance Extension MeasureReport DomainResource where
    supertype (MeasureReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MeasureReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MeasureReport -> DomainResource)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReportGroup = MeasureReportGroup
        { measureReportGroup_id :: Maybe String_primitive
        , measureReportGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReportGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReportGroup_identifier :: Identifier
          -- ^ The identifier of the population group as defined in the 
          --   measure definition.
        , measureReportGroup_population :: [MeasureReportPopulation]
          -- ^ The populations that make up the population group, one for 
          --   each type of population appropriate for the measure.
        , measureReportGroup_measureScore :: Maybe Decimal
          -- ^ The measure score for this population group, calculated as 
          --   appropriate for the measure type and scoring method, and 
          --   based on the contents of the populations defined in the 
          --   group.
        , measureReportGroup_stratifier :: [MeasureReportStratifier]
          -- ^ When a measure includes multiple stratifiers, there will be 
          --   a stratifier group for each stratifier defined by the 
          --   measure.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReportGroup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` many (parseSchemaType "population")
            `apply` optional (parseSchemaType "measureScore")
            `apply` many (parseSchemaType "stratifier")
    schemaTypeToXML s x@MeasureReportGroup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportGroup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReportGroup_modifierExtension x
            , schemaTypeToXML "identifier" $ measureReportGroup_identifier x
            , concatMap (schemaTypeToXML "population") $ measureReportGroup_population x
            , maybe [] (schemaTypeToXML "measureScore") $ measureReportGroup_measureScore x
            , concatMap (schemaTypeToXML "stratifier") $ measureReportGroup_stratifier x
            ]
instance Extension MeasureReportGroup BackboneElement where
    supertype (MeasureReportGroup a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReportGroup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReportGroup -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReportPopulation = MeasureReportPopulation
        { measureReportPopulation_id :: Maybe String_primitive
        , measureReportPopulation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReportPopulation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReportPopulation_identifier :: Maybe Identifier
          -- ^ The identifier of the population being reported, as defined 
          --   by the population element of the measure.
        , measureReportPopulation_code :: Maybe CodeableConcept
          -- ^ The type of the population.
        , measureReportPopulation_count :: Maybe Integer
          -- ^ The number of members of the population.
        , measureReportPopulation_patients :: Maybe Reference
          -- ^ This element refers to a List of patient level 
          --   MeasureReport resources, one for each patient in this 
          --   population.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportPopulation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReportPopulation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "patients")
    schemaTypeToXML s x@MeasureReportPopulation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportPopulation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportPopulation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReportPopulation_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReportPopulation_identifier x
            , maybe [] (schemaTypeToXML "code") $ measureReportPopulation_code x
            , maybe [] (schemaTypeToXML "count") $ measureReportPopulation_count x
            , maybe [] (schemaTypeToXML "patients") $ measureReportPopulation_patients x
            ]
instance Extension MeasureReportPopulation BackboneElement where
    supertype (MeasureReportPopulation a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReportPopulation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReportPopulation -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReportStratifier = MeasureReportStratifier
        { measureReportStratifier_id :: Maybe String_primitive
        , measureReportStratifier_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReportStratifier_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReportStratifier_identifier :: Maybe Identifier
          -- ^ The identifier of this stratifier, as defined in the 
          --   measure definition.
        , measureReportStratifier_stratum :: [MeasureReportStratum]
          -- ^ This element contains the results for a single stratum 
          --   within the stratifier. For example, when stratifying on 
          --   administrative gender, there will be four strata, one for 
          --   each possible gender value.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportStratifier where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReportStratifier a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "stratum")
    schemaTypeToXML s x@MeasureReportStratifier{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportStratifier_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportStratifier_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReportStratifier_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReportStratifier_identifier x
            , concatMap (schemaTypeToXML "stratum") $ measureReportStratifier_stratum x
            ]
instance Extension MeasureReportStratifier BackboneElement where
    supertype (MeasureReportStratifier a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MeasureReportStratifier Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReportStratifier -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReportStratum = MeasureReportStratum
        { measureReportStratum_id :: Maybe String_primitive
        , measureReportStratum_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReportStratum_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReportStratum_value :: Xsd.XsdString
          -- ^ The value for this stratum, expressed as a string. When 
          --   defining stratifiers on complex values, the value must be 
          --   rendered such that the value for each stratum within the 
          --   stratifier is unique.
        , measureReportStratum_population :: [MeasureReportPopulation1]
          -- ^ The populations that make up the stratum, one for each type 
          --   of population appropriate to the measure.
        , measureReportStratum_measureScore :: Maybe Decimal
          -- ^ The measure score for this stratum, calculated as 
          --   appropriate for the measure type and scoring method, and 
          --   based on only the members of this stratum.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportStratum where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReportStratum a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "value"
            `apply` many (parseSchemaType "population")
            `apply` optional (parseSchemaType "measureScore")
    schemaTypeToXML s x@MeasureReportStratum{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportStratum_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportStratum_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReportStratum_modifierExtension x
            , schemaTypeToXML "value" $ measureReportStratum_value x
            , concatMap (schemaTypeToXML "population") $ measureReportStratum_population x
            , maybe [] (schemaTypeToXML "measureScore") $ measureReportStratum_measureScore x
            ]
instance Extension MeasureReportStratum BackboneElement where
    supertype (MeasureReportStratum a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MeasureReportStratum Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReportStratum -> BackboneElement)
              
 
-- | The MeasureReport resource contains the results of 
--   evaluating a measure.
data MeasureReportPopulation1 = MeasureReportPopulation1
        { measureReportPopulation1_id :: Maybe String_primitive
        , measureReportPopulation1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , measureReportPopulation1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , measureReportPopulation1_identifier :: Maybe Identifier
          -- ^ The identifier of the population being reported, as defined 
          --   by the population element of the measure.
        , measureReportPopulation1_code :: Maybe CodeableConcept
          -- ^ The type of the population.
        , measureReportPopulation1_count :: Maybe Integer
          -- ^ The number of members of the population in this stratum.
        , measureReportPopulation1_patients :: Maybe Reference
          -- ^ This element refers to a List of patient level 
          --   MeasureReport resources, one for each patient in this 
          --   population in this stratum.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportPopulation1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MeasureReportPopulation1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "count")
            `apply` optional (parseSchemaType "patients")
    schemaTypeToXML s x@MeasureReportPopulation1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportPopulation1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportPopulation1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ measureReportPopulation1_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ measureReportPopulation1_identifier x
            , maybe [] (schemaTypeToXML "code") $ measureReportPopulation1_code x
            , maybe [] (schemaTypeToXML "count") $ measureReportPopulation1_count x
            , maybe [] (schemaTypeToXML "patients") $ measureReportPopulation1_patients x
            ]
instance Extension MeasureReportPopulation1 BackboneElement where
    supertype (MeasureReportPopulation1 a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MeasureReportPopulation1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MeasureReportPopulation1 -> BackboneElement)
              
 
data MeasureReportStatus_list
    = MeasureReportStatus_list_Complete
      -- ^ Complete
    | MeasureReportStatus_list_Pending
      -- ^ Pending
    | MeasureReportStatus_list_Error
      -- ^ Error
    deriving (Eq,Show,Enum)
instance SchemaType MeasureReportStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasureReportStatus_list where
    acceptingParser =  do literal "complete"; return MeasureReportStatus_list_Complete
                      `onFail` do literal "pending"; return MeasureReportStatus_list_Pending
                      `onFail` do literal "error"; return MeasureReportStatus_list_Error
                      
    simpleTypeText MeasureReportStatus_list_Complete = "complete"
    simpleTypeText MeasureReportStatus_list_Pending = "pending"
    simpleTypeText MeasureReportStatus_list_Error = "error"
 
data MeasureReportStatus = MeasureReportStatus
        { measureReportStatus_id :: Maybe String_primitive
        , measureReportStatus_value :: Maybe MeasureReportStatus_list
        , measureReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasureReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasureReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ measureReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportStatus_extension x
            ]
instance Extension MeasureReportStatus Element where
    supertype (MeasureReportStatus a0 a1 e0) =
               Element a0 e0
 
data MeasureReportType_list
    = MeasureReportType_list_Individual
      -- ^ Individual
    | MeasureReportType_list_Patient_list
      -- ^ Patient List
    | MeasureReportType_list_Summary
      -- ^ Summary
    deriving (Eq,Show,Enum)
instance SchemaType MeasureReportType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MeasureReportType_list where
    acceptingParser =  do literal "individual"; return MeasureReportType_list_Individual
                      `onFail` do literal "patient-list"; return MeasureReportType_list_Patient_list
                      `onFail` do literal "summary"; return MeasureReportType_list_Summary
                      
    simpleTypeText MeasureReportType_list_Individual = "individual"
    simpleTypeText MeasureReportType_list_Patient_list = "patient-list"
    simpleTypeText MeasureReportType_list_Summary = "summary"
 
data MeasureReportType = MeasureReportType
        { measureReportType_id :: Maybe String_primitive
        , measureReportType_value :: Maybe MeasureReportType_list
        , measureReportType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MeasureReportType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MeasureReportType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MeasureReportType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ measureReportType_id x
                       , maybe [] (toXMLAttribute "value") $ measureReportType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ measureReportType_extension x
            ]
instance Extension MeasureReportType Element where
    supertype (MeasureReportType a0 a1 e0) =
               Element a0 e0
 
-- | A photo, video, or audio recording acquired or used in 
--   healthcare. The actual content may be inline or provided by 
--   direct reference.
elementMedia :: XMLParser Media
elementMedia = parseSchemaType "Media"
elementToXMLMedia :: Media -> [Content ()]
elementToXMLMedia = schemaTypeToXML "Media"
 
data Media = Media
        { media_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , media_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , media_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , media_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , media_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , media_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , media_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , media_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , media_identifier :: [Identifier]
          -- ^ Identifiers associated with the image - these may include 
          --   identifiers for the image itself, identifiers for the 
          --   context of its collection (e.g. series ids) and context ids 
          --   such as accession numbers or other workflow identifiers.
        , media_basedOn :: [Reference]
          -- ^ A procedure that is fulfilled in whole or in part by the 
          --   creation of this media.
        , media_type :: DigitalMediaType
          -- ^ Whether the media is a photo (still image), an audio 
          --   recording, or a video recording.
        , media_subtype :: Maybe CodeableConcept
          -- ^ Details of the type of the media - usually, how it was 
          --   acquired (what type of device). If images sourced from a 
          --   DICOM system, are wrapped in a Media resource, then this is 
          --   the modality.
        , media_view :: Maybe CodeableConcept
          -- ^ The name of the imaging view e.g. Lateral or 
          --   Antero-posterior (AP).
        , media_subject :: Maybe Reference
          -- ^ Who/What this Media is a record of.
        , media_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this media.
        , media_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date and time(s) at which the media was collected.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , media_operator :: Maybe Reference
          -- ^ The person who administered the collection of the image.
        , media_reasonCode :: [CodeableConcept]
          -- ^ Describes why the event occurred in coded or textual form.
        , media_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the media 
          --   was collected (i.e. the target site).
        , media_device :: Maybe Reference
          -- ^ The device used to collect the media.
        , media_height :: Maybe PositiveInt
          -- ^ Height of the image in pixels (photo/video).
        , media_width :: Maybe PositiveInt
          -- ^ Width of the image in pixels (photo/video).
        , media_frames :: Maybe PositiveInt
          -- ^ The number of frames in a photo. This is used with a 
          --   multi-page fax, or an imaging acquisition context that 
          --   takes multiple slices in a single image, or an animated 
          --   gif. If there is more than one frame, this SHALL have a 
          --   value in order to alert interface software that a 
          --   multi-frame capable rendering widget is required.
        , media_duration :: Maybe UnsignedInt
          -- ^ The duration of the recording in seconds - for audio and 
          --   video.
        , media_content :: Attachment
          -- ^ The actual content of the media - inline or by direct 
          --   reference to the media source file.
        , media_note :: [Annotation]
          -- ^ Comments made about the media by the performer, subject or 
          --   other participants.
        }
        deriving (Eq,Show)
instance SchemaType Media where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Media
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "subtype")
            `apply` optional (parseSchemaType "view")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "operator")
            `apply` many (parseSchemaType "reasonCode")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "device")
            `apply` optional (parseSchemaType "height")
            `apply` optional (parseSchemaType "width")
            `apply` optional (parseSchemaType "frames")
            `apply` optional (parseSchemaType "duration")
            `apply` parseSchemaType "content"
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Media{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ media_id x
            , maybe [] (schemaTypeToXML "meta") $ media_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ media_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ media_language x
            , maybe [] (schemaTypeToXML "text") $ media_text x
            , concatMap (schemaTypeToXML "contained") $ media_contained x
            , concatMap (schemaTypeToXML "extension") $ media_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ media_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ media_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ media_basedOn x
            , schemaTypeToXML "type" $ media_type x
            , maybe [] (schemaTypeToXML "subtype") $ media_subtype x
            , maybe [] (schemaTypeToXML "view") $ media_view x
            , maybe [] (schemaTypeToXML "subject") $ media_subject x
            , maybe [] (schemaTypeToXML "context") $ media_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ media_choice15 x
            , maybe [] (schemaTypeToXML "operator") $ media_operator x
            , concatMap (schemaTypeToXML "reasonCode") $ media_reasonCode x
            , maybe [] (schemaTypeToXML "bodySite") $ media_bodySite x
            , maybe [] (schemaTypeToXML "device") $ media_device x
            , maybe [] (schemaTypeToXML "height") $ media_height x
            , maybe [] (schemaTypeToXML "width") $ media_width x
            , maybe [] (schemaTypeToXML "frames") $ media_frames x
            , maybe [] (schemaTypeToXML "duration") $ media_duration x
            , schemaTypeToXML "content" $ media_content x
            , concatMap (schemaTypeToXML "note") $ media_note x
            ]
instance Extension Media DomainResource where
    supertype (Media e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Media Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Media -> DomainResource)
              
 
data DigitalMediaType_list
    = DigitalMediaType_list_Photo
      -- ^ Photo
    | DigitalMediaType_list_Video
      -- ^ Video
    | DigitalMediaType_list_Audio
      -- ^ Audio
    deriving (Eq,Show,Enum)
instance SchemaType DigitalMediaType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType DigitalMediaType_list where
    acceptingParser =  do literal "photo"; return DigitalMediaType_list_Photo
                      `onFail` do literal "video"; return DigitalMediaType_list_Video
                      `onFail` do literal "audio"; return DigitalMediaType_list_Audio
                      
    simpleTypeText DigitalMediaType_list_Photo = "photo"
    simpleTypeText DigitalMediaType_list_Video = "video"
    simpleTypeText DigitalMediaType_list_Audio = "audio"
 
data DigitalMediaType = DigitalMediaType
        { digitalMediaType_id :: Maybe String_primitive
        , digitalMediaType_value :: Maybe DigitalMediaType_list
        , digitalMediaType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType DigitalMediaType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (DigitalMediaType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@DigitalMediaType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ digitalMediaType_id x
                       , maybe [] (toXMLAttribute "value") $ digitalMediaType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ digitalMediaType_extension x
            ]
instance Extension DigitalMediaType Element where
    supertype (DigitalMediaType a0 a1 e0) =
               Element a0 e0
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
elementMedication :: XMLParser Medication
elementMedication = parseSchemaType "Medication"
elementToXMLMedication :: Medication -> [Content ()]
elementToXMLMedication = schemaTypeToXML "Medication"
 
data Medication = Medication
        { medication_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medication_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medication_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medication_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medication_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medication_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medication_code :: Maybe CodeableConcept
          -- ^ A code (or set of codes) that specify this medication, or a 
          --   textual description if no code is available. Usage note: 
          --   This could be a standard medication code such as a code 
          --   from RxNorm, SNOMED CT, IDMP etc. It could also be a 
          --   national or local formulary code, optionally with 
          --   translations to other code systems.
        , medication_status :: Maybe MedicationStatus
          -- ^ A code to indicate if the medication is in active use.
        , medication_isBrand :: Maybe Boolean
          -- ^ Set to true if the item is attributable to a specific 
          --   manufacturer.
        , medication_isOverTheCounter :: Maybe Boolean
          -- ^ Set to true if the medication can be obtained without an 
          --   order from a prescriber.
        , medication_manufacturer :: Maybe Reference
          -- ^ Describes the details of the manufacturer of the medication 
          --   product. This is not intended to represent the distributor 
          --   of a medication product.
        , medication_form :: Maybe CodeableConcept
          -- ^ Describes the form of the item. Powder; tablets; capsule.
        , medication_ingredient :: [MedicationIngredient]
          -- ^ Identifies a particular constituent of interest in the 
          --   product.
        , medication_package :: Maybe MedicationPackage
          -- ^ Information that only applies to packages (not products).
        , medication_image :: [Attachment]
          -- ^ Photo(s) or graphic representation(s) of the medication.
        }
        deriving (Eq,Show)
instance SchemaType Medication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Medication
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "isBrand")
            `apply` optional (parseSchemaType "isOverTheCounter")
            `apply` optional (parseSchemaType "manufacturer")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "ingredient")
            `apply` optional (parseSchemaType "package")
            `apply` many (parseSchemaType "image")
    schemaTypeToXML s x@Medication{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medication_id x
            , maybe [] (schemaTypeToXML "meta") $ medication_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medication_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medication_language x
            , maybe [] (schemaTypeToXML "text") $ medication_text x
            , concatMap (schemaTypeToXML "contained") $ medication_contained x
            , concatMap (schemaTypeToXML "extension") $ medication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medication_modifierExtension x
            , maybe [] (schemaTypeToXML "code") $ medication_code x
            , maybe [] (schemaTypeToXML "status") $ medication_status x
            , maybe [] (schemaTypeToXML "isBrand") $ medication_isBrand x
            , maybe [] (schemaTypeToXML "isOverTheCounter") $ medication_isOverTheCounter x
            , maybe [] (schemaTypeToXML "manufacturer") $ medication_manufacturer x
            , maybe [] (schemaTypeToXML "form") $ medication_form x
            , concatMap (schemaTypeToXML "ingredient") $ medication_ingredient x
            , maybe [] (schemaTypeToXML "package") $ medication_package x
            , concatMap (schemaTypeToXML "image") $ medication_image x
            ]
instance Extension Medication DomainResource where
    supertype (Medication e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Medication Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Medication -> DomainResource)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data MedicationIngredient = MedicationIngredient
        { medicationIngredient_id :: Maybe String_primitive
        , medicationIngredient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationIngredient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationIngredient_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ The actual ingredient - either a substance (simple 
          --   ingredient) or another medication.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , medicationIngredient_isActive :: Maybe Boolean
          -- ^ Indication of whether this ingredient affects the 
          --   therapeutic action of the drug.
        , medicationIngredient_amount :: Maybe Ratio
          -- ^ Specifies how many (or how much) of the items there are in 
          --   this Medication. For example, 250 mg per tablet. This is 
          --   expressed as a ratio where the numerator is 250mg and the 
          --   denominator is 1 tablet.
        }
        deriving (Eq,Show)
instance SchemaType MedicationIngredient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationIngredient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "isActive")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@MedicationIngredient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationIngredient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationIngredient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationIngredient_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ medicationIngredient_choice2 x
            , maybe [] (schemaTypeToXML "isActive") $ medicationIngredient_isActive x
            , maybe [] (schemaTypeToXML "amount") $ medicationIngredient_amount x
            ]
instance Extension MedicationIngredient BackboneElement where
    supertype (MedicationIngredient a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MedicationIngredient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationIngredient -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data MedicationPackage = MedicationPackage
        { medicationPackage_id :: Maybe String_primitive
        , medicationPackage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationPackage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationPackage_container :: Maybe CodeableConcept
          -- ^ The kind of container that this package comes as.
        , medicationPackage_content :: [MedicationContent]
          -- ^ A set of components that go to make up the described item.
        , medicationPackage_batch :: [MedicationBatch]
          -- ^ Information about a group of medication produced or 
          --   packaged from one production run.
        }
        deriving (Eq,Show)
instance SchemaType MedicationPackage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationPackage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "container")
            `apply` many (parseSchemaType "content")
            `apply` many (parseSchemaType "batch")
    schemaTypeToXML s x@MedicationPackage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationPackage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationPackage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationPackage_modifierExtension x
            , maybe [] (schemaTypeToXML "container") $ medicationPackage_container x
            , concatMap (schemaTypeToXML "content") $ medicationPackage_content x
            , concatMap (schemaTypeToXML "batch") $ medicationPackage_batch x
            ]
instance Extension MedicationPackage BackboneElement where
    supertype (MedicationPackage a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MedicationPackage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationPackage -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data MedicationContent = MedicationContent
        { medicationContent_id :: Maybe String_primitive
        , medicationContent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationContent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationContent_choice2 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies one of the items in the package.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        , medicationContent_amount :: Maybe Quantity
          -- ^ The amount of the product that is in the package.
        }
        deriving (Eq,Show)
instance SchemaType MedicationContent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationContent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                           ]
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@MedicationContent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationContent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationContent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationContent_modifierExtension x
            , foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                          (schemaTypeToXML "itemReference")
                          $ medicationContent_choice2 x
            , maybe [] (schemaTypeToXML "amount") $ medicationContent_amount x
            ]
instance Extension MedicationContent BackboneElement where
    supertype (MedicationContent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationContent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationContent -> BackboneElement)
              
 
-- | This resource is primarily used for the identification and 
--   definition of a medication. It covers the ingredients and 
--   the packaging for a medication.
data MedicationBatch = MedicationBatch
        { medicationBatch_id :: Maybe String_primitive
        , medicationBatch_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationBatch_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationBatch_lotNumber :: Maybe Xsd.XsdString
          -- ^ The assigned lot number of a batch of the specified 
          --   product.
        , medicationBatch_expirationDate :: Maybe DateTime
          -- ^ When this specific batch of product will expire.
        }
        deriving (Eq,Show)
instance SchemaType MedicationBatch where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationBatch a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "lotNumber")
            `apply` optional (parseSchemaType "expirationDate")
    schemaTypeToXML s x@MedicationBatch{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationBatch_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationBatch_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationBatch_modifierExtension x
            , maybe [] (schemaTypeToXML "lotNumber") $ medicationBatch_lotNumber x
            , maybe [] (schemaTypeToXML "expirationDate") $ medicationBatch_expirationDate x
            ]
instance Extension MedicationBatch BackboneElement where
    supertype (MedicationBatch a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationBatch Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationBatch -> BackboneElement)
              
 
data MedicationStatus_list
    = MedicationStatus_list_Active
      -- ^ Active
    | MedicationStatus_list_Inactive
      -- ^ Inactive
    | MedicationStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatus_list where
    acceptingParser =  do literal "active"; return MedicationStatus_list_Active
                      `onFail` do literal "inactive"; return MedicationStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return MedicationStatus_list_Entered_in_error
                      
    simpleTypeText MedicationStatus_list_Active = "active"
    simpleTypeText MedicationStatus_list_Inactive = "inactive"
    simpleTypeText MedicationStatus_list_Entered_in_error = "entered-in-error"
 
data MedicationStatus = MedicationStatus
        { medicationStatus_id :: Maybe String_primitive
        , medicationStatus_value :: Maybe MedicationStatus_list
        , medicationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatus_extension x
            ]
instance Extension MedicationStatus Element where
    supertype (MedicationStatus a0 a1 e0) =
               Element a0 e0
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
elementMedicationAdministration :: XMLParser MedicationAdministration
elementMedicationAdministration = parseSchemaType "MedicationAdministration"
elementToXMLMedicationAdministration :: MedicationAdministration -> [Content ()]
elementToXMLMedicationAdministration = schemaTypeToXML "MedicationAdministration"
 
data MedicationAdministration = MedicationAdministration
        { medicationAdministration_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationAdministration_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationAdministration_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationAdministration_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationAdministration_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationAdministration_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationAdministration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministration_identifier :: [Identifier]
          -- ^ External identifier - FHIR will generate its own internal 
          --   identifiers (probably URLs) which do not need to be 
          --   explicitly managed by the resource. The identifier here is 
          --   one that would be used by another non-FHIR system - for 
          --   example an automated medication pump would provide a record 
          --   each time it operated; an administration while the patient 
          --   was off the ward might be made with a different system and 
          --   entered after the event. Particularly important if these 
          --   records have to be updated.
        , medicationAdministration_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that 
          --   was adhered to in whole or in part by this event.
        , medicationAdministration_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , medicationAdministration_status :: MedicationAdministrationStatus
          -- ^ Will generally be set to show that the administration has 
          --   been completed. For some long running administrations such 
          --   as infusions it is possible for an administration to be 
          --   started but not completed or it may be paused while some 
          --   other process is under way.
        , medicationAdministration_category :: Maybe CodeableConcept
          -- ^ Indicates the type of medication administration and where 
          --   the medication is expected to be consumed or administered.
        , medicationAdministration_choice13 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication that was administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationAdministration_subject :: Reference
          -- ^ The person or animal or group receiving the medication.
        , medicationAdministration_context :: Maybe Reference
          -- ^ The visit, admission or other contact between patient and 
          --   health care provider the medication administration was 
          --   performed as part of.
        , medicationAdministration_supportingInformation :: [Reference]
          -- ^ Additional information (for example, patient height and 
          --   weight) that supports the administration of the medication.
        , medicationAdministration_choice17 :: OneOf2 DateTime Period
          -- ^ A specific date/time or interval of time during which the 
          --   administration took place (or did not take place, when the 
          --   'notGiven' attribute is true). For many administrations, 
          --   such as swallowing a tablet the use of dateTime is more 
          --   appropriate.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , medicationAdministration_performer :: [MedicationAdministrationPerformer]
          -- ^ The individual who was responsible for giving the 
          --   medication to the patient.
        , medicationAdministration_notGiven :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the 
          --   medication was NOT administered.
        , medicationAdministration_reasonNotGiven :: [CodeableConcept]
          -- ^ A code indicating why the administration was not performed.
        , medicationAdministration_reasonCode :: [CodeableConcept]
          -- ^ A code indicating why the medication was given.
        , medicationAdministration_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   was administered.
        , medicationAdministration_prescription :: Maybe Reference
          -- ^ The original request, instruction or authority to perform 
          --   the administration.
        , medicationAdministration_device :: [Reference]
          -- ^ The device used in administering the medication to the 
          --   patient. For example, a particular infusion pump.
        , medicationAdministration_note :: [Annotation]
          -- ^ Extra information about the medication administration that 
          --   is not conveyed by the other attributes.
        , medicationAdministration_dosage :: Maybe MedicationAdministrationDosage
          -- ^ Describes the medication dosage information details e.g. 
          --   dose, rate, site, route, etc.
        , medicationAdministration_eventHistory :: [Reference]
          -- ^ A summary of the events of interest that have occurred, 
          --   such as when the administration was verified.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationAdministration
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                           , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                           ]
            `apply` many (parseSchemaType "performer")
            `apply` optional (parseSchemaType "notGiven")
            `apply` many (parseSchemaType "reasonNotGiven")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` optional (parseSchemaType "prescription")
            `apply` many (parseSchemaType "device")
            `apply` many (parseSchemaType "note")
            `apply` optional (parseSchemaType "dosage")
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationAdministration{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationAdministration_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationAdministration_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationAdministration_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationAdministration_language x
            , maybe [] (schemaTypeToXML "text") $ medicationAdministration_text x
            , concatMap (schemaTypeToXML "contained") $ medicationAdministration_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationAdministration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministration_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationAdministration_identifier x
            , concatMap (schemaTypeToXML "definition") $ medicationAdministration_definition x
            , concatMap (schemaTypeToXML "partOf") $ medicationAdministration_partOf x
            , schemaTypeToXML "status" $ medicationAdministration_status x
            , maybe [] (schemaTypeToXML "category") $ medicationAdministration_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationAdministration_choice13 x
            , schemaTypeToXML "subject" $ medicationAdministration_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationAdministration_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationAdministration_supportingInformation x
            , foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                          (schemaTypeToXML "effectivePeriod")
                          $ medicationAdministration_choice17 x
            , concatMap (schemaTypeToXML "performer") $ medicationAdministration_performer x
            , maybe [] (schemaTypeToXML "notGiven") $ medicationAdministration_notGiven x
            , concatMap (schemaTypeToXML "reasonNotGiven") $ medicationAdministration_reasonNotGiven x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationAdministration_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationAdministration_reasonReference x
            , maybe [] (schemaTypeToXML "prescription") $ medicationAdministration_prescription x
            , concatMap (schemaTypeToXML "device") $ medicationAdministration_device x
            , concatMap (schemaTypeToXML "note") $ medicationAdministration_note x
            , maybe [] (schemaTypeToXML "dosage") $ medicationAdministration_dosage x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationAdministration_eventHistory x
            ]
instance Extension MedicationAdministration DomainResource where
    supertype (MedicationAdministration e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationAdministration Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationAdministration -> DomainResource)
              
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
data MedicationAdministrationPerformer = MedicationAdministrationPerformer
        { medicationAdministrationPerformer_id :: Maybe String_primitive
        , medicationAdministrationPerformer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministrationPerformer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministrationPerformer_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action.
        , medicationAdministrationPerformer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministrationPerformer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationAdministrationPerformer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationAdministrationPerformer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministrationPerformer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministrationPerformer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministrationPerformer_modifierExtension x
            , schemaTypeToXML "actor" $ medicationAdministrationPerformer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationAdministrationPerformer_onBehalfOf x
            ]
instance Extension MedicationAdministrationPerformer BackboneElement where
    supertype (MedicationAdministrationPerformer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationAdministrationPerformer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationAdministrationPerformer -> BackboneElement)
              
 
-- | Describes the event of a patient consuming or otherwise 
--   being administered a medication. This may be as simple as 
--   swallowing a tablet or it may be a long running infusion. 
--   Related resources tie this event to the authorizing 
--   prescription, and the specific encounter between patient 
--   and health care practitioner.
data MedicationAdministrationDosage = MedicationAdministrationDosage
        { medicationAdministrationDosage_id :: Maybe String_primitive
        , medicationAdministrationDosage_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationAdministrationDosage_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationAdministrationDosage_text :: Maybe Xsd.XsdString
          -- ^ Free text dosage can be used for cases where the dosage 
          --   administered is too complex to code. When coded dosage is 
          --   present, the free text dosage may still be present for 
          --   display to humans.The dosage instructions should reflect 
          --   the dosage of the medication that was administered.
        , medicationAdministrationDosage_site :: Maybe CodeableConcept
          -- ^ A coded specification of the anatomic site where the 
          --   medication first entered the body. For example, &quot;left 
          --   arm&quot;.
        , medicationAdministrationDosage_route :: Maybe CodeableConcept
          -- ^ A code specifying the route or physiological path of 
          --   administration of a therapeutic agent into or onto the 
          --   patient. For example, topical, intravenous, etc.
        , medicationAdministrationDosage_method :: Maybe CodeableConcept
          -- ^ A coded value indicating the method by which the medication 
          --   is intended to be or was introduced into or on the body. 
          --   This attribute will most often NOT be populated. It is most 
          --   commonly used for injections. For example, Slow Push, Deep 
          --   IV.
        , medicationAdministrationDosage_dose :: Maybe Quantity
          -- ^ The amount of the medication given at one administration 
          --   event. Use this value when the administration is 
          --   essentially an instantaneous event such as a swallowing a 
          --   tablet or giving an injection.
        , medicationAdministrationDosage_choice7 :: (Maybe (OneOf2 Ratio Quantity))
          -- ^ Identifies the speed with which the medication was or will 
          --   be introduced into the patient. Typically the rate for an 
          --   infusion e.g. 100 ml per 1 hour or 100 ml/hr. May also be 
          --   expressed as a rate per unit of time e.g. 500 ml per 2 
          --   hours. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 
          --   liter/8 hours.
          --   
          --   Choice between:
          --   
          --   (1) rateRatio
          --   
          --   (2) rateQuantity
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministrationDosage where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationAdministrationDosage a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "site")
            `apply` optional (parseSchemaType "route")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "dose")
            `apply` optional (oneOf' [ ("Ratio", fmap OneOf2 (parseSchemaType "rateRatio"))
                                     , ("Quantity", fmap TwoOf2 (parseSchemaType "rateQuantity"))
                                     ])
    schemaTypeToXML s x@MedicationAdministrationDosage{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministrationDosage_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministrationDosage_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationAdministrationDosage_modifierExtension x
            , maybe [] (schemaTypeToXML "text") $ medicationAdministrationDosage_text x
            , maybe [] (schemaTypeToXML "site") $ medicationAdministrationDosage_site x
            , maybe [] (schemaTypeToXML "route") $ medicationAdministrationDosage_route x
            , maybe [] (schemaTypeToXML "method") $ medicationAdministrationDosage_method x
            , maybe [] (schemaTypeToXML "dose") $ medicationAdministrationDosage_dose x
            , maybe [] (foldOneOf2  (schemaTypeToXML "rateRatio")
                                    (schemaTypeToXML "rateQuantity")
                                   ) $ medicationAdministrationDosage_choice7 x
            ]
instance Extension MedicationAdministrationDosage BackboneElement where
    supertype (MedicationAdministrationDosage a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension MedicationAdministrationDosage Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationAdministrationDosage -> BackboneElement)
              
 
data MedicationAdministrationStatus_list
    = MedicationAdministrationStatus_list_In_progress
      -- ^ In Progress
    | MedicationAdministrationStatus_list_On_hold
      -- ^ On Hold
    | MedicationAdministrationStatus_list_Completed
      -- ^ Completed
    | MedicationAdministrationStatus_list_Entered_in_error
      -- ^ Entered in Error
    | MedicationAdministrationStatus_list_Stopped
      -- ^ Stopped
    | MedicationAdministrationStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType MedicationAdministrationStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationAdministrationStatus_list where
    acceptingParser =  do literal "in-progress"; return MedicationAdministrationStatus_list_In_progress
                      `onFail` do literal "on-hold"; return MedicationAdministrationStatus_list_On_hold
                      `onFail` do literal "completed"; return MedicationAdministrationStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationAdministrationStatus_list_Entered_in_error
                      `onFail` do literal "stopped"; return MedicationAdministrationStatus_list_Stopped
                      `onFail` do literal "unknown"; return MedicationAdministrationStatus_list_Unknown
                      
    simpleTypeText MedicationAdministrationStatus_list_In_progress = "in-progress"
    simpleTypeText MedicationAdministrationStatus_list_On_hold = "on-hold"
    simpleTypeText MedicationAdministrationStatus_list_Completed = "completed"
    simpleTypeText MedicationAdministrationStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText MedicationAdministrationStatus_list_Stopped = "stopped"
    simpleTypeText MedicationAdministrationStatus_list_Unknown = "unknown"
 
data MedicationAdministrationStatus = MedicationAdministrationStatus
        { medicationAdministrationStatus_id :: Maybe String_primitive
        , medicationAdministrationStatus_value :: Maybe MedicationAdministrationStatus_list
        , medicationAdministrationStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationAdministrationStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationAdministrationStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationAdministrationStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationAdministrationStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationAdministrationStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationAdministrationStatus_extension x
            ]
instance Extension MedicationAdministrationStatus Element where
    supertype (MedicationAdministrationStatus a0 a1 e0) =
               Element a0 e0
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
elementMedicationDispense :: XMLParser MedicationDispense
elementMedicationDispense = parseSchemaType "MedicationDispense"
elementToXMLMedicationDispense :: MedicationDispense -> [Content ()]
elementToXMLMedicationDispense = schemaTypeToXML "MedicationDispense"
 
data MedicationDispense = MedicationDispense
        { medicationDispense_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationDispense_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationDispense_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationDispense_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationDispense_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationDispense_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationDispense_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispense_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispense_identifier :: [Identifier]
          -- ^ Identifier assigned by the dispensing facility - this is an 
          --   identifier assigned outside FHIR.
        , medicationDispense_partOf :: [Reference]
          -- ^ The procedure that the dispense is done because of.
        , medicationDispense_status :: Maybe MedicationDispenseStatus
          -- ^ A code specifying the state of the set of dispense events.
        , medicationDispense_category :: Maybe CodeableConcept
          -- ^ Indicates type of medication dispense and where the 
          --   medication is expected to be consumed or administered.
        , medicationDispense_choice12 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationDispense_subject :: Maybe Reference
          -- ^ A link to a resource representing the person or the group 
          --   to whom the medication will be given.
        , medicationDispense_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this event.
        , medicationDispense_supportingInformation :: [Reference]
          -- ^ Additional information that supports the medication being 
          --   dispensed.
        , medicationDispense_performer :: [MedicationDispensePerformer]
          -- ^ Indicates who or what performed the event. It should be 
          --   assumed that the performer is the dispenser of the 
          --   medication.
        , medicationDispense_authorizingPrescription :: [Reference]
          -- ^ Indicates the medication order that is being dispensed 
          --   against.
        , medicationDispense_type :: Maybe CodeableConcept
          -- ^ Indicates the type of dispensing event that is performed. 
          --   For example, Trial Fill, Completion of Trial, Partial Fill, 
          --   Emergency Fill, Samples, etc.
        , medicationDispense_quantity :: Maybe Quantity
          -- ^ The amount of medication that has been dispensed. Includes 
          --   unit of measure.
        , medicationDispense_daysSupply :: Maybe Quantity
          -- ^ The amount of medication expressed as a timing amount.
        , medicationDispense_whenPrepared :: Maybe DateTime
          -- ^ The time when the dispensed product was packaged and 
          --   reviewed.
        , medicationDispense_whenHandedOver :: Maybe DateTime
          -- ^ The time the dispensed product was provided to the patient 
          --   or their representative.
        , medicationDispense_destination :: Maybe Reference
          -- ^ Identification of the facility/location where the 
          --   medication was shipped to, as part of the dispense event.
        , medicationDispense_receiver :: [Reference]
          -- ^ Identifies the person who picked up the medication. This 
          --   will usually be a patient or their caregiver, but some 
          --   cases exist where it can be a healthcare professional.
        , medicationDispense_note :: [Annotation]
          -- ^ Extra information about the dispense that could not be 
          --   conveyed in the other attributes.
        , medicationDispense_dosageInstruction :: [Dosage]
          -- ^ Indicates how the medication is to be used by the patient.
        , medicationDispense_substitution :: Maybe MedicationDispenseSubstitution
          -- ^ Indicates whether or not substitution was made as part of 
          --   the dispense. In some cases substitution will be expected 
          --   but does not happen, in other cases substitution is not 
          --   expected but does happen. This block explains what 
          --   substitution did or did not happen and why. If nothing is 
          --   specified, substitution was not done.
        , medicationDispense_detectedIssue :: [Reference]
          -- ^ Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions for 
          --   a patient; e.g. Drug-drug interaction, duplicate therapy, 
          --   dosage alert etc.
        , medicationDispense_notDone :: Maybe Boolean
          -- ^ True if the dispense was not performed for some reason.
        , medicationDispense_choice30 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason why a dispense was not performed.
          --   
          --   Choice between:
          --   
          --   (1) notDoneReasonCodeableConcept
          --   
          --   (2) notDoneReasonReference
        , medicationDispense_eventHistory :: [Reference]
          -- ^ A summary of the events of interest that have occurred, 
          --   such as when the dispense was verified.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispense where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationDispense
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` many (parseSchemaType "performer")
            `apply` many (parseSchemaType "authorizingPrescription")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "daysSupply")
            `apply` optional (parseSchemaType "whenPrepared")
            `apply` optional (parseSchemaType "whenHandedOver")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "receiver")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosageInstruction")
            `apply` optional (parseSchemaType "substitution")
            `apply` many (parseSchemaType "detectedIssue")
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "notDoneReasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "notDoneReasonReference"))
                                     ])
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationDispense{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationDispense_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationDispense_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationDispense_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationDispense_language x
            , maybe [] (schemaTypeToXML "text") $ medicationDispense_text x
            , concatMap (schemaTypeToXML "contained") $ medicationDispense_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationDispense_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispense_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationDispense_identifier x
            , concatMap (schemaTypeToXML "partOf") $ medicationDispense_partOf x
            , maybe [] (schemaTypeToXML "status") $ medicationDispense_status x
            , maybe [] (schemaTypeToXML "category") $ medicationDispense_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationDispense_choice12 x
            , maybe [] (schemaTypeToXML "subject") $ medicationDispense_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationDispense_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationDispense_supportingInformation x
            , concatMap (schemaTypeToXML "performer") $ medicationDispense_performer x
            , concatMap (schemaTypeToXML "authorizingPrescription") $ medicationDispense_authorizingPrescription x
            , maybe [] (schemaTypeToXML "type") $ medicationDispense_type x
            , maybe [] (schemaTypeToXML "quantity") $ medicationDispense_quantity x
            , maybe [] (schemaTypeToXML "daysSupply") $ medicationDispense_daysSupply x
            , maybe [] (schemaTypeToXML "whenPrepared") $ medicationDispense_whenPrepared x
            , maybe [] (schemaTypeToXML "whenHandedOver") $ medicationDispense_whenHandedOver x
            , maybe [] (schemaTypeToXML "destination") $ medicationDispense_destination x
            , concatMap (schemaTypeToXML "receiver") $ medicationDispense_receiver x
            , concatMap (schemaTypeToXML "note") $ medicationDispense_note x
            , concatMap (schemaTypeToXML "dosageInstruction") $ medicationDispense_dosageInstruction x
            , maybe [] (schemaTypeToXML "substitution") $ medicationDispense_substitution x
            , concatMap (schemaTypeToXML "detectedIssue") $ medicationDispense_detectedIssue x
            , maybe [] (schemaTypeToXML "notDone") $ medicationDispense_notDone x
            , maybe [] (foldOneOf2  (schemaTypeToXML "notDoneReasonCodeableConcept")
                                    (schemaTypeToXML "notDoneReasonReference")
                                   ) $ medicationDispense_choice30 x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationDispense_eventHistory x
            ]
instance Extension MedicationDispense DomainResource where
    supertype (MedicationDispense e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationDispense Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationDispense -> DomainResource)
              
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
data MedicationDispensePerformer = MedicationDispensePerformer
        { medicationDispensePerformer_id :: Maybe String_primitive
        , medicationDispensePerformer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispensePerformer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispensePerformer_actor :: Reference
          -- ^ The device, practitioner, etc. who performed the action. It 
          --   should be assumed that the actor is the dispenser of the 
          --   medication.
        , medicationDispensePerformer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispensePerformer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationDispensePerformer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationDispensePerformer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispensePerformer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispensePerformer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispensePerformer_modifierExtension x
            , schemaTypeToXML "actor" $ medicationDispensePerformer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationDispensePerformer_onBehalfOf x
            ]
instance Extension MedicationDispensePerformer BackboneElement where
    supertype (MedicationDispensePerformer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationDispensePerformer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationDispensePerformer -> BackboneElement)
              
 
-- | Indicates that a medication product is to be or has been 
--   dispensed for a named person/patient. This includes a 
--   description of the medication product (supply) provided and 
--   the instructions for administering the medication. The 
--   medication dispense is the result of a pharmacy system 
--   responding to a medication order.
data MedicationDispenseSubstitution = MedicationDispenseSubstitution
        { medicationDispenseSubstitution_id :: Maybe String_primitive
        , medicationDispenseSubstitution_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationDispenseSubstitution_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationDispenseSubstitution_wasSubstituted :: Boolean
          -- ^ True if the dispenser dispensed a different drug or product 
          --   from what was prescribed.
        , medicationDispenseSubstitution_type :: Maybe CodeableConcept
          -- ^ A code signifying whether a different drug was dispensed 
          --   from what was prescribed.
        , medicationDispenseSubstitution_reason :: [CodeableConcept]
          -- ^ Indicates the reason for the substitution of (or lack of 
          --   substitution) from what was prescribed.
        , medicationDispenseSubstitution_responsibleParty :: [Reference]
          -- ^ The person or organization that has primary responsibility 
          --   for the substitution.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispenseSubstitution where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationDispenseSubstitution a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "wasSubstituted"
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "responsibleParty")
    schemaTypeToXML s x@MedicationDispenseSubstitution{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispenseSubstitution_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispenseSubstitution_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationDispenseSubstitution_modifierExtension x
            , schemaTypeToXML "wasSubstituted" $ medicationDispenseSubstitution_wasSubstituted x
            , maybe [] (schemaTypeToXML "type") $ medicationDispenseSubstitution_type x
            , concatMap (schemaTypeToXML "reason") $ medicationDispenseSubstitution_reason x
            , concatMap (schemaTypeToXML "responsibleParty") $ medicationDispenseSubstitution_responsibleParty x
            ]
instance Extension MedicationDispenseSubstitution BackboneElement where
    supertype (MedicationDispenseSubstitution a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MedicationDispenseSubstitution Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationDispenseSubstitution -> BackboneElement)
              
 
data MedicationDispenseStatus_list
    = MedicationDispenseStatus_list_Preparation
      -- ^ Preparation
    | MedicationDispenseStatus_list_In_progress
      -- ^ In Progress
    | MedicationDispenseStatus_list_On_hold
      -- ^ On Hold
    | MedicationDispenseStatus_list_Completed
      -- ^ Completed
    | MedicationDispenseStatus_list_Entered_in_error
      -- ^ Entered in-Error
    | MedicationDispenseStatus_list_Stopped
      -- ^ Stopped
    deriving (Eq,Show,Enum)
instance SchemaType MedicationDispenseStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationDispenseStatus_list where
    acceptingParser =  do literal "preparation"; return MedicationDispenseStatus_list_Preparation
                      `onFail` do literal "in-progress"; return MedicationDispenseStatus_list_In_progress
                      `onFail` do literal "on-hold"; return MedicationDispenseStatus_list_On_hold
                      `onFail` do literal "completed"; return MedicationDispenseStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationDispenseStatus_list_Entered_in_error
                      `onFail` do literal "stopped"; return MedicationDispenseStatus_list_Stopped
                      
    simpleTypeText MedicationDispenseStatus_list_Preparation = "preparation"
    simpleTypeText MedicationDispenseStatus_list_In_progress = "in-progress"
    simpleTypeText MedicationDispenseStatus_list_On_hold = "on-hold"
    simpleTypeText MedicationDispenseStatus_list_Completed = "completed"
    simpleTypeText MedicationDispenseStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText MedicationDispenseStatus_list_Stopped = "stopped"
 
data MedicationDispenseStatus = MedicationDispenseStatus
        { medicationDispenseStatus_id :: Maybe String_primitive
        , medicationDispenseStatus_value :: Maybe MedicationDispenseStatus_list
        , medicationDispenseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationDispenseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationDispenseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationDispenseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationDispenseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationDispenseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationDispenseStatus_extension x
            ]
instance Extension MedicationDispenseStatus Element where
    supertype (MedicationDispenseStatus a0 a1 e0) =
               Element a0 e0
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
elementMedicationRequest :: XMLParser MedicationRequest
elementMedicationRequest = parseSchemaType "MedicationRequest"
elementToXMLMedicationRequest :: MedicationRequest -> [Content ()]
elementToXMLMedicationRequest = schemaTypeToXML "MedicationRequest"
 
data MedicationRequest = MedicationRequest
        { medicationRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequest_identifier :: [Identifier]
          -- ^ This records identifiers associated with this medication 
          --   request that are defined by business processes and/or used 
          --   to refer to it when a direct URL reference to the resource 
          --   itself is not appropriate. For example a re-imbursement 
          --   system might issue its own id for each prescription that is 
          --   created. This is particularly important where FHIR only 
          --   provides part of an entire workflow process where records 
          --   must be tracked through an entire system.
        , medicationRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request.
        , medicationRequest_basedOn :: [Reference]
          -- ^ A plan or request that is fulfilled in whole or in part by 
          --   this medication request.
        , medicationRequest_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition or 
          --   prescription.
        , medicationRequest_status :: Maybe MedicationRequestStatus
          -- ^ A code specifying the current state of the order. Generally 
          --   this will be active or completed state.
        , medicationRequest_intent :: MedicationRequestIntent
          -- ^ Whether the request is a proposal, plan, or an original 
          --   order.
        , medicationRequest_category :: Maybe CodeableConcept
          -- ^ Indicates the type of medication order and where the 
          --   medication is expected to be consumed or administered.
        , medicationRequest_priority :: Maybe MedicationRequestPriority
          -- ^ Indicates how quickly the Medication Request should be 
          --   addressed with respect to other requests.
        , medicationRequest_choice16 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being requested. This is a link 
          --   to a resource that represents the medication which may be 
          --   the details of the medication or simply an attribute 
          --   carrying a code that identifies the medication from a known 
          --   list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationRequest_subject :: Reference
          -- ^ A link to a resource representing the person or set of 
          --   individuals to whom the medication will be given.
        , medicationRequest_context :: Maybe Reference
          -- ^ A link to an encounter, or episode of care, that identifies 
          --   the particular occurrence or set occurrences of contact 
          --   between patient and health care provider.
        , medicationRequest_supportingInformation :: [Reference]
          -- ^ Include additional information (for example, patient height 
          --   and weight) that supports the ordering of the medication.
        , medicationRequest_authoredOn :: Maybe DateTime
          -- ^ The date (and perhaps time) when the prescription was 
          --   initially written or authored on.
        , medicationRequest_requester :: Maybe MedicationRequestRequester
          -- ^ The individual, organization or device that initiated the 
          --   request and has responsibility for its activation.
        , medicationRequest_recorder :: Maybe Reference
          -- ^ The person who entered the order on behalf of another 
          --   individual for example in the case of a verbal or a 
          --   telephone order.
        , medicationRequest_reasonCode :: [CodeableConcept]
          -- ^ The reason or the indication for ordering the medication.
        , medicationRequest_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   was ordered.
        , medicationRequest_note :: [Annotation]
          -- ^ Extra information about the prescription that could not be 
          --   conveyed by the other attributes.
        , medicationRequest_dosageInstruction :: [Dosage]
          -- ^ Indicates how the medication is to be used by the patient.
        , medicationRequest_dispenseRequest :: Maybe MedicationRequestDispenseRequest
          -- ^ Indicates the specific details for the dispense or 
          --   medication supply part of a medication request (also known 
          --   as a Medication Prescription or Medication Order). Note 
          --   that this information is not always sent with the order. 
          --   There may be in some settings (e.g. hospitals) 
          --   institutional or system support for completing the dispense 
          --   details in the pharmacy department.
        , medicationRequest_substitution :: Maybe MedicationRequestSubstitution
          -- ^ Indicates whether or not substitution can or should be part 
          --   of the dispense. In some cases substitution must happen, in 
          --   other cases substitution must not happen. This block 
          --   explains the prescriber's intent. If nothing is specified 
          --   substitution may be done.
        , medicationRequest_priorPrescription :: Maybe Reference
          -- ^ A link to a resource representing an earlier order related 
          --   order or prescription.
        , medicationRequest_detectedIssue :: [Reference]
          -- ^ Indicates an actual or potential clinical issue with or 
          --   between one or more active or proposed clinical actions for 
          --   a patient; e.g. Drug-drug interaction, duplicate therapy, 
          --   dosage alert etc.
        , medicationRequest_eventHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this 
          --   resource or fulfilling request or event resources that 
          --   identify key state transitions or updates that are likely 
          --   to be relevant to a user looking at the current version of 
          --   the resource.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` many (parseSchemaType "supportingInformation")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "recorder")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosageInstruction")
            `apply` optional (parseSchemaType "dispenseRequest")
            `apply` optional (parseSchemaType "substitution")
            `apply` optional (parseSchemaType "priorPrescription")
            `apply` many (parseSchemaType "detectedIssue")
            `apply` many (parseSchemaType "eventHistory")
    schemaTypeToXML s x@MedicationRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationRequest_language x
            , maybe [] (schemaTypeToXML "text") $ medicationRequest_text x
            , concatMap (schemaTypeToXML "contained") $ medicationRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ medicationRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ medicationRequest_basedOn x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ medicationRequest_groupIdentifier x
            , maybe [] (schemaTypeToXML "status") $ medicationRequest_status x
            , schemaTypeToXML "intent" $ medicationRequest_intent x
            , maybe [] (schemaTypeToXML "category") $ medicationRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ medicationRequest_priority x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationRequest_choice16 x
            , schemaTypeToXML "subject" $ medicationRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ medicationRequest_context x
            , concatMap (schemaTypeToXML "supportingInformation") $ medicationRequest_supportingInformation x
            , maybe [] (schemaTypeToXML "authoredOn") $ medicationRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ medicationRequest_requester x
            , maybe [] (schemaTypeToXML "recorder") $ medicationRequest_recorder x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationRequest_reasonReference x
            , concatMap (schemaTypeToXML "note") $ medicationRequest_note x
            , concatMap (schemaTypeToXML "dosageInstruction") $ medicationRequest_dosageInstruction x
            , maybe [] (schemaTypeToXML "dispenseRequest") $ medicationRequest_dispenseRequest x
            , maybe [] (schemaTypeToXML "substitution") $ medicationRequest_substitution x
            , maybe [] (schemaTypeToXML "priorPrescription") $ medicationRequest_priorPrescription x
            , concatMap (schemaTypeToXML "detectedIssue") $ medicationRequest_detectedIssue x
            , concatMap (schemaTypeToXML "eventHistory") $ medicationRequest_eventHistory x
            ]
instance Extension MedicationRequest DomainResource where
    supertype (MedicationRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationRequest -> DomainResource)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequestRequester = MedicationRequestRequester
        { medicationRequestRequester_id :: Maybe String_primitive
        , medicationRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequestRequester_agent :: Reference
          -- ^ The healthcare professional responsible for authorizing the 
          --   initial prescription.
        , medicationRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@MedicationRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ medicationRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ medicationRequestRequester_onBehalfOf x
            ]
instance Extension MedicationRequestRequester BackboneElement where
    supertype (MedicationRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequestRequester -> BackboneElement)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequestDispenseRequest = MedicationRequestDispenseRequest
        { medicationRequestDispenseRequest_id :: Maybe String_primitive
        , medicationRequestDispenseRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequestDispenseRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequestDispenseRequest_validityPeriod :: Maybe Period
          -- ^ This indicates the validity period of a prescription (stale 
          --   dating the Prescription).
        , medicationRequestDispenseRequest_numberOfRepeatsAllowed :: Maybe PositiveInt
          -- ^ An integer indicating the number of times, in addition to 
          --   the original dispense, (aka refills or repeats) that the 
          --   patient can receive the prescribed medication. Usage Notes: 
          --   This integer does not include the original order dispense. 
          --   This means that if an order indicates dispense 30 tablets 
          --   plus &quot;3 repeats&quot;, then the order can be dispensed 
          --   a total of 4 times and the patient can receive a total of 
          --   120 tablets.
        , medicationRequestDispenseRequest_quantity :: Maybe Quantity
          -- ^ The amount that is to be dispensed for one fill.
        , medicationRequestDispenseRequest_expectedSupplyDuration :: Maybe Duration
          -- ^ Identifies the period time over which the supplied product 
          --   is expected to be used, or the length of time the dispense 
          --   is expected to last.
        , medicationRequestDispenseRequest_performer :: Maybe Reference
          -- ^ Indicates the intended dispensing Organization specified by 
          --   the prescriber.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestDispenseRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequestDispenseRequest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "validityPeriod")
            `apply` optional (parseSchemaType "numberOfRepeatsAllowed")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "expectedSupplyDuration")
            `apply` optional (parseSchemaType "performer")
    schemaTypeToXML s x@MedicationRequestDispenseRequest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestDispenseRequest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestDispenseRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequestDispenseRequest_modifierExtension x
            , maybe [] (schemaTypeToXML "validityPeriod") $ medicationRequestDispenseRequest_validityPeriod x
            , maybe [] (schemaTypeToXML "numberOfRepeatsAllowed") $ medicationRequestDispenseRequest_numberOfRepeatsAllowed x
            , maybe [] (schemaTypeToXML "quantity") $ medicationRequestDispenseRequest_quantity x
            , maybe [] (schemaTypeToXML "expectedSupplyDuration") $ medicationRequestDispenseRequest_expectedSupplyDuration x
            , maybe [] (schemaTypeToXML "performer") $ medicationRequestDispenseRequest_performer x
            ]
instance Extension MedicationRequestDispenseRequest BackboneElement where
    supertype (MedicationRequestDispenseRequest a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequestDispenseRequest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequestDispenseRequest -> BackboneElement)
              
 
-- | An order or request for both supply of the medication and 
--   the instructions for administration of the medication to a 
--   patient. The resource is called 
--   &quot;MedicationRequest&quot; rather than 
--   &quot;MedicationPrescription&quot; or 
--   &quot;MedicationOrder&quot; to generalize the use across 
--   inpatient and outpatient settings, including care plans, 
--   etc., and to harmonize with workflow patterns.
data MedicationRequestSubstitution = MedicationRequestSubstitution
        { medicationRequestSubstitution_id :: Maybe String_primitive
        , medicationRequestSubstitution_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationRequestSubstitution_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationRequestSubstitution_allowed :: Boolean
          -- ^ True if the prescriber allows a different drug to be 
          --   dispensed from what was prescribed.
        , medicationRequestSubstitution_reason :: Maybe CodeableConcept
          -- ^ Indicates the reason for the substitution, or why 
          --   substitution must or must not be performed.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestSubstitution where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MedicationRequestSubstitution a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "allowed"
            `apply` optional (parseSchemaType "reason")
    schemaTypeToXML s x@MedicationRequestSubstitution{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestSubstitution_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestSubstitution_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationRequestSubstitution_modifierExtension x
            , schemaTypeToXML "allowed" $ medicationRequestSubstitution_allowed x
            , maybe [] (schemaTypeToXML "reason") $ medicationRequestSubstitution_reason x
            ]
instance Extension MedicationRequestSubstitution BackboneElement where
    supertype (MedicationRequestSubstitution a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MedicationRequestSubstitution Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MedicationRequestSubstitution -> BackboneElement)
              
 
data MedicationRequestStatus_list
    = MedicationRequestStatus_list_Active
      -- ^ Active
    | MedicationRequestStatus_list_On_hold
      -- ^ On Hold
    | MedicationRequestStatus_list_Cancelled
      -- ^ Cancelled
    | MedicationRequestStatus_list_Completed
      -- ^ Completed
    | MedicationRequestStatus_list_Entered_in_error
      -- ^ Entered In Error
    | MedicationRequestStatus_list_Stopped
      -- ^ Stopped
    | MedicationRequestStatus_list_Draft
      -- ^ Draft
    | MedicationRequestStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestStatus_list where
    acceptingParser =  do literal "active"; return MedicationRequestStatus_list_Active
                      `onFail` do literal "on-hold"; return MedicationRequestStatus_list_On_hold
                      `onFail` do literal "cancelled"; return MedicationRequestStatus_list_Cancelled
                      `onFail` do literal "completed"; return MedicationRequestStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationRequestStatus_list_Entered_in_error
                      `onFail` do literal "stopped"; return MedicationRequestStatus_list_Stopped
                      `onFail` do literal "draft"; return MedicationRequestStatus_list_Draft
                      `onFail` do literal "unknown"; return MedicationRequestStatus_list_Unknown
                      
    simpleTypeText MedicationRequestStatus_list_Active = "active"
    simpleTypeText MedicationRequestStatus_list_On_hold = "on-hold"
    simpleTypeText MedicationRequestStatus_list_Cancelled = "cancelled"
    simpleTypeText MedicationRequestStatus_list_Completed = "completed"
    simpleTypeText MedicationRequestStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText MedicationRequestStatus_list_Stopped = "stopped"
    simpleTypeText MedicationRequestStatus_list_Draft = "draft"
    simpleTypeText MedicationRequestStatus_list_Unknown = "unknown"
 
data MedicationRequestStatus = MedicationRequestStatus
        { medicationRequestStatus_id :: Maybe String_primitive
        , medicationRequestStatus_value :: Maybe MedicationRequestStatus_list
        , medicationRequestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestStatus_extension x
            ]
instance Extension MedicationRequestStatus Element where
    supertype (MedicationRequestStatus a0 a1 e0) =
               Element a0 e0
 
data MedicationRequestPriority_list
    = MedicationRequestPriority_list_Routine
      -- ^ Routine
    | MedicationRequestPriority_list_Urgent
      -- ^ Urgent
    | MedicationRequestPriority_list_Stat
      -- ^ Stat
    | MedicationRequestPriority_list_Asap
      -- ^ ASAP
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestPriority_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestPriority_list where
    acceptingParser =  do literal "routine"; return MedicationRequestPriority_list_Routine
                      `onFail` do literal "urgent"; return MedicationRequestPriority_list_Urgent
                      `onFail` do literal "stat"; return MedicationRequestPriority_list_Stat
                      `onFail` do literal "asap"; return MedicationRequestPriority_list_Asap
                      
    simpleTypeText MedicationRequestPriority_list_Routine = "routine"
    simpleTypeText MedicationRequestPriority_list_Urgent = "urgent"
    simpleTypeText MedicationRequestPriority_list_Stat = "stat"
    simpleTypeText MedicationRequestPriority_list_Asap = "asap"
 
data MedicationRequestPriority = MedicationRequestPriority
        { medicationRequestPriority_id :: Maybe String_primitive
        , medicationRequestPriority_value :: Maybe MedicationRequestPriority_list
        , medicationRequestPriority_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestPriority where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestPriority a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestPriority{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestPriority_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestPriority_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestPriority_extension x
            ]
instance Extension MedicationRequestPriority Element where
    supertype (MedicationRequestPriority a0 a1 e0) =
               Element a0 e0
 
data MedicationRequestIntent_list
    = MedicationRequestIntent_list_Proposal
      -- ^ Proposal
    | MedicationRequestIntent_list_Plan
      -- ^ Plan
    | MedicationRequestIntent_list_Order
      -- ^ Order
    | MedicationRequestIntent_list_Instance_order
      -- ^ Instance Order
    deriving (Eq,Show,Enum)
instance SchemaType MedicationRequestIntent_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationRequestIntent_list where
    acceptingParser =  do literal "proposal"; return MedicationRequestIntent_list_Proposal
                      `onFail` do literal "plan"; return MedicationRequestIntent_list_Plan
                      `onFail` do literal "order"; return MedicationRequestIntent_list_Order
                      `onFail` do literal "instance-order"; return MedicationRequestIntent_list_Instance_order
                      
    simpleTypeText MedicationRequestIntent_list_Proposal = "proposal"
    simpleTypeText MedicationRequestIntent_list_Plan = "plan"
    simpleTypeText MedicationRequestIntent_list_Order = "order"
    simpleTypeText MedicationRequestIntent_list_Instance_order = "instance-order"
 
data MedicationRequestIntent = MedicationRequestIntent
        { medicationRequestIntent_id :: Maybe String_primitive
        , medicationRequestIntent_value :: Maybe MedicationRequestIntent_list
        , medicationRequestIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationRequestIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationRequestIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationRequestIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationRequestIntent_id x
                       , maybe [] (toXMLAttribute "value") $ medicationRequestIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationRequestIntent_extension x
            ]
instance Extension MedicationRequestIntent Element where
    supertype (MedicationRequestIntent a0 a1 e0) =
               Element a0 e0
 
-- | A record of a medication that is being consumed by a 
--   patient. A MedicationStatement may indicate that the 
--   patient may be taking the medication now, or has taken the 
--   medication in the past or will be taking the medication in 
--   the future. The source of this information can be the 
--   patient, significant other (such as a family member or 
--   spouse), or a clinician. A common scenario where this 
--   information is captured is during the history taking 
--   process during a patient visit or stay. The medication 
--   information may come from sources such as the patient's 
--   memory, from a prescription bottle, or from a list of 
--   medications the patient, clinician or other party maintains 
--   The primary difference between a medication statement and a 
--   medication administration is that the medication 
--   administration has complete administration information and 
--   is based on actual administration information from the 
--   person who administered the medication. A medication 
--   statement is often, if not always, less specific. There is 
--   no required date/time when the medication was administered, 
--   in fact we only know that a source has reported the patient 
--   is taking this medication, where details such as time, 
--   quantity, or rate or even medication product may be 
--   incomplete or missing or less precise. As stated earlier, 
--   the medication statement information may come from the 
--   patient's memory, from a prescription bottle or from a list 
--   of medications the patient, clinician or other party 
--   maintains. Medication administration is more formal and is 
--   not missing detailed information.
elementMedicationStatement :: XMLParser MedicationStatement
elementMedicationStatement = parseSchemaType "MedicationStatement"
elementToXMLMedicationStatement :: MedicationStatement -> [Content ()]
elementToXMLMedicationStatement = schemaTypeToXML "MedicationStatement"
 
data MedicationStatement = MedicationStatement
        { medicationStatement_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , medicationStatement_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , medicationStatement_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , medicationStatement_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , medicationStatement_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , medicationStatement_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , medicationStatement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , medicationStatement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , medicationStatement_identifier :: [Identifier]
          -- ^ External identifier - FHIR will generate its own internal 
          --   identifiers (probably URLs) which do not need to be 
          --   explicitly managed by the resource. The identifier here is 
          --   one that would be used by another non-FHIR system - for 
          --   example an automated medication pump would provide a record 
          --   each time it operated; an administration while the patient 
          --   was off the ward might be made with a different system and 
          --   entered after the event. Particularly important if these 
          --   records have to be updated.
        , medicationStatement_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , medicationStatement_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , medicationStatement_context :: Maybe Reference
          -- ^ The encounter or episode of care that establishes the 
          --   context for this MedicationStatement.
        , medicationStatement_status :: MedicationStatementStatus
          -- ^ A code representing the patient or other source's judgment 
          --   about the state of the medication used that this statement 
          --   is about. Generally this will be active or completed.
        , medicationStatement_category :: Maybe CodeableConcept
          -- ^ Indicates where type of medication statement and where the 
          --   medication is expected to be consumed or administered.
        , medicationStatement_choice14 :: OneOf2 CodeableConcept Reference
          -- ^ Identifies the medication being administered. This is 
          --   either a link to a resource representing the details of the 
          --   medication or a simple attribute carrying a code that 
          --   identifies the medication from a known list of medications.
          --   
          --   Choice between:
          --   
          --   (1) medicationCodeableConcept
          --   
          --   (2) medicationReference
        , medicationStatement_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The interval of time during which it is being asserted that 
          --   the patient was taking the medication (or was not taking, 
          --   when the wasNotGiven element is true).
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , medicationStatement_dateAsserted :: Maybe DateTime
          -- ^ The date when the medication statement was asserted by the 
          --   information source.
        , medicationStatement_informationSource :: Maybe Reference
          -- ^ The person or organization that provided the information 
          --   about the taking of this medication. Note: Use derivedFrom 
          --   when a MedicationStatement is derived from other resources, 
          --   e.g Claim or MedicationRequest.
        , medicationStatement_subject :: Reference
          -- ^ The person, animal or group who is/was taking the 
          --   medication.
        , medicationStatement_derivedFrom :: [Reference]
          -- ^ Allows linking the MedicationStatement to the underlying 
          --   MedicationRequest, or to other information that supports or 
          --   is used to derive the MedicationStatement.
        , medicationStatement_taken :: MedicationStatementTaken
          -- ^ Indicator of the certainty of whether the medication was 
          --   taken by the patient.
        , medicationStatement_reasonNotTaken :: [CodeableConcept]
          -- ^ A code indicating why the medication was not taken.
        , medicationStatement_reasonCode :: [CodeableConcept]
          -- ^ A reason for why the medication is being/was taken.
        , medicationStatement_reasonReference :: [Reference]
          -- ^ Condition or observation that supports why the medication 
          --   is being/was taken.
        , medicationStatement_note :: [Annotation]
          -- ^ Provides extra information about the medication statement 
          --   that is not conveyed by the other attributes.
        , medicationStatement_dosage :: [Dosage]
          -- ^ Indicates how the medication is/was or should be taken by 
          --   the patient.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MedicationStatement
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "context")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "category")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "medicationCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "medicationReference"))
                           ]
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dateAsserted")
            `apply` optional (parseSchemaType "informationSource")
            `apply` parseSchemaType "subject"
            `apply` many (parseSchemaType "derivedFrom")
            `apply` parseSchemaType "taken"
            `apply` many (parseSchemaType "reasonNotTaken")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "dosage")
    schemaTypeToXML s x@MedicationStatement{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ medicationStatement_id x
            , maybe [] (schemaTypeToXML "meta") $ medicationStatement_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ medicationStatement_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ medicationStatement_language x
            , maybe [] (schemaTypeToXML "text") $ medicationStatement_text x
            , concatMap (schemaTypeToXML "contained") $ medicationStatement_contained x
            , concatMap (schemaTypeToXML "extension") $ medicationStatement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ medicationStatement_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ medicationStatement_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ medicationStatement_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ medicationStatement_partOf x
            , maybe [] (schemaTypeToXML "context") $ medicationStatement_context x
            , schemaTypeToXML "status" $ medicationStatement_status x
            , maybe [] (schemaTypeToXML "category") $ medicationStatement_category x
            , foldOneOf2  (schemaTypeToXML "medicationCodeableConcept")
                          (schemaTypeToXML "medicationReference")
                          $ medicationStatement_choice14 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ medicationStatement_choice15 x
            , maybe [] (schemaTypeToXML "dateAsserted") $ medicationStatement_dateAsserted x
            , maybe [] (schemaTypeToXML "informationSource") $ medicationStatement_informationSource x
            , schemaTypeToXML "subject" $ medicationStatement_subject x
            , concatMap (schemaTypeToXML "derivedFrom") $ medicationStatement_derivedFrom x
            , schemaTypeToXML "taken" $ medicationStatement_taken x
            , concatMap (schemaTypeToXML "reasonNotTaken") $ medicationStatement_reasonNotTaken x
            , concatMap (schemaTypeToXML "reasonCode") $ medicationStatement_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ medicationStatement_reasonReference x
            , concatMap (schemaTypeToXML "note") $ medicationStatement_note x
            , concatMap (schemaTypeToXML "dosage") $ medicationStatement_dosage x
            ]
instance Extension MedicationStatement DomainResource where
    supertype (MedicationStatement e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MedicationStatement Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MedicationStatement -> DomainResource)
              
 
data MedicationStatementStatus_list
    = MedicationStatementStatus_list_Active
      -- ^ Active
    | MedicationStatementStatus_list_Completed
      -- ^ Completed
    | MedicationStatementStatus_list_Entered_in_error
      -- ^ Entered in Error
    | MedicationStatementStatus_list_Intended
      -- ^ Intended
    | MedicationStatementStatus_list_Stopped
      -- ^ Stopped
    | MedicationStatementStatus_list_On_hold
      -- ^ On Hold
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatementStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatementStatus_list where
    acceptingParser =  do literal "active"; return MedicationStatementStatus_list_Active
                      `onFail` do literal "completed"; return MedicationStatementStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return MedicationStatementStatus_list_Entered_in_error
                      `onFail` do literal "intended"; return MedicationStatementStatus_list_Intended
                      `onFail` do literal "stopped"; return MedicationStatementStatus_list_Stopped
                      `onFail` do literal "on-hold"; return MedicationStatementStatus_list_On_hold
                      
    simpleTypeText MedicationStatementStatus_list_Active = "active"
    simpleTypeText MedicationStatementStatus_list_Completed = "completed"
    simpleTypeText MedicationStatementStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText MedicationStatementStatus_list_Intended = "intended"
    simpleTypeText MedicationStatementStatus_list_Stopped = "stopped"
    simpleTypeText MedicationStatementStatus_list_On_hold = "on-hold"
 
data MedicationStatementStatus = MedicationStatementStatus
        { medicationStatementStatus_id :: Maybe String_primitive
        , medicationStatementStatus_value :: Maybe MedicationStatementStatus_list
        , medicationStatementStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatementStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatementStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatementStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatementStatus_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatementStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatementStatus_extension x
            ]
instance Extension MedicationStatementStatus Element where
    supertype (MedicationStatementStatus a0 a1 e0) =
               Element a0 e0
 
data MedicationStatementTaken_list
    = MedicationStatementTaken_list_Y
      -- ^ Yes
    | MedicationStatementTaken_list_N
      -- ^ No
    | MedicationStatementTaken_list_Unk
      -- ^ Unknown
    | MedicationStatementTaken_list_Na
      -- ^ Not Applicable
    deriving (Eq,Show,Enum)
instance SchemaType MedicationStatementTaken_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType MedicationStatementTaken_list where
    acceptingParser =  do literal "y"; return MedicationStatementTaken_list_Y
                      `onFail` do literal "n"; return MedicationStatementTaken_list_N
                      `onFail` do literal "unk"; return MedicationStatementTaken_list_Unk
                      `onFail` do literal "na"; return MedicationStatementTaken_list_Na
                      
    simpleTypeText MedicationStatementTaken_list_Y = "y"
    simpleTypeText MedicationStatementTaken_list_N = "n"
    simpleTypeText MedicationStatementTaken_list_Unk = "unk"
    simpleTypeText MedicationStatementTaken_list_Na = "na"
 
data MedicationStatementTaken = MedicationStatementTaken
        { medicationStatementTaken_id :: Maybe String_primitive
        , medicationStatementTaken_value :: Maybe MedicationStatementTaken_list
        , medicationStatementTaken_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType MedicationStatementTaken where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (MedicationStatementTaken a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@MedicationStatementTaken{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ medicationStatementTaken_id x
                       , maybe [] (toXMLAttribute "value") $ medicationStatementTaken_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ medicationStatementTaken_extension x
            ]
instance Extension MedicationStatementTaken Element where
    supertype (MedicationStatementTaken a0 a1 e0) =
               Element a0 e0
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
elementMessageDefinition :: XMLParser MessageDefinition
elementMessageDefinition = parseSchemaType "MessageDefinition"
elementToXMLMessageDefinition :: MessageDefinition -> [Content ()]
elementToXMLMessageDefinition = schemaTypeToXML "MessageDefinition"
 
data MessageDefinition = MessageDefinition
        { messageDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , messageDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , messageDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , messageDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , messageDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , messageDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , messageDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this message 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   message definition is (or will be) published. The URL 
          --   SHOULD include the major version of the message definition. 
          --   For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , messageDefinition_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this message 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , messageDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   message definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the message definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , messageDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the message definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , messageDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the message 
          --   definition.
        , messageDefinition_status :: PublicationStatus
          -- ^ The status of this message definition. Enables tracking the 
          --   life-cycle of the content.
        , messageDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this message definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , messageDefinition_date :: DateTime
          -- ^ The date (and optionally time) when the message definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the message definition changes.
        , messageDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the message definition.
        , messageDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , messageDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the message 
          --   definition from a consumer's perspective.
        , messageDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   message definition instances.
        , messageDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the message 
          --   definition is intended to be used.
        , messageDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this message definition is needed and 
          --   why it has been designed as it has.
        , messageDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the message definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the message 
          --   definition.
        , messageDefinition_base :: Maybe Reference
          -- ^ The MessageDefinition that is the basis for the contents of 
          --   this resource.
        , messageDefinition_parent :: [Reference]
          -- ^ Identifies a protocol or workflow that this 
          --   MessageDefinition represents a step in.
        , messageDefinition_replaces :: [Reference]
          -- ^ A MessageDefinition that is superseded by this definition.
        , messageDefinition_event :: Coding
          -- ^ A coded identifier of a supported messaging event.
        , messageDefinition_category :: Maybe MessageSignificanceCategory
          -- ^ The impact of the content of the message.
        , messageDefinition_focus :: [MessageDefinitionFocus]
          -- ^ Identifies the resource (or resources) that are being 
          --   addressed by the event. For example, the Encounter for an 
          --   admit message or two Account records for a merge.
        , messageDefinition_responseRequired :: Maybe Boolean
          -- ^ Indicates whether a response is required for this message.
        , messageDefinition_allowedResponse :: [MessageDefinitionAllowedResponse]
          -- ^ Indicates what types of messages may be sent as an 
          --   application-level response to this message.
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MessageDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "base")
            `apply` many (parseSchemaType "parent")
            `apply` many (parseSchemaType "replaces")
            `apply` parseSchemaType "event"
            `apply` optional (parseSchemaType "category")
            `apply` many (parseSchemaType "focus")
            `apply` optional (parseSchemaType "responseRequired")
            `apply` many (parseSchemaType "allowedResponse")
    schemaTypeToXML s x@MessageDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ messageDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ messageDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ messageDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ messageDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ messageDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ messageDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ messageDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ messageDefinition_url x
            , maybe [] (schemaTypeToXML "identifier") $ messageDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ messageDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ messageDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ messageDefinition_title x
            , schemaTypeToXML "status" $ messageDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ messageDefinition_experimental x
            , schemaTypeToXML "date" $ messageDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ messageDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ messageDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ messageDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ messageDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ messageDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ messageDefinition_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ messageDefinition_copyright x
            , maybe [] (schemaTypeToXML "base") $ messageDefinition_base x
            , concatMap (schemaTypeToXML "parent") $ messageDefinition_parent x
            , concatMap (schemaTypeToXML "replaces") $ messageDefinition_replaces x
            , schemaTypeToXML "event" $ messageDefinition_event x
            , maybe [] (schemaTypeToXML "category") $ messageDefinition_category x
            , concatMap (schemaTypeToXML "focus") $ messageDefinition_focus x
            , maybe [] (schemaTypeToXML "responseRequired") $ messageDefinition_responseRequired x
            , concatMap (schemaTypeToXML "allowedResponse") $ messageDefinition_allowedResponse x
            ]
instance Extension MessageDefinition DomainResource where
    supertype (MessageDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MessageDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MessageDefinition -> DomainResource)
              
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
data MessageDefinitionFocus = MessageDefinitionFocus
        { messageDefinitionFocus_id :: Maybe String_primitive
        , messageDefinitionFocus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinitionFocus_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinitionFocus_code :: ResourceType
          -- ^ The kind of resource that must be the focus for this 
          --   message.
        , messageDefinitionFocus_profile :: Maybe Reference
          -- ^ A profile that reflects constraints for the focal resource 
          --   (and potentially for related resources).
        , messageDefinitionFocus_min :: Maybe UnsignedInt
          -- ^ Identifies the minimum number of resources of this type 
          --   that must be pointed to by a message in order for it to be 
          --   valid against this MessageDefinition.
        , messageDefinitionFocus_max :: Maybe Xsd.XsdString
          -- ^ Identifies the maximum number of resources of this type 
          --   that must be pointed to by a message in order for it to be 
          --   valid against this MessageDefinition.
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinitionFocus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageDefinitionFocus a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
    schemaTypeToXML s x@MessageDefinitionFocus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageDefinitionFocus_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageDefinitionFocus_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinitionFocus_modifierExtension x
            , schemaTypeToXML "code" $ messageDefinitionFocus_code x
            , maybe [] (schemaTypeToXML "profile") $ messageDefinitionFocus_profile x
            , maybe [] (schemaTypeToXML "min") $ messageDefinitionFocus_min x
            , maybe [] (schemaTypeToXML "max") $ messageDefinitionFocus_max x
            ]
instance Extension MessageDefinitionFocus BackboneElement where
    supertype (MessageDefinitionFocus a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension MessageDefinitionFocus Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageDefinitionFocus -> BackboneElement)
              
 
-- | Defines the characteristics of a message that can be shared 
--   between systems, including the type of event that initiates 
--   the message, the content to be transmitted and what 
--   response(s), if any, are permitted.
data MessageDefinitionAllowedResponse = MessageDefinitionAllowedResponse
        { messageDefinitionAllowedResponse_id :: Maybe String_primitive
        , messageDefinitionAllowedResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageDefinitionAllowedResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageDefinitionAllowedResponse_message :: Reference
          -- ^ A reference to the message definition that must be adhered 
          --   to by this supported response.
        , messageDefinitionAllowedResponse_situation :: Maybe Markdown
          -- ^ Provides a description of the circumstances in which this 
          --   response should be used (as opposed to one of the 
          --   alternative responses).
        }
        deriving (Eq,Show)
instance SchemaType MessageDefinitionAllowedResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageDefinitionAllowedResponse a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "message"
            `apply` optional (parseSchemaType "situation")
    schemaTypeToXML s x@MessageDefinitionAllowedResponse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageDefinitionAllowedResponse_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageDefinitionAllowedResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageDefinitionAllowedResponse_modifierExtension x
            , schemaTypeToXML "message" $ messageDefinitionAllowedResponse_message x
            , maybe [] (schemaTypeToXML "situation") $ messageDefinitionAllowedResponse_situation x
            ]
instance Extension MessageDefinitionAllowedResponse BackboneElement where
    supertype (MessageDefinitionAllowedResponse a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension MessageDefinitionAllowedResponse Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageDefinitionAllowedResponse -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
elementMessageHeader :: XMLParser MessageHeader
elementMessageHeader = parseSchemaType "MessageHeader"
elementToXMLMessageHeader :: MessageHeader -> [Content ()]
elementToXMLMessageHeader = schemaTypeToXML "MessageHeader"
 
data MessageHeader = MessageHeader
        { messageHeader_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , messageHeader_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , messageHeader_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , messageHeader_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , messageHeader_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , messageHeader_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , messageHeader_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeader_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeader_event :: Coding
          -- ^ Code that identifies the event this message represents and 
          --   connects it with its definition. Events defined as part of 
          --   the FHIR specification have the system value 
          --   &quot;http://hl7.org/fhir/message-events&quot;.
        , messageHeader_destination :: [MessageHeaderDestination]
          -- ^ The destination application which the message is intended 
          --   for.
        , messageHeader_receiver :: Maybe Reference
          -- ^ Allows data conveyed by a message to be addressed to a 
          --   particular person or department when routing to a specific 
          --   application isn't sufficient.
        , messageHeader_sender :: Maybe Reference
          -- ^ Identifies the sending system to allow the use of a trust 
          --   relationship.
        , messageHeader_timestamp :: Instant
          -- ^ The time that the message was sent.
        , messageHeader_enterer :: Maybe Reference
          -- ^ The person or device that performed the data entry leading 
          --   to this message. When there is more than one candidate, 
          --   pick the most proximal to the message. Can provide other 
          --   enterers in extensions.
        , messageHeader_author :: Maybe Reference
          -- ^ The logical author of the message - the person or device 
          --   that decided the described event should happen. When there 
          --   is more than one candidate, pick the most proximal to the 
          --   MessageHeader. Can provide other authors in extensions.
        , messageHeader_source :: MessageHeaderSource
          -- ^ The source application from which this message originated.
        , messageHeader_responsible :: Maybe Reference
          -- ^ The person or organization that accepts overall 
          --   responsibility for the contents of the message. The 
          --   implication is that the message event happened under the 
          --   policies of the responsible party.
        , messageHeader_reason :: Maybe CodeableConcept
          -- ^ Coded indication of the cause for the event - indicates a 
          --   reason for the occurrence of the event that is a focus of 
          --   this message.
        , messageHeader_response :: Maybe MessageHeaderResponse
          -- ^ Information about the message that this message is a 
          --   response to. Only present if this message is a response.
        , messageHeader_focus :: [Reference]
          -- ^ The actual data of the message - a reference to the 
          --   root/focus class of the event.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeader where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return MessageHeader
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "event"
            `apply` many (parseSchemaType "destination")
            `apply` optional (parseSchemaType "receiver")
            `apply` optional (parseSchemaType "sender")
            `apply` parseSchemaType "timestamp"
            `apply` optional (parseSchemaType "enterer")
            `apply` optional (parseSchemaType "author")
            `apply` parseSchemaType "source"
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "reason")
            `apply` optional (parseSchemaType "response")
            `apply` many (parseSchemaType "focus")
    schemaTypeToXML s x@MessageHeader{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ messageHeader_id x
            , maybe [] (schemaTypeToXML "meta") $ messageHeader_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ messageHeader_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ messageHeader_language x
            , maybe [] (schemaTypeToXML "text") $ messageHeader_text x
            , concatMap (schemaTypeToXML "contained") $ messageHeader_contained x
            , concatMap (schemaTypeToXML "extension") $ messageHeader_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeader_modifierExtension x
            , schemaTypeToXML "event" $ messageHeader_event x
            , concatMap (schemaTypeToXML "destination") $ messageHeader_destination x
            , maybe [] (schemaTypeToXML "receiver") $ messageHeader_receiver x
            , maybe [] (schemaTypeToXML "sender") $ messageHeader_sender x
            , schemaTypeToXML "timestamp" $ messageHeader_timestamp x
            , maybe [] (schemaTypeToXML "enterer") $ messageHeader_enterer x
            , maybe [] (schemaTypeToXML "author") $ messageHeader_author x
            , schemaTypeToXML "source" $ messageHeader_source x
            , maybe [] (schemaTypeToXML "responsible") $ messageHeader_responsible x
            , maybe [] (schemaTypeToXML "reason") $ messageHeader_reason x
            , maybe [] (schemaTypeToXML "response") $ messageHeader_response x
            , concatMap (schemaTypeToXML "focus") $ messageHeader_focus x
            ]
instance Extension MessageHeader DomainResource where
    supertype (MessageHeader e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension MessageHeader Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: MessageHeader -> DomainResource)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeaderDestination = MessageHeaderDestination
        { messageHeaderDestination_id :: Maybe String_primitive
        , messageHeaderDestination_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeaderDestination_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeaderDestination_name :: Maybe Xsd.XsdString
          -- ^ Human-readable name for the target system.
        , messageHeaderDestination_target :: Maybe Reference
          -- ^ Identifies the target end system in situations where the 
          --   initial message transmission is to an intermediary system.
        , messageHeaderDestination_endpoint :: Uri
          -- ^ Indicates where the message should be routed to.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeaderDestination where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeaderDestination a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "target")
            `apply` parseSchemaType "endpoint"
    schemaTypeToXML s x@MessageHeaderDestination{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeaderDestination_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeaderDestination_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeaderDestination_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ messageHeaderDestination_name x
            , maybe [] (schemaTypeToXML "target") $ messageHeaderDestination_target x
            , schemaTypeToXML "endpoint" $ messageHeaderDestination_endpoint x
            ]
instance Extension MessageHeaderDestination BackboneElement where
    supertype (MessageHeaderDestination a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MessageHeaderDestination Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeaderDestination -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeaderSource = MessageHeaderSource
        { messageHeaderSource_id :: Maybe String_primitive
        , messageHeaderSource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeaderSource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeaderSource_name :: Maybe Xsd.XsdString
          -- ^ Human-readable name for the source system.
        , messageHeaderSource_software :: Maybe Xsd.XsdString
          -- ^ May include configuration or other information useful in 
          --   debugging.
        , messageHeaderSource_version :: Maybe Xsd.XsdString
          -- ^ Can convey versions of multiple systems in situations where 
          --   a message passes through multiple hands.
        , messageHeaderSource_contact :: Maybe ContactPoint
          -- ^ An e-mail, phone, website or other contact point to use to 
          --   resolve issues with message communications.
        , messageHeaderSource_endpoint :: Uri
          -- ^ Identifies the routing target to send acknowledgements to.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeaderSource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeaderSource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "software")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "contact")
            `apply` parseSchemaType "endpoint"
    schemaTypeToXML s x@MessageHeaderSource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeaderSource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeaderSource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeaderSource_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ messageHeaderSource_name x
            , maybe [] (schemaTypeToXML "software") $ messageHeaderSource_software x
            , maybe [] (schemaTypeToXML "version") $ messageHeaderSource_version x
            , maybe [] (schemaTypeToXML "contact") $ messageHeaderSource_contact x
            , schemaTypeToXML "endpoint" $ messageHeaderSource_endpoint x
            ]
instance Extension MessageHeaderSource BackboneElement where
    supertype (MessageHeaderSource a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension MessageHeaderSource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeaderSource -> BackboneElement)
              
 
-- | The header for a message exchange that is either requesting 
--   or responding to an action. The reference(s) that are the 
--   subject of the action as well as other information related 
--   to the action are typically transmitted in a bundle in 
--   which the MessageHeader resource instance is the first 
--   resource in the bundle.
data MessageHeaderResponse = MessageHeaderResponse
        { messageHeaderResponse_id :: Maybe String_primitive
        , messageHeaderResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , messageHeaderResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , messageHeaderResponse_identifier :: Id
          -- ^ The MessageHeader.id of the message to which this message 
          --   is a response.
        , messageHeaderResponse_code :: ResponseType
          -- ^ Code that identifies the type of response to the message - 
          --   whether it was successful or not, and whether it should be 
          --   resent or not.
        , messageHeaderResponse_details :: Maybe Reference
          -- ^ Full details of any issues found in the message.
        }
        deriving (Eq,Show)
instance SchemaType MessageHeaderResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (MessageHeaderResponse a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "details")
    schemaTypeToXML s x@MessageHeaderResponse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ messageHeaderResponse_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ messageHeaderResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ messageHeaderResponse_modifierExtension x
            , schemaTypeToXML "identifier" $ messageHeaderResponse_identifier x
            , schemaTypeToXML "code" $ messageHeaderResponse_code x
            , maybe [] (schemaTypeToXML "details") $ messageHeaderResponse_details x
            ]
instance Extension MessageHeaderResponse BackboneElement where
    supertype (MessageHeaderResponse a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension MessageHeaderResponse Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: MessageHeaderResponse -> BackboneElement)
              
 
data ResponseType_list
    = ResponseType_list_Ok
      -- ^ OK
    | ResponseType_list_Transient_error
      -- ^ Transient Error
    | ResponseType_list_Fatal_error
      -- ^ Fatal Error
    deriving (Eq,Show,Enum)
instance SchemaType ResponseType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResponseType_list where
    acceptingParser =  do literal "ok"; return ResponseType_list_Ok
                      `onFail` do literal "transient-error"; return ResponseType_list_Transient_error
                      `onFail` do literal "fatal-error"; return ResponseType_list_Fatal_error
                      
    simpleTypeText ResponseType_list_Ok = "ok"
    simpleTypeText ResponseType_list_Transient_error = "transient-error"
    simpleTypeText ResponseType_list_Fatal_error = "fatal-error"
 
data ResponseType = ResponseType
        { responseType_id :: Maybe String_primitive
        , responseType_value :: Maybe ResponseType_list
        , responseType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResponseType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResponseType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResponseType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ responseType_id x
                       , maybe [] (toXMLAttribute "value") $ responseType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ responseType_extension x
            ]
instance Extension ResponseType Element where
    supertype (ResponseType a0 a1 e0) =
               Element a0 e0
 
-- | A curated namespace that issues unique symbols within that 
--   namespace for the identification of concepts, people, 
--   devices, etc. Represents a &quot;System&quot; used within 
--   the Identifier and Coding data types.
elementNamingSystem :: XMLParser NamingSystem
elementNamingSystem = parseSchemaType "NamingSystem"
elementToXMLNamingSystem :: NamingSystem -> [Content ()]
elementToXMLNamingSystem = schemaTypeToXML "NamingSystem"
 
data NamingSystem = NamingSystem
        { namingSystem_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , namingSystem_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , namingSystem_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , namingSystem_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , namingSystem_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , namingSystem_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , namingSystem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , namingSystem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , namingSystem_name :: Xsd.XsdString
          -- ^ A natural language name identifying the naming system. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , namingSystem_status :: PublicationStatus
          -- ^ The status of this naming system. Enables tracking the 
          --   life-cycle of the content.
        , namingSystem_kind :: NamingSystemType
          -- ^ Indicates the purpose for the naming system - what kinds of 
          --   things does it make unique?
        , namingSystem_date :: DateTime
          -- ^ The date (and optionally time) when the naming system was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the naming system changes.
        , namingSystem_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the naming system.
        , namingSystem_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , namingSystem_responsible :: Maybe Xsd.XsdString
          -- ^ The name of the organization that is responsible for 
          --   issuing identifiers or codes for this namespace and 
          --   ensuring their non-collision.
        , namingSystem_type :: Maybe CodeableConcept
          -- ^ Categorizes a naming system for easier search by grouping 
          --   related naming systems.
        , namingSystem_description :: Maybe Markdown
          -- ^ A free text natural language description of the naming 
          --   system from a consumer's perspective. Details about what 
          --   the namespace identifies including scope, granularity, 
          --   version labeling, etc.
        , namingSystem_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   naming system instances.
        , namingSystem_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the naming system is 
          --   intended to be used.
        , namingSystem_usage :: Maybe Xsd.XsdString
          -- ^ Provides guidance on the use of the namespace, including 
          --   the handling of formatting characters, use of upper vs. 
          --   lower case, etc.
        , namingSystem_uniqueId :: [NamingSystemUniqueId]
          -- ^ Indicates how the system may be identified when referenced 
          --   in electronic exchange.
        , namingSystem_replacedBy :: Maybe Reference
          -- ^ For naming systems that are retired, indicates the naming 
          --   system that should be used in their place (if any).
        }
        deriving (Eq,Show)
instance SchemaType NamingSystem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return NamingSystem
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "kind"
            `apply` parseSchemaType "date"
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "responsible")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "usage")
            `apply` many1 (parseSchemaType "uniqueId")
            `apply` optional (parseSchemaType "replacedBy")
    schemaTypeToXML s x@NamingSystem{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ namingSystem_id x
            , maybe [] (schemaTypeToXML "meta") $ namingSystem_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ namingSystem_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ namingSystem_language x
            , maybe [] (schemaTypeToXML "text") $ namingSystem_text x
            , concatMap (schemaTypeToXML "contained") $ namingSystem_contained x
            , concatMap (schemaTypeToXML "extension") $ namingSystem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ namingSystem_modifierExtension x
            , schemaTypeToXML "name" $ namingSystem_name x
            , schemaTypeToXML "status" $ namingSystem_status x
            , schemaTypeToXML "kind" $ namingSystem_kind x
            , schemaTypeToXML "date" $ namingSystem_date x
            , maybe [] (schemaTypeToXML "publisher") $ namingSystem_publisher x
            , concatMap (schemaTypeToXML "contact") $ namingSystem_contact x
            , maybe [] (schemaTypeToXML "responsible") $ namingSystem_responsible x
            , maybe [] (schemaTypeToXML "type") $ namingSystem_type x
            , maybe [] (schemaTypeToXML "description") $ namingSystem_description x
            , concatMap (schemaTypeToXML "useContext") $ namingSystem_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ namingSystem_jurisdiction x
            , maybe [] (schemaTypeToXML "usage") $ namingSystem_usage x
            , concatMap (schemaTypeToXML "uniqueId") $ namingSystem_uniqueId x
            , maybe [] (schemaTypeToXML "replacedBy") $ namingSystem_replacedBy x
            ]
instance Extension NamingSystem DomainResource where
    supertype (NamingSystem e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension NamingSystem Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: NamingSystem -> DomainResource)
              
 
-- | A curated namespace that issues unique symbols within that 
--   namespace for the identification of concepts, people, 
--   devices, etc. Represents a &quot;System&quot; used within 
--   the Identifier and Coding data types.
data NamingSystemUniqueId = NamingSystemUniqueId
        { namingSystemUniqueId_id :: Maybe String_primitive
        , namingSystemUniqueId_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , namingSystemUniqueId_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , namingSystemUniqueId_type :: NamingSystemIdentifierType
          -- ^ Identifies the unique identifier scheme used for this 
          --   particular identifier.
        , namingSystemUniqueId_value :: Xsd.XsdString
          -- ^ The string that should be sent over the wire to identify 
          --   the code system or identifier system.
        , namingSystemUniqueId_preferred :: Maybe Boolean
          -- ^ Indicates whether this identifier is the 
          --   &quot;preferred&quot; identifier of this type.
        , namingSystemUniqueId_comment :: Maybe Xsd.XsdString
          -- ^ Notes about the past or intended usage of this identifier.
        , namingSystemUniqueId_period :: Maybe Period
          -- ^ Identifies the period of time over which this identifier is 
          --   considered appropriate to refer to the naming system. 
          --   Outside of this window, the identifier might be 
          --   non-deterministic.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystemUniqueId where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NamingSystemUniqueId a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "value"
            `apply` optional (parseSchemaType "preferred")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@NamingSystemUniqueId{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystemUniqueId_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystemUniqueId_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ namingSystemUniqueId_modifierExtension x
            , schemaTypeToXML "type" $ namingSystemUniqueId_type x
            , schemaTypeToXML "value" $ namingSystemUniqueId_value x
            , maybe [] (schemaTypeToXML "preferred") $ namingSystemUniqueId_preferred x
            , maybe [] (schemaTypeToXML "comment") $ namingSystemUniqueId_comment x
            , maybe [] (schemaTypeToXML "period") $ namingSystemUniqueId_period x
            ]
instance Extension NamingSystemUniqueId BackboneElement where
    supertype (NamingSystemUniqueId a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension NamingSystemUniqueId Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NamingSystemUniqueId -> BackboneElement)
              
 
data NamingSystemIdentifierType_list
    = NamingSystemIdentifierType_list_Oid
      -- ^ OID
    | NamingSystemIdentifierType_list_Uuid
      -- ^ UUID
    | NamingSystemIdentifierType_list_Uri
      -- ^ URI
    | NamingSystemIdentifierType_list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType NamingSystemIdentifierType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NamingSystemIdentifierType_list where
    acceptingParser =  do literal "oid"; return NamingSystemIdentifierType_list_Oid
                      `onFail` do literal "uuid"; return NamingSystemIdentifierType_list_Uuid
                      `onFail` do literal "uri"; return NamingSystemIdentifierType_list_Uri
                      `onFail` do literal "other"; return NamingSystemIdentifierType_list_Other
                      
    simpleTypeText NamingSystemIdentifierType_list_Oid = "oid"
    simpleTypeText NamingSystemIdentifierType_list_Uuid = "uuid"
    simpleTypeText NamingSystemIdentifierType_list_Uri = "uri"
    simpleTypeText NamingSystemIdentifierType_list_Other = "other"
 
data NamingSystemIdentifierType = NamingSystemIdentifierType
        { namingSystemIdentifierType_id :: Maybe String_primitive
        , namingSystemIdentifierType_value :: Maybe NamingSystemIdentifierType_list
        , namingSystemIdentifierType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystemIdentifierType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NamingSystemIdentifierType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NamingSystemIdentifierType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystemIdentifierType_id x
                       , maybe [] (toXMLAttribute "value") $ namingSystemIdentifierType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystemIdentifierType_extension x
            ]
instance Extension NamingSystemIdentifierType Element where
    supertype (NamingSystemIdentifierType a0 a1 e0) =
               Element a0 e0
 
data NamingSystemType_list
    = NamingSystemType_list_Codesystem
      -- ^ Code System
    | NamingSystemType_list_Identifier
      -- ^ Identifier
    | NamingSystemType_list_Root
      -- ^ Root
    deriving (Eq,Show,Enum)
instance SchemaType NamingSystemType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NamingSystemType_list where
    acceptingParser =  do literal "codesystem"; return NamingSystemType_list_Codesystem
                      `onFail` do literal "identifier"; return NamingSystemType_list_Identifier
                      `onFail` do literal "root"; return NamingSystemType_list_Root
                      
    simpleTypeText NamingSystemType_list_Codesystem = "codesystem"
    simpleTypeText NamingSystemType_list_Identifier = "identifier"
    simpleTypeText NamingSystemType_list_Root = "root"
 
data NamingSystemType = NamingSystemType
        { namingSystemType_id :: Maybe String_primitive
        , namingSystemType_value :: Maybe NamingSystemType_list
        , namingSystemType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NamingSystemType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NamingSystemType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NamingSystemType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ namingSystemType_id x
                       , maybe [] (toXMLAttribute "value") $ namingSystemType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ namingSystemType_extension x
            ]
instance Extension NamingSystemType Element where
    supertype (NamingSystemType a0 a1 e0) =
               Element a0 e0
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
elementNutritionOrder :: XMLParser NutritionOrder
elementNutritionOrder = parseSchemaType "NutritionOrder"
elementToXMLNutritionOrder :: NutritionOrder -> [Content ()]
elementToXMLNutritionOrder = schemaTypeToXML "NutritionOrder"
 
data NutritionOrder = NutritionOrder
        { nutritionOrder_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , nutritionOrder_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , nutritionOrder_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , nutritionOrder_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , nutritionOrder_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , nutritionOrder_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , nutritionOrder_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrder_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrder_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order by the order sender or 
          --   by the order receiver.
        , nutritionOrder_status :: Maybe NutritionOrderStatus
          -- ^ The workflow status of the nutrition order/request.
        , nutritionOrder_patient :: Reference
          -- ^ The person (patient) who needs the nutrition order for an 
          --   oral diet, nutritional supplement and/or enteral or formula 
          --   feeding.
        , nutritionOrder_encounter :: Maybe Reference
          -- ^ An encounter that provides additional information about the 
          --   healthcare context in which this request is made.
        , nutritionOrder_dateTime :: DateTime
          -- ^ The date and time that this nutrition order was requested.
        , nutritionOrder_orderer :: Maybe Reference
          -- ^ The practitioner that holds legal responsibility for 
          --   ordering the diet, nutritional supplement, or formula 
          --   feedings.
        , nutritionOrder_allergyIntolerance :: [Reference]
          -- ^ A link to a record of allergies or intolerances which 
          --   should be included in the nutrition order.
        , nutritionOrder_foodPreferenceModifier :: [CodeableConcept]
          -- ^ This modifier is used to convey order-specific modifiers 
          --   about the type of food that should be given. These can be 
          --   derived from patient allergies, intolerances, or 
          --   preferences such as Halal, Vegan or Kosher. This modifier 
          --   applies to the entire nutrition order inclusive of the oral 
          --   diet, nutritional supplements and enteral formula feedings.
        , nutritionOrder_excludeFoodModifier :: [CodeableConcept]
          -- ^ This modifier is used to convey order-specific modifiers 
          --   about the type of food that should NOT be given. These can 
          --   be derived from patient allergies, intolerances, or 
          --   preferences such as No Red Meat, No Soy or No Wheat or 
          --   Gluten-Free. While it should not be necessary to repeat 
          --   allergy or intolerance information captured in the 
          --   referenced AllergyIntolerance resource in the 
          --   excludeFoodModifier, this element may be used to convey 
          --   additional specificity related to foods that should be 
          --   eliminated from the patientâ€™s diet for any reason. This 
          --   modifier applies to the entire nutrition order inclusive of 
          --   the oral diet, nutritional supplements and enteral formula 
          --   feedings.
        , nutritionOrder_oralDiet :: Maybe NutritionOrderOralDiet
          -- ^ Diet given orally in contrast to enteral (tube) feeding.
        , nutritionOrder_supplement :: [NutritionOrderSupplement]
          -- ^ Oral nutritional products given in order to add further 
          --   nutritional value to the patient's diet.
        , nutritionOrder_enteralFormula :: Maybe NutritionOrderEnteralFormula
          -- ^ Feeding provided through the gastrointestinal tract via a 
          --   tube, catheter, or stoma that delivers nutrition distal to 
          --   the oral cavity.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrder where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return NutritionOrder
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "encounter")
            `apply` parseSchemaType "dateTime"
            `apply` optional (parseSchemaType "orderer")
            `apply` many (parseSchemaType "allergyIntolerance")
            `apply` many (parseSchemaType "foodPreferenceModifier")
            `apply` many (parseSchemaType "excludeFoodModifier")
            `apply` optional (parseSchemaType "oralDiet")
            `apply` many (parseSchemaType "supplement")
            `apply` optional (parseSchemaType "enteralFormula")
    schemaTypeToXML s x@NutritionOrder{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ nutritionOrder_id x
            , maybe [] (schemaTypeToXML "meta") $ nutritionOrder_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ nutritionOrder_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ nutritionOrder_language x
            , maybe [] (schemaTypeToXML "text") $ nutritionOrder_text x
            , concatMap (schemaTypeToXML "contained") $ nutritionOrder_contained x
            , concatMap (schemaTypeToXML "extension") $ nutritionOrder_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrder_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ nutritionOrder_identifier x
            , maybe [] (schemaTypeToXML "status") $ nutritionOrder_status x
            , schemaTypeToXML "patient" $ nutritionOrder_patient x
            , maybe [] (schemaTypeToXML "encounter") $ nutritionOrder_encounter x
            , schemaTypeToXML "dateTime" $ nutritionOrder_dateTime x
            , maybe [] (schemaTypeToXML "orderer") $ nutritionOrder_orderer x
            , concatMap (schemaTypeToXML "allergyIntolerance") $ nutritionOrder_allergyIntolerance x
            , concatMap (schemaTypeToXML "foodPreferenceModifier") $ nutritionOrder_foodPreferenceModifier x
            , concatMap (schemaTypeToXML "excludeFoodModifier") $ nutritionOrder_excludeFoodModifier x
            , maybe [] (schemaTypeToXML "oralDiet") $ nutritionOrder_oralDiet x
            , concatMap (schemaTypeToXML "supplement") $ nutritionOrder_supplement x
            , maybe [] (schemaTypeToXML "enteralFormula") $ nutritionOrder_enteralFormula x
            ]
instance Extension NutritionOrder DomainResource where
    supertype (NutritionOrder e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension NutritionOrder Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: NutritionOrder -> DomainResource)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderOralDiet = NutritionOrderOralDiet
        { nutritionOrderOralDiet_id :: Maybe String_primitive
        , nutritionOrderOralDiet_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderOralDiet_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderOralDiet_type :: [CodeableConcept]
          -- ^ The kind of diet or dietary restriction such as fiber 
          --   restricted diet or diabetic diet.
        , nutritionOrderOralDiet_schedule :: [Timing]
          -- ^ The time period and frequency at which the diet should be 
          --   given. The diet should be given for the combination of all 
          --   schedules if more than one schedule is present.
        , nutritionOrderOralDiet_nutrient :: [NutritionOrderNutrient]
          -- ^ Class that defines the quantity and type of nutrient 
          --   modifications (for example carbohydrate, fiber or sodium) 
          --   required for the oral diet.
        , nutritionOrderOralDiet_texture :: [NutritionOrderTexture]
          -- ^ Class that describes any texture modifications required for 
          --   the patient to safely consume various types of solid foods.
        , nutritionOrderOralDiet_fluidConsistencyType :: [CodeableConcept]
          -- ^ The required consistency (e.g. honey-thick, nectar-thick, 
          --   thin, thickened.) of liquids or fluids served to the 
          --   patient.
        , nutritionOrderOralDiet_instruction :: Maybe Xsd.XsdString
          -- ^ Free text or additional instructions or information 
          --   pertaining to the oral diet.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderOralDiet where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderOralDiet a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "type")
            `apply` many (parseSchemaType "schedule")
            `apply` many (parseSchemaType "nutrient")
            `apply` many (parseSchemaType "texture")
            `apply` many (parseSchemaType "fluidConsistencyType")
            `apply` optional (parseSchemaType "instruction")
    schemaTypeToXML s x@NutritionOrderOralDiet{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderOralDiet_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderOralDiet_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderOralDiet_modifierExtension x
            , concatMap (schemaTypeToXML "type") $ nutritionOrderOralDiet_type x
            , concatMap (schemaTypeToXML "schedule") $ nutritionOrderOralDiet_schedule x
            , concatMap (schemaTypeToXML "nutrient") $ nutritionOrderOralDiet_nutrient x
            , concatMap (schemaTypeToXML "texture") $ nutritionOrderOralDiet_texture x
            , concatMap (schemaTypeToXML "fluidConsistencyType") $ nutritionOrderOralDiet_fluidConsistencyType x
            , maybe [] (schemaTypeToXML "instruction") $ nutritionOrderOralDiet_instruction x
            ]
instance Extension NutritionOrderOralDiet BackboneElement where
    supertype (NutritionOrderOralDiet a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderOralDiet Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderOralDiet -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderNutrient = NutritionOrderNutrient
        { nutritionOrderNutrient_id :: Maybe String_primitive
        , nutritionOrderNutrient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderNutrient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderNutrient_modifier :: Maybe CodeableConcept
          -- ^ The nutrient that is being modified such as carbohydrate or 
          --   sodium.
        , nutritionOrderNutrient_amount :: Maybe Quantity
          -- ^ The quantity of the specified nutrient to include in diet.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderNutrient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderNutrient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@NutritionOrderNutrient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderNutrient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderNutrient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderNutrient_modifierExtension x
            , maybe [] (schemaTypeToXML "modifier") $ nutritionOrderNutrient_modifier x
            , maybe [] (schemaTypeToXML "amount") $ nutritionOrderNutrient_amount x
            ]
instance Extension NutritionOrderNutrient BackboneElement where
    supertype (NutritionOrderNutrient a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderNutrient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderNutrient -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderTexture = NutritionOrderTexture
        { nutritionOrderTexture_id :: Maybe String_primitive
        , nutritionOrderTexture_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderTexture_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderTexture_modifier :: Maybe CodeableConcept
          -- ^ Any texture modifications (for solid foods) that should be 
          --   made, e.g. easy to chew, chopped, ground, and pureed.
        , nutritionOrderTexture_foodType :: Maybe CodeableConcept
          -- ^ The food type(s) (e.g. meats, all foods) that the texture 
          --   modification applies to. This could be all foods types.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderTexture where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderTexture a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "modifier")
            `apply` optional (parseSchemaType "foodType")
    schemaTypeToXML s x@NutritionOrderTexture{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderTexture_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderTexture_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderTexture_modifierExtension x
            , maybe [] (schemaTypeToXML "modifier") $ nutritionOrderTexture_modifier x
            , maybe [] (schemaTypeToXML "foodType") $ nutritionOrderTexture_foodType x
            ]
instance Extension NutritionOrderTexture BackboneElement where
    supertype (NutritionOrderTexture a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderTexture Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderTexture -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderSupplement = NutritionOrderSupplement
        { nutritionOrderSupplement_id :: Maybe String_primitive
        , nutritionOrderSupplement_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderSupplement_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderSupplement_type :: Maybe CodeableConcept
          -- ^ The kind of nutritional supplement product required such as 
          --   a high protein or pediatric clear liquid supplement.
        , nutritionOrderSupplement_productName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the nutritional supplement 
          --   such as &quot;Acme Protein Shake&quot;.
        , nutritionOrderSupplement_schedule :: [Timing]
          -- ^ The time period and frequency at which the supplement(s) 
          --   should be given. The supplement should be given for the 
          --   combination of all schedules if more than one schedule is 
          --   present.
        , nutritionOrderSupplement_quantity :: Maybe Quantity
          -- ^ The amount of the nutritional supplement to be given.
        , nutritionOrderSupplement_instruction :: Maybe Xsd.XsdString
          -- ^ Free text or additional instructions or information 
          --   pertaining to the oral supplement.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderSupplement where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderSupplement a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "productName")
            `apply` many (parseSchemaType "schedule")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "instruction")
    schemaTypeToXML s x@NutritionOrderSupplement{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderSupplement_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderSupplement_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderSupplement_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ nutritionOrderSupplement_type x
            , maybe [] (schemaTypeToXML "productName") $ nutritionOrderSupplement_productName x
            , concatMap (schemaTypeToXML "schedule") $ nutritionOrderSupplement_schedule x
            , maybe [] (schemaTypeToXML "quantity") $ nutritionOrderSupplement_quantity x
            , maybe [] (schemaTypeToXML "instruction") $ nutritionOrderSupplement_instruction x
            ]
instance Extension NutritionOrderSupplement BackboneElement where
    supertype (NutritionOrderSupplement a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderSupplement Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderSupplement -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderEnteralFormula = NutritionOrderEnteralFormula
        { nutritionOrderEnteralFormula_id :: Maybe String_primitive
        , nutritionOrderEnteralFormula_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderEnteralFormula_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderEnteralFormula_baseFormulaType :: Maybe CodeableConcept
          -- ^ The type of enteral or infant formula such as an adult 
          --   standard formula with fiber or a soy-based infant formula.
        , nutritionOrderEnteralFormula_baseFormulaProductName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the enteral or infant formula 
          --   product such as &quot;ACME Adult Standard Formula&quot;.
        , nutritionOrderEnteralFormula_additiveType :: Maybe CodeableConcept
          -- ^ Indicates the type of modular component such as protein, 
          --   carbohydrate, fat or fiber to be provided in addition to or 
          --   mixed with the base formula.
        , nutritionOrderEnteralFormula_additiveProductName :: Maybe Xsd.XsdString
          -- ^ The product or brand name of the type of modular component 
          --   to be added to the formula.
        , nutritionOrderEnteralFormula_caloricDensity :: Maybe Quantity
          -- ^ The amount of energy (calories) that the formula should 
          --   provide per specified volume, typically per mL or fluid oz. 
          --   For example, an infant may require a formula that provides 
          --   24 calories per fluid ounce or an adult may require an 
          --   enteral formula that provides 1.5 calorie/mL.
        , nutritionOrderEnteralFormula_routeofAdministration :: Maybe CodeableConcept
          -- ^ The route or physiological path of administration into the 
          --   patient's gastrointestinal tract for purposes of providing 
          --   the formula feeding, e.g. nasogastric tube.
        , nutritionOrderEnteralFormula_administration :: [NutritionOrderAdministration]
          -- ^ Formula administration instructions as structured data. 
          --   This repeating structure allows for changing the 
          --   administration rate or volume over time for both bolus and 
          --   continuous feeding. An example of this would be an 
          --   instruction to increase the rate of continuous feeding 
          --   every 2 hours.
        , nutritionOrderEnteralFormula_maxVolumeToDeliver :: Maybe Quantity
          -- ^ The maximum total quantity of formula that may be 
          --   administered to a subject over the period of time, e.g. 
          --   1440 mL over 24 hours.
        , nutritionOrderEnteralFormula_administrationInstruction :: Maybe Xsd.XsdString
          -- ^ Free text formula administration, feeding instructions or 
          --   additional instructions or information.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderEnteralFormula where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderEnteralFormula a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "baseFormulaType")
            `apply` optional (parseSchemaType "baseFormulaProductName")
            `apply` optional (parseSchemaType "additiveType")
            `apply` optional (parseSchemaType "additiveProductName")
            `apply` optional (parseSchemaType "caloricDensity")
            `apply` optional (parseSchemaType "routeofAdministration")
            `apply` many (parseSchemaType "administration")
            `apply` optional (parseSchemaType "maxVolumeToDeliver")
            `apply` optional (parseSchemaType "administrationInstruction")
    schemaTypeToXML s x@NutritionOrderEnteralFormula{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderEnteralFormula_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderEnteralFormula_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderEnteralFormula_modifierExtension x
            , maybe [] (schemaTypeToXML "baseFormulaType") $ nutritionOrderEnteralFormula_baseFormulaType x
            , maybe [] (schemaTypeToXML "baseFormulaProductName") $ nutritionOrderEnteralFormula_baseFormulaProductName x
            , maybe [] (schemaTypeToXML "additiveType") $ nutritionOrderEnteralFormula_additiveType x
            , maybe [] (schemaTypeToXML "additiveProductName") $ nutritionOrderEnteralFormula_additiveProductName x
            , maybe [] (schemaTypeToXML "caloricDensity") $ nutritionOrderEnteralFormula_caloricDensity x
            , maybe [] (schemaTypeToXML "routeofAdministration") $ nutritionOrderEnteralFormula_routeofAdministration x
            , concatMap (schemaTypeToXML "administration") $ nutritionOrderEnteralFormula_administration x
            , maybe [] (schemaTypeToXML "maxVolumeToDeliver") $ nutritionOrderEnteralFormula_maxVolumeToDeliver x
            , maybe [] (schemaTypeToXML "administrationInstruction") $ nutritionOrderEnteralFormula_administrationInstruction x
            ]
instance Extension NutritionOrderEnteralFormula BackboneElement where
    supertype (NutritionOrderEnteralFormula a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderEnteralFormula Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderEnteralFormula -> BackboneElement)
              
 
-- | A request to supply a diet, formula feeding (enteral) or 
--   oral nutritional supplement to a patient/resident.
data NutritionOrderAdministration = NutritionOrderAdministration
        { nutritionOrderAdministration_id :: Maybe String_primitive
        , nutritionOrderAdministration_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , nutritionOrderAdministration_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , nutritionOrderAdministration_schedule :: Maybe Timing
          -- ^ The time period and frequency at which the enteral formula 
          --   should be delivered to the patient.
        , nutritionOrderAdministration_quantity :: Maybe Quantity
          -- ^ The volume of formula to provide to the patient per the 
          --   specified administration schedule.
        , nutritionOrderAdministration_choice4 :: (Maybe (OneOf2 Quantity Ratio))
          -- ^ The rate of administration of formula via a feeding pump, 
          --   e.g. 60 mL per hour, according to the specified schedule.
          --   
          --   Choice between:
          --   
          --   (1) rateQuantity
          --   
          --   (2) rateRatio
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderAdministration where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (NutritionOrderAdministration a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "schedule")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf2 (parseSchemaType "rateQuantity"))
                                     , ("Ratio", fmap TwoOf2 (parseSchemaType "rateRatio"))
                                     ])
    schemaTypeToXML s x@NutritionOrderAdministration{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderAdministration_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderAdministration_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ nutritionOrderAdministration_modifierExtension x
            , maybe [] (schemaTypeToXML "schedule") $ nutritionOrderAdministration_schedule x
            , maybe [] (schemaTypeToXML "quantity") $ nutritionOrderAdministration_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "rateQuantity")
                                    (schemaTypeToXML "rateRatio")
                                   ) $ nutritionOrderAdministration_choice4 x
            ]
instance Extension NutritionOrderAdministration BackboneElement where
    supertype (NutritionOrderAdministration a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension NutritionOrderAdministration Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: NutritionOrderAdministration -> BackboneElement)
              
 
data NutritionOrderStatus_list
    = NutritionOrderStatus_list_Proposed
      -- ^ Proposed
    | NutritionOrderStatus_list_Draft
      -- ^ Draft
    | NutritionOrderStatus_list_Planned
      -- ^ Planned
    | NutritionOrderStatus_list_Requested
      -- ^ Requested
    | NutritionOrderStatus_list_Active
      -- ^ Active
    | NutritionOrderStatus_list_On_hold
      -- ^ On-Hold
    | NutritionOrderStatus_list_Completed
      -- ^ Completed
    | NutritionOrderStatus_list_Cancelled
      -- ^ Cancelled
    | NutritionOrderStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType NutritionOrderStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType NutritionOrderStatus_list where
    acceptingParser =  do literal "proposed"; return NutritionOrderStatus_list_Proposed
                      `onFail` do literal "draft"; return NutritionOrderStatus_list_Draft
                      `onFail` do literal "planned"; return NutritionOrderStatus_list_Planned
                      `onFail` do literal "requested"; return NutritionOrderStatus_list_Requested
                      `onFail` do literal "active"; return NutritionOrderStatus_list_Active
                      `onFail` do literal "on-hold"; return NutritionOrderStatus_list_On_hold
                      `onFail` do literal "completed"; return NutritionOrderStatus_list_Completed
                      `onFail` do literal "cancelled"; return NutritionOrderStatus_list_Cancelled
                      `onFail` do literal "entered-in-error"; return NutritionOrderStatus_list_Entered_in_error
                      
    simpleTypeText NutritionOrderStatus_list_Proposed = "proposed"
    simpleTypeText NutritionOrderStatus_list_Draft = "draft"
    simpleTypeText NutritionOrderStatus_list_Planned = "planned"
    simpleTypeText NutritionOrderStatus_list_Requested = "requested"
    simpleTypeText NutritionOrderStatus_list_Active = "active"
    simpleTypeText NutritionOrderStatus_list_On_hold = "on-hold"
    simpleTypeText NutritionOrderStatus_list_Completed = "completed"
    simpleTypeText NutritionOrderStatus_list_Cancelled = "cancelled"
    simpleTypeText NutritionOrderStatus_list_Entered_in_error = "entered-in-error"
 
data NutritionOrderStatus = NutritionOrderStatus
        { nutritionOrderStatus_id :: Maybe String_primitive
        , nutritionOrderStatus_value :: Maybe NutritionOrderStatus_list
        , nutritionOrderStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType NutritionOrderStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (NutritionOrderStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@NutritionOrderStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ nutritionOrderStatus_id x
                       , maybe [] (toXMLAttribute "value") $ nutritionOrderStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ nutritionOrderStatus_extension x
            ]
instance Extension NutritionOrderStatus Element where
    supertype (NutritionOrderStatus a0 a1 e0) =
               Element a0 e0
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
elementObservation :: XMLParser Observation
elementObservation = parseSchemaType "Observation"
elementToXMLObservation :: Observation -> [Content ()]
elementToXMLObservation = schemaTypeToXML "Observation"
 
data Observation = Observation
        { observation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , observation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , observation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , observation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , observation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , observation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , observation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observation_identifier :: [Identifier]
          -- ^ A unique identifier assigned to this observation.
        , observation_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , observation_status :: ObservationStatus
          -- ^ The status of the result value.
        , observation_category :: [CodeableConcept]
          -- ^ A code that classifies the general type of observation 
          --   being made.
        , observation_code :: CodeableConcept
          -- ^ Describes what was observed. Sometimes this is called the 
          --   observation &quot;name&quot;.
        , observation_subject :: Maybe Reference
          -- ^ The patient, or group of patients, location, or device 
          --   whose characteristics (direct or indirect) are described by 
          --   the observation and into whose record the observation is 
          --   placed. Comments: Indirect characteristics may be those of 
          --   a specimen, fetus, donor, other observer (for example a 
          --   relative or EMT), or any observation made about the 
          --   subject.
        , observation_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) during which this observation is 
          --   made.
        , observation_choice15 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The time or time-period the observed value is asserted as 
          --   being true. For biological subjects - e.g. human patients - 
          --   this is usually called the &quot;physiologically relevant 
          --   time&quot;. This is usually either the time of the 
          --   procedure or of specimen collection, but very often the 
          --   source of the date/time is not known, only the date/time 
          --   itself.
          --   
          --   Choice between:
          --   
          --   (1) effectiveDateTime
          --   
          --   (2) effectivePeriod
        , observation_issued :: Maybe Instant
          -- ^ The date and time this observation was made available to 
          --   providers, typically after the results have been reviewed 
          --   and verified.
        , observation_performer :: [Reference]
          -- ^ Who was responsible for asserting the observed value as 
          --   &quot;true&quot;.
        , observation_choice18 :: (Maybe (OneOf11 Quantity CodeableConcept Xsd.XsdString Boolean Range Ratio SampledData Attachment Time DateTime Period))
          -- ^ The information determined as a result of making the 
          --   observation, if the information has a simple value.
          --   
          --   Choice between:
          --   
          --   (1) valueQuantity
          --   
          --   (2) valueCodeableConcept
          --   
          --   (3) valueString
          --   
          --   (4) valueBoolean
          --   
          --   (5) valueRange
          --   
          --   (6) valueRatio
          --   
          --   (7) valueSampledData
          --   
          --   (8) valueAttachment
          --   
          --   (9) valueTime
          --   
          --   (10) valueDateTime
          --   
          --   (11) valuePeriod
        , observation_dataAbsentReason :: Maybe CodeableConcept
          -- ^ Provides a reason why the expected value in the element 
          --   Observation.value[x] is missing.
        , observation_interpretation :: Maybe CodeableConcept
          -- ^ The assessment made based on the result of the observation. 
          --   Intended as a simple compact code often placed adjacent to 
          --   the result value in reports and flow sheets to signal the 
          --   meaning/normalcy status of the result. Otherwise known as 
          --   abnormal flag.
        , observation_comment :: Maybe Xsd.XsdString
          -- ^ May include statements about significant, unexpected or 
          --   unreliable values, or information about the source of the 
          --   value where this may be relevant to the interpretation of 
          --   the result.
        , observation_bodySite :: Maybe CodeableConcept
          -- ^ Indicates the site on the subject's body where the 
          --   observation was made (i.e. the target site).
        , observation_method :: Maybe CodeableConcept
          -- ^ Indicates the mechanism used to perform the observation.
        , observation_specimen :: Maybe Reference
          -- ^ The specimen that was used when this observation was made.
        , observation_device :: Maybe Reference
          -- ^ The device used to generate the observation data.
        , observation_referenceRange :: [ObservationReferenceRange]
          -- ^ Guidance on how to interpret the value by comparison to a 
          --   normal or recommended range.
        , observation_related :: [ObservationRelated]
          -- ^ A reference to another resource (usually another 
          --   Observation) whose relationship is defined by the 
          --   relationship type code.
        , observation_component :: [ObservationComponent]
          -- ^ Some observations have multiple component observations. 
          --   These component observations are expressed as separate code 
          --   value pairs that share the same attributes. Examples 
          --   include systolic and diastolic component observations for 
          --   blood pressure measurement and multiple component 
          --   observations for genetics observations.
        }
        deriving (Eq,Show)
instance SchemaType Observation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Observation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "effectiveDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "effectivePeriod"))
                                     ])
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf11 (parseSchemaType "valueQuantity"))
                                     , ("CodeableConcept", fmap TwoOf11 (parseSchemaType "valueCodeableConcept"))
                                     , ("Xsd.XsdString", fmap ThreeOf11 (parseSchemaType "valueString"))
                                     , ("Boolean", fmap FourOf11 (parseSchemaType "valueBoolean"))
                                     , ("Range", fmap FiveOf11 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap SixOf11 (parseSchemaType "valueRatio"))
                                     , ("SampledData", fmap SevenOf11 (parseSchemaType "valueSampledData"))
                                     , ("Attachment", fmap EightOf11 (parseSchemaType "valueAttachment"))
                                     , ("Time", fmap NineOf11 (parseSchemaType "valueTime"))
                                     , ("DateTime", fmap TenOf11 (parseSchemaType "valueDateTime"))
                                     , ("Period", fmap ElevenOf11 (parseSchemaType "valuePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dataAbsentReason")
            `apply` optional (parseSchemaType "interpretation")
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "specimen")
            `apply` optional (parseSchemaType "device")
            `apply` many (parseSchemaType "referenceRange")
            `apply` many (parseSchemaType "related")
            `apply` many (parseSchemaType "component")
    schemaTypeToXML s x@Observation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ observation_id x
            , maybe [] (schemaTypeToXML "meta") $ observation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ observation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ observation_language x
            , maybe [] (schemaTypeToXML "text") $ observation_text x
            , concatMap (schemaTypeToXML "contained") $ observation_contained x
            , concatMap (schemaTypeToXML "extension") $ observation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ observation_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ observation_basedOn x
            , schemaTypeToXML "status" $ observation_status x
            , concatMap (schemaTypeToXML "category") $ observation_category x
            , schemaTypeToXML "code" $ observation_code x
            , maybe [] (schemaTypeToXML "subject") $ observation_subject x
            , maybe [] (schemaTypeToXML "context") $ observation_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "effectiveDateTime")
                                    (schemaTypeToXML "effectivePeriod")
                                   ) $ observation_choice15 x
            , maybe [] (schemaTypeToXML "issued") $ observation_issued x
            , concatMap (schemaTypeToXML "performer") $ observation_performer x
            , maybe [] (foldOneOf11  (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valuePeriod")
                                    ) $ observation_choice18 x
            , maybe [] (schemaTypeToXML "dataAbsentReason") $ observation_dataAbsentReason x
            , maybe [] (schemaTypeToXML "interpretation") $ observation_interpretation x
            , maybe [] (schemaTypeToXML "comment") $ observation_comment x
            , maybe [] (schemaTypeToXML "bodySite") $ observation_bodySite x
            , maybe [] (schemaTypeToXML "method") $ observation_method x
            , maybe [] (schemaTypeToXML "specimen") $ observation_specimen x
            , maybe [] (schemaTypeToXML "device") $ observation_device x
            , concatMap (schemaTypeToXML "referenceRange") $ observation_referenceRange x
            , concatMap (schemaTypeToXML "related") $ observation_related x
            , concatMap (schemaTypeToXML "component") $ observation_component x
            ]
instance Extension Observation DomainResource where
    supertype (Observation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Observation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Observation -> DomainResource)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data ObservationReferenceRange = ObservationReferenceRange
        { observationReferenceRange_id :: Maybe String_primitive
        , observationReferenceRange_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observationReferenceRange_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observationReferenceRange_low :: Maybe Quantity
          -- ^ The value of the low bound of the reference range. The low 
          --   bound of the reference range endpoint is inclusive of the 
          --   value (e.g. reference range is &gt;=5 - &lt;=9). If the low 
          --   bound is omitted, it is assumed to be meaningless (e.g. 
          --   reference range is &lt;=2.3).
        , observationReferenceRange_high :: Maybe Quantity
          -- ^ The value of the high bound of the reference range. The 
          --   high bound of the reference range endpoint is inclusive of 
          --   the value (e.g. reference range is &gt;=5 - &lt;=9). If the 
          --   high bound is omitted, it is assumed to be meaningless 
          --   (e.g. reference range is &gt;= 2.3).
        , observationReferenceRange_type :: Maybe CodeableConcept
          -- ^ Codes to indicate the what part of the targeted reference 
          --   population it applies to. For example, the normal or 
          --   therapeutic range.
        , observationReferenceRange_appliesTo :: [CodeableConcept]
          -- ^ Codes to indicate the target population this reference 
          --   range applies to. For example, a reference range may be 
          --   based on the normal population or a particular sex or race.
        , observationReferenceRange_age :: Maybe Range
          -- ^ The age at which this reference range is applicable. This 
          --   is a neonatal age (e.g. number of weeks at term) if the 
          --   meaning says so.
        , observationReferenceRange_text :: Maybe Xsd.XsdString
          -- ^ Text based reference range in an observation which may be 
          --   used when a quantitative range is not appropriate for an 
          --   observation. An example would be a reference value of 
          --   &quot;Negative&quot; or a list or table of 'normals'.
        }
        deriving (Eq,Show)
instance SchemaType ObservationReferenceRange where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ObservationReferenceRange a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "low")
            `apply` optional (parseSchemaType "high")
            `apply` optional (parseSchemaType "type")
            `apply` many (parseSchemaType "appliesTo")
            `apply` optional (parseSchemaType "age")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@ObservationReferenceRange{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationReferenceRange_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationReferenceRange_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observationReferenceRange_modifierExtension x
            , maybe [] (schemaTypeToXML "low") $ observationReferenceRange_low x
            , maybe [] (schemaTypeToXML "high") $ observationReferenceRange_high x
            , maybe [] (schemaTypeToXML "type") $ observationReferenceRange_type x
            , concatMap (schemaTypeToXML "appliesTo") $ observationReferenceRange_appliesTo x
            , maybe [] (schemaTypeToXML "age") $ observationReferenceRange_age x
            , maybe [] (schemaTypeToXML "text") $ observationReferenceRange_text x
            ]
instance Extension ObservationReferenceRange BackboneElement where
    supertype (ObservationReferenceRange a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ObservationReferenceRange Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ObservationReferenceRange -> BackboneElement)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data ObservationRelated = ObservationRelated
        { observationRelated_id :: Maybe String_primitive
        , observationRelated_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observationRelated_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observationRelated_type :: Maybe ObservationRelationshipType
          -- ^ A code specifying the kind of relationship that exists with 
          --   the target resource.
        , observationRelated_target :: Reference
          -- ^ A reference to the observation or 
          --   [[[QuestionnaireResponse]]] resource that is related to 
          --   this observation.
        }
        deriving (Eq,Show)
instance SchemaType ObservationRelated where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ObservationRelated a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "target"
    schemaTypeToXML s x@ObservationRelated{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationRelated_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationRelated_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observationRelated_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ observationRelated_type x
            , schemaTypeToXML "target" $ observationRelated_target x
            ]
instance Extension ObservationRelated BackboneElement where
    supertype (ObservationRelated a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ObservationRelated Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ObservationRelated -> BackboneElement)
              
 
-- | Measurements and simple assertions made about a patient, 
--   device or other subject.
data ObservationComponent = ObservationComponent
        { observationComponent_id :: Maybe String_primitive
        , observationComponent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , observationComponent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , observationComponent_code :: CodeableConcept
          -- ^ Describes what was observed. Sometimes this is called the 
          --   observation &quot;code&quot;.
        , observationComponent_choice3 :: (Maybe (OneOf10 Quantity CodeableConcept Xsd.XsdString Range Ratio SampledData Attachment Time DateTime Period))
          -- ^ The information determined as a result of making the 
          --   observation, if the information has a simple value.
          --   
          --   Choice between:
          --   
          --   (1) valueQuantity
          --   
          --   (2) valueCodeableConcept
          --   
          --   (3) valueString
          --   
          --   (4) valueRange
          --   
          --   (5) valueRatio
          --   
          --   (6) valueSampledData
          --   
          --   (7) valueAttachment
          --   
          --   (8) valueTime
          --   
          --   (9) valueDateTime
          --   
          --   (10) valuePeriod
        , observationComponent_dataAbsentReason :: Maybe CodeableConcept
          -- ^ Provides a reason why the expected value in the element 
          --   Observation.value[x] is missing.
        , observationComponent_interpretation :: Maybe CodeableConcept
          -- ^ The assessment made based on the result of the observation. 
          --   Intended as a simple compact code often placed adjacent to 
          --   the result value in reports and flow sheets to signal the 
          --   meaning/normalcy status of the result. Otherwise known as 
          --   abnormal flag.
        , observationComponent_referenceRange :: [ObservationReferenceRange]
          -- ^ Guidance on how to interpret the value by comparison to a 
          --   normal or recommended range.
        }
        deriving (Eq,Show)
instance SchemaType ObservationComponent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ObservationComponent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf10 (parseSchemaType "valueQuantity"))
                                     , ("CodeableConcept", fmap TwoOf10 (parseSchemaType "valueCodeableConcept"))
                                     , ("Xsd.XsdString", fmap ThreeOf10 (parseSchemaType "valueString"))
                                     , ("Range", fmap FourOf10 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap FiveOf10 (parseSchemaType "valueRatio"))
                                     , ("SampledData", fmap SixOf10 (parseSchemaType "valueSampledData"))
                                     , ("Attachment", fmap SevenOf10 (parseSchemaType "valueAttachment"))
                                     , ("Time", fmap EightOf10 (parseSchemaType "valueTime"))
                                     , ("DateTime", fmap NineOf10 (parseSchemaType "valueDateTime"))
                                     , ("Period", fmap TenOf10 (parseSchemaType "valuePeriod"))
                                     ])
            `apply` optional (parseSchemaType "dataAbsentReason")
            `apply` optional (parseSchemaType "interpretation")
            `apply` many (parseSchemaType "referenceRange")
    schemaTypeToXML s x@ObservationComponent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationComponent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationComponent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ observationComponent_modifierExtension x
            , schemaTypeToXML "code" $ observationComponent_code x
            , maybe [] (foldOneOf10  (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valuePeriod")
                                    ) $ observationComponent_choice3 x
            , maybe [] (schemaTypeToXML "dataAbsentReason") $ observationComponent_dataAbsentReason x
            , maybe [] (schemaTypeToXML "interpretation") $ observationComponent_interpretation x
            , concatMap (schemaTypeToXML "referenceRange") $ observationComponent_referenceRange x
            ]
instance Extension ObservationComponent BackboneElement where
    supertype (ObservationComponent a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ObservationComponent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ObservationComponent -> BackboneElement)
              
 
data ObservationRelationshipType_list
    = ObservationRelationshipType_list_Has_member
      -- ^ Has Member
    | ObservationRelationshipType_list_Derived_from
      -- ^ Derived From
    | ObservationRelationshipType_list_Sequel_to
      -- ^ Sequel To
    | ObservationRelationshipType_list_Replaces
      -- ^ Replaces
    | ObservationRelationshipType_list_Qualified_by
      -- ^ Qualified By
    | ObservationRelationshipType_list_Interfered_by
      -- ^ Interfered By
    deriving (Eq,Show,Enum)
instance SchemaType ObservationRelationshipType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ObservationRelationshipType_list where
    acceptingParser =  do literal "has-member"; return ObservationRelationshipType_list_Has_member
                      `onFail` do literal "derived-from"; return ObservationRelationshipType_list_Derived_from
                      `onFail` do literal "sequel-to"; return ObservationRelationshipType_list_Sequel_to
                      `onFail` do literal "replaces"; return ObservationRelationshipType_list_Replaces
                      `onFail` do literal "qualified-by"; return ObservationRelationshipType_list_Qualified_by
                      `onFail` do literal "interfered-by"; return ObservationRelationshipType_list_Interfered_by
                      
    simpleTypeText ObservationRelationshipType_list_Has_member = "has-member"
    simpleTypeText ObservationRelationshipType_list_Derived_from = "derived-from"
    simpleTypeText ObservationRelationshipType_list_Sequel_to = "sequel-to"
    simpleTypeText ObservationRelationshipType_list_Replaces = "replaces"
    simpleTypeText ObservationRelationshipType_list_Qualified_by = "qualified-by"
    simpleTypeText ObservationRelationshipType_list_Interfered_by = "interfered-by"
 
data ObservationRelationshipType = ObservationRelationshipType
        { observationRelationshipType_id :: Maybe String_primitive
        , observationRelationshipType_value :: Maybe ObservationRelationshipType_list
        , observationRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ObservationRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ObservationRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ObservationRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ observationRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ observationRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ observationRelationshipType_extension x
            ]
instance Extension ObservationRelationshipType Element where
    supertype (ObservationRelationshipType a0 a1 e0) =
               Element a0 e0
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
elementOperationDefinition :: XMLParser OperationDefinition
elementOperationDefinition = parseSchemaType "OperationDefinition"
elementToXMLOperationDefinition :: OperationDefinition -> [Content ()]
elementToXMLOperationDefinition = schemaTypeToXML "OperationDefinition"
 
data OperationDefinition = OperationDefinition
        { operationDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , operationDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , operationDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , operationDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , operationDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , operationDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , operationDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this operation 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   operation definition is (or will be) published. The URL 
          --   SHOULD include the major version of the operation 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , operationDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   operation definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the operation definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , operationDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the operation 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , operationDefinition_status :: PublicationStatus
          -- ^ The status of this operation definition. Enables tracking 
          --   the life-cycle of the content.
        , operationDefinition_kind :: OperationKind
          -- ^ Whether this is an operation or a named query.
        , operationDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this operation definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , operationDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the operation 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the operation definition changes.
        , operationDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the operation definition.
        , operationDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , operationDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the operation 
          --   definition from a consumer's perspective.
        , operationDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   operation definition instances.
        , operationDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the operation 
          --   definition is intended to be used.
        , operationDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this operation definition is needed and 
          --   why it has been designed as it has.
        , operationDefinition_idempotent :: Maybe Boolean
          -- ^ Operations that are idempotent (see [HTTP specification 
          --   definition of 
          --   idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) 
          --   may be invoked by performing an HTTP GET operation instead 
          --   of a POST.
        , operationDefinition_code :: Code
          -- ^ The name used to invoke the operation.
        , operationDefinition_comment :: Maybe Xsd.XsdString
          -- ^ Additional information about how to use this operation or 
          --   named query.
        , operationDefinition_base :: Maybe Reference
          -- ^ Indicates that this operation definition is a constraining 
          --   profile on the base.
        , operationDefinition_resource :: [ResourceType]
          -- ^ The types on which this operation can be executed.
        , operationDefinition_system :: Boolean
          -- ^ Indicates whether this operation or named query can be 
          --   invoked at the system level (e.g. without needing to choose 
          --   a resource type for the context).
        , operationDefinition_type :: Boolean
          -- ^ Indicates whether this operation or named query can be 
          --   invoked at the resource type level for any given resource 
          --   type level (e.g. without needing to choose a specific 
          --   resource id for the context).
        , operationDefinition_instance :: Boolean
          -- ^ Indicates whether this operation can be invoked on a 
          --   particular instance of one of the given types.
        , operationDefinition_parameter :: [OperationDefinitionParameter]
          -- ^ The parameters for the operation/query.
        , operationDefinition_overload :: [OperationDefinitionOverload]
          -- ^ Defines an appropriate combination of parameters to use 
          --   when invoking this operation, to help code generators when 
          --   generating overloaded parameter sets for this operation.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return OperationDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "idempotent")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "comment")
            `apply` optional (parseSchemaType "base")
            `apply` many (parseSchemaType "resource")
            `apply` parseSchemaType "system"
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "instance"
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "overload")
    schemaTypeToXML s x@OperationDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ operationDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ operationDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ operationDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ operationDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ operationDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ operationDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ operationDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ operationDefinition_url x
            , maybe [] (schemaTypeToXML "version") $ operationDefinition_version x
            , schemaTypeToXML "name" $ operationDefinition_name x
            , schemaTypeToXML "status" $ operationDefinition_status x
            , schemaTypeToXML "kind" $ operationDefinition_kind x
            , maybe [] (schemaTypeToXML "experimental") $ operationDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ operationDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ operationDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ operationDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ operationDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ operationDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ operationDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ operationDefinition_purpose x
            , maybe [] (schemaTypeToXML "idempotent") $ operationDefinition_idempotent x
            , schemaTypeToXML "code" $ operationDefinition_code x
            , maybe [] (schemaTypeToXML "comment") $ operationDefinition_comment x
            , maybe [] (schemaTypeToXML "base") $ operationDefinition_base x
            , concatMap (schemaTypeToXML "resource") $ operationDefinition_resource x
            , schemaTypeToXML "system" $ operationDefinition_system x
            , schemaTypeToXML "type" $ operationDefinition_type x
            , schemaTypeToXML "instance" $ operationDefinition_instance x
            , concatMap (schemaTypeToXML "parameter") $ operationDefinition_parameter x
            , concatMap (schemaTypeToXML "overload") $ operationDefinition_overload x
            ]
instance Extension OperationDefinition DomainResource where
    supertype (OperationDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension OperationDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: OperationDefinition -> DomainResource)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinitionParameter = OperationDefinitionParameter
        { operationDefinitionParameter_id :: Maybe String_primitive
        , operationDefinitionParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinitionParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinitionParameter_name :: Code
          -- ^ The name of used to identify the parameter.
        , operationDefinitionParameter_use :: OperationParameterUse
          -- ^ Whether this is an input or an output parameter.
        , operationDefinitionParameter_min :: Integer
          -- ^ The minimum number of times this parameter SHALL appear in 
          --   the request or response.
        , operationDefinitionParameter_max :: Xsd.XsdString
          -- ^ The maximum number of times this element is permitted to 
          --   appear in the request or response.
        , operationDefinitionParameter_documentation :: Maybe Xsd.XsdString
          -- ^ Describes the meaning or use of this parameter.
        , operationDefinitionParameter_type :: Maybe FHIRAllTypes
          -- ^ The type for this parameter.
        , operationDefinitionParameter_searchType :: Maybe SearchParamType
          -- ^ How the parameter is understood as a search parameter. This 
          --   is only used if the parameter type is 'string'.
        , operationDefinitionParameter_profile :: Maybe Reference
          -- ^ A profile the specifies the rules that this parameter must 
          --   conform to.
        , operationDefinitionParameter_binding :: Maybe OperationDefinitionBinding
          -- ^ Binds to a value set if this parameter is coded (code, 
          --   Coding, CodeableConcept).
        , operationDefinitionParameter_part :: [OperationDefinitionParameter]
          -- ^ The parts of a nested Parameter.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinitionParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinitionParameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "use"
            `apply` parseSchemaType "min"
            `apply` parseSchemaType "max"
            `apply` optional (parseSchemaType "documentation")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "searchType")
            `apply` optional (parseSchemaType "profile")
            `apply` optional (parseSchemaType "binding")
            `apply` many (parseSchemaType "part")
    schemaTypeToXML s x@OperationDefinitionParameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinitionParameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinitionParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinitionParameter_modifierExtension x
            , schemaTypeToXML "name" $ operationDefinitionParameter_name x
            , schemaTypeToXML "use" $ operationDefinitionParameter_use x
            , schemaTypeToXML "min" $ operationDefinitionParameter_min x
            , schemaTypeToXML "max" $ operationDefinitionParameter_max x
            , maybe [] (schemaTypeToXML "documentation") $ operationDefinitionParameter_documentation x
            , maybe [] (schemaTypeToXML "type") $ operationDefinitionParameter_type x
            , maybe [] (schemaTypeToXML "searchType") $ operationDefinitionParameter_searchType x
            , maybe [] (schemaTypeToXML "profile") $ operationDefinitionParameter_profile x
            , maybe [] (schemaTypeToXML "binding") $ operationDefinitionParameter_binding x
            , concatMap (schemaTypeToXML "part") $ operationDefinitionParameter_part x
            ]
instance Extension OperationDefinitionParameter BackboneElement where
    supertype (OperationDefinitionParameter a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinitionParameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinitionParameter -> BackboneElement)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinitionBinding = OperationDefinitionBinding
        { operationDefinitionBinding_id :: Maybe String_primitive
        , operationDefinitionBinding_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinitionBinding_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinitionBinding_strength :: BindingStrength
          -- ^ Indicates the degree of conformance expectations associated 
          --   with this binding - that is, the degree to which the 
          --   provided value set must be adhered to in the instances.
        , operationDefinitionBinding_choice3 :: OneOf2 Uri Reference
          -- ^ Points to the value set or external definition (e.g. 
          --   implicit value set) that identifies the set of codes to be 
          --   used.
          --   
          --   Choice between:
          --   
          --   (1) valueSetUri
          --   
          --   (2) valueSetReference
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinitionBinding where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinitionBinding a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "strength"
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "valueSetUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "valueSetReference"))
                           ]
    schemaTypeToXML s x@OperationDefinitionBinding{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinitionBinding_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinitionBinding_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinitionBinding_modifierExtension x
            , schemaTypeToXML "strength" $ operationDefinitionBinding_strength x
            , foldOneOf2  (schemaTypeToXML "valueSetUri")
                          (schemaTypeToXML "valueSetReference")
                          $ operationDefinitionBinding_choice3 x
            ]
instance Extension OperationDefinitionBinding BackboneElement where
    supertype (OperationDefinitionBinding a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinitionBinding Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinitionBinding -> BackboneElement)
              
 
-- | A formal computable definition of an operation (on the 
--   RESTful interface) or a named query (using the search 
--   interaction).
data OperationDefinitionOverload = OperationDefinitionOverload
        { operationDefinitionOverload_id :: Maybe String_primitive
        , operationDefinitionOverload_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationDefinitionOverload_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationDefinitionOverload_parameterName :: [Xsd.XsdString]
          -- ^ Name of parameter to include in overload.
        , operationDefinitionOverload_comment :: Maybe Xsd.XsdString
          -- ^ Comments to go on overload.
        }
        deriving (Eq,Show)
instance SchemaType OperationDefinitionOverload where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationDefinitionOverload a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "parameterName")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@OperationDefinitionOverload{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationDefinitionOverload_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationDefinitionOverload_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationDefinitionOverload_modifierExtension x
            , concatMap (schemaTypeToXML "parameterName") $ operationDefinitionOverload_parameterName x
            , maybe [] (schemaTypeToXML "comment") $ operationDefinitionOverload_comment x
            ]
instance Extension OperationDefinitionOverload BackboneElement where
    supertype (OperationDefinitionOverload a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension OperationDefinitionOverload Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationDefinitionOverload -> BackboneElement)
              
 
data FHIRAllTypes_list
    = FHIRAllTypes_list_Address
      -- ^ Address
    | FHIRAllTypes_list_Age
      -- ^ Age
    | FHIRAllTypes_list_Annotation
      -- ^ Annotation
    | FHIRAllTypes_list_Attachment
      -- ^ Attachment
    | FHIRAllTypes_list_BackboneElement
      -- ^ BackboneElement
    | FHIRAllTypes_list_CodeableConcept
      -- ^ CodeableConcept
    | FHIRAllTypes_list_Coding
      -- ^ Coding
    | FHIRAllTypes_list_ContactDetail
      -- ^ ContactDetail
    | FHIRAllTypes_list_ContactPoint
      -- ^ ContactPoint
    | FHIRAllTypes_list_Contributor
      -- ^ Contributor
    | FHIRAllTypes_list_Count
      -- ^ Count
    | FHIRAllTypes_list_DataRequirement
      -- ^ DataRequirement
    | FHIRAllTypes_list_Distance
      -- ^ Distance
    | FHIRAllTypes_list_Dosage
      -- ^ Dosage
    | FHIRAllTypes_list_Duration
      -- ^ Duration
    | FHIRAllTypes_list_Element
      -- ^ Element
    | FHIRAllTypes_list_ElementDefinition
      -- ^ ElementDefinition
    | FHIRAllTypes_list_Extension
      -- ^ Extension
    | FHIRAllTypes_list_HumanName
      -- ^ HumanName
    | FHIRAllTypes_list_Identifier
      -- ^ Identifier
    | FHIRAllTypes_list_Meta
      -- ^ Meta
    | FHIRAllTypes_list_Money
      -- ^ Money
    | FHIRAllTypes_list_Narrative
      -- ^ Narrative
    | FHIRAllTypes_list_ParameterDefinition
      -- ^ ParameterDefinition
    | FHIRAllTypes_list_Period
      -- ^ Period
    | FHIRAllTypes_list_Quantity
      -- ^ Quantity
    | FHIRAllTypes_list_Range
      -- ^ Range
    | FHIRAllTypes_list_Ratio
      -- ^ Ratio
    | FHIRAllTypes_list_Reference
      -- ^ Reference
    | FHIRAllTypes_list_RelatedArtifact
      -- ^ RelatedArtifact
    | FHIRAllTypes_list_SampledData
      -- ^ SampledData
    | FHIRAllTypes_list_Signature
      -- ^ Signature
    | FHIRAllTypes_list_SimpleQuantity
      -- ^ SimpleQuantity
    | FHIRAllTypes_list_Timing
      -- ^ Timing
    | FHIRAllTypes_list_TriggerDefinition
      -- ^ TriggerDefinition
    | FHIRAllTypes_list_UsageContext
      -- ^ UsageContext
    | FHIRAllTypes_list_Base64Binary
      -- ^ base64Binary
    | FHIRAllTypes_list_Boolean
      -- ^ boolean
    | FHIRAllTypes_list_Code
      -- ^ code
    | FHIRAllTypes_list_Date
      -- ^ date
    | FHIRAllTypes_list_DateTime
      -- ^ dateTime
    | FHIRAllTypes_list_Decimal
      -- ^ decimal
    | FHIRAllTypes_list_Id
      -- ^ id
    | FHIRAllTypes_list_Instant
      -- ^ instant
    | FHIRAllTypes_list_Integer
      -- ^ integer
    | FHIRAllTypes_list_Markdown
      -- ^ markdown
    | FHIRAllTypes_list_Oid
      -- ^ oid
    | FHIRAllTypes_list_PositiveInt
      -- ^ positiveInt
    | FHIRAllTypes_list_Xsd.XsdString
      -- ^ string
    | FHIRAllTypes_list_Time
      -- ^ time
    | FHIRAllTypes_list_UnsignedInt
      -- ^ unsignedInt
    | FHIRAllTypes_list_Uri
      -- ^ uri
    | FHIRAllTypes_list_Uuid
      -- ^ uuid
    | FHIRAllTypes_list_Xhtml
      -- ^ XHTML
    | FHIRAllTypes_list_Account
      -- ^ Account
    | FHIRAllTypes_list_ActivityDefinition
      -- ^ ActivityDefinition
    | FHIRAllTypes_list_AdverseEvent
      -- ^ AdverseEvent
    | FHIRAllTypes_list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | FHIRAllTypes_list_Appointment
      -- ^ Appointment
    | FHIRAllTypes_list_AppointmentResponse
      -- ^ AppointmentResponse
    | FHIRAllTypes_list_AuditEvent
      -- ^ AuditEvent
    | FHIRAllTypes_list_Basic
      -- ^ Basic
    | FHIRAllTypes_list_Binary
      -- ^ Binary
    | FHIRAllTypes_list_BodySite
      -- ^ BodySite
    | FHIRAllTypes_list_Bundle
      -- ^ Bundle
    | FHIRAllTypes_list_CapabilityStatement
      -- ^ CapabilityStatement
    | FHIRAllTypes_list_CarePlan
      -- ^ CarePlan
    | FHIRAllTypes_list_CareTeam
      -- ^ CareTeam
    | FHIRAllTypes_list_ChargeItem
      -- ^ ChargeItem
    | FHIRAllTypes_list_Claim
      -- ^ Claim
    | FHIRAllTypes_list_ClaimResponse
      -- ^ ClaimResponse
    | FHIRAllTypes_list_ClinicalImpression
      -- ^ ClinicalImpression
    | FHIRAllTypes_list_CodeSystem
      -- ^ CodeSystem
    | FHIRAllTypes_list_Communication
      -- ^ Communication
    | FHIRAllTypes_list_CommunicationRequest
      -- ^ CommunicationRequest
    | FHIRAllTypes_list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | FHIRAllTypes_list_Composition
      -- ^ Composition
    | FHIRAllTypes_list_ConceptMap
      -- ^ ConceptMap
    | FHIRAllTypes_list_Condition
      -- ^ Condition
    | FHIRAllTypes_list_Consent
      -- ^ Consent
    | FHIRAllTypes_list_Contract
      -- ^ Contract
    | FHIRAllTypes_list_Coverage
      -- ^ Coverage
    | FHIRAllTypes_list_DataElement
      -- ^ DataElement
    | FHIRAllTypes_list_DetectedIssue
      -- ^ DetectedIssue
    | FHIRAllTypes_list_Device
      -- ^ Device
    | FHIRAllTypes_list_DeviceComponent
      -- ^ DeviceComponent
    | FHIRAllTypes_list_DeviceMetric
      -- ^ DeviceMetric
    | FHIRAllTypes_list_DeviceRequest
      -- ^ DeviceRequest
    | FHIRAllTypes_list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | FHIRAllTypes_list_DiagnosticReport
      -- ^ DiagnosticReport
    | FHIRAllTypes_list_DocumentManifest
      -- ^ DocumentManifest
    | FHIRAllTypes_list_DocumentReference
      -- ^ DocumentReference
    | FHIRAllTypes_list_DomainResource
      -- ^ DomainResource
    | FHIRAllTypes_list_EligibilityRequest
      -- ^ EligibilityRequest
    | FHIRAllTypes_list_EligibilityResponse
      -- ^ EligibilityResponse
    | FHIRAllTypes_list_Encounter
      -- ^ Encounter
    | FHIRAllTypes_list_Endpoint
      -- ^ Endpoint
    | FHIRAllTypes_list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | FHIRAllTypes_list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | FHIRAllTypes_list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | FHIRAllTypes_list_ExpansionProfile
      -- ^ ExpansionProfile
    | FHIRAllTypes_list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | FHIRAllTypes_list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | FHIRAllTypes_list_Flag
      -- ^ Flag
    | FHIRAllTypes_list_Goal
      -- ^ Goal
    | FHIRAllTypes_list_GraphDefinition
      -- ^ GraphDefinition
    | FHIRAllTypes_list_Group
      -- ^ Group
    | FHIRAllTypes_list_GuidanceResponse
      -- ^ GuidanceResponse
    | FHIRAllTypes_list_HealthcareService
      -- ^ HealthcareService
    | FHIRAllTypes_list_ImagingManifest
      -- ^ ImagingManifest
    | FHIRAllTypes_list_ImagingStudy
      -- ^ ImagingStudy
    | FHIRAllTypes_list_Immunization
      -- ^ Immunization
    | FHIRAllTypes_list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | FHIRAllTypes_list_ImplementationGuide
      -- ^ ImplementationGuide
    | FHIRAllTypes_list_Library
      -- ^ Library
    | FHIRAllTypes_list_Linkage
      -- ^ Linkage
    | FHIRAllTypes_list_List
      -- ^ List
    | FHIRAllTypes_list_Location
      -- ^ Location
    | FHIRAllTypes_list_Measure
      -- ^ Measure
    | FHIRAllTypes_list_MeasureReport
      -- ^ MeasureReport
    | FHIRAllTypes_list_Media
      -- ^ Media
    | FHIRAllTypes_list_Medication
      -- ^ Medication
    | FHIRAllTypes_list_MedicationAdministration
      -- ^ MedicationAdministration
    | FHIRAllTypes_list_MedicationDispense
      -- ^ MedicationDispense
    | FHIRAllTypes_list_MedicationRequest
      -- ^ MedicationRequest
    | FHIRAllTypes_list_MedicationStatement
      -- ^ MedicationStatement
    | FHIRAllTypes_list_MessageDefinition
      -- ^ MessageDefinition
    | FHIRAllTypes_list_MessageHeader
      -- ^ MessageHeader
    | FHIRAllTypes_list_NamingSystem
      -- ^ NamingSystem
    | FHIRAllTypes_list_NutritionOrder
      -- ^ NutritionOrder
    | FHIRAllTypes_list_Observation
      -- ^ Observation
    | FHIRAllTypes_list_OperationDefinition
      -- ^ OperationDefinition
    | FHIRAllTypes_list_OperationOutcome
      -- ^ OperationOutcome
    | FHIRAllTypes_list_Organization
      -- ^ Organization
    | FHIRAllTypes_list_Parameters
      -- ^ Parameters
    | FHIRAllTypes_list_Patient
      -- ^ Patient
    | FHIRAllTypes_list_PaymentNotice
      -- ^ PaymentNotice
    | FHIRAllTypes_list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | FHIRAllTypes_list_Person
      -- ^ Person
    | FHIRAllTypes_list_PlanDefinition
      -- ^ PlanDefinition
    | FHIRAllTypes_list_Practitioner
      -- ^ Practitioner
    | FHIRAllTypes_list_PractitionerRole
      -- ^ PractitionerRole
    | FHIRAllTypes_list_Procedure
      -- ^ Procedure
    | FHIRAllTypes_list_ProcedureRequest
      -- ^ ProcedureRequest
    | FHIRAllTypes_list_ProcessRequest
      -- ^ ProcessRequest
    | FHIRAllTypes_list_ProcessResponse
      -- ^ ProcessResponse
    | FHIRAllTypes_list_Provenance
      -- ^ Provenance
    | FHIRAllTypes_list_Questionnaire
      -- ^ Questionnaire
    | FHIRAllTypes_list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | FHIRAllTypes_list_ReferralRequest
      -- ^ ReferralRequest
    | FHIRAllTypes_list_RelatedPerson
      -- ^ RelatedPerson
    | FHIRAllTypes_list_RequestGroup
      -- ^ RequestGroup
    | FHIRAllTypes_list_ResearchStudy
      -- ^ ResearchStudy
    | FHIRAllTypes_list_ResearchSubject
      -- ^ ResearchSubject
    | FHIRAllTypes_list_Resource
      -- ^ Resource
    | FHIRAllTypes_list_RiskAssessment
      -- ^ RiskAssessment
    | FHIRAllTypes_list_Schedule
      -- ^ Schedule
    | FHIRAllTypes_list_SearchParameter
      -- ^ SearchParameter
    | FHIRAllTypes_list_Sequence
      -- ^ Sequence
    | FHIRAllTypes_list_ServiceDefinition
      -- ^ ServiceDefinition
    | FHIRAllTypes_list_Slot
      -- ^ Slot
    | FHIRAllTypes_list_Specimen
      -- ^ Specimen
    | FHIRAllTypes_list_StructureDefinition
      -- ^ StructureDefinition
    | FHIRAllTypes_list_StructureMap
      -- ^ StructureMap
    | FHIRAllTypes_list_Subscription
      -- ^ Subscription
    | FHIRAllTypes_list_Substance
      -- ^ Substance
    | FHIRAllTypes_list_SupplyDelivery
      -- ^ SupplyDelivery
    | FHIRAllTypes_list_SupplyRequest
      -- ^ SupplyRequest
    | FHIRAllTypes_list_Task
      -- ^ Task
    | FHIRAllTypes_list_TestReport
      -- ^ TestReport
    | FHIRAllTypes_list_TestScript
      -- ^ TestScript
    | FHIRAllTypes_list_ValueSet
      -- ^ ValueSet
    | FHIRAllTypes_list_VisionPrescription
      -- ^ VisionPrescription
    | FHIRAllTypes_list_Type
      -- ^ Type
    | FHIRAllTypes_list_Any
      -- ^ Any
    deriving (Eq,Show,Enum)
instance SchemaType FHIRAllTypes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRAllTypes_list where
    acceptingParser =  do literal "Address"; return FHIRAllTypes_list_Address
                      `onFail` do literal "Age"; return FHIRAllTypes_list_Age
                      `onFail` do literal "Annotation"; return FHIRAllTypes_list_Annotation
                      `onFail` do literal "Attachment"; return FHIRAllTypes_list_Attachment
                      `onFail` do literal "BackboneElement"; return FHIRAllTypes_list_BackboneElement
                      `onFail` do literal "CodeableConcept"; return FHIRAllTypes_list_CodeableConcept
                      `onFail` do literal "Coding"; return FHIRAllTypes_list_Coding
                      `onFail` do literal "ContactDetail"; return FHIRAllTypes_list_ContactDetail
                      `onFail` do literal "ContactPoint"; return FHIRAllTypes_list_ContactPoint
                      `onFail` do literal "Contributor"; return FHIRAllTypes_list_Contributor
                      `onFail` do literal "Count"; return FHIRAllTypes_list_Count
                      `onFail` do literal "DataRequirement"; return FHIRAllTypes_list_DataRequirement
                      `onFail` do literal "Distance"; return FHIRAllTypes_list_Distance
                      `onFail` do literal "Dosage"; return FHIRAllTypes_list_Dosage
                      `onFail` do literal "Duration"; return FHIRAllTypes_list_Duration
                      `onFail` do literal "Element"; return FHIRAllTypes_list_Element
                      `onFail` do literal "ElementDefinition"; return FHIRAllTypes_list_ElementDefinition
                      `onFail` do literal "Extension"; return FHIRAllTypes_list_Extension
                      `onFail` do literal "HumanName"; return FHIRAllTypes_list_HumanName
                      `onFail` do literal "Identifier"; return FHIRAllTypes_list_Identifier
                      `onFail` do literal "Meta"; return FHIRAllTypes_list_Meta
                      `onFail` do literal "Money"; return FHIRAllTypes_list_Money
                      `onFail` do literal "Narrative"; return FHIRAllTypes_list_Narrative
                      `onFail` do literal "ParameterDefinition"; return FHIRAllTypes_list_ParameterDefinition
                      `onFail` do literal "Period"; return FHIRAllTypes_list_Period
                      `onFail` do literal "Quantity"; return FHIRAllTypes_list_Quantity
                      `onFail` do literal "Range"; return FHIRAllTypes_list_Range
                      `onFail` do literal "Ratio"; return FHIRAllTypes_list_Ratio
                      `onFail` do literal "Reference"; return FHIRAllTypes_list_Reference
                      `onFail` do literal "RelatedArtifact"; return FHIRAllTypes_list_RelatedArtifact
                      `onFail` do literal "SampledData"; return FHIRAllTypes_list_SampledData
                      `onFail` do literal "Signature"; return FHIRAllTypes_list_Signature
                      `onFail` do literal "SimpleQuantity"; return FHIRAllTypes_list_SimpleQuantity
                      `onFail` do literal "Timing"; return FHIRAllTypes_list_Timing
                      `onFail` do literal "TriggerDefinition"; return FHIRAllTypes_list_TriggerDefinition
                      `onFail` do literal "UsageContext"; return FHIRAllTypes_list_UsageContext
                      `onFail` do literal "base64Binary"; return FHIRAllTypes_list_Base64Binary
                      `onFail` do literal "boolean"; return FHIRAllTypes_list_Boolean
                      `onFail` do literal "code"; return FHIRAllTypes_list_Code
                      `onFail` do literal "date"; return FHIRAllTypes_list_Date
                      `onFail` do literal "dateTime"; return FHIRAllTypes_list_DateTime
                      `onFail` do literal "decimal"; return FHIRAllTypes_list_Decimal
                      `onFail` do literal "id"; return FHIRAllTypes_list_Id
                      `onFail` do literal "instant"; return FHIRAllTypes_list_Instant
                      `onFail` do literal "integer"; return FHIRAllTypes_list_Integer
                      `onFail` do literal "markdown"; return FHIRAllTypes_list_Markdown
                      `onFail` do literal "oid"; return FHIRAllTypes_list_Oid
                      `onFail` do literal "positiveInt"; return FHIRAllTypes_list_PositiveInt
                      `onFail` do literal "string"; return FHIRAllTypes_list_Xsd.XsdString
                      `onFail` do literal "time"; return FHIRAllTypes_list_Time
                      `onFail` do literal "unsignedInt"; return FHIRAllTypes_list_UnsignedInt
                      `onFail` do literal "uri"; return FHIRAllTypes_list_Uri
                      `onFail` do literal "uuid"; return FHIRAllTypes_list_Uuid
                      `onFail` do literal "xhtml"; return FHIRAllTypes_list_Xhtml
                      `onFail` do literal "Account"; return FHIRAllTypes_list_Account
                      `onFail` do literal "ActivityDefinition"; return FHIRAllTypes_list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return FHIRAllTypes_list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return FHIRAllTypes_list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return FHIRAllTypes_list_Appointment
                      `onFail` do literal "AppointmentResponse"; return FHIRAllTypes_list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return FHIRAllTypes_list_AuditEvent
                      `onFail` do literal "Basic"; return FHIRAllTypes_list_Basic
                      `onFail` do literal "Binary"; return FHIRAllTypes_list_Binary
                      `onFail` do literal "BodySite"; return FHIRAllTypes_list_BodySite
                      `onFail` do literal "Bundle"; return FHIRAllTypes_list_Bundle
                      `onFail` do literal "CapabilityStatement"; return FHIRAllTypes_list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return FHIRAllTypes_list_CarePlan
                      `onFail` do literal "CareTeam"; return FHIRAllTypes_list_CareTeam
                      `onFail` do literal "ChargeItem"; return FHIRAllTypes_list_ChargeItem
                      `onFail` do literal "Claim"; return FHIRAllTypes_list_Claim
                      `onFail` do literal "ClaimResponse"; return FHIRAllTypes_list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return FHIRAllTypes_list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return FHIRAllTypes_list_CodeSystem
                      `onFail` do literal "Communication"; return FHIRAllTypes_list_Communication
                      `onFail` do literal "CommunicationRequest"; return FHIRAllTypes_list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return FHIRAllTypes_list_CompartmentDefinition
                      `onFail` do literal "Composition"; return FHIRAllTypes_list_Composition
                      `onFail` do literal "ConceptMap"; return FHIRAllTypes_list_ConceptMap
                      `onFail` do literal "Condition"; return FHIRAllTypes_list_Condition
                      `onFail` do literal "Consent"; return FHIRAllTypes_list_Consent
                      `onFail` do literal "Contract"; return FHIRAllTypes_list_Contract
                      `onFail` do literal "Coverage"; return FHIRAllTypes_list_Coverage
                      `onFail` do literal "DataElement"; return FHIRAllTypes_list_DataElement
                      `onFail` do literal "DetectedIssue"; return FHIRAllTypes_list_DetectedIssue
                      `onFail` do literal "Device"; return FHIRAllTypes_list_Device
                      `onFail` do literal "DeviceComponent"; return FHIRAllTypes_list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return FHIRAllTypes_list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return FHIRAllTypes_list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return FHIRAllTypes_list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return FHIRAllTypes_list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return FHIRAllTypes_list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return FHIRAllTypes_list_DocumentReference
                      `onFail` do literal "DomainResource"; return FHIRAllTypes_list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return FHIRAllTypes_list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return FHIRAllTypes_list_EligibilityResponse
                      `onFail` do literal "Encounter"; return FHIRAllTypes_list_Encounter
                      `onFail` do literal "Endpoint"; return FHIRAllTypes_list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return FHIRAllTypes_list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return FHIRAllTypes_list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return FHIRAllTypes_list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return FHIRAllTypes_list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return FHIRAllTypes_list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return FHIRAllTypes_list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return FHIRAllTypes_list_Flag
                      `onFail` do literal "Goal"; return FHIRAllTypes_list_Goal
                      `onFail` do literal "GraphDefinition"; return FHIRAllTypes_list_GraphDefinition
                      `onFail` do literal "Group"; return FHIRAllTypes_list_Group
                      `onFail` do literal "GuidanceResponse"; return FHIRAllTypes_list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return FHIRAllTypes_list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return FHIRAllTypes_list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return FHIRAllTypes_list_ImagingStudy
                      `onFail` do literal "Immunization"; return FHIRAllTypes_list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return FHIRAllTypes_list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return FHIRAllTypes_list_ImplementationGuide
                      `onFail` do literal "Library"; return FHIRAllTypes_list_Library
                      `onFail` do literal "Linkage"; return FHIRAllTypes_list_Linkage
                      `onFail` do literal "List"; return FHIRAllTypes_list_List
                      `onFail` do literal "Location"; return FHIRAllTypes_list_Location
                      `onFail` do literal "Measure"; return FHIRAllTypes_list_Measure
                      `onFail` do literal "MeasureReport"; return FHIRAllTypes_list_MeasureReport
                      `onFail` do literal "Media"; return FHIRAllTypes_list_Media
                      `onFail` do literal "Medication"; return FHIRAllTypes_list_Medication
                      `onFail` do literal "MedicationAdministration"; return FHIRAllTypes_list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return FHIRAllTypes_list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return FHIRAllTypes_list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return FHIRAllTypes_list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return FHIRAllTypes_list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return FHIRAllTypes_list_MessageHeader
                      `onFail` do literal "NamingSystem"; return FHIRAllTypes_list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return FHIRAllTypes_list_NutritionOrder
                      `onFail` do literal "Observation"; return FHIRAllTypes_list_Observation
                      `onFail` do literal "OperationDefinition"; return FHIRAllTypes_list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return FHIRAllTypes_list_OperationOutcome
                      `onFail` do literal "Organization"; return FHIRAllTypes_list_Organization
                      `onFail` do literal "Parameters"; return FHIRAllTypes_list_Parameters
                      `onFail` do literal "Patient"; return FHIRAllTypes_list_Patient
                      `onFail` do literal "PaymentNotice"; return FHIRAllTypes_list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return FHIRAllTypes_list_PaymentReconciliation
                      `onFail` do literal "Person"; return FHIRAllTypes_list_Person
                      `onFail` do literal "PlanDefinition"; return FHIRAllTypes_list_PlanDefinition
                      `onFail` do literal "Practitioner"; return FHIRAllTypes_list_Practitioner
                      `onFail` do literal "PractitionerRole"; return FHIRAllTypes_list_PractitionerRole
                      `onFail` do literal "Procedure"; return FHIRAllTypes_list_Procedure
                      `onFail` do literal "ProcedureRequest"; return FHIRAllTypes_list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return FHIRAllTypes_list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return FHIRAllTypes_list_ProcessResponse
                      `onFail` do literal "Provenance"; return FHIRAllTypes_list_Provenance
                      `onFail` do literal "Questionnaire"; return FHIRAllTypes_list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return FHIRAllTypes_list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return FHIRAllTypes_list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return FHIRAllTypes_list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return FHIRAllTypes_list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return FHIRAllTypes_list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return FHIRAllTypes_list_ResearchSubject
                      `onFail` do literal "Resource"; return FHIRAllTypes_list_Resource
                      `onFail` do literal "RiskAssessment"; return FHIRAllTypes_list_RiskAssessment
                      `onFail` do literal "Schedule"; return FHIRAllTypes_list_Schedule
                      `onFail` do literal "SearchParameter"; return FHIRAllTypes_list_SearchParameter
                      `onFail` do literal "Sequence"; return FHIRAllTypes_list_Sequence
                      `onFail` do literal "ServiceDefinition"; return FHIRAllTypes_list_ServiceDefinition
                      `onFail` do literal "Slot"; return FHIRAllTypes_list_Slot
                      `onFail` do literal "Specimen"; return FHIRAllTypes_list_Specimen
                      `onFail` do literal "StructureDefinition"; return FHIRAllTypes_list_StructureDefinition
                      `onFail` do literal "StructureMap"; return FHIRAllTypes_list_StructureMap
                      `onFail` do literal "Subscription"; return FHIRAllTypes_list_Subscription
                      `onFail` do literal "Substance"; return FHIRAllTypes_list_Substance
                      `onFail` do literal "SupplyDelivery"; return FHIRAllTypes_list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return FHIRAllTypes_list_SupplyRequest
                      `onFail` do literal "Task"; return FHIRAllTypes_list_Task
                      `onFail` do literal "TestReport"; return FHIRAllTypes_list_TestReport
                      `onFail` do literal "TestScript"; return FHIRAllTypes_list_TestScript
                      `onFail` do literal "ValueSet"; return FHIRAllTypes_list_ValueSet
                      `onFail` do literal "VisionPrescription"; return FHIRAllTypes_list_VisionPrescription
                      `onFail` do literal "Type"; return FHIRAllTypes_list_Type
                      `onFail` do literal "Any"; return FHIRAllTypes_list_Any
                      
    simpleTypeText FHIRAllTypes_list_Address = "Address"
    simpleTypeText FHIRAllTypes_list_Age = "Age"
    simpleTypeText FHIRAllTypes_list_Annotation = "Annotation"
    simpleTypeText FHIRAllTypes_list_Attachment = "Attachment"
    simpleTypeText FHIRAllTypes_list_BackboneElement = "BackboneElement"
    simpleTypeText FHIRAllTypes_list_CodeableConcept = "CodeableConcept"
    simpleTypeText FHIRAllTypes_list_Coding = "Coding"
    simpleTypeText FHIRAllTypes_list_ContactDetail = "ContactDetail"
    simpleTypeText FHIRAllTypes_list_ContactPoint = "ContactPoint"
    simpleTypeText FHIRAllTypes_list_Contributor = "Contributor"
    simpleTypeText FHIRAllTypes_list_Count = "Count"
    simpleTypeText FHIRAllTypes_list_DataRequirement = "DataRequirement"
    simpleTypeText FHIRAllTypes_list_Distance = "Distance"
    simpleTypeText FHIRAllTypes_list_Dosage = "Dosage"
    simpleTypeText FHIRAllTypes_list_Duration = "Duration"
    simpleTypeText FHIRAllTypes_list_Element = "Element"
    simpleTypeText FHIRAllTypes_list_ElementDefinition = "ElementDefinition"
    simpleTypeText FHIRAllTypes_list_Extension = "Extension"
    simpleTypeText FHIRAllTypes_list_HumanName = "HumanName"
    simpleTypeText FHIRAllTypes_list_Identifier = "Identifier"
    simpleTypeText FHIRAllTypes_list_Meta = "Meta"
    simpleTypeText FHIRAllTypes_list_Money = "Money"
    simpleTypeText FHIRAllTypes_list_Narrative = "Narrative"
    simpleTypeText FHIRAllTypes_list_ParameterDefinition = "ParameterDefinition"
    simpleTypeText FHIRAllTypes_list_Period = "Period"
    simpleTypeText FHIRAllTypes_list_Quantity = "Quantity"
    simpleTypeText FHIRAllTypes_list_Range = "Range"
    simpleTypeText FHIRAllTypes_list_Ratio = "Ratio"
    simpleTypeText FHIRAllTypes_list_Reference = "Reference"
    simpleTypeText FHIRAllTypes_list_RelatedArtifact = "RelatedArtifact"
    simpleTypeText FHIRAllTypes_list_SampledData = "SampledData"
    simpleTypeText FHIRAllTypes_list_Signature = "Signature"
    simpleTypeText FHIRAllTypes_list_SimpleQuantity = "SimpleQuantity"
    simpleTypeText FHIRAllTypes_list_Timing = "Timing"
    simpleTypeText FHIRAllTypes_list_TriggerDefinition = "TriggerDefinition"
    simpleTypeText FHIRAllTypes_list_UsageContext = "UsageContext"
    simpleTypeText FHIRAllTypes_list_Base64Binary = "base64Binary"
    simpleTypeText FHIRAllTypes_list_Boolean = "boolean"
    simpleTypeText FHIRAllTypes_list_Code = "code"
    simpleTypeText FHIRAllTypes_list_Date = "date"
    simpleTypeText FHIRAllTypes_list_DateTime = "dateTime"
    simpleTypeText FHIRAllTypes_list_Decimal = "decimal"
    simpleTypeText FHIRAllTypes_list_Id = "id"
    simpleTypeText FHIRAllTypes_list_Instant = "instant"
    simpleTypeText FHIRAllTypes_list_Integer = "integer"
    simpleTypeText FHIRAllTypes_list_Markdown = "markdown"
    simpleTypeText FHIRAllTypes_list_Oid = "oid"
    simpleTypeText FHIRAllTypes_list_PositiveInt = "positiveInt"
    simpleTypeText FHIRAllTypes_list_Xsd.XsdString = "string"
    simpleTypeText FHIRAllTypes_list_Time = "time"
    simpleTypeText FHIRAllTypes_list_UnsignedInt = "unsignedInt"
    simpleTypeText FHIRAllTypes_list_Uri = "uri"
    simpleTypeText FHIRAllTypes_list_Uuid = "uuid"
    simpleTypeText FHIRAllTypes_list_Xhtml = "xhtml"
    simpleTypeText FHIRAllTypes_list_Account = "Account"
    simpleTypeText FHIRAllTypes_list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText FHIRAllTypes_list_AdverseEvent = "AdverseEvent"
    simpleTypeText FHIRAllTypes_list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText FHIRAllTypes_list_Appointment = "Appointment"
    simpleTypeText FHIRAllTypes_list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText FHIRAllTypes_list_AuditEvent = "AuditEvent"
    simpleTypeText FHIRAllTypes_list_Basic = "Basic"
    simpleTypeText FHIRAllTypes_list_Binary = "Binary"
    simpleTypeText FHIRAllTypes_list_BodySite = "BodySite"
    simpleTypeText FHIRAllTypes_list_Bundle = "Bundle"
    simpleTypeText FHIRAllTypes_list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText FHIRAllTypes_list_CarePlan = "CarePlan"
    simpleTypeText FHIRAllTypes_list_CareTeam = "CareTeam"
    simpleTypeText FHIRAllTypes_list_ChargeItem = "ChargeItem"
    simpleTypeText FHIRAllTypes_list_Claim = "Claim"
    simpleTypeText FHIRAllTypes_list_ClaimResponse = "ClaimResponse"
    simpleTypeText FHIRAllTypes_list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText FHIRAllTypes_list_CodeSystem = "CodeSystem"
    simpleTypeText FHIRAllTypes_list_Communication = "Communication"
    simpleTypeText FHIRAllTypes_list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText FHIRAllTypes_list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText FHIRAllTypes_list_Composition = "Composition"
    simpleTypeText FHIRAllTypes_list_ConceptMap = "ConceptMap"
    simpleTypeText FHIRAllTypes_list_Condition = "Condition"
    simpleTypeText FHIRAllTypes_list_Consent = "Consent"
    simpleTypeText FHIRAllTypes_list_Contract = "Contract"
    simpleTypeText FHIRAllTypes_list_Coverage = "Coverage"
    simpleTypeText FHIRAllTypes_list_DataElement = "DataElement"
    simpleTypeText FHIRAllTypes_list_DetectedIssue = "DetectedIssue"
    simpleTypeText FHIRAllTypes_list_Device = "Device"
    simpleTypeText FHIRAllTypes_list_DeviceComponent = "DeviceComponent"
    simpleTypeText FHIRAllTypes_list_DeviceMetric = "DeviceMetric"
    simpleTypeText FHIRAllTypes_list_DeviceRequest = "DeviceRequest"
    simpleTypeText FHIRAllTypes_list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText FHIRAllTypes_list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText FHIRAllTypes_list_DocumentManifest = "DocumentManifest"
    simpleTypeText FHIRAllTypes_list_DocumentReference = "DocumentReference"
    simpleTypeText FHIRAllTypes_list_DomainResource = "DomainResource"
    simpleTypeText FHIRAllTypes_list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText FHIRAllTypes_list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText FHIRAllTypes_list_Encounter = "Encounter"
    simpleTypeText FHIRAllTypes_list_Endpoint = "Endpoint"
    simpleTypeText FHIRAllTypes_list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText FHIRAllTypes_list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText FHIRAllTypes_list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText FHIRAllTypes_list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText FHIRAllTypes_list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText FHIRAllTypes_list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText FHIRAllTypes_list_Flag = "Flag"
    simpleTypeText FHIRAllTypes_list_Goal = "Goal"
    simpleTypeText FHIRAllTypes_list_GraphDefinition = "GraphDefinition"
    simpleTypeText FHIRAllTypes_list_Group = "Group"
    simpleTypeText FHIRAllTypes_list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText FHIRAllTypes_list_HealthcareService = "HealthcareService"
    simpleTypeText FHIRAllTypes_list_ImagingManifest = "ImagingManifest"
    simpleTypeText FHIRAllTypes_list_ImagingStudy = "ImagingStudy"
    simpleTypeText FHIRAllTypes_list_Immunization = "Immunization"
    simpleTypeText FHIRAllTypes_list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText FHIRAllTypes_list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText FHIRAllTypes_list_Library = "Library"
    simpleTypeText FHIRAllTypes_list_Linkage = "Linkage"
    simpleTypeText FHIRAllTypes_list_List = "List"
    simpleTypeText FHIRAllTypes_list_Location = "Location"
    simpleTypeText FHIRAllTypes_list_Measure = "Measure"
    simpleTypeText FHIRAllTypes_list_MeasureReport = "MeasureReport"
    simpleTypeText FHIRAllTypes_list_Media = "Media"
    simpleTypeText FHIRAllTypes_list_Medication = "Medication"
    simpleTypeText FHIRAllTypes_list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText FHIRAllTypes_list_MedicationDispense = "MedicationDispense"
    simpleTypeText FHIRAllTypes_list_MedicationRequest = "MedicationRequest"
    simpleTypeText FHIRAllTypes_list_MedicationStatement = "MedicationStatement"
    simpleTypeText FHIRAllTypes_list_MessageDefinition = "MessageDefinition"
    simpleTypeText FHIRAllTypes_list_MessageHeader = "MessageHeader"
    simpleTypeText FHIRAllTypes_list_NamingSystem = "NamingSystem"
    simpleTypeText FHIRAllTypes_list_NutritionOrder = "NutritionOrder"
    simpleTypeText FHIRAllTypes_list_Observation = "Observation"
    simpleTypeText FHIRAllTypes_list_OperationDefinition = "OperationDefinition"
    simpleTypeText FHIRAllTypes_list_OperationOutcome = "OperationOutcome"
    simpleTypeText FHIRAllTypes_list_Organization = "Organization"
    simpleTypeText FHIRAllTypes_list_Parameters = "Parameters"
    simpleTypeText FHIRAllTypes_list_Patient = "Patient"
    simpleTypeText FHIRAllTypes_list_PaymentNotice = "PaymentNotice"
    simpleTypeText FHIRAllTypes_list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText FHIRAllTypes_list_Person = "Person"
    simpleTypeText FHIRAllTypes_list_PlanDefinition = "PlanDefinition"
    simpleTypeText FHIRAllTypes_list_Practitioner = "Practitioner"
    simpleTypeText FHIRAllTypes_list_PractitionerRole = "PractitionerRole"
    simpleTypeText FHIRAllTypes_list_Procedure = "Procedure"
    simpleTypeText FHIRAllTypes_list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText FHIRAllTypes_list_ProcessRequest = "ProcessRequest"
    simpleTypeText FHIRAllTypes_list_ProcessResponse = "ProcessResponse"
    simpleTypeText FHIRAllTypes_list_Provenance = "Provenance"
    simpleTypeText FHIRAllTypes_list_Questionnaire = "Questionnaire"
    simpleTypeText FHIRAllTypes_list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText FHIRAllTypes_list_ReferralRequest = "ReferralRequest"
    simpleTypeText FHIRAllTypes_list_RelatedPerson = "RelatedPerson"
    simpleTypeText FHIRAllTypes_list_RequestGroup = "RequestGroup"
    simpleTypeText FHIRAllTypes_list_ResearchStudy = "ResearchStudy"
    simpleTypeText FHIRAllTypes_list_ResearchSubject = "ResearchSubject"
    simpleTypeText FHIRAllTypes_list_Resource = "Resource"
    simpleTypeText FHIRAllTypes_list_RiskAssessment = "RiskAssessment"
    simpleTypeText FHIRAllTypes_list_Schedule = "Schedule"
    simpleTypeText FHIRAllTypes_list_SearchParameter = "SearchParameter"
    simpleTypeText FHIRAllTypes_list_Sequence = "Sequence"
    simpleTypeText FHIRAllTypes_list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText FHIRAllTypes_list_Slot = "Slot"
    simpleTypeText FHIRAllTypes_list_Specimen = "Specimen"
    simpleTypeText FHIRAllTypes_list_StructureDefinition = "StructureDefinition"
    simpleTypeText FHIRAllTypes_list_StructureMap = "StructureMap"
    simpleTypeText FHIRAllTypes_list_Subscription = "Subscription"
    simpleTypeText FHIRAllTypes_list_Substance = "Substance"
    simpleTypeText FHIRAllTypes_list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText FHIRAllTypes_list_SupplyRequest = "SupplyRequest"
    simpleTypeText FHIRAllTypes_list_Task = "Task"
    simpleTypeText FHIRAllTypes_list_TestReport = "TestReport"
    simpleTypeText FHIRAllTypes_list_TestScript = "TestScript"
    simpleTypeText FHIRAllTypes_list_ValueSet = "ValueSet"
    simpleTypeText FHIRAllTypes_list_VisionPrescription = "VisionPrescription"
    simpleTypeText FHIRAllTypes_list_Type = "Type"
    simpleTypeText FHIRAllTypes_list_Any = "Any"
 
data FHIRAllTypes = FHIRAllTypes
        { fHIRAllTypes_id :: Maybe String_primitive
        , fHIRAllTypes_value :: Maybe FHIRAllTypes_list
        , fHIRAllTypes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRAllTypes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRAllTypes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRAllTypes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRAllTypes_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRAllTypes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRAllTypes_extension x
            ]
instance Extension FHIRAllTypes Element where
    supertype (FHIRAllTypes a0 a1 e0) =
               Element a0 e0
 
data OperationParameterUse_list
    = OperationParameterUse_list_In
      -- ^ In
    | OperationParameterUse_list_Out
      -- ^ Out
    deriving (Eq,Show,Enum)
instance SchemaType OperationParameterUse_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType OperationParameterUse_list where
    acceptingParser =  do literal "in"; return OperationParameterUse_list_In
                      `onFail` do literal "out"; return OperationParameterUse_list_Out
                      
    simpleTypeText OperationParameterUse_list_In = "in"
    simpleTypeText OperationParameterUse_list_Out = "out"
 
data OperationParameterUse = OperationParameterUse
        { operationParameterUse_id :: Maybe String_primitive
        , operationParameterUse_value :: Maybe OperationParameterUse_list
        , operationParameterUse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType OperationParameterUse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (OperationParameterUse a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@OperationParameterUse{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationParameterUse_id x
                       , maybe [] (toXMLAttribute "value") $ operationParameterUse_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationParameterUse_extension x
            ]
instance Extension OperationParameterUse Element where
    supertype (OperationParameterUse a0 a1 e0) =
               Element a0 e0
 
data OperationKind_list
    = OperationKind_list_Operation
      -- ^ Operation
    | OperationKind_list_Query
      -- ^ Query
    deriving (Eq,Show,Enum)
instance SchemaType OperationKind_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType OperationKind_list where
    acceptingParser =  do literal "operation"; return OperationKind_list_Operation
                      `onFail` do literal "query"; return OperationKind_list_Query
                      
    simpleTypeText OperationKind_list_Operation = "operation"
    simpleTypeText OperationKind_list_Query = "query"
 
data OperationKind = OperationKind
        { operationKind_id :: Maybe String_primitive
        , operationKind_value :: Maybe OperationKind_list
        , operationKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType OperationKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (OperationKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@OperationKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationKind_id x
                       , maybe [] (toXMLAttribute "value") $ operationKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationKind_extension x
            ]
instance Extension OperationKind Element where
    supertype (OperationKind a0 a1 e0) =
               Element a0 e0
 
-- | A collection of error, warning or information messages that 
--   result from a system action.
elementOperationOutcome :: XMLParser OperationOutcome
elementOperationOutcome = parseSchemaType "OperationOutcome"
elementToXMLOperationOutcome :: OperationOutcome -> [Content ()]
elementToXMLOperationOutcome = schemaTypeToXML "OperationOutcome"
 
data OperationOutcome = OperationOutcome
        { operationOutcome_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , operationOutcome_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , operationOutcome_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , operationOutcome_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , operationOutcome_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , operationOutcome_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , operationOutcome_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationOutcome_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationOutcome_issue :: [OperationOutcomeIssue]
          -- ^ An error, warning or information message that results from 
          --   a system action.
        }
        deriving (Eq,Show)
instance SchemaType OperationOutcome where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return OperationOutcome
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "issue")
    schemaTypeToXML s x@OperationOutcome{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ operationOutcome_id x
            , maybe [] (schemaTypeToXML "meta") $ operationOutcome_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ operationOutcome_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ operationOutcome_language x
            , maybe [] (schemaTypeToXML "text") $ operationOutcome_text x
            , concatMap (schemaTypeToXML "contained") $ operationOutcome_contained x
            , concatMap (schemaTypeToXML "extension") $ operationOutcome_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationOutcome_modifierExtension x
            , concatMap (schemaTypeToXML "issue") $ operationOutcome_issue x
            ]
instance Extension OperationOutcome DomainResource where
    supertype (OperationOutcome e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension OperationOutcome Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: OperationOutcome -> DomainResource)
              
 
-- | A collection of error, warning or information messages that 
--   result from a system action.
data OperationOutcomeIssue = OperationOutcomeIssue
        { operationOutcomeIssue_id :: Maybe String_primitive
        , operationOutcomeIssue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , operationOutcomeIssue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , operationOutcomeIssue_severity :: IssueSeverity
          -- ^ Indicates whether the issue indicates a variation from 
          --   successful processing.
        , operationOutcomeIssue_code :: IssueType
          -- ^ Describes the type of the issue. The system that creates an 
          --   OperationOutcome SHALL choose the most applicable code from 
          --   the IssueType value set, and may additional provide its own 
          --   code for the error in the details element.
        , operationOutcomeIssue_details :: Maybe CodeableConcept
          -- ^ Additional details about the error. This may be a text 
          --   description of the error, or a system code that identifies 
          --   the error.
        , operationOutcomeIssue_diagnostics :: Maybe Xsd.XsdString
          -- ^ Additional diagnostic information about the issue. 
          --   Typically, this may be a description of how a value is 
          --   erroneous, or a stack dump to help trace the issue.
        , operationOutcomeIssue_location :: [Xsd.XsdString]
          -- ^ For resource issues, this will be a simple XPath limited to 
          --   element names, repetition indicators and the default child 
          --   access that identifies one of the elements in the resource 
          --   that caused this issue to be raised. For HTTP errors, will 
          --   be &quot;http.&quot; + the parameter name.
        , operationOutcomeIssue_expression :: [Xsd.XsdString]
          -- ^ A simple FHIRPath limited to element names, repetition 
          --   indicators and the default child access that identifies one 
          --   of the elements in the resource that caused this issue to 
          --   be raised.
        }
        deriving (Eq,Show)
instance SchemaType OperationOutcomeIssue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OperationOutcomeIssue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "severity"
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "details")
            `apply` optional (parseSchemaType "diagnostics")
            `apply` many (parseSchemaType "location")
            `apply` many (parseSchemaType "expression")
    schemaTypeToXML s x@OperationOutcomeIssue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ operationOutcomeIssue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ operationOutcomeIssue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ operationOutcomeIssue_modifierExtension x
            , schemaTypeToXML "severity" $ operationOutcomeIssue_severity x
            , schemaTypeToXML "code" $ operationOutcomeIssue_code x
            , maybe [] (schemaTypeToXML "details") $ operationOutcomeIssue_details x
            , maybe [] (schemaTypeToXML "diagnostics") $ operationOutcomeIssue_diagnostics x
            , concatMap (schemaTypeToXML "location") $ operationOutcomeIssue_location x
            , concatMap (schemaTypeToXML "expression") $ operationOutcomeIssue_expression x
            ]
instance Extension OperationOutcomeIssue BackboneElement where
    supertype (OperationOutcomeIssue a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension OperationOutcomeIssue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OperationOutcomeIssue -> BackboneElement)
              
 
data IssueType_list
    = IssueType_list_Invalid
      -- ^ Invalid Content
    | IssueType_list_Structure
      -- ^ Structural Issue
    | IssueType_list_Required
      -- ^ Required element missing
    | IssueType_list_Value
      -- ^ Element value invalid
    | IssueType_list_Invariant
      -- ^ Validation rule failed
    | IssueType_list_Security
      -- ^ Security Problem
    | IssueType_list_Login
      -- ^ Login Required
    | IssueType_list_Unknown
      -- ^ Unknown User
    | IssueType_list_Expired
      -- ^ Session Expired
    | IssueType_list_Forbidden
      -- ^ Forbidden
    | IssueType_list_Suppressed
      -- ^ Information Suppressed
    | IssueType_list_Processing
      -- ^ Processing Failure
    | IssueType_list_Not_supported
      -- ^ Content not supported
    | IssueType_list_Duplicate
      -- ^ Duplicate
    | IssueType_list_Not_found
      -- ^ Not Found
    | IssueType_list_Too_long
      -- ^ Content Too Long
    | IssueType_list_Code_invalid
      -- ^ Invalid Code
    | IssueType_list_Extension
      -- ^ Unacceptable Extension
    | IssueType_list_Too_costly
      -- ^ Operation Too Costly
    | IssueType_list_Business_rule
      -- ^ Business Rule Violation
    | IssueType_list_Conflict
      -- ^ Edit Version Conflict
    | IssueType_list_Incomplete
      -- ^ Incomplete Results
    | IssueType_list_Transient
      -- ^ Transient Issue
    | IssueType_list_Lock_error
      -- ^ Lock Error
    | IssueType_list_No_store
      -- ^ No Store Available
    | IssueType_list_Exception
      -- ^ Exception
    | IssueType_list_Timeout
      -- ^ Timeout
    | IssueType_list_Throttled
      -- ^ Throttled
    | IssueType_list_Informational
      -- ^ Informational Note
    deriving (Eq,Show,Enum)
instance SchemaType IssueType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IssueType_list where
    acceptingParser =  do literal "invalid"; return IssueType_list_Invalid
                      `onFail` do literal "structure"; return IssueType_list_Structure
                      `onFail` do literal "required"; return IssueType_list_Required
                      `onFail` do literal "value"; return IssueType_list_Value
                      `onFail` do literal "invariant"; return IssueType_list_Invariant
                      `onFail` do literal "security"; return IssueType_list_Security
                      `onFail` do literal "login"; return IssueType_list_Login
                      `onFail` do literal "unknown"; return IssueType_list_Unknown
                      `onFail` do literal "expired"; return IssueType_list_Expired
                      `onFail` do literal "forbidden"; return IssueType_list_Forbidden
                      `onFail` do literal "suppressed"; return IssueType_list_Suppressed
                      `onFail` do literal "processing"; return IssueType_list_Processing
                      `onFail` do literal "not-supported"; return IssueType_list_Not_supported
                      `onFail` do literal "duplicate"; return IssueType_list_Duplicate
                      `onFail` do literal "not-found"; return IssueType_list_Not_found
                      `onFail` do literal "too-long"; return IssueType_list_Too_long
                      `onFail` do literal "code-invalid"; return IssueType_list_Code_invalid
                      `onFail` do literal "extension"; return IssueType_list_Extension
                      `onFail` do literal "too-costly"; return IssueType_list_Too_costly
                      `onFail` do literal "business-rule"; return IssueType_list_Business_rule
                      `onFail` do literal "conflict"; return IssueType_list_Conflict
                      `onFail` do literal "incomplete"; return IssueType_list_Incomplete
                      `onFail` do literal "transient"; return IssueType_list_Transient
                      `onFail` do literal "lock-error"; return IssueType_list_Lock_error
                      `onFail` do literal "no-store"; return IssueType_list_No_store
                      `onFail` do literal "exception"; return IssueType_list_Exception
                      `onFail` do literal "timeout"; return IssueType_list_Timeout
                      `onFail` do literal "throttled"; return IssueType_list_Throttled
                      `onFail` do literal "informational"; return IssueType_list_Informational
                      
    simpleTypeText IssueType_list_Invalid = "invalid"
    simpleTypeText IssueType_list_Structure = "structure"
    simpleTypeText IssueType_list_Required = "required"
    simpleTypeText IssueType_list_Value = "value"
    simpleTypeText IssueType_list_Invariant = "invariant"
    simpleTypeText IssueType_list_Security = "security"
    simpleTypeText IssueType_list_Login = "login"
    simpleTypeText IssueType_list_Unknown = "unknown"
    simpleTypeText IssueType_list_Expired = "expired"
    simpleTypeText IssueType_list_Forbidden = "forbidden"
    simpleTypeText IssueType_list_Suppressed = "suppressed"
    simpleTypeText IssueType_list_Processing = "processing"
    simpleTypeText IssueType_list_Not_supported = "not-supported"
    simpleTypeText IssueType_list_Duplicate = "duplicate"
    simpleTypeText IssueType_list_Not_found = "not-found"
    simpleTypeText IssueType_list_Too_long = "too-long"
    simpleTypeText IssueType_list_Code_invalid = "code-invalid"
    simpleTypeText IssueType_list_Extension = "extension"
    simpleTypeText IssueType_list_Too_costly = "too-costly"
    simpleTypeText IssueType_list_Business_rule = "business-rule"
    simpleTypeText IssueType_list_Conflict = "conflict"
    simpleTypeText IssueType_list_Incomplete = "incomplete"
    simpleTypeText IssueType_list_Transient = "transient"
    simpleTypeText IssueType_list_Lock_error = "lock-error"
    simpleTypeText IssueType_list_No_store = "no-store"
    simpleTypeText IssueType_list_Exception = "exception"
    simpleTypeText IssueType_list_Timeout = "timeout"
    simpleTypeText IssueType_list_Throttled = "throttled"
    simpleTypeText IssueType_list_Informational = "informational"
 
data IssueType = IssueType
        { issueType_id :: Maybe String_primitive
        , issueType_value :: Maybe IssueType_list
        , issueType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IssueType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IssueType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IssueType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ issueType_id x
                       , maybe [] (toXMLAttribute "value") $ issueType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ issueType_extension x
            ]
instance Extension IssueType Element where
    supertype (IssueType a0 a1 e0) =
               Element a0 e0
 
data IssueSeverity_list
    = IssueSeverity_list_Fatal
      -- ^ Fatal
    | IssueSeverity_list_Error
      -- ^ Error
    | IssueSeverity_list_Warning
      -- ^ Warning
    | IssueSeverity_list_Information
      -- ^ Information
    deriving (Eq,Show,Enum)
instance SchemaType IssueSeverity_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IssueSeverity_list where
    acceptingParser =  do literal "fatal"; return IssueSeverity_list_Fatal
                      `onFail` do literal "error"; return IssueSeverity_list_Error
                      `onFail` do literal "warning"; return IssueSeverity_list_Warning
                      `onFail` do literal "information"; return IssueSeverity_list_Information
                      
    simpleTypeText IssueSeverity_list_Fatal = "fatal"
    simpleTypeText IssueSeverity_list_Error = "error"
    simpleTypeText IssueSeverity_list_Warning = "warning"
    simpleTypeText IssueSeverity_list_Information = "information"
 
data IssueSeverity = IssueSeverity
        { issueSeverity_id :: Maybe String_primitive
        , issueSeverity_value :: Maybe IssueSeverity_list
        , issueSeverity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IssueSeverity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IssueSeverity a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IssueSeverity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ issueSeverity_id x
                       , maybe [] (toXMLAttribute "value") $ issueSeverity_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ issueSeverity_extension x
            ]
instance Extension IssueSeverity Element where
    supertype (IssueSeverity a0 a1 e0) =
               Element a0 e0
 
-- | A formally or informally recognized grouping of people or 
--   organizations formed for the purpose of achieving some form 
--   of collective action. Includes companies, institutions, 
--   corporations, departments, community groups, healthcare 
--   practice groups, etc.
elementOrganization :: XMLParser Organization
elementOrganization = parseSchemaType "Organization"
elementToXMLOrganization :: Organization -> [Content ()]
elementToXMLOrganization = schemaTypeToXML "Organization"
 
data Organization = Organization
        { organization_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , organization_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , organization_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , organization_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , organization_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , organization_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , organization_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , organization_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , organization_identifier :: [Identifier]
          -- ^ Identifier for the organization that is used to identify 
          --   the organization across multiple disparate systems.
        , organization_active :: Maybe Boolean
          -- ^ Whether the organization's record is still in active use.
        , organization_type :: [CodeableConcept]
          -- ^ The kind(s) of organization that this is.
        , organization_name :: Maybe Xsd.XsdString
          -- ^ A name associated with the organization.
        , organization_alias :: [Xsd.XsdString]
          -- ^ A list of alternate names that the organization is known 
          --   as, or was known as in the past.
        , organization_telecom :: [ContactPoint]
          -- ^ A contact detail for the organization.
        , organization_address :: [Address]
          -- ^ An address for the organization.
        , organization_partOf :: Maybe Reference
          -- ^ The organization of which this organization forms a part.
        , organization_contact :: [OrganizationContact]
          -- ^ Contact for the organization for a certain purpose.
        , organization_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the organization.
        }
        deriving (Eq,Show)
instance SchemaType Organization where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Organization
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "type")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "alias")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "partOf")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@Organization{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ organization_id x
            , maybe [] (schemaTypeToXML "meta") $ organization_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ organization_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ organization_language x
            , maybe [] (schemaTypeToXML "text") $ organization_text x
            , concatMap (schemaTypeToXML "contained") $ organization_contained x
            , concatMap (schemaTypeToXML "extension") $ organization_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ organization_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ organization_identifier x
            , maybe [] (schemaTypeToXML "active") $ organization_active x
            , concatMap (schemaTypeToXML "type") $ organization_type x
            , maybe [] (schemaTypeToXML "name") $ organization_name x
            , concatMap (schemaTypeToXML "alias") $ organization_alias x
            , concatMap (schemaTypeToXML "telecom") $ organization_telecom x
            , concatMap (schemaTypeToXML "address") $ organization_address x
            , maybe [] (schemaTypeToXML "partOf") $ organization_partOf x
            , concatMap (schemaTypeToXML "contact") $ organization_contact x
            , concatMap (schemaTypeToXML "endpoint") $ organization_endpoint x
            ]
instance Extension Organization DomainResource where
    supertype (Organization e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Organization Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Organization -> DomainResource)
              
 
-- | A formally or informally recognized grouping of people or 
--   organizations formed for the purpose of achieving some form 
--   of collective action. Includes companies, institutions, 
--   corporations, departments, community groups, healthcare 
--   practice groups, etc.
data OrganizationContact = OrganizationContact
        { organizationContact_id :: Maybe String_primitive
        , organizationContact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , organizationContact_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , organizationContact_purpose :: Maybe CodeableConcept
          -- ^ Indicates a purpose for which the contact can be reached.
        , organizationContact_name :: Maybe HumanName
          -- ^ A name associated with the contact.
        , organizationContact_telecom :: [ContactPoint]
          -- ^ A contact detail (e.g. a telephone number or an email 
          --   address) by which the party may be contacted.
        , organizationContact_address :: Maybe Address
          -- ^ Visiting or postal addresses for the contact.
        }
        deriving (Eq,Show)
instance SchemaType OrganizationContact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (OrganizationContact a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
    schemaTypeToXML s x@OrganizationContact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ organizationContact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ organizationContact_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ organizationContact_modifierExtension x
            , maybe [] (schemaTypeToXML "purpose") $ organizationContact_purpose x
            , maybe [] (schemaTypeToXML "name") $ organizationContact_name x
            , concatMap (schemaTypeToXML "telecom") $ organizationContact_telecom x
            , maybe [] (schemaTypeToXML "address") $ organizationContact_address x
            ]
instance Extension OrganizationContact BackboneElement where
    supertype (OrganizationContact a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension OrganizationContact Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: OrganizationContact -> BackboneElement)
              
 
-- | This special resource type is used to represent an 
--   operation request and response (operations.html). It has no 
--   other use, and there is no RESTful endpoint associated with 
--   it.
elementParameters :: XMLParser Parameters
elementParameters = parseSchemaType "Parameters"
elementToXMLParameters :: Parameters -> [Content ()]
elementToXMLParameters = schemaTypeToXML "Parameters"
 
data Parameters = Parameters
        { parameters_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , parameters_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , parameters_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , parameters_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , parameters_parameter :: [ParametersParameter]
          -- ^ A parameter passed to or received from the operation.
        }
        deriving (Eq,Show)
instance SchemaType Parameters where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Parameters
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` many (parseSchemaType "parameter")
    schemaTypeToXML s x@Parameters{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ parameters_id x
            , maybe [] (schemaTypeToXML "meta") $ parameters_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ parameters_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ parameters_language x
            , concatMap (schemaTypeToXML "parameter") $ parameters_parameter x
            ]
instance Extension Parameters Resource where
    supertype (Parameters e0 e1 e2 e3 e4) =
               Resource e0 e1 e2 e3
 
-- | This special resource type is used to represent an 
--   operation request and response (operations.html). It has no 
--   other use, and there is no RESTful endpoint associated with 
--   it.
data ParametersParameter = ParametersParameter
        { parametersParameter_id :: Maybe String_primitive
        , parametersParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , parametersParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , parametersParameter_name :: Xsd.XsdString
          -- ^ The name of the parameter (reference to the operation 
          --   definition).
        , parametersParameter_choice3 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ If the parameter is a data type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        , parametersParameter_resource :: Maybe ResourceContainer
          -- ^ If the parameter is a whole resource.
        , parametersParameter_part :: [ParametersParameter]
          -- ^ A named part of a multi-part parameter.
        }
        deriving (Eq,Show)
instance SchemaType ParametersParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ParametersParameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                                     ])
            `apply` optional (parseSchemaType "resource")
            `apply` many (parseSchemaType "part")
    schemaTypeToXML s x@ParametersParameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ parametersParameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ parametersParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ parametersParameter_modifierExtension x
            , schemaTypeToXML "name" $ parametersParameter_name x
            , maybe [] (foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                                     (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueCode")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueId")
                                     (schemaTypeToXML "valueInstant")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueMarkdown")
                                     (schemaTypeToXML "valueOid")
                                     (schemaTypeToXML "valuePositiveInt")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueUnsignedInt")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAddress")
                                     (schemaTypeToXML "valueAge")
                                     (schemaTypeToXML "valueAnnotation")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCodeableConcept")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueContactPoint")
                                     (schemaTypeToXML "valueCount")
                                     (schemaTypeToXML "valueDistance")
                                     (schemaTypeToXML "valueDuration")
                                     (schemaTypeToXML "valueHumanName")
                                     (schemaTypeToXML "valueIdentifier")
                                     (schemaTypeToXML "valueMoney")
                                     (schemaTypeToXML "valuePeriod")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueRange")
                                     (schemaTypeToXML "valueRatio")
                                     (schemaTypeToXML "valueReference")
                                     (schemaTypeToXML "valueSampledData")
                                     (schemaTypeToXML "valueSignature")
                                     (schemaTypeToXML "valueTiming")
                                     (schemaTypeToXML "valueMeta")
                                    ) $ parametersParameter_choice3 x
            , maybe [] (schemaTypeToXML "resource") $ parametersParameter_resource x
            , concatMap (schemaTypeToXML "part") $ parametersParameter_part x
            ]
instance Extension ParametersParameter BackboneElement where
    supertype (ParametersParameter a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ParametersParameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ParametersParameter -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
elementPatient :: XMLParser Patient
elementPatient = parseSchemaType "Patient"
elementToXMLPatient :: Patient -> [Content ()]
elementToXMLPatient = schemaTypeToXML "Patient"
 
data Patient = Patient
        { patient_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , patient_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , patient_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , patient_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , patient_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , patient_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , patient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patient_identifier :: [Identifier]
          -- ^ An identifier for this patient.
        , patient_active :: Maybe Boolean
          -- ^ Whether this patient record is in active use.
        , patient_name :: [HumanName]
          -- ^ A name associated with the individual.
        , patient_telecom :: [ContactPoint]
          -- ^ A contact detail (e.g. a telephone number or an email 
          --   address) by which the individual may be contacted.
        , patient_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the patient is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , patient_birthDate :: Maybe Date
          -- ^ The date of birth for the individual.
        , patient_choice14 :: (Maybe (OneOf2 Boolean DateTime))
          -- ^ Indicates if the individual is deceased or not.
          --   
          --   Choice between:
          --   
          --   (1) deceasedBoolean
          --   
          --   (2) deceasedDateTime
        , patient_address :: [Address]
          -- ^ Addresses for the individual.
        , patient_maritalStatus :: Maybe CodeableConcept
          -- ^ This field contains a patient's most recent marital (civil) 
          --   status.
        , patient_choice17 :: (Maybe (OneOf2 Boolean Integer))
          -- ^ Indicates whether the patient is part of a multiple (bool) 
          --   or indicates the actual birth order (integer).
          --   
          --   Choice between:
          --   
          --   (1) multipleBirthBoolean
          --   
          --   (2) multipleBirthInteger
        , patient_photo :: [Attachment]
          -- ^ Image of the patient.
        , patient_contact :: [PatientContact]
          -- ^ A contact party (e.g. guardian, partner, friend) for the 
          --   patient.
        , patient_animal :: Maybe PatientAnimal
          -- ^ This patient is known to be an animal.
        , patient_communication :: [PatientCommunication]
          -- ^ Languages which may be used to communicate with the patient 
          --   about his or her health.
        , patient_generalPractitioner :: [Reference]
          -- ^ Patient's nominated care provider.
        , patient_managingOrganization :: Maybe Reference
          -- ^ Organization that is the custodian of the patient record.
        , patient_link :: [PatientLink]
          -- ^ Link to another patient resource that concerns the same 
          --   actual patient.
        }
        deriving (Eq,Show)
instance SchemaType Patient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Patient
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "deceasedBoolean"))
                                     , ("DateTime", fmap TwoOf2 (parseSchemaType "deceasedDateTime"))
                                     ])
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "maritalStatus")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "multipleBirthBoolean"))
                                     , ("Integer", fmap TwoOf2 (parseSchemaType "multipleBirthInteger"))
                                     ])
            `apply` many (parseSchemaType "photo")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "animal")
            `apply` many (parseSchemaType "communication")
            `apply` many (parseSchemaType "generalPractitioner")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@Patient{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ patient_id x
            , maybe [] (schemaTypeToXML "meta") $ patient_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ patient_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ patient_language x
            , maybe [] (schemaTypeToXML "text") $ patient_text x
            , concatMap (schemaTypeToXML "contained") $ patient_contained x
            , concatMap (schemaTypeToXML "extension") $ patient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patient_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ patient_identifier x
            , maybe [] (schemaTypeToXML "active") $ patient_active x
            , concatMap (schemaTypeToXML "name") $ patient_name x
            , concatMap (schemaTypeToXML "telecom") $ patient_telecom x
            , maybe [] (schemaTypeToXML "gender") $ patient_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ patient_birthDate x
            , maybe [] (foldOneOf2  (schemaTypeToXML "deceasedBoolean")
                                    (schemaTypeToXML "deceasedDateTime")
                                   ) $ patient_choice14 x
            , concatMap (schemaTypeToXML "address") $ patient_address x
            , maybe [] (schemaTypeToXML "maritalStatus") $ patient_maritalStatus x
            , maybe [] (foldOneOf2  (schemaTypeToXML "multipleBirthBoolean")
                                    (schemaTypeToXML "multipleBirthInteger")
                                   ) $ patient_choice17 x
            , concatMap (schemaTypeToXML "photo") $ patient_photo x
            , concatMap (schemaTypeToXML "contact") $ patient_contact x
            , maybe [] (schemaTypeToXML "animal") $ patient_animal x
            , concatMap (schemaTypeToXML "communication") $ patient_communication x
            , concatMap (schemaTypeToXML "generalPractitioner") $ patient_generalPractitioner x
            , maybe [] (schemaTypeToXML "managingOrganization") $ patient_managingOrganization x
            , concatMap (schemaTypeToXML "link") $ patient_link x
            ]
instance Extension Patient DomainResource where
    supertype (Patient e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Patient Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Patient -> DomainResource)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data PatientContact = PatientContact
        { patientContact_id :: Maybe String_primitive
        , patientContact_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patientContact_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patientContact_relationship :: [CodeableConcept]
          -- ^ The nature of the relationship between the patient and the 
          --   contact person.
        , patientContact_name :: Maybe HumanName
          -- ^ A name associated with the contact person.
        , patientContact_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , patientContact_address :: Maybe Address
          -- ^ Address for the contact person.
        , patientContact_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the contact person 
          --   is considered to have for administration and record keeping 
          --   purposes.
        , patientContact_organization :: Maybe Reference
          -- ^ Organization on behalf of which the contact is acting or 
          --   for which the contact is working.
        , patientContact_period :: Maybe Period
          -- ^ The period during which this contact person or organization 
          --   is valid to be contacted relating to this patient.
        }
        deriving (Eq,Show)
instance SchemaType PatientContact where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PatientContact a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "relationship")
            `apply` optional (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "address")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@PatientContact{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patientContact_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patientContact_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patientContact_modifierExtension x
            , concatMap (schemaTypeToXML "relationship") $ patientContact_relationship x
            , maybe [] (schemaTypeToXML "name") $ patientContact_name x
            , concatMap (schemaTypeToXML "telecom") $ patientContact_telecom x
            , maybe [] (schemaTypeToXML "address") $ patientContact_address x
            , maybe [] (schemaTypeToXML "gender") $ patientContact_gender x
            , maybe [] (schemaTypeToXML "organization") $ patientContact_organization x
            , maybe [] (schemaTypeToXML "period") $ patientContact_period x
            ]
instance Extension PatientContact BackboneElement where
    supertype (PatientContact a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension PatientContact Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PatientContact -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data PatientAnimal = PatientAnimal
        { patientAnimal_id :: Maybe String_primitive
        , patientAnimal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patientAnimal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patientAnimal_species :: CodeableConcept
          -- ^ Identifies the high level taxonomic categorization of the 
          --   kind of animal.
        , patientAnimal_breed :: Maybe CodeableConcept
          -- ^ Identifies the detailed categorization of the kind of 
          --   animal.
        , patientAnimal_genderStatus :: Maybe CodeableConcept
          -- ^ Indicates the current state of the animal's reproductive 
          --   organs.
        }
        deriving (Eq,Show)
instance SchemaType PatientAnimal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PatientAnimal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "species"
            `apply` optional (parseSchemaType "breed")
            `apply` optional (parseSchemaType "genderStatus")
    schemaTypeToXML s x@PatientAnimal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patientAnimal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patientAnimal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patientAnimal_modifierExtension x
            , schemaTypeToXML "species" $ patientAnimal_species x
            , maybe [] (schemaTypeToXML "breed") $ patientAnimal_breed x
            , maybe [] (schemaTypeToXML "genderStatus") $ patientAnimal_genderStatus x
            ]
instance Extension PatientAnimal BackboneElement where
    supertype (PatientAnimal a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension PatientAnimal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PatientAnimal -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data PatientCommunication = PatientCommunication
        { patientCommunication_id :: Maybe String_primitive
        , patientCommunication_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patientCommunication_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patientCommunication_language :: CodeableConcept
          -- ^ The ISO-639-1 alpha 2 code in lower case for the language, 
          --   optionally followed by a hyphen and the ISO-3166-1 alpha 2 
          --   code for the region in upper case; e.g. &quot;en&quot; for 
          --   English, or &quot;en-US&quot; for American English versus 
          --   &quot;en-EN&quot; for England English.
        , patientCommunication_preferred :: Maybe Boolean
          -- ^ Indicates whether or not the patient prefers this language 
          --   (over other languages he masters up a certain level).
        }
        deriving (Eq,Show)
instance SchemaType PatientCommunication where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PatientCommunication a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "language"
            `apply` optional (parseSchemaType "preferred")
    schemaTypeToXML s x@PatientCommunication{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patientCommunication_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patientCommunication_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patientCommunication_modifierExtension x
            , schemaTypeToXML "language" $ patientCommunication_language x
            , maybe [] (schemaTypeToXML "preferred") $ patientCommunication_preferred x
            ]
instance Extension PatientCommunication BackboneElement where
    supertype (PatientCommunication a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PatientCommunication Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PatientCommunication -> BackboneElement)
              
 
-- | Demographics and other administrative information about an 
--   individual or animal receiving care or other health-related 
--   services.
data PatientLink = PatientLink
        { patientLink_id :: Maybe String_primitive
        , patientLink_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , patientLink_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , patientLink_other :: Reference
          -- ^ The other patient resource that the link refers to.
        , patientLink_type :: LinkType
          -- ^ The type of link between this patient resource and another 
          --   patient resource.
        }
        deriving (Eq,Show)
instance SchemaType PatientLink where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PatientLink a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "other"
            `apply` parseSchemaType "type"
    schemaTypeToXML s x@PatientLink{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ patientLink_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ patientLink_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ patientLink_modifierExtension x
            , schemaTypeToXML "other" $ patientLink_other x
            , schemaTypeToXML "type" $ patientLink_type x
            ]
instance Extension PatientLink BackboneElement where
    supertype (PatientLink a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PatientLink Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PatientLink -> BackboneElement)
              
 
data LinkType_list
    = LinkType_list_Replaced_by
    | LinkType_list_Replaces
      -- ^ Replaces
    | LinkType_list_Refer
    | LinkType_list_Seealso
    deriving (Eq,Show,Enum)
instance SchemaType LinkType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType LinkType_list where
    acceptingParser =  do literal "replaced-by"; return LinkType_list_Replaced_by
                      `onFail` do literal "replaces"; return LinkType_list_Replaces
                      `onFail` do literal "refer"; return LinkType_list_Refer
                      `onFail` do literal "seealso"; return LinkType_list_Seealso
                      
    simpleTypeText LinkType_list_Replaced_by = "replaced-by"
    simpleTypeText LinkType_list_Replaces = "replaces"
    simpleTypeText LinkType_list_Refer = "refer"
    simpleTypeText LinkType_list_Seealso = "seealso"
 
data LinkType = LinkType
        { linkType_id :: Maybe String_primitive
        , linkType_value :: Maybe LinkType_list
        , linkType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType LinkType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (LinkType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@LinkType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ linkType_id x
                       , maybe [] (toXMLAttribute "value") $ linkType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ linkType_extension x
            ]
instance Extension LinkType Element where
    supertype (LinkType a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the status of the payment for goods 
--   and services rendered, and the request and response 
--   resource references.
elementPaymentNotice :: XMLParser PaymentNotice
elementPaymentNotice = parseSchemaType "PaymentNotice"
elementToXMLPaymentNotice :: PaymentNotice -> [Content ()]
elementToXMLPaymentNotice = schemaTypeToXML "PaymentNotice"
 
data PaymentNotice = PaymentNotice
        { paymentNotice_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , paymentNotice_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , paymentNotice_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , paymentNotice_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , paymentNotice_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , paymentNotice_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , paymentNotice_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentNotice_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentNotice_identifier :: [Identifier]
          -- ^ The notice business identifier.
        , paymentNotice_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , paymentNotice_request :: Maybe Reference
          -- ^ Reference of resource for which payment is being made.
        , paymentNotice_response :: Maybe Reference
          -- ^ Reference of response to resource for which payment is 
          --   being made.
        , paymentNotice_statusDate :: Maybe Date
          -- ^ The date when the above payment action occurrred.
        , paymentNotice_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , paymentNotice_target :: Maybe Reference
          -- ^ The Insurer who is target of the request.
        , paymentNotice_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , paymentNotice_organization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , paymentNotice_paymentStatus :: Maybe CodeableConcept
          -- ^ The payment status, typically paid: payment sent, cleared: 
          --   payment received.
        }
        deriving (Eq,Show)
instance SchemaType PaymentNotice where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PaymentNotice
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "statusDate")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "paymentStatus")
    schemaTypeToXML s x@PaymentNotice{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ paymentNotice_id x
            , maybe [] (schemaTypeToXML "meta") $ paymentNotice_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ paymentNotice_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ paymentNotice_language x
            , maybe [] (schemaTypeToXML "text") $ paymentNotice_text x
            , concatMap (schemaTypeToXML "contained") $ paymentNotice_contained x
            , concatMap (schemaTypeToXML "extension") $ paymentNotice_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentNotice_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ paymentNotice_identifier x
            , maybe [] (schemaTypeToXML "status") $ paymentNotice_status x
            , maybe [] (schemaTypeToXML "request") $ paymentNotice_request x
            , maybe [] (schemaTypeToXML "response") $ paymentNotice_response x
            , maybe [] (schemaTypeToXML "statusDate") $ paymentNotice_statusDate x
            , maybe [] (schemaTypeToXML "created") $ paymentNotice_created x
            , maybe [] (schemaTypeToXML "target") $ paymentNotice_target x
            , maybe [] (schemaTypeToXML "provider") $ paymentNotice_provider x
            , maybe [] (schemaTypeToXML "organization") $ paymentNotice_organization x
            , maybe [] (schemaTypeToXML "paymentStatus") $ paymentNotice_paymentStatus x
            ]
instance Extension PaymentNotice DomainResource where
    supertype (PaymentNotice e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PaymentNotice Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PaymentNotice -> DomainResource)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
elementPaymentReconciliation :: XMLParser PaymentReconciliation
elementPaymentReconciliation = parseSchemaType "PaymentReconciliation"
elementToXMLPaymentReconciliation :: PaymentReconciliation -> [Content ()]
elementToXMLPaymentReconciliation = schemaTypeToXML "PaymentReconciliation"
 
data PaymentReconciliation = PaymentReconciliation
        { paymentReconciliation_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , paymentReconciliation_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , paymentReconciliation_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , paymentReconciliation_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , paymentReconciliation_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , paymentReconciliation_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , paymentReconciliation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliation_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , paymentReconciliation_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , paymentReconciliation_period :: Maybe Period
          -- ^ The period of time for which payments have been gathered 
          --   into this bulk payment for settlement.
        , paymentReconciliation_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , paymentReconciliation_organization :: Maybe Reference
          -- ^ The Insurer who produced this adjudicated response.
        , paymentReconciliation_request :: Maybe Reference
          -- ^ Original request resource reference.
        , paymentReconciliation_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete.
        , paymentReconciliation_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication.
        , paymentReconciliation_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , paymentReconciliation_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , paymentReconciliation_detail :: [PaymentReconciliationDetail]
          -- ^ List of individual settlement amounts and the corresponding 
          --   transaction.
        , paymentReconciliation_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , paymentReconciliation_total :: Maybe Money
          -- ^ Total payment amount.
        , paymentReconciliation_processNote :: [PaymentReconciliationProcessNote]
          -- ^ Suite of notes.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PaymentReconciliation
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` many (parseSchemaType "detail")
            `apply` optional (parseSchemaType "form")
            `apply` optional (parseSchemaType "total")
            `apply` many (parseSchemaType "processNote")
    schemaTypeToXML s x@PaymentReconciliation{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ paymentReconciliation_id x
            , maybe [] (schemaTypeToXML "meta") $ paymentReconciliation_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ paymentReconciliation_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ paymentReconciliation_language x
            , maybe [] (schemaTypeToXML "text") $ paymentReconciliation_text x
            , concatMap (schemaTypeToXML "contained") $ paymentReconciliation_contained x
            , concatMap (schemaTypeToXML "extension") $ paymentReconciliation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliation_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ paymentReconciliation_identifier x
            , maybe [] (schemaTypeToXML "status") $ paymentReconciliation_status x
            , maybe [] (schemaTypeToXML "period") $ paymentReconciliation_period x
            , maybe [] (schemaTypeToXML "created") $ paymentReconciliation_created x
            , maybe [] (schemaTypeToXML "organization") $ paymentReconciliation_organization x
            , maybe [] (schemaTypeToXML "request") $ paymentReconciliation_request x
            , maybe [] (schemaTypeToXML "outcome") $ paymentReconciliation_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ paymentReconciliation_disposition x
            , maybe [] (schemaTypeToXML "requestProvider") $ paymentReconciliation_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ paymentReconciliation_requestOrganization x
            , concatMap (schemaTypeToXML "detail") $ paymentReconciliation_detail x
            , maybe [] (schemaTypeToXML "form") $ paymentReconciliation_form x
            , maybe [] (schemaTypeToXML "total") $ paymentReconciliation_total x
            , concatMap (schemaTypeToXML "processNote") $ paymentReconciliation_processNote x
            ]
instance Extension PaymentReconciliation DomainResource where
    supertype (PaymentReconciliation e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PaymentReconciliation Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PaymentReconciliation -> DomainResource)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
data PaymentReconciliationDetail = PaymentReconciliationDetail
        { paymentReconciliationDetail_id :: Maybe String_primitive
        , paymentReconciliationDetail_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliationDetail_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliationDetail_type :: CodeableConcept
          -- ^ Code to indicate the nature of the payment, adjustment, 
          --   funds advance, etc.
        , paymentReconciliationDetail_request :: Maybe Reference
          -- ^ The claim or financial resource.
        , paymentReconciliationDetail_response :: Maybe Reference
          -- ^ The claim response resource.
        , paymentReconciliationDetail_submitter :: Maybe Reference
          -- ^ The Organization which submitted the claim or financial 
          --   transaction.
        , paymentReconciliationDetail_payee :: Maybe Reference
          -- ^ The organization which is receiving the payment.
        , paymentReconciliationDetail_date :: Maybe Date
          -- ^ The date of the invoice or financial resource.
        , paymentReconciliationDetail_amount :: Maybe Money
          -- ^ Amount paid for this detail.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliationDetail where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PaymentReconciliationDetail a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "submitter")
            `apply` optional (parseSchemaType "payee")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "amount")
    schemaTypeToXML s x@PaymentReconciliationDetail{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ paymentReconciliationDetail_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ paymentReconciliationDetail_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliationDetail_modifierExtension x
            , schemaTypeToXML "type" $ paymentReconciliationDetail_type x
            , maybe [] (schemaTypeToXML "request") $ paymentReconciliationDetail_request x
            , maybe [] (schemaTypeToXML "response") $ paymentReconciliationDetail_response x
            , maybe [] (schemaTypeToXML "submitter") $ paymentReconciliationDetail_submitter x
            , maybe [] (schemaTypeToXML "payee") $ paymentReconciliationDetail_payee x
            , maybe [] (schemaTypeToXML "date") $ paymentReconciliationDetail_date x
            , maybe [] (schemaTypeToXML "amount") $ paymentReconciliationDetail_amount x
            ]
instance Extension PaymentReconciliationDetail BackboneElement where
    supertype (PaymentReconciliationDetail a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension PaymentReconciliationDetail Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PaymentReconciliationDetail -> BackboneElement)
              
 
-- | This resource provides payment details and claim references 
--   supporting a bulk payment.
data PaymentReconciliationProcessNote = PaymentReconciliationProcessNote
        { paymentReconciliationProcessNote_id :: Maybe String_primitive
        , paymentReconciliationProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , paymentReconciliationProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , paymentReconciliationProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , paymentReconciliationProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        }
        deriving (Eq,Show)
instance SchemaType PaymentReconciliationProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PaymentReconciliationProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@PaymentReconciliationProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ paymentReconciliationProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ paymentReconciliationProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ paymentReconciliationProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ paymentReconciliationProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ paymentReconciliationProcessNote_text x
            ]
instance Extension PaymentReconciliationProcessNote BackboneElement where
    supertype (PaymentReconciliationProcessNote a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PaymentReconciliationProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PaymentReconciliationProcessNote -> BackboneElement)
              
 
-- | Demographics and administrative information about a person 
--   independent of a specific health-related context.
elementPerson :: XMLParser Person
elementPerson = parseSchemaType "Person"
elementToXMLPerson :: Person -> [Content ()]
elementToXMLPerson = schemaTypeToXML "Person"
 
data Person = Person
        { person_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , person_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , person_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , person_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , person_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , person_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , person_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , person_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , person_identifier :: [Identifier]
          -- ^ Identifier for a person within a particular scope.
        , person_name :: [HumanName]
          -- ^ A name associated with the person.
        , person_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , person_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender.
        , person_birthDate :: Maybe Date
          -- ^ The birth date for the person.
        , person_address :: [Address]
          -- ^ One or more addresses for the person.
        , person_photo :: Maybe Attachment
          -- ^ An image that can be displayed as a thumbnail of the person 
          --   to enhance the identification of the individual.
        , person_managingOrganization :: Maybe Reference
          -- ^ The organization that is the custodian of the person 
          --   record.
        , person_active :: Maybe Boolean
          -- ^ Whether this person's record is in active use.
        , person_link :: [PersonLink]
          -- ^ Link to a resource that concerns the same actual person.
        }
        deriving (Eq,Show)
instance SchemaType Person where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Person
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "photo")
            `apply` optional (parseSchemaType "managingOrganization")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "link")
    schemaTypeToXML s x@Person{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ person_id x
            , maybe [] (schemaTypeToXML "meta") $ person_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ person_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ person_language x
            , maybe [] (schemaTypeToXML "text") $ person_text x
            , concatMap (schemaTypeToXML "contained") $ person_contained x
            , concatMap (schemaTypeToXML "extension") $ person_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ person_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ person_identifier x
            , concatMap (schemaTypeToXML "name") $ person_name x
            , concatMap (schemaTypeToXML "telecom") $ person_telecom x
            , maybe [] (schemaTypeToXML "gender") $ person_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ person_birthDate x
            , concatMap (schemaTypeToXML "address") $ person_address x
            , maybe [] (schemaTypeToXML "photo") $ person_photo x
            , maybe [] (schemaTypeToXML "managingOrganization") $ person_managingOrganization x
            , maybe [] (schemaTypeToXML "active") $ person_active x
            , concatMap (schemaTypeToXML "link") $ person_link x
            ]
instance Extension Person DomainResource where
    supertype (Person e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Person Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Person -> DomainResource)
              
 
-- | Demographics and administrative information about a person 
--   independent of a specific health-related context.
data PersonLink = PersonLink
        { personLink_id :: Maybe String_primitive
        , personLink_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , personLink_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , personLink_target :: Reference
          -- ^ The resource to which this actual person is associated.
        , personLink_assurance :: Maybe IdentityAssuranceLevel
          -- ^ Level of assurance that this link is actually associated 
          --   with the target resource.
        }
        deriving (Eq,Show)
instance SchemaType PersonLink where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PersonLink a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "target"
            `apply` optional (parseSchemaType "assurance")
    schemaTypeToXML s x@PersonLink{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ personLink_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ personLink_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ personLink_modifierExtension x
            , schemaTypeToXML "target" $ personLink_target x
            , maybe [] (schemaTypeToXML "assurance") $ personLink_assurance x
            ]
instance Extension PersonLink BackboneElement where
    supertype (PersonLink a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PersonLink Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PersonLink -> BackboneElement)
              
 
data IdentityAssuranceLevel_list
    = IdentityAssuranceLevel_list_Level1
      -- ^ Level 1
    | IdentityAssuranceLevel_list_Level2
      -- ^ Level 2
    | IdentityAssuranceLevel_list_Level3
      -- ^ Level 3
    | IdentityAssuranceLevel_list_Level4
      -- ^ Level 4
    deriving (Eq,Show,Enum)
instance SchemaType IdentityAssuranceLevel_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType IdentityAssuranceLevel_list where
    acceptingParser =  do literal "level1"; return IdentityAssuranceLevel_list_Level1
                      `onFail` do literal "level2"; return IdentityAssuranceLevel_list_Level2
                      `onFail` do literal "level3"; return IdentityAssuranceLevel_list_Level3
                      `onFail` do literal "level4"; return IdentityAssuranceLevel_list_Level4
                      
    simpleTypeText IdentityAssuranceLevel_list_Level1 = "level1"
    simpleTypeText IdentityAssuranceLevel_list_Level2 = "level2"
    simpleTypeText IdentityAssuranceLevel_list_Level3 = "level3"
    simpleTypeText IdentityAssuranceLevel_list_Level4 = "level4"
 
data IdentityAssuranceLevel = IdentityAssuranceLevel
        { identityAssuranceLevel_id :: Maybe String_primitive
        , identityAssuranceLevel_value :: Maybe IdentityAssuranceLevel_list
        , identityAssuranceLevel_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType IdentityAssuranceLevel where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (IdentityAssuranceLevel a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@IdentityAssuranceLevel{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ identityAssuranceLevel_id x
                       , maybe [] (toXMLAttribute "value") $ identityAssuranceLevel_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ identityAssuranceLevel_extension x
            ]
instance Extension IdentityAssuranceLevel Element where
    supertype (IdentityAssuranceLevel a0 a1 e0) =
               Element a0 e0
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
elementPlanDefinition :: XMLParser PlanDefinition
elementPlanDefinition = parseSchemaType "PlanDefinition"
elementToXMLPlanDefinition :: PlanDefinition -> [Content ()]
elementToXMLPlanDefinition = schemaTypeToXML "PlanDefinition"
 
data PlanDefinition = PlanDefinition
        { planDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , planDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , planDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , planDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , planDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , planDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , planDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this plan 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   plan definition is (or will be) published. The URL SHOULD 
          --   include the major version of the plan definition. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , planDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this plan 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , planDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   plan definition when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the plan definition author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence. To provide a version consistent 
          --   with the Decision Support Service specification, use the 
          --   format Major.Minor.Revision (e.g. 1.0.0). For more 
          --   information on versioning knowledge assets, refer to the 
          --   Decision Support Service specification. Note that a version 
          --   is required for non-experimental active artifacts.
        , planDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the plan definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , planDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the plan 
          --   definition.
        , planDefinition_type :: Maybe CodeableConcept
          -- ^ The type of asset the plan definition represents, e.g. an 
          --   order set, protocol, or event-condition-action rule.
        , planDefinition_status :: PublicationStatus
          -- ^ The status of this plan definition. Enables tracking the 
          --   life-cycle of the content.
        , planDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this plan definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , planDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the plan definition was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the plan definition changes.
        , planDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the plan definition.
        , planDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the plan 
          --   definition from a consumer's perspective.
        , planDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this plan definition is needed and why 
          --   it has been designed as it has.
        , planDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the asset is used from a 
          --   clinical perspective.
        , planDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , planDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , planDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the plan definition content was or 
          --   is planned to be in active use.
        , planDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   plan definition instances.
        , planDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the plan definition 
          --   is intended to be used.
        , planDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the content of the plan 
          --   definition. Topics provide a high-level categorization of 
          --   the definition that can be useful for filtering and 
          --   searching.
        , planDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the asset, including 
          --   authors, editors, reviewers, and endorsers.
        , planDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , planDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the plan definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the plan 
          --   definition.
        , planDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related artifacts such as additional documentation, 
          --   justification, or bibliographic references.
        , planDefinition_library :: [Reference]
          -- ^ A reference to a Library resource containing any formal 
          --   logic used by the plan definition.
        , planDefinition_goal :: [PlanDefinitionGoal]
          -- ^ Goals that describe what the activities within the plan are 
          --   intended to achieve. For example, weight loss, restoring an 
          --   activity of daily living, obtaining herd immunity via 
          --   immunization, meeting a process improvement objective, etc.
        , planDefinition_action :: [PlanDefinitionAction]
          -- ^ An action to be taken as part of the plan.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PlanDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "library")
            `apply` many (parseSchemaType "goal")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@PlanDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ planDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ planDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ planDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ planDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ planDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ planDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ planDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ planDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ planDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ planDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ planDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ planDefinition_title x
            , maybe [] (schemaTypeToXML "type") $ planDefinition_type x
            , schemaTypeToXML "status" $ planDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ planDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ planDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ planDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ planDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ planDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ planDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ planDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ planDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ planDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ planDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ planDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ planDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ planDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ planDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ planDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ planDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "library") $ planDefinition_library x
            , concatMap (schemaTypeToXML "goal") $ planDefinition_goal x
            , concatMap (schemaTypeToXML "action") $ planDefinition_action x
            ]
instance Extension PlanDefinition DomainResource where
    supertype (PlanDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PlanDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PlanDefinition -> DomainResource)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionGoal = PlanDefinitionGoal
        { planDefinitionGoal_id :: Maybe String_primitive
        , planDefinitionGoal_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionGoal_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionGoal_category :: Maybe CodeableConcept
          -- ^ Indicates a category the goal falls within.
        , planDefinitionGoal_description :: CodeableConcept
          -- ^ Human-readable and/or coded description of a specific 
          --   desired objective of care, such as &quot;control blood 
          --   pressure&quot; or &quot;negotiate an obstacle course&quot; 
          --   or &quot;dance with child at wedding&quot;.
        , planDefinitionGoal_priority :: Maybe CodeableConcept
          -- ^ Identifies the expected level of importance associated with 
          --   reaching/sustaining the defined goal.
        , planDefinitionGoal_start :: Maybe CodeableConcept
          -- ^ The event after which the goal should begin being pursued.
        , planDefinitionGoal_addresses :: [CodeableConcept]
          -- ^ Identifies problems, conditions, issues, or concerns the 
          --   goal is intended to address.
        , planDefinitionGoal_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the goal that provide further supporting information about 
          --   the goal. Information resources can include inline text 
          --   commentary and links to web resources.
        , planDefinitionGoal_target :: [PlanDefinitionTarget]
          -- ^ Indicates what should be done and within what timeframe.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionGoal where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionGoal a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "category")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "start")
            `apply` many (parseSchemaType "addresses")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "target")
    schemaTypeToXML s x@PlanDefinitionGoal{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionGoal_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionGoal_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionGoal_modifierExtension x
            , maybe [] (schemaTypeToXML "category") $ planDefinitionGoal_category x
            , schemaTypeToXML "description" $ planDefinitionGoal_description x
            , maybe [] (schemaTypeToXML "priority") $ planDefinitionGoal_priority x
            , maybe [] (schemaTypeToXML "start") $ planDefinitionGoal_start x
            , concatMap (schemaTypeToXML "addresses") $ planDefinitionGoal_addresses x
            , concatMap (schemaTypeToXML "documentation") $ planDefinitionGoal_documentation x
            , concatMap (schemaTypeToXML "target") $ planDefinitionGoal_target x
            ]
instance Extension PlanDefinitionGoal BackboneElement where
    supertype (PlanDefinitionGoal a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionGoal Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionGoal -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionTarget = PlanDefinitionTarget
        { planDefinitionTarget_id :: Maybe String_primitive
        , planDefinitionTarget_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionTarget_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionTarget_measure :: Maybe CodeableConcept
          -- ^ The parameter whose value is to be tracked, e.g. body 
          --   weigth, blood pressure, or hemoglobin A1c level.
        , planDefinitionTarget_choice3 :: (Maybe (OneOf3 Quantity Range CodeableConcept))
          -- ^ The target value of the measure to be achieved to signify 
          --   fulfillment of the goal, e.g. 150 pounds or 7.0%. Either 
          --   the high or low or both values of the range can be 
          --   specified. Whan a low value is missing, it indicates that 
          --   the goal is achieved at any value at or below the high 
          --   value. Similarly, if the high value is missing, it 
          --   indicates that the goal is achieved at any value at or 
          --   above the low value.
          --   
          --   Choice between:
          --   
          --   (1) detailQuantity
          --   
          --   (2) detailRange
          --   
          --   (3) detailCodeableConcept
        , planDefinitionTarget_due :: Maybe Duration
          -- ^ Indicates the timeframe after the start of the goal in 
          --   which the goal should be met.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionTarget where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionTarget a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "measure")
            `apply` optional (oneOf' [ ("Quantity", fmap OneOf3 (parseSchemaType "detailQuantity"))
                                     , ("Range", fmap TwoOf3 (parseSchemaType "detailRange"))
                                     , ("CodeableConcept", fmap ThreeOf3 (parseSchemaType "detailCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "due")
    schemaTypeToXML s x@PlanDefinitionTarget{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionTarget_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionTarget_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionTarget_modifierExtension x
            , maybe [] (schemaTypeToXML "measure") $ planDefinitionTarget_measure x
            , maybe [] (foldOneOf3  (schemaTypeToXML "detailQuantity")
                                    (schemaTypeToXML "detailRange")
                                    (schemaTypeToXML "detailCodeableConcept")
                                   ) $ planDefinitionTarget_choice3 x
            , maybe [] (schemaTypeToXML "due") $ planDefinitionTarget_due x
            ]
instance Extension PlanDefinitionTarget BackboneElement where
    supertype (PlanDefinitionTarget a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionTarget Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionTarget -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionAction = PlanDefinitionAction
        { planDefinitionAction_id :: Maybe String_primitive
        , planDefinitionAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionAction_label :: Maybe Xsd.XsdString
          -- ^ A user-visible label for the action.
        , planDefinitionAction_title :: Maybe Xsd.XsdString
          -- ^ The title of the action displayed to a user.
        , planDefinitionAction_description :: Maybe Xsd.XsdString
          -- ^ A short description of the action used to provide a summary 
          --   to display to the user.
        , planDefinitionAction_textEquivalent :: Maybe Xsd.XsdString
          -- ^ A text equivalent of the action to be performed. This 
          --   provides a human-interpretable description of the action 
          --   when the definition is consumed by a system that may not be 
          --   capable of interpreting it dynamically.
        , planDefinitionAction_code :: [CodeableConcept]
          -- ^ A code that provides meaning for the action or action 
          --   group. For example, a section may have a LOINC code for a 
          --   the section of a documentation template.
        , planDefinitionAction_reason :: [CodeableConcept]
          -- ^ A description of why this action is necessary or 
          --   appropriate.
        , planDefinitionAction_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the action that can be provided to the CDS recipient. 
          --   Information resources can include inline text commentary 
          --   and links to web resources.
        , planDefinitionAction_goalId :: [Id]
          -- ^ Identifies goals that this action supports. The reference 
          --   must be to a goal element defined within this plan 
          --   definition.
        , planDefinitionAction_triggerDefinition :: [TriggerDefinition]
          -- ^ A description of when the action should be triggered.
        , planDefinitionAction_condition :: [PlanDefinitionCondition]
          -- ^ An expression that describes applicability criteria, or 
          --   start/stop conditions for the action.
        , planDefinitionAction_input :: [DataRequirement]
          -- ^ Defines input data requirements for the action.
        , planDefinitionAction_output :: [DataRequirement]
          -- ^ Defines the outputs of the action, if any.
        , planDefinitionAction_relatedAction :: [PlanDefinitionRelatedAction]
          -- ^ A relationship to another action such as &quot;before&quot; 
          --   or &quot;30-60 minutes after start of&quot;.
        , planDefinitionAction_choice15 :: (Maybe (OneOf5 DateTime Period Duration Range Timing))
          -- ^ An optional value describing when the action should be 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) timingDateTime
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDuration
          --   
          --   (4) timingRange
          --   
          --   (5) timingTiming
        , planDefinitionAction_participant :: [PlanDefinitionParticipant]
          -- ^ Indicates who should participate in performing the action 
          --   described.
        , planDefinitionAction_type :: Maybe Coding
          -- ^ The type of action to perform (create, update, remove).
        , planDefinitionAction_groupingBehavior :: Maybe ActionGroupingBehavior
          -- ^ Defines the grouping behavior for the action and its 
          --   children.
        , planDefinitionAction_selectionBehavior :: Maybe ActionSelectionBehavior
          -- ^ Defines the selection behavior for the action and its 
          --   children.
        , planDefinitionAction_requiredBehavior :: Maybe ActionRequiredBehavior
          -- ^ Defines the requiredness behavior for the action.
        , planDefinitionAction_precheckBehavior :: Maybe ActionPrecheckBehavior
          -- ^ Defines whether the action should usually be preselected.
        , planDefinitionAction_cardinalityBehavior :: Maybe ActionCardinalityBehavior
          -- ^ Defines whether the action can be selected multiple times.
        , planDefinitionAction_definition :: Maybe Reference
          -- ^ A reference to an ActivityDefinition that describes the 
          --   action to be taken in detail, or a PlanDefinition that 
          --   describes a series of actions to be taken.
        , planDefinitionAction_transform :: Maybe Reference
          -- ^ A reference to a StructureMap resource that defines a 
          --   transform that can be executed to produce the intent 
          --   resource using the ActivityDefinition instance as the 
          --   input.
        , planDefinitionAction_dynamicValue :: [PlanDefinitionDynamicValue]
          -- ^ Customizations that should be applied to the statically 
          --   defined resource. For example, if the dosage of a 
          --   medication must be computed based on the patient's weight, 
          --   a customization would be used to specify an expression that 
          --   calculated the weight, and the path on the resource that 
          --   would contain the result.
        , planDefinitionAction_action :: [PlanDefinitionAction]
          -- ^ Sub actions that are contained within the action. The 
          --   behavior of this action determines the functionality of the 
          --   sub-actions. For example, a selection behavior of 
          --   at-most-one indicates that of the sub-actions, at most one 
          --   may be chosen as part of realizing the action definition.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "textEquivalent")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "reason")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "goalId")
            `apply` many (parseSchemaType "triggerDefinition")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "input")
            `apply` many (parseSchemaType "output")
            `apply` many (parseSchemaType "relatedAction")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap TwoOf5 (parseSchemaType "timingPeriod"))
                                     , ("Duration", fmap ThreeOf5 (parseSchemaType "timingDuration"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "timingRange"))
                                     , ("Timing", fmap FiveOf5 (parseSchemaType "timingTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "groupingBehavior")
            `apply` optional (parseSchemaType "selectionBehavior")
            `apply` optional (parseSchemaType "requiredBehavior")
            `apply` optional (parseSchemaType "precheckBehavior")
            `apply` optional (parseSchemaType "cardinalityBehavior")
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "dynamicValue")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@PlanDefinitionAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionAction_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ planDefinitionAction_label x
            , maybe [] (schemaTypeToXML "title") $ planDefinitionAction_title x
            , maybe [] (schemaTypeToXML "description") $ planDefinitionAction_description x
            , maybe [] (schemaTypeToXML "textEquivalent") $ planDefinitionAction_textEquivalent x
            , concatMap (schemaTypeToXML "code") $ planDefinitionAction_code x
            , concatMap (schemaTypeToXML "reason") $ planDefinitionAction_reason x
            , concatMap (schemaTypeToXML "documentation") $ planDefinitionAction_documentation x
            , concatMap (schemaTypeToXML "goalId") $ planDefinitionAction_goalId x
            , concatMap (schemaTypeToXML "triggerDefinition") $ planDefinitionAction_triggerDefinition x
            , concatMap (schemaTypeToXML "condition") $ planDefinitionAction_condition x
            , concatMap (schemaTypeToXML "input") $ planDefinitionAction_input x
            , concatMap (schemaTypeToXML "output") $ planDefinitionAction_output x
            , concatMap (schemaTypeToXML "relatedAction") $ planDefinitionAction_relatedAction x
            , maybe [] (foldOneOf5  (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDuration")
                                    (schemaTypeToXML "timingRange")
                                    (schemaTypeToXML "timingTiming")
                                   ) $ planDefinitionAction_choice15 x
            , concatMap (schemaTypeToXML "participant") $ planDefinitionAction_participant x
            , maybe [] (schemaTypeToXML "type") $ planDefinitionAction_type x
            , maybe [] (schemaTypeToXML "groupingBehavior") $ planDefinitionAction_groupingBehavior x
            , maybe [] (schemaTypeToXML "selectionBehavior") $ planDefinitionAction_selectionBehavior x
            , maybe [] (schemaTypeToXML "requiredBehavior") $ planDefinitionAction_requiredBehavior x
            , maybe [] (schemaTypeToXML "precheckBehavior") $ planDefinitionAction_precheckBehavior x
            , maybe [] (schemaTypeToXML "cardinalityBehavior") $ planDefinitionAction_cardinalityBehavior x
            , maybe [] (schemaTypeToXML "definition") $ planDefinitionAction_definition x
            , maybe [] (schemaTypeToXML "transform") $ planDefinitionAction_transform x
            , concatMap (schemaTypeToXML "dynamicValue") $ planDefinitionAction_dynamicValue x
            , concatMap (schemaTypeToXML "action") $ planDefinitionAction_action x
            ]
instance Extension PlanDefinitionAction BackboneElement where
    supertype (PlanDefinitionAction a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionAction -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionCondition = PlanDefinitionCondition
        { planDefinitionCondition_id :: Maybe String_primitive
        , planDefinitionCondition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionCondition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionCondition_kind :: ActionConditionKind
          -- ^ The kind of condition.
        , planDefinitionCondition_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the condition that 
          --   effectively communicates the intended semantics.
        , planDefinitionCondition_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , planDefinitionCondition_expression :: Maybe Xsd.XsdString
          -- ^ An expression that returns true or false, indicating 
          --   whether or not the condition is satisfied.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionCondition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionCondition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@PlanDefinitionCondition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionCondition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionCondition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionCondition_modifierExtension x
            , schemaTypeToXML "kind" $ planDefinitionCondition_kind x
            , maybe [] (schemaTypeToXML "description") $ planDefinitionCondition_description x
            , maybe [] (schemaTypeToXML "language") $ planDefinitionCondition_language x
            , maybe [] (schemaTypeToXML "expression") $ planDefinitionCondition_expression x
            ]
instance Extension PlanDefinitionCondition BackboneElement where
    supertype (PlanDefinitionCondition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionCondition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionCondition -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionRelatedAction = PlanDefinitionRelatedAction
        { planDefinitionRelatedAction_id :: Maybe String_primitive
        , planDefinitionRelatedAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionRelatedAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionRelatedAction_actionId :: Id
          -- ^ The element id of the related action.
        , planDefinitionRelatedAction_relationship :: ActionRelationshipType
          -- ^ The relationship of this action to the related action.
        , planDefinitionRelatedAction_choice4 :: (Maybe (OneOf2 Duration Range))
          -- ^ A duration or range of durations to apply to the 
          --   relationship. For example, 30-60 minutes before.
          --   
          --   Choice between:
          --   
          --   (1) offsetDuration
          --   
          --   (2) offsetRange
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionRelatedAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionRelatedAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actionId"
            `apply` parseSchemaType "relationship"
            `apply` optional (oneOf' [ ("Duration", fmap OneOf2 (parseSchemaType "offsetDuration"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "offsetRange"))
                                     ])
    schemaTypeToXML s x@PlanDefinitionRelatedAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionRelatedAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionRelatedAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionRelatedAction_modifierExtension x
            , schemaTypeToXML "actionId" $ planDefinitionRelatedAction_actionId x
            , schemaTypeToXML "relationship" $ planDefinitionRelatedAction_relationship x
            , maybe [] (foldOneOf2  (schemaTypeToXML "offsetDuration")
                                    (schemaTypeToXML "offsetRange")
                                   ) $ planDefinitionRelatedAction_choice4 x
            ]
instance Extension PlanDefinitionRelatedAction BackboneElement where
    supertype (PlanDefinitionRelatedAction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionRelatedAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionRelatedAction -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionParticipant = PlanDefinitionParticipant
        { planDefinitionParticipant_id :: Maybe String_primitive
        , planDefinitionParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionParticipant_type :: ActionParticipantType
          -- ^ The type of participant in the action.
        , planDefinitionParticipant_role :: Maybe CodeableConcept
          -- ^ The role the participant should play in performing the 
          --   described action.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "role")
    schemaTypeToXML s x@PlanDefinitionParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionParticipant_modifierExtension x
            , schemaTypeToXML "type" $ planDefinitionParticipant_type x
            , maybe [] (schemaTypeToXML "role") $ planDefinitionParticipant_role x
            ]
instance Extension PlanDefinitionParticipant BackboneElement where
    supertype (PlanDefinitionParticipant a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionParticipant -> BackboneElement)
              
 
-- | This resource allows for the definition of various types of 
--   plans as a sharable, consumable, and executable artifact. 
--   The resource is general enough to support the description 
--   of a broad range of clinical artifacts such as clinical 
--   decision support rules, order sets and protocols.
data PlanDefinitionDynamicValue = PlanDefinitionDynamicValue
        { planDefinitionDynamicValue_id :: Maybe String_primitive
        , planDefinitionDynamicValue_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , planDefinitionDynamicValue_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , planDefinitionDynamicValue_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the intended 
          --   semantics of the dynamic value.
        , planDefinitionDynamicValue_path :: Maybe Xsd.XsdString
          -- ^ The path to the element to be customized. This is the path 
          --   on the resource that will hold the result of the 
          --   calculation defined by the expression.
        , planDefinitionDynamicValue_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , planDefinitionDynamicValue_expression :: Maybe Xsd.XsdString
          -- ^ An expression specifying the value of the customized 
          --   element.
        }
        deriving (Eq,Show)
instance SchemaType PlanDefinitionDynamicValue where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PlanDefinitionDynamicValue a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@PlanDefinitionDynamicValue{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ planDefinitionDynamicValue_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ planDefinitionDynamicValue_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ planDefinitionDynamicValue_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ planDefinitionDynamicValue_description x
            , maybe [] (schemaTypeToXML "path") $ planDefinitionDynamicValue_path x
            , maybe [] (schemaTypeToXML "language") $ planDefinitionDynamicValue_language x
            , maybe [] (schemaTypeToXML "expression") $ planDefinitionDynamicValue_expression x
            ]
instance Extension PlanDefinitionDynamicValue BackboneElement where
    supertype (PlanDefinitionDynamicValue a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PlanDefinitionDynamicValue Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PlanDefinitionDynamicValue -> BackboneElement)
              
 
data ActionRequiredBehavior_list
    = ActionRequiredBehavior_list_Must
      -- ^ Must
    | ActionRequiredBehavior_list_Could
      -- ^ Could
    | ActionRequiredBehavior_list_Must_unless_documented
      -- ^ Must Unless Documented
    deriving (Eq,Show,Enum)
instance SchemaType ActionRequiredBehavior_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionRequiredBehavior_list where
    acceptingParser =  do literal "must"; return ActionRequiredBehavior_list_Must
                      `onFail` do literal "could"; return ActionRequiredBehavior_list_Could
                      `onFail` do literal "must-unless-documented"; return ActionRequiredBehavior_list_Must_unless_documented
                      
    simpleTypeText ActionRequiredBehavior_list_Must = "must"
    simpleTypeText ActionRequiredBehavior_list_Could = "could"
    simpleTypeText ActionRequiredBehavior_list_Must_unless_documented = "must-unless-documented"
 
data ActionRequiredBehavior = ActionRequiredBehavior
        { actionRequiredBehavior_id :: Maybe String_primitive
        , actionRequiredBehavior_value :: Maybe ActionRequiredBehavior_list
        , actionRequiredBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionRequiredBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionRequiredBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionRequiredBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionRequiredBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionRequiredBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionRequiredBehavior_extension x
            ]
instance Extension ActionRequiredBehavior Element where
    supertype (ActionRequiredBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionRelationshipType_list
    = ActionRelationshipType_list_Before_start
      -- ^ Before Start
    | ActionRelationshipType_list_Before
      -- ^ Before
    | ActionRelationshipType_list_Before_end
      -- ^ Before End
    | ActionRelationshipType_list_Concurrent_with_start
      -- ^ Concurrent With Start
    | ActionRelationshipType_list_Concurrent
      -- ^ Concurrent
    | ActionRelationshipType_list_Concurrent_with_end
      -- ^ Concurrent With End
    | ActionRelationshipType_list_After_start
      -- ^ After Start
    | ActionRelationshipType_list_After
      -- ^ After
    | ActionRelationshipType_list_After_end
      -- ^ After End
    deriving (Eq,Show,Enum)
instance SchemaType ActionRelationshipType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionRelationshipType_list where
    acceptingParser =  do literal "before-start"; return ActionRelationshipType_list_Before_start
                      `onFail` do literal "before"; return ActionRelationshipType_list_Before
                      `onFail` do literal "before-end"; return ActionRelationshipType_list_Before_end
                      `onFail` do literal "concurrent-with-start"; return ActionRelationshipType_list_Concurrent_with_start
                      `onFail` do literal "concurrent"; return ActionRelationshipType_list_Concurrent
                      `onFail` do literal "concurrent-with-end"; return ActionRelationshipType_list_Concurrent_with_end
                      `onFail` do literal "after-start"; return ActionRelationshipType_list_After_start
                      `onFail` do literal "after"; return ActionRelationshipType_list_After
                      `onFail` do literal "after-end"; return ActionRelationshipType_list_After_end
                      
    simpleTypeText ActionRelationshipType_list_Before_start = "before-start"
    simpleTypeText ActionRelationshipType_list_Before = "before"
    simpleTypeText ActionRelationshipType_list_Before_end = "before-end"
    simpleTypeText ActionRelationshipType_list_Concurrent_with_start = "concurrent-with-start"
    simpleTypeText ActionRelationshipType_list_Concurrent = "concurrent"
    simpleTypeText ActionRelationshipType_list_Concurrent_with_end = "concurrent-with-end"
    simpleTypeText ActionRelationshipType_list_After_start = "after-start"
    simpleTypeText ActionRelationshipType_list_After = "after"
    simpleTypeText ActionRelationshipType_list_After_end = "after-end"
 
data ActionRelationshipType = ActionRelationshipType
        { actionRelationshipType_id :: Maybe String_primitive
        , actionRelationshipType_value :: Maybe ActionRelationshipType_list
        , actionRelationshipType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionRelationshipType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionRelationshipType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionRelationshipType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionRelationshipType_id x
                       , maybe [] (toXMLAttribute "value") $ actionRelationshipType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionRelationshipType_extension x
            ]
instance Extension ActionRelationshipType Element where
    supertype (ActionRelationshipType a0 a1 e0) =
               Element a0 e0
 
data ActionGroupingBehavior_list
    = ActionGroupingBehavior_list_Visual_group
      -- ^ Visual Group
    | ActionGroupingBehavior_list_Logical_group
      -- ^ Logical Group
    | ActionGroupingBehavior_list_Sentence_group
      -- ^ Sentence Group
    deriving (Eq,Show,Enum)
instance SchemaType ActionGroupingBehavior_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionGroupingBehavior_list where
    acceptingParser =  do literal "visual-group"; return ActionGroupingBehavior_list_Visual_group
                      `onFail` do literal "logical-group"; return ActionGroupingBehavior_list_Logical_group
                      `onFail` do literal "sentence-group"; return ActionGroupingBehavior_list_Sentence_group
                      
    simpleTypeText ActionGroupingBehavior_list_Visual_group = "visual-group"
    simpleTypeText ActionGroupingBehavior_list_Logical_group = "logical-group"
    simpleTypeText ActionGroupingBehavior_list_Sentence_group = "sentence-group"
 
data ActionGroupingBehavior = ActionGroupingBehavior
        { actionGroupingBehavior_id :: Maybe String_primitive
        , actionGroupingBehavior_value :: Maybe ActionGroupingBehavior_list
        , actionGroupingBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionGroupingBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionGroupingBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionGroupingBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionGroupingBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionGroupingBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionGroupingBehavior_extension x
            ]
instance Extension ActionGroupingBehavior Element where
    supertype (ActionGroupingBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionSelectionBehavior_list
    = ActionSelectionBehavior_list_Any
      -- ^ Any
    | ActionSelectionBehavior_list_All
      -- ^ All
    | ActionSelectionBehavior_list_All_or_none
      -- ^ All Or None
    | ActionSelectionBehavior_list_Exactly_one
      -- ^ Exactly One
    | ActionSelectionBehavior_list_At_most_one
      -- ^ At Most One
    | ActionSelectionBehavior_list_One_or_more
      -- ^ One Or More
    deriving (Eq,Show,Enum)
instance SchemaType ActionSelectionBehavior_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionSelectionBehavior_list where
    acceptingParser =  do literal "any"; return ActionSelectionBehavior_list_Any
                      `onFail` do literal "all"; return ActionSelectionBehavior_list_All
                      `onFail` do literal "all-or-none"; return ActionSelectionBehavior_list_All_or_none
                      `onFail` do literal "exactly-one"; return ActionSelectionBehavior_list_Exactly_one
                      `onFail` do literal "at-most-one"; return ActionSelectionBehavior_list_At_most_one
                      `onFail` do literal "one-or-more"; return ActionSelectionBehavior_list_One_or_more
                      
    simpleTypeText ActionSelectionBehavior_list_Any = "any"
    simpleTypeText ActionSelectionBehavior_list_All = "all"
    simpleTypeText ActionSelectionBehavior_list_All_or_none = "all-or-none"
    simpleTypeText ActionSelectionBehavior_list_Exactly_one = "exactly-one"
    simpleTypeText ActionSelectionBehavior_list_At_most_one = "at-most-one"
    simpleTypeText ActionSelectionBehavior_list_One_or_more = "one-or-more"
 
data ActionSelectionBehavior = ActionSelectionBehavior
        { actionSelectionBehavior_id :: Maybe String_primitive
        , actionSelectionBehavior_value :: Maybe ActionSelectionBehavior_list
        , actionSelectionBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionSelectionBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionSelectionBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionSelectionBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionSelectionBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionSelectionBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionSelectionBehavior_extension x
            ]
instance Extension ActionSelectionBehavior Element where
    supertype (ActionSelectionBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionCardinalityBehavior_list
    = ActionCardinalityBehavior_list_Single
      -- ^ Single
    | ActionCardinalityBehavior_list_Multiple
      -- ^ Multiple
    deriving (Eq,Show,Enum)
instance SchemaType ActionCardinalityBehavior_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionCardinalityBehavior_list where
    acceptingParser =  do literal "single"; return ActionCardinalityBehavior_list_Single
                      `onFail` do literal "multiple"; return ActionCardinalityBehavior_list_Multiple
                      
    simpleTypeText ActionCardinalityBehavior_list_Single = "single"
    simpleTypeText ActionCardinalityBehavior_list_Multiple = "multiple"
 
data ActionCardinalityBehavior = ActionCardinalityBehavior
        { actionCardinalityBehavior_id :: Maybe String_primitive
        , actionCardinalityBehavior_value :: Maybe ActionCardinalityBehavior_list
        , actionCardinalityBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionCardinalityBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionCardinalityBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionCardinalityBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionCardinalityBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionCardinalityBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionCardinalityBehavior_extension x
            ]
instance Extension ActionCardinalityBehavior Element where
    supertype (ActionCardinalityBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionPrecheckBehavior_list
    = ActionPrecheckBehavior_list_Yes
      -- ^ Yes
    | ActionPrecheckBehavior_list_No
      -- ^ No
    deriving (Eq,Show,Enum)
instance SchemaType ActionPrecheckBehavior_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionPrecheckBehavior_list where
    acceptingParser =  do literal "yes"; return ActionPrecheckBehavior_list_Yes
                      `onFail` do literal "no"; return ActionPrecheckBehavior_list_No
                      
    simpleTypeText ActionPrecheckBehavior_list_Yes = "yes"
    simpleTypeText ActionPrecheckBehavior_list_No = "no"
 
data ActionPrecheckBehavior = ActionPrecheckBehavior
        { actionPrecheckBehavior_id :: Maybe String_primitive
        , actionPrecheckBehavior_value :: Maybe ActionPrecheckBehavior_list
        , actionPrecheckBehavior_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionPrecheckBehavior where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionPrecheckBehavior a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionPrecheckBehavior{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionPrecheckBehavior_id x
                       , maybe [] (toXMLAttribute "value") $ actionPrecheckBehavior_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionPrecheckBehavior_extension x
            ]
instance Extension ActionPrecheckBehavior Element where
    supertype (ActionPrecheckBehavior a0 a1 e0) =
               Element a0 e0
 
data ActionConditionKind_list
    = ActionConditionKind_list_Applicability
      -- ^ Applicability
    | ActionConditionKind_list_Start
      -- ^ Start
    | ActionConditionKind_list_Stop
      -- ^ Stop
    deriving (Eq,Show,Enum)
instance SchemaType ActionConditionKind_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionConditionKind_list where
    acceptingParser =  do literal "applicability"; return ActionConditionKind_list_Applicability
                      `onFail` do literal "start"; return ActionConditionKind_list_Start
                      `onFail` do literal "stop"; return ActionConditionKind_list_Stop
                      
    simpleTypeText ActionConditionKind_list_Applicability = "applicability"
    simpleTypeText ActionConditionKind_list_Start = "start"
    simpleTypeText ActionConditionKind_list_Stop = "stop"
 
data ActionConditionKind = ActionConditionKind
        { actionConditionKind_id :: Maybe String_primitive
        , actionConditionKind_value :: Maybe ActionConditionKind_list
        , actionConditionKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionConditionKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionConditionKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionConditionKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionConditionKind_id x
                       , maybe [] (toXMLAttribute "value") $ actionConditionKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionConditionKind_extension x
            ]
instance Extension ActionConditionKind Element where
    supertype (ActionConditionKind a0 a1 e0) =
               Element a0 e0
 
-- | A person who is directly or indirectly involved in the 
--   provisioning of healthcare.
elementPractitioner :: XMLParser Practitioner
elementPractitioner = parseSchemaType "Practitioner"
elementToXMLPractitioner :: Practitioner -> [Content ()]
elementToXMLPractitioner = schemaTypeToXML "Practitioner"
 
data Practitioner = Practitioner
        { practitioner_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , practitioner_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , practitioner_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , practitioner_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , practitioner_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , practitioner_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , practitioner_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitioner_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitioner_identifier :: [Identifier]
          -- ^ An identifier that applies to this person in this role.
        , practitioner_active :: Maybe Boolean
          -- ^ Whether this practitioner's record is in active use.
        , practitioner_name :: [HumanName]
          -- ^ The name(s) associated with the practitioner.
        , practitioner_telecom :: [ContactPoint]
          -- ^ A contact detail for the practitioner, e.g. a telephone 
          --   number or an email address.
        , practitioner_address :: [Address]
          -- ^ Address(es) of the practitioner that are not role specific 
          --   (typically home address). Work addresses are not typically 
          --   entered in this property as they are usually role 
          --   dependent.
        , practitioner_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the person is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , practitioner_birthDate :: Maybe Date
          -- ^ The date of birth for the practitioner.
        , practitioner_photo :: [Attachment]
          -- ^ Image of the person.
        , practitioner_qualification :: [PractitionerQualification]
          -- ^ Qualifications obtained by training and certification.
        , practitioner_communication :: [CodeableConcept]
          -- ^ A language the practitioner is able to use in patient 
          --   communication.
        }
        deriving (Eq,Show)
instance SchemaType Practitioner where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Practitioner
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "address")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "photo")
            `apply` many (parseSchemaType "qualification")
            `apply` many (parseSchemaType "communication")
    schemaTypeToXML s x@Practitioner{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ practitioner_id x
            , maybe [] (schemaTypeToXML "meta") $ practitioner_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ practitioner_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ practitioner_language x
            , maybe [] (schemaTypeToXML "text") $ practitioner_text x
            , concatMap (schemaTypeToXML "contained") $ practitioner_contained x
            , concatMap (schemaTypeToXML "extension") $ practitioner_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitioner_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitioner_identifier x
            , maybe [] (schemaTypeToXML "active") $ practitioner_active x
            , concatMap (schemaTypeToXML "name") $ practitioner_name x
            , concatMap (schemaTypeToXML "telecom") $ practitioner_telecom x
            , concatMap (schemaTypeToXML "address") $ practitioner_address x
            , maybe [] (schemaTypeToXML "gender") $ practitioner_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ practitioner_birthDate x
            , concatMap (schemaTypeToXML "photo") $ practitioner_photo x
            , concatMap (schemaTypeToXML "qualification") $ practitioner_qualification x
            , concatMap (schemaTypeToXML "communication") $ practitioner_communication x
            ]
instance Extension Practitioner DomainResource where
    supertype (Practitioner e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Practitioner Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Practitioner -> DomainResource)
              
 
-- | A person who is directly or indirectly involved in the 
--   provisioning of healthcare.
data PractitionerQualification = PractitionerQualification
        { practitionerQualification_id :: Maybe String_primitive
        , practitionerQualification_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerQualification_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerQualification_identifier :: [Identifier]
          -- ^ An identifier that applies to this person's qualification 
          --   in this role.
        , practitionerQualification_code :: CodeableConcept
          -- ^ Coded representation of the qualification.
        , practitionerQualification_period :: Maybe Period
          -- ^ Period during which the qualification is valid.
        , practitionerQualification_issuer :: Maybe Reference
          -- ^ Organization that regulates and issues the qualification.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerQualification where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PractitionerQualification a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "issuer")
    schemaTypeToXML s x@PractitionerQualification{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitionerQualification_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitionerQualification_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerQualification_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitionerQualification_identifier x
            , schemaTypeToXML "code" $ practitionerQualification_code x
            , maybe [] (schemaTypeToXML "period") $ practitionerQualification_period x
            , maybe [] (schemaTypeToXML "issuer") $ practitionerQualification_issuer x
            ]
instance Extension PractitionerQualification BackboneElement where
    supertype (PractitionerQualification a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PractitionerQualification Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PractitionerQualification -> BackboneElement)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
elementPractitionerRole :: XMLParser PractitionerRole
elementPractitionerRole = parseSchemaType "PractitionerRole"
elementToXMLPractitionerRole :: PractitionerRole -> [Content ()]
elementToXMLPractitionerRole = schemaTypeToXML "PractitionerRole"
 
data PractitionerRole = PractitionerRole
        { practitionerRole_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , practitionerRole_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , practitionerRole_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , practitionerRole_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , practitionerRole_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , practitionerRole_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , practitionerRole_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRole_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRole_identifier :: [Identifier]
          -- ^ Business Identifiers that are specific to a role/location.
        , practitionerRole_active :: Maybe Boolean
          -- ^ Whether this practitioner's record is in active use.
        , practitionerRole_period :: Maybe Period
          -- ^ The period during which the person is authorized to act as 
          --   a practitioner in these role(s) for the organization.
        , practitionerRole_practitioner :: Maybe Reference
          -- ^ Practitioner that is able to provide the defined services 
          --   for the organation.
        , practitionerRole_organization :: Maybe Reference
          -- ^ The organization where the Practitioner performs the roles 
          --   associated.
        , practitionerRole_code :: [CodeableConcept]
          -- ^ Roles which this practitioner is authorized to perform for 
          --   the organization.
        , practitionerRole_specialty :: [CodeableConcept]
          -- ^ Specific specialty of the practitioner.
        , practitionerRole_location :: [Reference]
          -- ^ The location(s) at which this practitioner provides care.
        , practitionerRole_healthcareService :: [Reference]
          -- ^ The list of healthcare services that this worker provides 
          --   for this role's Organization/Location(s).
        , practitionerRole_telecom :: [ContactPoint]
          -- ^ Contact details that are specific to the 
          --   role/location/service.
        , practitionerRole_availableTime :: [PractitionerRoleAvailableTime]
          -- ^ A collection of times that the Service Site is available.
        , practitionerRole_notAvailable :: [PractitionerRoleNotAvailable]
          -- ^ The HealthcareService is not available during this period 
          --   of time due to the provided reason.
        , practitionerRole_availabilityExceptions :: Maybe Xsd.XsdString
          -- ^ A description of site availability exceptions, e.g. public 
          --   holiday availability. Succinctly describing all possible 
          --   exceptions to normal site availability as details in the 
          --   available Times and not available Times.
        , practitionerRole_endpoint :: [Reference]
          -- ^ Technical endpoints providing access to services operated 
          --   for the practitioner with this role.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRole where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return PractitionerRole
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "practitioner")
            `apply` optional (parseSchemaType "organization")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "specialty")
            `apply` many (parseSchemaType "location")
            `apply` many (parseSchemaType "healthcareService")
            `apply` many (parseSchemaType "telecom")
            `apply` many (parseSchemaType "availableTime")
            `apply` many (parseSchemaType "notAvailable")
            `apply` optional (parseSchemaType "availabilityExceptions")
            `apply` many (parseSchemaType "endpoint")
    schemaTypeToXML s x@PractitionerRole{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ practitionerRole_id x
            , maybe [] (schemaTypeToXML "meta") $ practitionerRole_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ practitionerRole_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ practitionerRole_language x
            , maybe [] (schemaTypeToXML "text") $ practitionerRole_text x
            , concatMap (schemaTypeToXML "contained") $ practitionerRole_contained x
            , concatMap (schemaTypeToXML "extension") $ practitionerRole_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRole_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ practitionerRole_identifier x
            , maybe [] (schemaTypeToXML "active") $ practitionerRole_active x
            , maybe [] (schemaTypeToXML "period") $ practitionerRole_period x
            , maybe [] (schemaTypeToXML "practitioner") $ practitionerRole_practitioner x
            , maybe [] (schemaTypeToXML "organization") $ practitionerRole_organization x
            , concatMap (schemaTypeToXML "code") $ practitionerRole_code x
            , concatMap (schemaTypeToXML "specialty") $ practitionerRole_specialty x
            , concatMap (schemaTypeToXML "location") $ practitionerRole_location x
            , concatMap (schemaTypeToXML "healthcareService") $ practitionerRole_healthcareService x
            , concatMap (schemaTypeToXML "telecom") $ practitionerRole_telecom x
            , concatMap (schemaTypeToXML "availableTime") $ practitionerRole_availableTime x
            , concatMap (schemaTypeToXML "notAvailable") $ practitionerRole_notAvailable x
            , maybe [] (schemaTypeToXML "availabilityExceptions") $ practitionerRole_availabilityExceptions x
            , concatMap (schemaTypeToXML "endpoint") $ practitionerRole_endpoint x
            ]
instance Extension PractitionerRole DomainResource where
    supertype (PractitionerRole e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension PractitionerRole Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: PractitionerRole -> DomainResource)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
data PractitionerRoleAvailableTime = PractitionerRoleAvailableTime
        { practitionerRoleAvailableTime_id :: Maybe String_primitive
        , practitionerRoleAvailableTime_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRoleAvailableTime_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRoleAvailableTime_daysOfWeek :: [DaysOfWeek]
          -- ^ Indicates which days of the week are available between the 
          --   start and end Times.
        , practitionerRoleAvailableTime_allDay :: Maybe Boolean
          -- ^ Is this always available? (hence times are irrelevant) e.g. 
          --   24 hour service.
        , practitionerRoleAvailableTime_availableStartTime :: Maybe Time
          -- ^ The opening time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        , practitionerRoleAvailableTime_availableEndTime :: Maybe Time
          -- ^ The closing time of day. Note: If the AllDay flag is set, 
          --   then this time is ignored.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRoleAvailableTime where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PractitionerRoleAvailableTime a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "daysOfWeek")
            `apply` optional (parseSchemaType "allDay")
            `apply` optional (parseSchemaType "availableStartTime")
            `apply` optional (parseSchemaType "availableEndTime")
    schemaTypeToXML s x@PractitionerRoleAvailableTime{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitionerRoleAvailableTime_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitionerRoleAvailableTime_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRoleAvailableTime_modifierExtension x
            , concatMap (schemaTypeToXML "daysOfWeek") $ practitionerRoleAvailableTime_daysOfWeek x
            , maybe [] (schemaTypeToXML "allDay") $ practitionerRoleAvailableTime_allDay x
            , maybe [] (schemaTypeToXML "availableStartTime") $ practitionerRoleAvailableTime_availableStartTime x
            , maybe [] (schemaTypeToXML "availableEndTime") $ practitionerRoleAvailableTime_availableEndTime x
            ]
instance Extension PractitionerRoleAvailableTime BackboneElement where
    supertype (PractitionerRoleAvailableTime a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension PractitionerRoleAvailableTime Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PractitionerRoleAvailableTime -> BackboneElement)
              
 
-- | A specific set of Roles/Locations/specialties/services that 
--   a practitioner may perform at an organization for a period 
--   of time.
data PractitionerRoleNotAvailable = PractitionerRoleNotAvailable
        { practitionerRoleNotAvailable_id :: Maybe String_primitive
        , practitionerRoleNotAvailable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , practitionerRoleNotAvailable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , practitionerRoleNotAvailable_description :: Xsd.XsdString
          -- ^ The reason that can be presented to the user as to why this 
          --   time is not available.
        , practitionerRoleNotAvailable_during :: Maybe Period
          -- ^ Service is not available (seasonally or for a public 
          --   holiday) from this date.
        }
        deriving (Eq,Show)
instance SchemaType PractitionerRoleNotAvailable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (PractitionerRoleNotAvailable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "during")
    schemaTypeToXML s x@PractitionerRoleNotAvailable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ practitionerRoleNotAvailable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ practitionerRoleNotAvailable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ practitionerRoleNotAvailable_modifierExtension x
            , schemaTypeToXML "description" $ practitionerRoleNotAvailable_description x
            , maybe [] (schemaTypeToXML "during") $ practitionerRoleNotAvailable_during x
            ]
instance Extension PractitionerRoleNotAvailable BackboneElement where
    supertype (PractitionerRoleNotAvailable a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension PractitionerRoleNotAvailable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: PractitionerRoleNotAvailable -> BackboneElement)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
elementProcedure :: XMLParser Procedure
elementProcedure = parseSchemaType "Procedure"
elementToXMLProcedure :: Procedure -> [Content ()]
elementToXMLProcedure = schemaTypeToXML "Procedure"
 
data Procedure = Procedure
        { procedure_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , procedure_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , procedure_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , procedure_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , procedure_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , procedure_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , procedure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedure_identifier :: [Identifier]
          -- ^ This records identifiers associated with this procedure 
          --   that are defined by business processes and/or used to refer 
          --   to it when a direct URL reference to the resource itself is 
          --   not appropriate (e.g. in CDA documents, or in written / 
          --   printed documentation).
        , procedure_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that 
          --   was adhered to in whole or in part by this procedure.
        , procedure_basedOn :: [Reference]
          -- ^ A reference to a resource that contains details of the 
          --   request for this procedure.
        , procedure_partOf :: [Reference]
          -- ^ A larger event of which this particular procedure is a 
          --   component or step.
        , procedure_status :: EventStatus
          -- ^ A code specifying the state of the procedure. Generally 
          --   this will be in-progress or completed state.
        , procedure_notDone :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the procedure 
          --   was NOT performed.
        , procedure_notDoneReason :: Maybe CodeableConcept
          -- ^ A code indicating why the procedure was not performed.
        , procedure_category :: Maybe CodeableConcept
          -- ^ A code that classifies the procedure for searching, sorting 
          --   and display purposes (e.g. &quot;Surgical Procedure&quot;).
        , procedure_code :: Maybe CodeableConcept
          -- ^ The specific procedure that is performed. Use text if the 
          --   exact nature of the procedure cannot be coded (e.g. 
          --   &quot;Laparoscopic Appendectomy&quot;).
        , procedure_subject :: Reference
          -- ^ The person, animal or group on which the procedure was 
          --   performed.
        , procedure_context :: Maybe Reference
          -- ^ The encounter during which the procedure was performed.
        , procedure_choice19 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date(time)/period over which the procedure was 
          --   performed. Allows a period to support complex procedures 
          --   that span more than one date, and also allows for the 
          --   length of the procedure to be captured.
          --   
          --   Choice between:
          --   
          --   (1) performedDateTime
          --   
          --   (2) performedPeriod
        , procedure_performer :: [ProcedurePerformer]
          -- ^ Limited to 'real' people rather than equipment.
        , procedure_location :: Maybe Reference
          -- ^ The location where the procedure actually happened. E.g. a 
          --   newborn at home, a tracheostomy at a restaurant.
        , procedure_reasonCode :: [CodeableConcept]
          -- ^ The coded reason why the procedure was performed. This may 
          --   be coded entity of some type, or may simply be present as 
          --   text.
        , procedure_reasonReference :: [Reference]
          -- ^ The condition that is the reason why the procedure was 
          --   performed.
        , procedure_bodySite :: [CodeableConcept]
          -- ^ Detailed and structured anatomical location information. 
          --   Multiple locations are allowed - e.g. multiple punch 
          --   biopsies of a lesion.
        , procedure_outcome :: Maybe CodeableConcept
          -- ^ The outcome of the procedure - did it resolve reasons for 
          --   the procedure being performed?
        , procedure_report :: [Reference]
          -- ^ This could be a histology result, pathology report, 
          --   surgical report, etc..
        , procedure_complication :: [CodeableConcept]
          -- ^ Any complications that occurred during the procedure, or in 
          --   the immediate post-performance period. These are generally 
          --   tracked separately from the notes, which will typically 
          --   describe the procedure itself rather than any 'post 
          --   procedure' issues.
        , procedure_complicationDetail :: [Reference]
          -- ^ Any complications that occurred during the procedure, or in 
          --   the immediate post-performance period.
        , procedure_followUp :: [CodeableConcept]
          -- ^ If the procedure required specific follow up - e.g. removal 
          --   of sutures. The followup may be represented as a simple 
          --   note, or could potentially be more complex in which case 
          --   the CarePlan resource can be used.
        , procedure_note :: [Annotation]
          -- ^ Any other notes about the procedure. E.g. the operative 
          --   notes.
        , procedure_focalDevice :: [ProcedureFocalDevice]
          -- ^ A device that is implanted, removed or otherwise 
          --   manipulated (calibration, battery replacement, fitting a 
          --   prosthesis, attaching a wound-vac, etc.) as a focal portion 
          --   of the Procedure.
        , procedure_usedReference :: [Reference]
          -- ^ Identifies medications, devices and any other substance 
          --   used as part of the procedure.
        , procedure_usedCode :: [CodeableConcept]
          -- ^ Identifies coded items that were used as part of the 
          --   procedure.
        }
        deriving (Eq,Show)
instance SchemaType Procedure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Procedure
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "notDone")
            `apply` optional (parseSchemaType "notDoneReason")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "code")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "performedDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "performedPeriod"))
                                     ])
            `apply` many (parseSchemaType "performer")
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "bodySite")
            `apply` optional (parseSchemaType "outcome")
            `apply` many (parseSchemaType "report")
            `apply` many (parseSchemaType "complication")
            `apply` many (parseSchemaType "complicationDetail")
            `apply` many (parseSchemaType "followUp")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "focalDevice")
            `apply` many (parseSchemaType "usedReference")
            `apply` many (parseSchemaType "usedCode")
    schemaTypeToXML s x@Procedure{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ procedure_id x
            , maybe [] (schemaTypeToXML "meta") $ procedure_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ procedure_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ procedure_language x
            , maybe [] (schemaTypeToXML "text") $ procedure_text x
            , concatMap (schemaTypeToXML "contained") $ procedure_contained x
            , concatMap (schemaTypeToXML "extension") $ procedure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedure_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ procedure_identifier x
            , concatMap (schemaTypeToXML "definition") $ procedure_definition x
            , concatMap (schemaTypeToXML "basedOn") $ procedure_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ procedure_partOf x
            , schemaTypeToXML "status" $ procedure_status x
            , maybe [] (schemaTypeToXML "notDone") $ procedure_notDone x
            , maybe [] (schemaTypeToXML "notDoneReason") $ procedure_notDoneReason x
            , maybe [] (schemaTypeToXML "category") $ procedure_category x
            , maybe [] (schemaTypeToXML "code") $ procedure_code x
            , schemaTypeToXML "subject" $ procedure_subject x
            , maybe [] (schemaTypeToXML "context") $ procedure_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "performedDateTime")
                                    (schemaTypeToXML "performedPeriod")
                                   ) $ procedure_choice19 x
            , concatMap (schemaTypeToXML "performer") $ procedure_performer x
            , maybe [] (schemaTypeToXML "location") $ procedure_location x
            , concatMap (schemaTypeToXML "reasonCode") $ procedure_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ procedure_reasonReference x
            , concatMap (schemaTypeToXML "bodySite") $ procedure_bodySite x
            , maybe [] (schemaTypeToXML "outcome") $ procedure_outcome x
            , concatMap (schemaTypeToXML "report") $ procedure_report x
            , concatMap (schemaTypeToXML "complication") $ procedure_complication x
            , concatMap (schemaTypeToXML "complicationDetail") $ procedure_complicationDetail x
            , concatMap (schemaTypeToXML "followUp") $ procedure_followUp x
            , concatMap (schemaTypeToXML "note") $ procedure_note x
            , concatMap (schemaTypeToXML "focalDevice") $ procedure_focalDevice x
            , concatMap (schemaTypeToXML "usedReference") $ procedure_usedReference x
            , concatMap (schemaTypeToXML "usedCode") $ procedure_usedCode x
            ]
instance Extension Procedure DomainResource where
    supertype (Procedure e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Procedure Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Procedure -> DomainResource)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
data ProcedurePerformer = ProcedurePerformer
        { procedurePerformer_id :: Maybe String_primitive
        , procedurePerformer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedurePerformer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedurePerformer_role :: Maybe CodeableConcept
          -- ^ For example: surgeon, anaethetist, endoscopist.
        , procedurePerformer_actor :: Reference
          -- ^ The practitioner who was involved in the procedure.
        , procedurePerformer_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType ProcedurePerformer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcedurePerformer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "role")
            `apply` parseSchemaType "actor"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@ProcedurePerformer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedurePerformer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedurePerformer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedurePerformer_modifierExtension x
            , maybe [] (schemaTypeToXML "role") $ procedurePerformer_role x
            , schemaTypeToXML "actor" $ procedurePerformer_actor x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ procedurePerformer_onBehalfOf x
            ]
instance Extension ProcedurePerformer BackboneElement where
    supertype (ProcedurePerformer a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ProcedurePerformer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcedurePerformer -> BackboneElement)
              
 
-- | An action that is or was performed on a patient. This can 
--   be a physical intervention like an operation, or less 
--   invasive like counseling or hypnotherapy.
data ProcedureFocalDevice = ProcedureFocalDevice
        { procedureFocalDevice_id :: Maybe String_primitive
        , procedureFocalDevice_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedureFocalDevice_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedureFocalDevice_action :: Maybe CodeableConcept
          -- ^ The kind of change that happened to the device during the 
          --   procedure.
        , procedureFocalDevice_manipulated :: Reference
          -- ^ The device that was manipulated (changed) during the 
          --   procedure.
        }
        deriving (Eq,Show)
instance SchemaType ProcedureFocalDevice where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcedureFocalDevice a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "action")
            `apply` parseSchemaType "manipulated"
    schemaTypeToXML s x@ProcedureFocalDevice{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedureFocalDevice_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedureFocalDevice_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedureFocalDevice_modifierExtension x
            , maybe [] (schemaTypeToXML "action") $ procedureFocalDevice_action x
            , schemaTypeToXML "manipulated" $ procedureFocalDevice_manipulated x
            ]
instance Extension ProcedureFocalDevice BackboneElement where
    supertype (ProcedureFocalDevice a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ProcedureFocalDevice Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcedureFocalDevice -> BackboneElement)
              
 
-- | A record of a request for diagnostic investigations, 
--   treatments, or operations to be performed.
elementProcedureRequest :: XMLParser ProcedureRequest
elementProcedureRequest = parseSchemaType "ProcedureRequest"
elementToXMLProcedureRequest :: ProcedureRequest -> [Content ()]
elementToXMLProcedureRequest = schemaTypeToXML "ProcedureRequest"
 
data ProcedureRequest = ProcedureRequest
        { procedureRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , procedureRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , procedureRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , procedureRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , procedureRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , procedureRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , procedureRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedureRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedureRequest_identifier :: [Identifier]
          -- ^ Identifiers assigned to this order instance by the orderer 
          --   and/or the receiver and/or order fulfiller.
        , procedureRequest_definition :: [Reference]
          -- ^ Protocol or definition followed by this request.
        , procedureRequest_basedOn :: [Reference]
          -- ^ Plan/proposal/order fulfilled by this request.
        , procedureRequest_replaces :: [Reference]
          -- ^ The request takes the place of the referenced completed or 
          --   terminated request(s).
        , procedureRequest_requisition :: Maybe Identifier
          -- ^ A shared identifier common to all procedure or diagnostic 
          --   requests that were authorized more or less simultaneously 
          --   by a single author, representing the composite or group 
          --   identifier.
        , procedureRequest_status :: RequestStatus
          -- ^ The status of the order.
        , procedureRequest_intent :: RequestIntent
          -- ^ Whether the request is a proposal, plan, an original order 
          --   or a reflex order.
        , procedureRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the ProcedureRequest should be 
          --   addressed with respect to other requests.
        , procedureRequest_doNotPerform :: Maybe Boolean
          -- ^ Set this to true if the record is saying that the procedure 
          --   should NOT be performed.
        , procedureRequest_category :: [CodeableConcept]
          -- ^ A code that classifies the procedure for searching, sorting 
          --   and display purposes (e.g. &quot;Surgical Procedure&quot;).
        , procedureRequest_code :: CodeableConcept
          -- ^ A code that identifies a particular procedure, diagnostic 
          --   investigation, or panel of investigations, that have been 
          --   requested.
        , procedureRequest_subject :: Reference
          -- ^ On whom or what the procedure or diagnostic is to be 
          --   performed. This is usually a human patient, but can also be 
          --   requested on animals, groups of humans or animals, devices 
          --   such as dialysis machines, or even locations (typically for 
          --   environmental scans).
        , procedureRequest_context :: Maybe Reference
          -- ^ An encounter or episode of care that provides additional 
          --   information about the healthcare context in which this 
          --   request is made.
        , procedureRequest_choice21 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The date/time at which the diagnostic testing should occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , procedureRequest_choice22 :: (Maybe (OneOf2 Boolean CodeableConcept))
          -- ^ If a CodeableConcept is present, it indicates the 
          --   pre-condition for performing the procedure. For example 
          --   &quot;pain&quot;, &quot;on flare-up&quot;, etc.
          --   
          --   Choice between:
          --   
          --   (1) asNeededBoolean
          --   
          --   (2) asNeededCodeableConcept
        , procedureRequest_authoredOn :: Maybe DateTime
          -- ^ When the request transitioned to being actionable.
        , procedureRequest_requester :: Maybe ProcedureRequestRequester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , procedureRequest_performerType :: Maybe CodeableConcept
          -- ^ Desired type of performer for doing the diagnostic testing.
        , procedureRequest_performer :: Maybe Reference
          -- ^ The desired perfomer for doing the diagnostic testing. For 
          --   example, the surgeon, dermatopathologist, endoscopist, etc.
        , procedureRequest_reasonCode :: [CodeableConcept]
          -- ^ An explanation or justification for why this diagnostic 
          --   investigation is being requested in coded or textual form. 
          --   This is often for billing purposes. May relate to the 
          --   resources referred to in supportingInformation.
        , procedureRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource that provides a justification 
          --   for why this diagnostic investigation is being requested. 
          --   May relate to the resources referred to in 
          --   supportingInformation.
        , procedureRequest_supportingInfo :: [Reference]
          -- ^ Additional clinical information about the patient or 
          --   specimen that may influence the procedure or diagnostics or 
          --   their interpretations. This information includes diagnosis, 
          --   clinical findings and other observations. In laboratory 
          --   ordering these are typically referred to as &quot;ask at 
          --   order entry questions (AOEs)&quot;. This includes 
          --   observations explicitly requested by the producer (filler) 
          --   to provide context or supporting information needed to 
          --   complete the order. For example, reporting the amount of 
          --   inspired oxygen for blood gas measurements.
        , procedureRequest_specimen :: [Reference]
          -- ^ One or more specimens that the laboratory procedure will 
          --   use.
        , procedureRequest_bodySite :: [CodeableConcept]
          -- ^ Anatomic location where the procedure should be performed. 
          --   This is the target site.
        , procedureRequest_note :: [Annotation]
          -- ^ Any other notes and comments made about the service 
          --   request. For example, letting provider know that 
          --   &quot;patient hates needles&quot; or other provider 
          --   instructions.
        , procedureRequest_relevantHistory :: [Reference]
          -- ^ Key events in the history of the request.
        }
        deriving (Eq,Show)
instance SchemaType ProcedureRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcedureRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "requisition")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "doNotPerform")
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf2 (parseSchemaType "asNeededBoolean"))
                                     , ("CodeableConcept", fmap TwoOf2 (parseSchemaType "asNeededCodeableConcept"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "performer")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "specimen")
            `apply` many (parseSchemaType "bodySite")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@ProcedureRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ procedureRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ procedureRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ procedureRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ procedureRequest_language x
            , maybe [] (schemaTypeToXML "text") $ procedureRequest_text x
            , concatMap (schemaTypeToXML "contained") $ procedureRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ procedureRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedureRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ procedureRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ procedureRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ procedureRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ procedureRequest_replaces x
            , maybe [] (schemaTypeToXML "requisition") $ procedureRequest_requisition x
            , schemaTypeToXML "status" $ procedureRequest_status x
            , schemaTypeToXML "intent" $ procedureRequest_intent x
            , maybe [] (schemaTypeToXML "priority") $ procedureRequest_priority x
            , maybe [] (schemaTypeToXML "doNotPerform") $ procedureRequest_doNotPerform x
            , concatMap (schemaTypeToXML "category") $ procedureRequest_category x
            , schemaTypeToXML "code" $ procedureRequest_code x
            , schemaTypeToXML "subject" $ procedureRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ procedureRequest_context x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ procedureRequest_choice21 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "asNeededBoolean")
                                    (schemaTypeToXML "asNeededCodeableConcept")
                                   ) $ procedureRequest_choice22 x
            , maybe [] (schemaTypeToXML "authoredOn") $ procedureRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ procedureRequest_requester x
            , maybe [] (schemaTypeToXML "performerType") $ procedureRequest_performerType x
            , maybe [] (schemaTypeToXML "performer") $ procedureRequest_performer x
            , concatMap (schemaTypeToXML "reasonCode") $ procedureRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ procedureRequest_reasonReference x
            , concatMap (schemaTypeToXML "supportingInfo") $ procedureRequest_supportingInfo x
            , concatMap (schemaTypeToXML "specimen") $ procedureRequest_specimen x
            , concatMap (schemaTypeToXML "bodySite") $ procedureRequest_bodySite x
            , concatMap (schemaTypeToXML "note") $ procedureRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ procedureRequest_relevantHistory x
            ]
instance Extension ProcedureRequest DomainResource where
    supertype (ProcedureRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcedureRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcedureRequest -> DomainResource)
              
 
-- | A record of a request for diagnostic investigations, 
--   treatments, or operations to be performed.
data ProcedureRequestRequester = ProcedureRequestRequester
        { procedureRequestRequester_id :: Maybe String_primitive
        , procedureRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , procedureRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , procedureRequestRequester_agent :: Reference
          -- ^ The device, practitioner or organization who initiated the 
          --   request.
        , procedureRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType ProcedureRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcedureRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@ProcedureRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ procedureRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ procedureRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ procedureRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ procedureRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ procedureRequestRequester_onBehalfOf x
            ]
instance Extension ProcedureRequestRequester BackboneElement where
    supertype (ProcedureRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ProcedureRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcedureRequestRequester -> BackboneElement)
              
 
data RequestIntent_list
    = RequestIntent_list_Proposal
      -- ^ Proposal
    | RequestIntent_list_Plan
      -- ^ Plan
    | RequestIntent_list_Order
      -- ^ Order
    | RequestIntent_list_Original_order
      -- ^ Original Order
    | RequestIntent_list_Reflex_order
      -- ^ Reflex Order
    | RequestIntent_list_Filler_order
      -- ^ Filler Order
    | RequestIntent_list_Instance_order
      -- ^ Instance Order
    | RequestIntent_list_Option
      -- ^ Option
    deriving (Eq,Show,Enum)
instance SchemaType RequestIntent_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RequestIntent_list where
    acceptingParser =  do literal "proposal"; return RequestIntent_list_Proposal
                      `onFail` do literal "plan"; return RequestIntent_list_Plan
                      `onFail` do literal "order"; return RequestIntent_list_Order
                      `onFail` do literal "original-order"; return RequestIntent_list_Original_order
                      `onFail` do literal "reflex-order"; return RequestIntent_list_Reflex_order
                      `onFail` do literal "filler-order"; return RequestIntent_list_Filler_order
                      `onFail` do literal "instance-order"; return RequestIntent_list_Instance_order
                      `onFail` do literal "option"; return RequestIntent_list_Option
                      
    simpleTypeText RequestIntent_list_Proposal = "proposal"
    simpleTypeText RequestIntent_list_Plan = "plan"
    simpleTypeText RequestIntent_list_Order = "order"
    simpleTypeText RequestIntent_list_Original_order = "original-order"
    simpleTypeText RequestIntent_list_Reflex_order = "reflex-order"
    simpleTypeText RequestIntent_list_Filler_order = "filler-order"
    simpleTypeText RequestIntent_list_Instance_order = "instance-order"
    simpleTypeText RequestIntent_list_Option = "option"
 
data RequestIntent = RequestIntent
        { requestIntent_id :: Maybe String_primitive
        , requestIntent_value :: Maybe RequestIntent_list
        , requestIntent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RequestIntent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RequestIntent a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RequestIntent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestIntent_id x
                       , maybe [] (toXMLAttribute "value") $ requestIntent_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestIntent_extension x
            ]
instance Extension RequestIntent Element where
    supertype (RequestIntent a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides the target, request and response, 
--   and action details for an action to be performed by the 
--   target on or about existing resources.
elementProcessRequest :: XMLParser ProcessRequest
elementProcessRequest = parseSchemaType "ProcessRequest"
elementToXMLProcessRequest :: ProcessRequest -> [Content ()]
elementToXMLProcessRequest = schemaTypeToXML "ProcessRequest"
 
data ProcessRequest = ProcessRequest
        { processRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , processRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , processRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , processRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , processRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , processRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , processRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processRequest_identifier :: [Identifier]
          -- ^ The ProcessRequest business identifier.
        , processRequest_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , processRequest_action :: Maybe ActionList
          -- ^ The type of processing action being requested, for example 
          --   Reversal, Readjudication, StatusRequest,PendedRequest.
        , processRequest_target :: Maybe Reference
          -- ^ The organization which is the target of the request.
        , processRequest_created :: Maybe DateTime
          -- ^ The date when this resource was created.
        , processRequest_provider :: Maybe Reference
          -- ^ The practitioner who is responsible for the action 
          --   specified in this request.
        , processRequest_organization :: Maybe Reference
          -- ^ The organization which is responsible for the action 
          --   speccified in this request.
        , processRequest_request :: Maybe Reference
          -- ^ Reference of resource which is the target or subject of 
          --   this action.
        , processRequest_response :: Maybe Reference
          -- ^ Reference of a prior response to resource which is the 
          --   target or subject of this action.
        , processRequest_nullify :: Maybe Boolean
          -- ^ If true remove all history excluding audit.
        , processRequest_reference :: Maybe Xsd.XsdString
          -- ^ A reference to supply which authenticates the process.
        , processRequest_item :: [ProcessRequestItem]
          -- ^ List of top level items to be re-adjudicated, if none 
          --   specified then the entire submission is re-adjudicated.
        , processRequest_include :: [Xsd.XsdString]
          -- ^ Names of resource types to include.
        , processRequest_exclude :: [Xsd.XsdString]
          -- ^ Names of resource types to exclude.
        , processRequest_period :: Maybe Period
          -- ^ A period of time during which the fulfilling resources 
          --   would have been created.
        }
        deriving (Eq,Show)
instance SchemaType ProcessRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcessRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "action")
            `apply` optional (parseSchemaType "target")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "provider")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "nullify")
            `apply` optional (parseSchemaType "reference")
            `apply` many (parseSchemaType "item")
            `apply` many (parseSchemaType "include")
            `apply` many (parseSchemaType "exclude")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@ProcessRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ processRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ processRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ processRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ processRequest_language x
            , maybe [] (schemaTypeToXML "text") $ processRequest_text x
            , concatMap (schemaTypeToXML "contained") $ processRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ processRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ processRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ processRequest_status x
            , maybe [] (schemaTypeToXML "action") $ processRequest_action x
            , maybe [] (schemaTypeToXML "target") $ processRequest_target x
            , maybe [] (schemaTypeToXML "created") $ processRequest_created x
            , maybe [] (schemaTypeToXML "provider") $ processRequest_provider x
            , maybe [] (schemaTypeToXML "organization") $ processRequest_organization x
            , maybe [] (schemaTypeToXML "request") $ processRequest_request x
            , maybe [] (schemaTypeToXML "response") $ processRequest_response x
            , maybe [] (schemaTypeToXML "nullify") $ processRequest_nullify x
            , maybe [] (schemaTypeToXML "reference") $ processRequest_reference x
            , concatMap (schemaTypeToXML "item") $ processRequest_item x
            , concatMap (schemaTypeToXML "include") $ processRequest_include x
            , concatMap (schemaTypeToXML "exclude") $ processRequest_exclude x
            , maybe [] (schemaTypeToXML "period") $ processRequest_period x
            ]
instance Extension ProcessRequest DomainResource where
    supertype (ProcessRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcessRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcessRequest -> DomainResource)
              
 
-- | This resource provides the target, request and response, 
--   and action details for an action to be performed by the 
--   target on or about existing resources.
data ProcessRequestItem = ProcessRequestItem
        { processRequestItem_id :: Maybe String_primitive
        , processRequestItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processRequestItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processRequestItem_sequenceLinkId :: Integer
          -- ^ A service line number.
        }
        deriving (Eq,Show)
instance SchemaType ProcessRequestItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcessRequestItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "sequenceLinkId"
    schemaTypeToXML s x@ProcessRequestItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ processRequestItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ processRequestItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processRequestItem_modifierExtension x
            , schemaTypeToXML "sequenceLinkId" $ processRequestItem_sequenceLinkId x
            ]
instance Extension ProcessRequestItem BackboneElement where
    supertype (ProcessRequestItem a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension ProcessRequestItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcessRequestItem -> BackboneElement)
              
 
data ActionList_list
    = ActionList_list_Cancel
      -- ^ Cancel, Reverse or Nullify
    | ActionList_list_Poll
      -- ^ Poll
    | ActionList_list_Reprocess
      -- ^ Re-Process
    | ActionList_list_Status
      -- ^ Status Check
    deriving (Eq,Show,Enum)
instance SchemaType ActionList_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ActionList_list where
    acceptingParser =  do literal "cancel"; return ActionList_list_Cancel
                      `onFail` do literal "poll"; return ActionList_list_Poll
                      `onFail` do literal "reprocess"; return ActionList_list_Reprocess
                      `onFail` do literal "status"; return ActionList_list_Status
                      
    simpleTypeText ActionList_list_Cancel = "cancel"
    simpleTypeText ActionList_list_Poll = "poll"
    simpleTypeText ActionList_list_Reprocess = "reprocess"
    simpleTypeText ActionList_list_Status = "status"
 
data ActionList = ActionList
        { actionList_id :: Maybe String_primitive
        , actionList_value :: Maybe ActionList_list
        , actionList_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ActionList where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ActionList a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ActionList{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ actionList_id x
                       , maybe [] (toXMLAttribute "value") $ actionList_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ actionList_extension x
            ]
instance Extension ActionList Element where
    supertype (ActionList a0 a1 e0) =
               Element a0 e0
 
-- | This resource provides processing status, errors and notes 
--   from the processing of a resource.
elementProcessResponse :: XMLParser ProcessResponse
elementProcessResponse = parseSchemaType "ProcessResponse"
elementToXMLProcessResponse :: ProcessResponse -> [Content ()]
elementToXMLProcessResponse = schemaTypeToXML "ProcessResponse"
 
data ProcessResponse = ProcessResponse
        { processResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , processResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , processResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , processResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , processResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , processResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , processResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processResponse_identifier :: [Identifier]
          -- ^ The Response business identifier.
        , processResponse_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , processResponse_created :: Maybe DateTime
          -- ^ The date when the enclosed suite of services were performed 
          --   or completed.
        , processResponse_organization :: Maybe Reference
          -- ^ The organization who produced this adjudicated response.
        , processResponse_request :: Maybe Reference
          -- ^ Original request resource reference.
        , processResponse_outcome :: Maybe CodeableConcept
          -- ^ Transaction status: error, complete, held.
        , processResponse_disposition :: Maybe Xsd.XsdString
          -- ^ A description of the status of the adjudication or 
          --   processing.
        , processResponse_requestProvider :: Maybe Reference
          -- ^ The practitioner who is responsible for the services 
          --   rendered to the patient.
        , processResponse_requestOrganization :: Maybe Reference
          -- ^ The organization which is responsible for the services 
          --   rendered to the patient.
        , processResponse_form :: Maybe CodeableConcept
          -- ^ The form to be used for printing the content.
        , processResponse_processNote :: [ProcessResponseProcessNote]
          -- ^ Suite of processing notes or additional requirements if the 
          --   processing has been held.
        , processResponse_error :: [CodeableConcept]
          -- ^ Processing errors.
        , processResponse_communicationRequest :: [Reference]
          -- ^ Request for additional supporting or authorizing 
          --   information, such as: documents, images or resources.
        }
        deriving (Eq,Show)
instance SchemaType ProcessResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ProcessResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "created")
            `apply` optional (parseSchemaType "organization")
            `apply` optional (parseSchemaType "request")
            `apply` optional (parseSchemaType "outcome")
            `apply` optional (parseSchemaType "disposition")
            `apply` optional (parseSchemaType "requestProvider")
            `apply` optional (parseSchemaType "requestOrganization")
            `apply` optional (parseSchemaType "form")
            `apply` many (parseSchemaType "processNote")
            `apply` many (parseSchemaType "error")
            `apply` many (parseSchemaType "communicationRequest")
    schemaTypeToXML s x@ProcessResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ processResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ processResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ processResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ processResponse_language x
            , maybe [] (schemaTypeToXML "text") $ processResponse_text x
            , concatMap (schemaTypeToXML "contained") $ processResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ processResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processResponse_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ processResponse_identifier x
            , maybe [] (schemaTypeToXML "status") $ processResponse_status x
            , maybe [] (schemaTypeToXML "created") $ processResponse_created x
            , maybe [] (schemaTypeToXML "organization") $ processResponse_organization x
            , maybe [] (schemaTypeToXML "request") $ processResponse_request x
            , maybe [] (schemaTypeToXML "outcome") $ processResponse_outcome x
            , maybe [] (schemaTypeToXML "disposition") $ processResponse_disposition x
            , maybe [] (schemaTypeToXML "requestProvider") $ processResponse_requestProvider x
            , maybe [] (schemaTypeToXML "requestOrganization") $ processResponse_requestOrganization x
            , maybe [] (schemaTypeToXML "form") $ processResponse_form x
            , concatMap (schemaTypeToXML "processNote") $ processResponse_processNote x
            , concatMap (schemaTypeToXML "error") $ processResponse_error x
            , concatMap (schemaTypeToXML "communicationRequest") $ processResponse_communicationRequest x
            ]
instance Extension ProcessResponse DomainResource where
    supertype (ProcessResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ProcessResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ProcessResponse -> DomainResource)
              
 
-- | This resource provides processing status, errors and notes 
--   from the processing of a resource.
data ProcessResponseProcessNote = ProcessResponseProcessNote
        { processResponseProcessNote_id :: Maybe String_primitive
        , processResponseProcessNote_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , processResponseProcessNote_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , processResponseProcessNote_type :: Maybe CodeableConcept
          -- ^ The note purpose: Print/Display.
        , processResponseProcessNote_text :: Maybe Xsd.XsdString
          -- ^ The note text.
        }
        deriving (Eq,Show)
instance SchemaType ProcessResponseProcessNote where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProcessResponseProcessNote a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "text")
    schemaTypeToXML s x@ProcessResponseProcessNote{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ processResponseProcessNote_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ processResponseProcessNote_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ processResponseProcessNote_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ processResponseProcessNote_type x
            , maybe [] (schemaTypeToXML "text") $ processResponseProcessNote_text x
            ]
instance Extension ProcessResponseProcessNote BackboneElement where
    supertype (ProcessResponseProcessNote a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ProcessResponseProcessNote Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProcessResponseProcessNote -> BackboneElement)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
elementProvenance :: XMLParser Provenance
elementProvenance = parseSchemaType "Provenance"
elementToXMLProvenance :: Provenance -> [Content ()]
elementToXMLProvenance = schemaTypeToXML "Provenance"
 
data Provenance = Provenance
        { provenance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , provenance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , provenance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , provenance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , provenance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , provenance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , provenance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenance_target :: [Reference]
          -- ^ The Reference(s) that were generated or updated by the 
          --   activity described in this resource. A provenance can point 
          --   to more than one target if multiple resources were 
          --   created/updated by the same activity.
        , provenance_period :: Maybe Period
          -- ^ The period during which the activity occurred.
        , provenance_recorded :: Instant
          -- ^ The instant of time at which the activity was recorded.
        , provenance_policy :: [Uri]
          -- ^ Policy or plan the activity was defined by. Typically, a 
          --   single activity may have multiple applicable policy 
          --   documents, such as patient consent, guarantor funding, etc.
        , provenance_location :: Maybe Reference
          -- ^ Where the activity occurred, if relevant.
        , provenance_reason :: [Coding]
          -- ^ The reason that the activity was taking place.
        , provenance_activity :: Maybe Coding
          -- ^ An activity is something that occurs over a period of time 
          --   and acts upon or with entities; it may include consuming, 
          --   processing, transforming, modifying, relocating, using, or 
          --   generating entities.
        , provenance_agent :: [ProvenanceAgent]
          -- ^ An actor taking a role in an activity for which it can be 
          --   assigned some degree of responsibility for the activity 
          --   taking place.
        , provenance_entity :: [ProvenanceEntity]
          -- ^ An entity used in this activity.
        , provenance_signature :: [Signature]
          -- ^ A digital signature on the target Reference(s). The signer 
          --   should match a Provenance.agent. The purpose of the 
          --   signature is indicated.
        }
        deriving (Eq,Show)
instance SchemaType Provenance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Provenance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "target")
            `apply` optional (parseSchemaType "period")
            `apply` parseSchemaType "recorded"
            `apply` many (parseSchemaType "policy")
            `apply` optional (parseSchemaType "location")
            `apply` many (parseSchemaType "reason")
            `apply` optional (parseSchemaType "activity")
            `apply` many1 (parseSchemaType "agent")
            `apply` many (parseSchemaType "entity")
            `apply` many (parseSchemaType "signature")
    schemaTypeToXML s x@Provenance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ provenance_id x
            , maybe [] (schemaTypeToXML "meta") $ provenance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ provenance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ provenance_language x
            , maybe [] (schemaTypeToXML "text") $ provenance_text x
            , concatMap (schemaTypeToXML "contained") $ provenance_contained x
            , concatMap (schemaTypeToXML "extension") $ provenance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenance_modifierExtension x
            , concatMap (schemaTypeToXML "target") $ provenance_target x
            , maybe [] (schemaTypeToXML "period") $ provenance_period x
            , schemaTypeToXML "recorded" $ provenance_recorded x
            , concatMap (schemaTypeToXML "policy") $ provenance_policy x
            , maybe [] (schemaTypeToXML "location") $ provenance_location x
            , concatMap (schemaTypeToXML "reason") $ provenance_reason x
            , maybe [] (schemaTypeToXML "activity") $ provenance_activity x
            , concatMap (schemaTypeToXML "agent") $ provenance_agent x
            , concatMap (schemaTypeToXML "entity") $ provenance_entity x
            , concatMap (schemaTypeToXML "signature") $ provenance_signature x
            ]
instance Extension Provenance DomainResource where
    supertype (Provenance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Provenance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Provenance -> DomainResource)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
data ProvenanceAgent = ProvenanceAgent
        { provenanceAgent_id :: Maybe String_primitive
        , provenanceAgent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenanceAgent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenanceAgent_role :: [CodeableConcept]
          -- ^ The function of the agent with respect to the activity. The 
          --   security role enabling the agent with respect to the 
          --   activity.
        , provenanceAgent_choice3 :: OneOf2 Uri Reference
          -- ^ The individual, device or organization that participated in 
          --   the event.
          --   
          --   Choice between:
          --   
          --   (1) whoUri
          --   
          --   (2) whoReference
        , provenanceAgent_choice4 :: (Maybe (OneOf2 Uri Reference))
          -- ^ The individual, device, or organization for whom the change 
          --   was made.
          --   
          --   Choice between:
          --   
          --   (1) onBehalfOfUri
          --   
          --   (2) onBehalfOfReference
        , provenanceAgent_relatedAgentType :: Maybe CodeableConcept
          -- ^ The type of relationship between agents.
        }
        deriving (Eq,Show)
instance SchemaType ProvenanceAgent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProvenanceAgent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "role")
            `apply` oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "whoUri"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "whoReference"))
                           ]
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "onBehalfOfUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "onBehalfOfReference"))
                                     ])
            `apply` optional (parseSchemaType "relatedAgentType")
    schemaTypeToXML s x@ProvenanceAgent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenanceAgent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenanceAgent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenanceAgent_modifierExtension x
            , concatMap (schemaTypeToXML "role") $ provenanceAgent_role x
            , foldOneOf2  (schemaTypeToXML "whoUri")
                          (schemaTypeToXML "whoReference")
                          $ provenanceAgent_choice3 x
            , maybe [] (foldOneOf2  (schemaTypeToXML "onBehalfOfUri")
                                    (schemaTypeToXML "onBehalfOfReference")
                                   ) $ provenanceAgent_choice4 x
            , maybe [] (schemaTypeToXML "relatedAgentType") $ provenanceAgent_relatedAgentType x
            ]
instance Extension ProvenanceAgent BackboneElement where
    supertype (ProvenanceAgent a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ProvenanceAgent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProvenanceAgent -> BackboneElement)
              
 
-- | Provenance of a resource is a record that describes 
--   entities and processes involved in producing and delivering 
--   or otherwise influencing that resource. Provenance provides 
--   a critical foundation for assessing authenticity, enabling 
--   trust, and allowing reproducibility. Provenance assertions 
--   are a form of contextual metadata and can themselves become 
--   important records with their own provenance. Provenance 
--   statement indicates clinical significance in terms of 
--   confidence in authenticity, reliability, and 
--   trustworthiness, integrity, and stage in lifecycle (e.g. 
--   Document Completion - has the artifact been legally 
--   authenticated), all of which may impact security, privacy, 
--   and trust policies.
data ProvenanceEntity = ProvenanceEntity
        { provenanceEntity_id :: Maybe String_primitive
        , provenanceEntity_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , provenanceEntity_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , provenanceEntity_role :: ProvenanceEntityRole
          -- ^ How the entity was used during the activity.
        , provenanceEntity_choice3 :: OneOf3 Uri Reference Identifier
          -- ^ Identity of the Entity used. May be a logical or physical 
          --   uri and maybe absolute or relative.
          --   
          --   Choice between:
          --   
          --   (1) whatUri
          --   
          --   (2) whatReference
          --   
          --   (3) whatIdentifier
        , provenanceEntity_agent :: [ProvenanceAgent]
          -- ^ The entity is attributed to an agent to express the agent's 
          --   responsibility for that entity, possibly along with other 
          --   agents. This description can be understood as shorthand for 
          --   saying that the agent was responsible for the activity 
          --   which generated the entity.
        }
        deriving (Eq,Show)
instance SchemaType ProvenanceEntity where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ProvenanceEntity a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "role"
            `apply` oneOf' [ ("Uri", fmap OneOf3 (parseSchemaType "whatUri"))
                           , ("Reference", fmap TwoOf3 (parseSchemaType "whatReference"))
                           , ("Identifier", fmap ThreeOf3 (parseSchemaType "whatIdentifier"))
                           ]
            `apply` many (parseSchemaType "agent")
    schemaTypeToXML s x@ProvenanceEntity{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenanceEntity_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenanceEntity_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ provenanceEntity_modifierExtension x
            , schemaTypeToXML "role" $ provenanceEntity_role x
            , foldOneOf3  (schemaTypeToXML "whatUri")
                          (schemaTypeToXML "whatReference")
                          (schemaTypeToXML "whatIdentifier")
                          $ provenanceEntity_choice3 x
            , concatMap (schemaTypeToXML "agent") $ provenanceEntity_agent x
            ]
instance Extension ProvenanceEntity BackboneElement where
    supertype (ProvenanceEntity a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ProvenanceEntity Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ProvenanceEntity -> BackboneElement)
              
 
data ProvenanceEntityRole_list
    = ProvenanceEntityRole_list_Derivation
      -- ^ Derivation
    | ProvenanceEntityRole_list_Revision
      -- ^ Revision
    | ProvenanceEntityRole_list_Quotation
      -- ^ Quotation
    | ProvenanceEntityRole_list_Source
      -- ^ Source
    | ProvenanceEntityRole_list_Removal
      -- ^ Removal
    deriving (Eq,Show,Enum)
instance SchemaType ProvenanceEntityRole_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ProvenanceEntityRole_list where
    acceptingParser =  do literal "derivation"; return ProvenanceEntityRole_list_Derivation
                      `onFail` do literal "revision"; return ProvenanceEntityRole_list_Revision
                      `onFail` do literal "quotation"; return ProvenanceEntityRole_list_Quotation
                      `onFail` do literal "source"; return ProvenanceEntityRole_list_Source
                      `onFail` do literal "removal"; return ProvenanceEntityRole_list_Removal
                      
    simpleTypeText ProvenanceEntityRole_list_Derivation = "derivation"
    simpleTypeText ProvenanceEntityRole_list_Revision = "revision"
    simpleTypeText ProvenanceEntityRole_list_Quotation = "quotation"
    simpleTypeText ProvenanceEntityRole_list_Source = "source"
    simpleTypeText ProvenanceEntityRole_list_Removal = "removal"
 
data ProvenanceEntityRole = ProvenanceEntityRole
        { provenanceEntityRole_id :: Maybe String_primitive
        , provenanceEntityRole_value :: Maybe ProvenanceEntityRole_list
        , provenanceEntityRole_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ProvenanceEntityRole where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ProvenanceEntityRole a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ProvenanceEntityRole{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ provenanceEntityRole_id x
                       , maybe [] (toXMLAttribute "value") $ provenanceEntityRole_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ provenanceEntityRole_extension x
            ]
instance Extension ProvenanceEntityRole Element where
    supertype (ProvenanceEntityRole a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
elementQuestionnaire :: XMLParser Questionnaire
elementQuestionnaire = parseSchemaType "Questionnaire"
elementToXMLQuestionnaire :: Questionnaire -> [Content ()]
elementToXMLQuestionnaire = schemaTypeToXML "Questionnaire"
 
data Questionnaire = Questionnaire
        { questionnaire_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , questionnaire_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , questionnaire_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , questionnaire_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , questionnaire_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , questionnaire_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , questionnaire_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaire_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaire_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this questionnaire 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this 
          --   questionnaire is (or will be) published. The URL SHOULD 
          --   include the major version of the questionnaire. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , questionnaire_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this 
          --   questionnaire when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , questionnaire_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   questionnaire when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the questionnaire author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , questionnaire_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the questionnaire. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , questionnaire_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the 
          --   questionnaire.
        , questionnaire_status :: PublicationStatus
          -- ^ The status of this questionnaire. Enables tracking the 
          --   life-cycle of the content.
        , questionnaire_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this questionnaire is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , questionnaire_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the questionnaire was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the questionnaire changes.
        , questionnaire_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the questionnaire.
        , questionnaire_description :: Maybe Markdown
          -- ^ A free text natural language description of the 
          --   questionnaire from a consumer's perspective.
        , questionnaire_purpose :: Maybe Markdown
          -- ^ Explaination of why this questionnaire is needed and why it 
          --   has been designed as it has.
        , questionnaire_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , questionnaire_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , questionnaire_effectivePeriod :: Maybe Period
          -- ^ The period during which the questionnaire content was or is 
          --   planned to be in active use.
        , questionnaire_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   questionnaire instances.
        , questionnaire_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the questionnaire is 
          --   intended to be used.
        , questionnaire_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , questionnaire_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the questionnaire and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the 
          --   questionnaire.
        , questionnaire_code :: [Coding]
          -- ^ An identifier for this question or group of questions in a 
          --   particular terminology such as LOINC.
        , questionnaire_subjectType :: [ResourceType]
          -- ^ The types of subjects that can be the subject of responses 
          --   created for the questionnaire.
        , questionnaire_item :: [QuestionnaireItem]
          -- ^ A particular question, question grouping or display text 
          --   that is part of the questionnaire.
        }
        deriving (Eq,Show)
instance SchemaType Questionnaire where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Questionnaire
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "subjectType")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@Questionnaire{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ questionnaire_id x
            , maybe [] (schemaTypeToXML "meta") $ questionnaire_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ questionnaire_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ questionnaire_language x
            , maybe [] (schemaTypeToXML "text") $ questionnaire_text x
            , concatMap (schemaTypeToXML "contained") $ questionnaire_contained x
            , concatMap (schemaTypeToXML "extension") $ questionnaire_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaire_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ questionnaire_url x
            , concatMap (schemaTypeToXML "identifier") $ questionnaire_identifier x
            , maybe [] (schemaTypeToXML "version") $ questionnaire_version x
            , maybe [] (schemaTypeToXML "name") $ questionnaire_name x
            , maybe [] (schemaTypeToXML "title") $ questionnaire_title x
            , schemaTypeToXML "status" $ questionnaire_status x
            , maybe [] (schemaTypeToXML "experimental") $ questionnaire_experimental x
            , maybe [] (schemaTypeToXML "date") $ questionnaire_date x
            , maybe [] (schemaTypeToXML "publisher") $ questionnaire_publisher x
            , maybe [] (schemaTypeToXML "description") $ questionnaire_description x
            , maybe [] (schemaTypeToXML "purpose") $ questionnaire_purpose x
            , maybe [] (schemaTypeToXML "approvalDate") $ questionnaire_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ questionnaire_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ questionnaire_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ questionnaire_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ questionnaire_jurisdiction x
            , concatMap (schemaTypeToXML "contact") $ questionnaire_contact x
            , maybe [] (schemaTypeToXML "copyright") $ questionnaire_copyright x
            , concatMap (schemaTypeToXML "code") $ questionnaire_code x
            , concatMap (schemaTypeToXML "subjectType") $ questionnaire_subjectType x
            , concatMap (schemaTypeToXML "item") $ questionnaire_item x
            ]
instance Extension Questionnaire DomainResource where
    supertype (Questionnaire e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Questionnaire Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Questionnaire -> DomainResource)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data QuestionnaireItem = QuestionnaireItem
        { questionnaireItem_id :: Maybe String_primitive
        , questionnaireItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireItem_linkId :: Xsd.XsdString
          -- ^ An identifier that is unique within the Questionnaire 
          --   allowing linkage to the equivalent item in a 
          --   QuestionnaireResponse resource.
        , questionnaireItem_definition :: Maybe Uri
          -- ^ A reference to an [[[ElementDefinition]]] that provides the 
          --   details for the item. If a definition is provided, then the 
          --   following element values can be inferred from the 
          --   definition: * code (ElementDefinition.code) * type 
          --   (ElementDefinition.type) * required (ElementDefinition.min) 
          --   * repeats (ElementDefinition.max) * maxLength 
          --   (ElementDefinition.maxLength) * options 
          --   (ElementDefinition.binding) Any information provided in 
          --   these elements on a Questionnaire Item overrides the 
          --   information from the definition.
        , questionnaireItem_code :: [Coding]
          -- ^ A terminology code that corresponds to this group or 
          --   question (e.g. a code from LOINC, which defines many 
          --   questions and answers).
        , questionnaireItem_prefix :: Maybe Xsd.XsdString
          -- ^ A short label for a particular group, question or set of 
          --   display text within the questionnaire used for reference by 
          --   the individual completing the questionnaire.
        , questionnaireItem_text :: Maybe Xsd.XsdString
          -- ^ The name of a section, the text of a question or text 
          --   content for a display item.
        , questionnaireItem_type :: QuestionnaireItemType
          -- ^ The type of questionnaire item this is - whether text for 
          --   display, a grouping of other items or a particular type of 
          --   data to be captured (string, integer, coded choice, etc.).
        , questionnaireItem_enableWhen :: [QuestionnaireEnableWhen]
          -- ^ A constraint indicating that this item should only be 
          --   enabled (displayed/allow answers to be captured) when the 
          --   specified condition is true.
        , questionnaireItem_required :: Maybe Boolean
          -- ^ An indication, if true, that the item must be present in a 
          --   &quot;completed&quot; QuestionnaireResponse. If false, the 
          --   item may be skipped when answering the questionnaire.
        , questionnaireItem_repeats :: Maybe Boolean
          -- ^ An indication, if true, that the item may occur multiple 
          --   times in the response, collecting multiple answers answers 
          --   for questions or multiple sets of answers for groups.
        , questionnaireItem_readOnly :: Maybe Boolean
          -- ^ An indication, when true, that the value cannot be changed 
          --   by a human respondent to the Questionnaire.
        , questionnaireItem_maxLength :: Maybe Integer
          -- ^ The maximum number of characters that are permitted in the 
          --   answer to be considered a &quot;valid&quot; 
          --   QuestionnaireResponse.
        , questionnaireItem_options :: Maybe Reference
          -- ^ A reference to a value set containing a list of codes 
          --   representing permitted answers for a &quot;choice&quot; or 
          --   &quot;open-choice&quot; question.
        , questionnaireItem_option :: [QuestionnaireOption]
          -- ^ One of the permitted answers for a &quot;choice&quot; or 
          --   &quot;open-choice&quot; question.
        , questionnaireItem_choice15 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ The value that should be defaulted when initially rendering 
          --   the questionnaire for user input.
          --   
          --   Choice between:
          --   
          --   (1) initialBoolean
          --   
          --   (2) initialDecimal
          --   
          --   (3) initialInteger
          --   
          --   (4) initialDate
          --   
          --   (5) initialDateTime
          --   
          --   (6) initialTime
          --   
          --   (7) initialString
          --   
          --   (8) initialUri
          --   
          --   (9) initialAttachment
          --   
          --   (10) initialCoding
          --   
          --   (11) initialQuantity
          --   
          --   (12) initialReference
        , questionnaireItem_item :: [QuestionnaireItem]
          -- ^ Text, questions and other groups to be nested beneath a 
          --   question or group.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "linkId"
            `apply` optional (parseSchemaType "definition")
            `apply` many (parseSchemaType "code")
            `apply` optional (parseSchemaType "prefix")
            `apply` optional (parseSchemaType "text")
            `apply` parseSchemaType "type"
            `apply` many (parseSchemaType "enableWhen")
            `apply` optional (parseSchemaType "required")
            `apply` optional (parseSchemaType "repeats")
            `apply` optional (parseSchemaType "readOnly")
            `apply` optional (parseSchemaType "maxLength")
            `apply` optional (parseSchemaType "options")
            `apply` many (parseSchemaType "option")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "initialBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "initialDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "initialInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "initialDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "initialDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "initialTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "initialString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "initialUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "initialAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "initialCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "initialQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "initialReference"))
                                     ])
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireItem_modifierExtension x
            , schemaTypeToXML "linkId" $ questionnaireItem_linkId x
            , maybe [] (schemaTypeToXML "definition") $ questionnaireItem_definition x
            , concatMap (schemaTypeToXML "code") $ questionnaireItem_code x
            , maybe [] (schemaTypeToXML "prefix") $ questionnaireItem_prefix x
            , maybe [] (schemaTypeToXML "text") $ questionnaireItem_text x
            , schemaTypeToXML "type" $ questionnaireItem_type x
            , concatMap (schemaTypeToXML "enableWhen") $ questionnaireItem_enableWhen x
            , maybe [] (schemaTypeToXML "required") $ questionnaireItem_required x
            , maybe [] (schemaTypeToXML "repeats") $ questionnaireItem_repeats x
            , maybe [] (schemaTypeToXML "readOnly") $ questionnaireItem_readOnly x
            , maybe [] (schemaTypeToXML "maxLength") $ questionnaireItem_maxLength x
            , maybe [] (schemaTypeToXML "options") $ questionnaireItem_options x
            , concatMap (schemaTypeToXML "option") $ questionnaireItem_option x
            , maybe [] (foldOneOf12  (schemaTypeToXML "initialBoolean")
                                     (schemaTypeToXML "initialDecimal")
                                     (schemaTypeToXML "initialInteger")
                                     (schemaTypeToXML "initialDate")
                                     (schemaTypeToXML "initialDateTime")
                                     (schemaTypeToXML "initialTime")
                                     (schemaTypeToXML "initialString")
                                     (schemaTypeToXML "initialUri")
                                     (schemaTypeToXML "initialAttachment")
                                     (schemaTypeToXML "initialCoding")
                                     (schemaTypeToXML "initialQuantity")
                                     (schemaTypeToXML "initialReference")
                                    ) $ questionnaireItem_choice15 x
            , concatMap (schemaTypeToXML "item") $ questionnaireItem_item x
            ]
instance Extension QuestionnaireItem BackboneElement where
    supertype (QuestionnaireItem a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireItem -> BackboneElement)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data QuestionnaireEnableWhen = QuestionnaireEnableWhen
        { questionnaireEnableWhen_id :: Maybe String_primitive
        , questionnaireEnableWhen_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireEnableWhen_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireEnableWhen_question :: Xsd.XsdString
          -- ^ The linkId for the question whose answer (or lack of 
          --   answer) governs whether this item is enabled.
        , questionnaireEnableWhen_hasAnswer :: Maybe Boolean
          -- ^ An indication that this item should be enabled only if the 
          --   specified question is answered (hasAnswer=true) or not 
          --   answered (hasAnswer=false).
        , questionnaireEnableWhen_choice4 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ An answer that the referenced question must match in order 
          --   for the item to be enabled.
          --   
          --   Choice between:
          --   
          --   (1) answerBoolean
          --   
          --   (2) answerDecimal
          --   
          --   (3) answerInteger
          --   
          --   (4) answerDate
          --   
          --   (5) answerDateTime
          --   
          --   (6) answerTime
          --   
          --   (7) answerString
          --   
          --   (8) answerUri
          --   
          --   (9) answerAttachment
          --   
          --   (10) answerCoding
          --   
          --   (11) answerQuantity
          --   
          --   (12) answerReference
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireEnableWhen where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireEnableWhen a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "question"
            `apply` optional (parseSchemaType "hasAnswer")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "answerBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "answerDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "answerInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "answerDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "answerDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "answerTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "answerString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "answerUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "answerAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "answerCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "answerQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "answerReference"))
                                     ])
    schemaTypeToXML s x@QuestionnaireEnableWhen{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireEnableWhen_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireEnableWhen_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireEnableWhen_modifierExtension x
            , schemaTypeToXML "question" $ questionnaireEnableWhen_question x
            , maybe [] (schemaTypeToXML "hasAnswer") $ questionnaireEnableWhen_hasAnswer x
            , maybe [] (foldOneOf12  (schemaTypeToXML "answerBoolean")
                                     (schemaTypeToXML "answerDecimal")
                                     (schemaTypeToXML "answerInteger")
                                     (schemaTypeToXML "answerDate")
                                     (schemaTypeToXML "answerDateTime")
                                     (schemaTypeToXML "answerTime")
                                     (schemaTypeToXML "answerString")
                                     (schemaTypeToXML "answerUri")
                                     (schemaTypeToXML "answerAttachment")
                                     (schemaTypeToXML "answerCoding")
                                     (schemaTypeToXML "answerQuantity")
                                     (schemaTypeToXML "answerReference")
                                    ) $ questionnaireEnableWhen_choice4 x
            ]
instance Extension QuestionnaireEnableWhen BackboneElement where
    supertype (QuestionnaireEnableWhen a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireEnableWhen Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireEnableWhen -> BackboneElement)
              
 
-- | A structured set of questions intended to guide the 
--   collection of answers from end-users. Questionnaires 
--   provide detailed control over order, presentation, 
--   phraseology and grouping to allow coherent, consistent data 
--   collection.
data QuestionnaireOption = QuestionnaireOption
        { questionnaireOption_id :: Maybe String_primitive
        , questionnaireOption_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireOption_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireOption_choice2 :: OneOf5 Integer Date Time Xsd.XsdString Coding
          -- ^ A potential answer that's allowed as the answer to this 
          --   question.
          --   
          --   Choice between:
          --   
          --   (1) valueInteger
          --   
          --   (2) valueDate
          --   
          --   (3) valueTime
          --   
          --   (4) valueString
          --   
          --   (5) valueCoding
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireOption where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireOption a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Integer", fmap OneOf5 (parseSchemaType "valueInteger"))
                           , ("Date", fmap TwoOf5 (parseSchemaType "valueDate"))
                           , ("Time", fmap ThreeOf5 (parseSchemaType "valueTime"))
                           , ("Xsd.XsdString", fmap FourOf5 (parseSchemaType "valueString"))
                           , ("Coding", fmap FiveOf5 (parseSchemaType "valueCoding"))
                           ]
    schemaTypeToXML s x@QuestionnaireOption{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireOption_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireOption_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireOption_modifierExtension x
            , foldOneOf5  (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueDate")
                          (schemaTypeToXML "valueTime")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueCoding")
                          $ questionnaireOption_choice2 x
            ]
instance Extension QuestionnaireOption BackboneElement where
    supertype (QuestionnaireOption a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireOption Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireOption -> BackboneElement)
              
 
data QuestionnaireItemType_list
    = QuestionnaireItemType_list_Group
      -- ^ Group
    | QuestionnaireItemType_list_Display
      -- ^ Display
    | QuestionnaireItemType_list_Boolean
      -- ^ Boolean
    | QuestionnaireItemType_list_Decimal
      -- ^ Decimal
    | QuestionnaireItemType_list_Integer
      -- ^ Integer
    | QuestionnaireItemType_list_Date
      -- ^ Date
    | QuestionnaireItemType_list_DateTime
      -- ^ Date Time
    | QuestionnaireItemType_list_Time
      -- ^ Time
    | QuestionnaireItemType_list_Xsd.XsdString
      -- ^ String
    | QuestionnaireItemType_list_Text
      -- ^ Text
    | QuestionnaireItemType_list_Url
      -- ^ Url
    | QuestionnaireItemType_list_Choice
      -- ^ Choice
    | QuestionnaireItemType_list_Open_choice
      -- ^ Open Choice
    | QuestionnaireItemType_list_Attachment
      -- ^ Attachment
    | QuestionnaireItemType_list_Reference
      -- ^ Reference
    | QuestionnaireItemType_list_Quantity
      -- ^ Quantity
    deriving (Eq,Show,Enum)
instance SchemaType QuestionnaireItemType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuestionnaireItemType_list where
    acceptingParser =  do literal "group"; return QuestionnaireItemType_list_Group
                      `onFail` do literal "display"; return QuestionnaireItemType_list_Display
                      `onFail` do literal "boolean"; return QuestionnaireItemType_list_Boolean
                      `onFail` do literal "decimal"; return QuestionnaireItemType_list_Decimal
                      `onFail` do literal "integer"; return QuestionnaireItemType_list_Integer
                      `onFail` do literal "date"; return QuestionnaireItemType_list_Date
                      `onFail` do literal "dateTime"; return QuestionnaireItemType_list_DateTime
                      `onFail` do literal "time"; return QuestionnaireItemType_list_Time
                      `onFail` do literal "string"; return QuestionnaireItemType_list_Xsd.XsdString
                      `onFail` do literal "text"; return QuestionnaireItemType_list_Text
                      `onFail` do literal "url"; return QuestionnaireItemType_list_Url
                      `onFail` do literal "choice"; return QuestionnaireItemType_list_Choice
                      `onFail` do literal "open-choice"; return QuestionnaireItemType_list_Open_choice
                      `onFail` do literal "attachment"; return QuestionnaireItemType_list_Attachment
                      `onFail` do literal "reference"; return QuestionnaireItemType_list_Reference
                      `onFail` do literal "quantity"; return QuestionnaireItemType_list_Quantity
                      
    simpleTypeText QuestionnaireItemType_list_Group = "group"
    simpleTypeText QuestionnaireItemType_list_Display = "display"
    simpleTypeText QuestionnaireItemType_list_Boolean = "boolean"
    simpleTypeText QuestionnaireItemType_list_Decimal = "decimal"
    simpleTypeText QuestionnaireItemType_list_Integer = "integer"
    simpleTypeText QuestionnaireItemType_list_Date = "date"
    simpleTypeText QuestionnaireItemType_list_DateTime = "dateTime"
    simpleTypeText QuestionnaireItemType_list_Time = "time"
    simpleTypeText QuestionnaireItemType_list_Xsd.XsdString = "string"
    simpleTypeText QuestionnaireItemType_list_Text = "text"
    simpleTypeText QuestionnaireItemType_list_Url = "url"
    simpleTypeText QuestionnaireItemType_list_Choice = "choice"
    simpleTypeText QuestionnaireItemType_list_Open_choice = "open-choice"
    simpleTypeText QuestionnaireItemType_list_Attachment = "attachment"
    simpleTypeText QuestionnaireItemType_list_Reference = "reference"
    simpleTypeText QuestionnaireItemType_list_Quantity = "quantity"
 
data QuestionnaireItemType = QuestionnaireItemType
        { questionnaireItemType_id :: Maybe String_primitive
        , questionnaireItemType_value :: Maybe QuestionnaireItemType_list
        , questionnaireItemType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireItemType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuestionnaireItemType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuestionnaireItemType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireItemType_id x
                       , maybe [] (toXMLAttribute "value") $ questionnaireItemType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireItemType_extension x
            ]
instance Extension QuestionnaireItemType Element where
    supertype (QuestionnaireItemType a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
elementQuestionnaireResponse :: XMLParser QuestionnaireResponse
elementQuestionnaireResponse = parseSchemaType "QuestionnaireResponse"
elementToXMLQuestionnaireResponse :: QuestionnaireResponse -> [Content ()]
elementToXMLQuestionnaireResponse = schemaTypeToXML "QuestionnaireResponse"
 
data QuestionnaireResponse = QuestionnaireResponse
        { questionnaireResponse_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , questionnaireResponse_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , questionnaireResponse_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , questionnaireResponse_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , questionnaireResponse_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , questionnaireResponse_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , questionnaireResponse_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponse_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponse_identifier :: Maybe Identifier
          -- ^ A business identifier assigned to a particular completed 
          --   (or partially completed) questionnaire.
        , questionnaireResponse_basedOn :: [Reference]
          -- ^ The order, proposal or plan that is fulfilled in whole or 
          --   in part by this QuestionnaireResponse. For example, a 
          --   ProcedureRequest seeking an intake assessment or a decision 
          --   support recommendation to assess for post-partum 
          --   depression.
        , questionnaireResponse_parent :: [Reference]
          -- ^ A procedure or observation that this questionnaire was 
          --   performed as part of the execution of. For example, the 
          --   surgery a checklist was executed as part of.
        , questionnaireResponse_questionnaire :: Maybe Reference
          -- ^ The Questionnaire that defines and organizes the questions 
          --   for which answers are being provided.
        , questionnaireResponse_status :: QuestionnaireResponseStatus
          -- ^ The position of the questionnaire response within its 
          --   overall lifecycle.
        , questionnaireResponse_subject :: Maybe Reference
          -- ^ The subject of the questionnaire response. This could be a 
          --   patient, organization, practitioner, device, etc. This is 
          --   who/what the answers apply to, but is not necessarily the 
          --   source of information.
        , questionnaireResponse_context :: Maybe Reference
          -- ^ The encounter or episode of care with primary association 
          --   to the questionnaire response.
        , questionnaireResponse_authored :: Maybe DateTime
          -- ^ The date and/or time that this set of answers were last 
          --   changed.
        , questionnaireResponse_author :: Maybe Reference
          -- ^ Person who received the answers to the questions in the 
          --   QuestionnaireResponse and recorded them in the system.
        , questionnaireResponse_source :: Maybe Reference
          -- ^ The person who answered the questions about the subject.
        , questionnaireResponse_item :: [QuestionnaireResponseItem]
          -- ^ A group or question item from the original questionnaire 
          --   for which answers are provided.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponse where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return QuestionnaireResponse
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "parent")
            `apply` optional (parseSchemaType "questionnaire")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "authored")
            `apply` optional (parseSchemaType "author")
            `apply` optional (parseSchemaType "source")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponse{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ questionnaireResponse_id x
            , maybe [] (schemaTypeToXML "meta") $ questionnaireResponse_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ questionnaireResponse_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ questionnaireResponse_language x
            , maybe [] (schemaTypeToXML "text") $ questionnaireResponse_text x
            , concatMap (schemaTypeToXML "contained") $ questionnaireResponse_contained x
            , concatMap (schemaTypeToXML "extension") $ questionnaireResponse_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponse_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ questionnaireResponse_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ questionnaireResponse_basedOn x
            , concatMap (schemaTypeToXML "parent") $ questionnaireResponse_parent x
            , maybe [] (schemaTypeToXML "questionnaire") $ questionnaireResponse_questionnaire x
            , schemaTypeToXML "status" $ questionnaireResponse_status x
            , maybe [] (schemaTypeToXML "subject") $ questionnaireResponse_subject x
            , maybe [] (schemaTypeToXML "context") $ questionnaireResponse_context x
            , maybe [] (schemaTypeToXML "authored") $ questionnaireResponse_authored x
            , maybe [] (schemaTypeToXML "author") $ questionnaireResponse_author x
            , maybe [] (schemaTypeToXML "source") $ questionnaireResponse_source x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponse_item x
            ]
instance Extension QuestionnaireResponse DomainResource where
    supertype (QuestionnaireResponse e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension QuestionnaireResponse Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: QuestionnaireResponse -> DomainResource)
              
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
data QuestionnaireResponseItem = QuestionnaireResponseItem
        { questionnaireResponseItem_id :: Maybe String_primitive
        , questionnaireResponseItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponseItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponseItem_linkId :: Xsd.XsdString
          -- ^ The item from the Questionnaire that corresponds to this 
          --   item in the QuestionnaireResponse resource.
        , questionnaireResponseItem_definition :: Maybe Uri
          -- ^ A reference to an [[[ElementDefinition]]] that provides the 
          --   details for the item.
        , questionnaireResponseItem_text :: Maybe Xsd.XsdString
          -- ^ Text that is displayed above the contents of the group or 
          --   as the text of the question being answered.
        , questionnaireResponseItem_subject :: Maybe Reference
          -- ^ More specific subject this section's answers are about, 
          --   details the subject given in QuestionnaireResponse.
        , questionnaireResponseItem_answer :: [QuestionnaireResponseAnswer]
          -- ^ The respondent's answer(s) to the question.
        , questionnaireResponseItem_item :: [QuestionnaireResponseItem]
          -- ^ Questions or sub-groups nested beneath a question or group.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponseItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireResponseItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "linkId"
            `apply` optional (parseSchemaType "definition")
            `apply` optional (parseSchemaType "text")
            `apply` optional (parseSchemaType "subject")
            `apply` many (parseSchemaType "answer")
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponseItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponseItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponseItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponseItem_modifierExtension x
            , schemaTypeToXML "linkId" $ questionnaireResponseItem_linkId x
            , maybe [] (schemaTypeToXML "definition") $ questionnaireResponseItem_definition x
            , maybe [] (schemaTypeToXML "text") $ questionnaireResponseItem_text x
            , maybe [] (schemaTypeToXML "subject") $ questionnaireResponseItem_subject x
            , concatMap (schemaTypeToXML "answer") $ questionnaireResponseItem_answer x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponseItem_item x
            ]
instance Extension QuestionnaireResponseItem BackboneElement where
    supertype (QuestionnaireResponseItem a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireResponseItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireResponseItem -> BackboneElement)
              
 
-- | A structured set of questions and their answers. The 
--   questions are ordered and grouped into coherent subsets, 
--   corresponding to the structure of the grouping of the 
--   questionnaire being responded to.
data QuestionnaireResponseAnswer = QuestionnaireResponseAnswer
        { questionnaireResponseAnswer_id :: Maybe String_primitive
        , questionnaireResponseAnswer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , questionnaireResponseAnswer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , questionnaireResponseAnswer_choice2 :: (Maybe (OneOf12 Boolean Decimal Integer Date DateTime Time Xsd.XsdString Uri Attachment Coding Quantity Reference))
          -- ^ The answer (or one of the answers) provided by the 
          --   respondent to the question.
          --   
          --   Choice between:
          --   
          --   (1) valueBoolean
          --   
          --   (2) valueDecimal
          --   
          --   (3) valueInteger
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueTime
          --   
          --   (7) valueString
          --   
          --   (8) valueUri
          --   
          --   (9) valueAttachment
          --   
          --   (10) valueCoding
          --   
          --   (11) valueQuantity
          --   
          --   (12) valueReference
        , questionnaireResponseAnswer_item :: [QuestionnaireResponseItem]
          -- ^ Nested groups and/or questions found within this particular 
          --   answer.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponseAnswer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (QuestionnaireResponseAnswer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (oneOf' [ ("Boolean", fmap OneOf12 (parseSchemaType "valueBoolean"))
                                     , ("Decimal", fmap TwoOf12 (parseSchemaType "valueDecimal"))
                                     , ("Integer", fmap ThreeOf12 (parseSchemaType "valueInteger"))
                                     , ("Date", fmap FourOf12 (parseSchemaType "valueDate"))
                                     , ("DateTime", fmap FiveOf12 (parseSchemaType "valueDateTime"))
                                     , ("Time", fmap SixOf12 (parseSchemaType "valueTime"))
                                     , ("Xsd.XsdString", fmap SevenOf12 (parseSchemaType "valueString"))
                                     , ("Uri", fmap EightOf12 (parseSchemaType "valueUri"))
                                     , ("Attachment", fmap NineOf12 (parseSchemaType "valueAttachment"))
                                     , ("Coding", fmap TenOf12 (parseSchemaType "valueCoding"))
                                     , ("Quantity", fmap ElevenOf12 (parseSchemaType "valueQuantity"))
                                     , ("Reference", fmap TwelveOf12 (parseSchemaType "valueReference"))
                                     ])
            `apply` many (parseSchemaType "item")
    schemaTypeToXML s x@QuestionnaireResponseAnswer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponseAnswer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponseAnswer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ questionnaireResponseAnswer_modifierExtension x
            , maybe [] (foldOneOf12  (schemaTypeToXML "valueBoolean")
                                     (schemaTypeToXML "valueDecimal")
                                     (schemaTypeToXML "valueInteger")
                                     (schemaTypeToXML "valueDate")
                                     (schemaTypeToXML "valueDateTime")
                                     (schemaTypeToXML "valueTime")
                                     (schemaTypeToXML "valueString")
                                     (schemaTypeToXML "valueUri")
                                     (schemaTypeToXML "valueAttachment")
                                     (schemaTypeToXML "valueCoding")
                                     (schemaTypeToXML "valueQuantity")
                                     (schemaTypeToXML "valueReference")
                                    ) $ questionnaireResponseAnswer_choice2 x
            , concatMap (schemaTypeToXML "item") $ questionnaireResponseAnswer_item x
            ]
instance Extension QuestionnaireResponseAnswer BackboneElement where
    supertype (QuestionnaireResponseAnswer a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension QuestionnaireResponseAnswer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: QuestionnaireResponseAnswer -> BackboneElement)
              
 
data QuestionnaireResponseStatus_list
    = QuestionnaireResponseStatus_list_In_progress
      -- ^ In Progress
    | QuestionnaireResponseStatus_list_Completed
      -- ^ Completed
    | QuestionnaireResponseStatus_list_Amended
      -- ^ Amended
    | QuestionnaireResponseStatus_list_Entered_in_error
      -- ^ Entered in Error
    | QuestionnaireResponseStatus_list_Stopped
      -- ^ Stopped
    deriving (Eq,Show,Enum)
instance SchemaType QuestionnaireResponseStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QuestionnaireResponseStatus_list where
    acceptingParser =  do literal "in-progress"; return QuestionnaireResponseStatus_list_In_progress
                      `onFail` do literal "completed"; return QuestionnaireResponseStatus_list_Completed
                      `onFail` do literal "amended"; return QuestionnaireResponseStatus_list_Amended
                      `onFail` do literal "entered-in-error"; return QuestionnaireResponseStatus_list_Entered_in_error
                      `onFail` do literal "stopped"; return QuestionnaireResponseStatus_list_Stopped
                      
    simpleTypeText QuestionnaireResponseStatus_list_In_progress = "in-progress"
    simpleTypeText QuestionnaireResponseStatus_list_Completed = "completed"
    simpleTypeText QuestionnaireResponseStatus_list_Amended = "amended"
    simpleTypeText QuestionnaireResponseStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText QuestionnaireResponseStatus_list_Stopped = "stopped"
 
data QuestionnaireResponseStatus = QuestionnaireResponseStatus
        { questionnaireResponseStatus_id :: Maybe String_primitive
        , questionnaireResponseStatus_value :: Maybe QuestionnaireResponseStatus_list
        , questionnaireResponseStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QuestionnaireResponseStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QuestionnaireResponseStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QuestionnaireResponseStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ questionnaireResponseStatus_id x
                       , maybe [] (toXMLAttribute "value") $ questionnaireResponseStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ questionnaireResponseStatus_extension x
            ]
instance Extension QuestionnaireResponseStatus Element where
    supertype (QuestionnaireResponseStatus a0 a1 e0) =
               Element a0 e0
 
-- | Used to record and send details about a request for 
--   referral service or transfer of a patient to the care of 
--   another provider or provider organization.
elementReferralRequest :: XMLParser ReferralRequest
elementReferralRequest = parseSchemaType "ReferralRequest"
elementToXMLReferralRequest :: ReferralRequest -> [Content ()]
elementToXMLReferralRequest = schemaTypeToXML "ReferralRequest"
 
data ReferralRequest = ReferralRequest
        { referralRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , referralRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , referralRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , referralRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , referralRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , referralRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , referralRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , referralRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , referralRequest_identifier :: [Identifier]
          -- ^ Business identifier that uniquely identifies the 
          --   referral/care transfer request instance.
        , referralRequest_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that is 
          --   adhered to in whole or in part by this request.
        , referralRequest_basedOn :: [Reference]
          -- ^ Indicates any plans, proposals or orders that this request 
          --   is intended to satisfy - in whole or in part.
        , referralRequest_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , referralRequest_groupIdentifier :: Maybe Identifier
          -- ^ The business identifier of the logical &quot;grouping&quot; 
          --   request/order that this referral is a part of.
        , referralRequest_status :: RequestStatus
          -- ^ The status of the authorization/intention reflected by the 
          --   referral request record.
        , referralRequest_intent :: RequestIntent
          -- ^ Distinguishes the &quot;level&quot; of authorization/demand 
          --   implicit in this request.
        , referralRequest_type :: Maybe CodeableConcept
          -- ^ An indication of the type of referral (or where applicable 
          --   the type of transfer of care) request.
        , referralRequest_priority :: Maybe RequestPriority
          -- ^ An indication of the urgency of referral (or where 
          --   applicable the type of transfer of care) request.
        , referralRequest_serviceRequested :: [CodeableConcept]
          -- ^ The service(s) that is/are requested to be provided to the 
          --   patient. For example: cardiac pacemaker insertion.
        , referralRequest_subject :: Reference
          -- ^ The patient who is the subject of a referral or transfer of 
          --   care request.
        , referralRequest_context :: Maybe Reference
          -- ^ The encounter at which the request for referral or transfer 
          --   of care is initiated.
        , referralRequest_choice20 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The period of time within which the services identified in 
          --   the referral/transfer of care is specified or required to 
          --   occur.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , referralRequest_authoredOn :: Maybe DateTime
          -- ^ Date/DateTime of creation for draft requests and date of 
          --   activation for active requests.
        , referralRequest_requester :: Maybe ReferralRequestRequester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , referralRequest_specialty :: Maybe CodeableConcept
          -- ^ Indication of the clinical domain or discipline to which 
          --   the referral or transfer of care request is sent. For 
          --   example: Cardiology Gastroenterology Diabetology.
        , referralRequest_recipient :: [Reference]
          -- ^ The healthcare provider(s) or provider organization(s) 
          --   who/which is to receive the referral/transfer of care 
          --   request.
        , referralRequest_reasonCode :: [CodeableConcept]
          -- ^ Description of clinical condition indicating why 
          --   referral/transfer of care is requested. For example: 
          --   Pathological Anomalies, Disabled (physical or mental), 
          --   Behavioral Management.
        , referralRequest_reasonReference :: [Reference]
          -- ^ Indicates another resource whose existence justifies this 
          --   request.
        , referralRequest_description :: Maybe Xsd.XsdString
          -- ^ The reason element gives a short description of why the 
          --   referral is being made, the description expands on this to 
          --   support a more complete clinical summary.
        , referralRequest_supportingInfo :: [Reference]
          -- ^ Any additional (administrative, financial or clinical) 
          --   information required to support request for referral or 
          --   transfer of care. For example: Presenting problems/chief 
          --   complaints Medical History Family History Alerts 
          --   Allergy/Intolerance and Adverse Reactions Medications 
          --   Observations/Assessments (may include cognitive and 
          --   fundtional assessments) Diagnostic Reports Care Plan.
        , referralRequest_note :: [Annotation]
          -- ^ Comments made about the referral request by any of the 
          --   participants.
        , referralRequest_relevantHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this 
          --   resource or fulfilling request or event resources that 
          --   identify key state transitions or updates that are likely 
          --   to be relevant to a user looking at the current version of 
          --   the resource.
        }
        deriving (Eq,Show)
instance SchemaType ReferralRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ReferralRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "priority")
            `apply` many (parseSchemaType "serviceRequested")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` optional (parseSchemaType "specialty")
            `apply` many (parseSchemaType "recipient")
            `apply` many (parseSchemaType "reasonCode")
            `apply` many (parseSchemaType "reasonReference")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "supportingInfo")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
    schemaTypeToXML s x@ReferralRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ referralRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ referralRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ referralRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ referralRequest_language x
            , maybe [] (schemaTypeToXML "text") $ referralRequest_text x
            , concatMap (schemaTypeToXML "contained") $ referralRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ referralRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ referralRequest_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ referralRequest_identifier x
            , concatMap (schemaTypeToXML "definition") $ referralRequest_definition x
            , concatMap (schemaTypeToXML "basedOn") $ referralRequest_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ referralRequest_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ referralRequest_groupIdentifier x
            , schemaTypeToXML "status" $ referralRequest_status x
            , schemaTypeToXML "intent" $ referralRequest_intent x
            , maybe [] (schemaTypeToXML "type") $ referralRequest_type x
            , maybe [] (schemaTypeToXML "priority") $ referralRequest_priority x
            , concatMap (schemaTypeToXML "serviceRequested") $ referralRequest_serviceRequested x
            , schemaTypeToXML "subject" $ referralRequest_subject x
            , maybe [] (schemaTypeToXML "context") $ referralRequest_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ referralRequest_choice20 x
            , maybe [] (schemaTypeToXML "authoredOn") $ referralRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ referralRequest_requester x
            , maybe [] (schemaTypeToXML "specialty") $ referralRequest_specialty x
            , concatMap (schemaTypeToXML "recipient") $ referralRequest_recipient x
            , concatMap (schemaTypeToXML "reasonCode") $ referralRequest_reasonCode x
            , concatMap (schemaTypeToXML "reasonReference") $ referralRequest_reasonReference x
            , maybe [] (schemaTypeToXML "description") $ referralRequest_description x
            , concatMap (schemaTypeToXML "supportingInfo") $ referralRequest_supportingInfo x
            , concatMap (schemaTypeToXML "note") $ referralRequest_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ referralRequest_relevantHistory x
            ]
instance Extension ReferralRequest DomainResource where
    supertype (ReferralRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ReferralRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ReferralRequest -> DomainResource)
              
 
-- | Used to record and send details about a request for 
--   referral service or transfer of a patient to the care of 
--   another provider or provider organization.
data ReferralRequestRequester = ReferralRequestRequester
        { referralRequestRequester_id :: Maybe String_primitive
        , referralRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , referralRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , referralRequestRequester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , referralRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType ReferralRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ReferralRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@ReferralRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ referralRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ referralRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ referralRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ referralRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ referralRequestRequester_onBehalfOf x
            ]
instance Extension ReferralRequestRequester BackboneElement where
    supertype (ReferralRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ReferralRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ReferralRequestRequester -> BackboneElement)
              
 
-- | Information about a person that is involved in the care for 
--   a patient, but who is not the target of healthcare, nor has 
--   a formal responsibility in the care process.
elementRelatedPerson :: XMLParser RelatedPerson
elementRelatedPerson = parseSchemaType "RelatedPerson"
elementToXMLRelatedPerson :: RelatedPerson -> [Content ()]
elementToXMLRelatedPerson = schemaTypeToXML "RelatedPerson"
 
data RelatedPerson = RelatedPerson
        { relatedPerson_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , relatedPerson_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , relatedPerson_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , relatedPerson_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , relatedPerson_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , relatedPerson_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , relatedPerson_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , relatedPerson_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , relatedPerson_identifier :: [Identifier]
          -- ^ Identifier for a person within a particular scope.
        , relatedPerson_active :: Maybe Boolean
          -- ^ Whether this related person record is in active use.
        , relatedPerson_patient :: Reference
          -- ^ The patient this person is related to.
        , relatedPerson_relationship :: Maybe CodeableConcept
          -- ^ The nature of the relationship between a patient and the 
          --   related person.
        , relatedPerson_name :: [HumanName]
          -- ^ A name associated with the person.
        , relatedPerson_telecom :: [ContactPoint]
          -- ^ A contact detail for the person, e.g. a telephone number or 
          --   an email address.
        , relatedPerson_gender :: Maybe AdministrativeGender
          -- ^ Administrative Gender - the gender that the person is 
          --   considered to have for administration and record keeping 
          --   purposes.
        , relatedPerson_birthDate :: Maybe Date
          -- ^ The date on which the related person was born.
        , relatedPerson_address :: [Address]
          -- ^ Address where the related person can be contacted or 
          --   visited.
        , relatedPerson_photo :: [Attachment]
          -- ^ Image of the person.
        , relatedPerson_period :: Maybe Period
          -- ^ The period of time that this relationship is considered to 
          --   be valid. If there are no dates defined, then the interval 
          --   is unknown.
        }
        deriving (Eq,Show)
instance SchemaType RelatedPerson where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RelatedPerson
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` parseSchemaType "patient"
            `apply` optional (parseSchemaType "relationship")
            `apply` many (parseSchemaType "name")
            `apply` many (parseSchemaType "telecom")
            `apply` optional (parseSchemaType "gender")
            `apply` optional (parseSchemaType "birthDate")
            `apply` many (parseSchemaType "address")
            `apply` many (parseSchemaType "photo")
            `apply` optional (parseSchemaType "period")
    schemaTypeToXML s x@RelatedPerson{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ relatedPerson_id x
            , maybe [] (schemaTypeToXML "meta") $ relatedPerson_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ relatedPerson_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ relatedPerson_language x
            , maybe [] (schemaTypeToXML "text") $ relatedPerson_text x
            , concatMap (schemaTypeToXML "contained") $ relatedPerson_contained x
            , concatMap (schemaTypeToXML "extension") $ relatedPerson_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ relatedPerson_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ relatedPerson_identifier x
            , maybe [] (schemaTypeToXML "active") $ relatedPerson_active x
            , schemaTypeToXML "patient" $ relatedPerson_patient x
            , maybe [] (schemaTypeToXML "relationship") $ relatedPerson_relationship x
            , concatMap (schemaTypeToXML "name") $ relatedPerson_name x
            , concatMap (schemaTypeToXML "telecom") $ relatedPerson_telecom x
            , maybe [] (schemaTypeToXML "gender") $ relatedPerson_gender x
            , maybe [] (schemaTypeToXML "birthDate") $ relatedPerson_birthDate x
            , concatMap (schemaTypeToXML "address") $ relatedPerson_address x
            , concatMap (schemaTypeToXML "photo") $ relatedPerson_photo x
            , maybe [] (schemaTypeToXML "period") $ relatedPerson_period x
            ]
instance Extension RelatedPerson DomainResource where
    supertype (RelatedPerson e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RelatedPerson Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RelatedPerson -> DomainResource)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
elementRequestGroup :: XMLParser RequestGroup
elementRequestGroup = parseSchemaType "RequestGroup"
elementToXMLRequestGroup :: RequestGroup -> [Content ()]
elementToXMLRequestGroup = schemaTypeToXML "RequestGroup"
 
data RequestGroup = RequestGroup
        { requestGroup_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , requestGroup_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , requestGroup_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , requestGroup_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , requestGroup_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , requestGroup_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , requestGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroup_identifier :: [Identifier]
          -- ^ Allows a service to provide a unique, business identifier 
          --   for the request.
        , requestGroup_definition :: [Reference]
          -- ^ A protocol, guideline, orderset or other definition that is 
          --   adhered to in whole or in part by this request.
        , requestGroup_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this request.
        , requestGroup_replaces :: [Reference]
          -- ^ Completed or terminated request(s) whose function is taken 
          --   by this new request.
        , requestGroup_groupIdentifier :: Maybe Identifier
          -- ^ A shared identifier common to all requests that were 
          --   authorized more or less simultaneously by a single author, 
          --   representing the identifier of the requisition, 
          --   prescription or similar form.
        , requestGroup_status :: RequestStatus
          -- ^ The current state of the request. For request groups, the 
          --   status reflects the status of all the requests in the 
          --   group.
        , requestGroup_intent :: RequestIntent
          -- ^ Indicates the level of authority/intentionality associated 
          --   with the request and where the request fits into the 
          --   workflow chain.
        , requestGroup_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the request should be addressed with 
          --   respect to other requests.
        , requestGroup_subject :: Maybe Reference
          -- ^ The subject for which the request group was created.
        , requestGroup_context :: Maybe Reference
          -- ^ Describes the context of the request group, if any.
        , requestGroup_authoredOn :: Maybe DateTime
          -- ^ Indicates when the request group was created.
        , requestGroup_author :: Maybe Reference
          -- ^ Provides a reference to the author of the request group.
        , requestGroup_choice20 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Indicates the reason the request group was created. This is 
          --   typically provided as a parameter to the evaluation and 
          --   echoed by the service, although for some use cases, such as 
          --   subscription- or event-based scenarios, it may provide an 
          --   indication of the cause for the response.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , requestGroup_note :: [Annotation]
          -- ^ Provides a mechanism to communicate additional information 
          --   about the response.
        , requestGroup_action :: [RequestGroupAction]
          -- ^ The actions, if any, produced by the evaluation of the 
          --   artifact.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RequestGroup
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` many (parseSchemaType "definition")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "replaces")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "author")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@RequestGroup{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ requestGroup_id x
            , maybe [] (schemaTypeToXML "meta") $ requestGroup_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ requestGroup_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ requestGroup_language x
            , maybe [] (schemaTypeToXML "text") $ requestGroup_text x
            , concatMap (schemaTypeToXML "contained") $ requestGroup_contained x
            , concatMap (schemaTypeToXML "extension") $ requestGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroup_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ requestGroup_identifier x
            , concatMap (schemaTypeToXML "definition") $ requestGroup_definition x
            , concatMap (schemaTypeToXML "basedOn") $ requestGroup_basedOn x
            , concatMap (schemaTypeToXML "replaces") $ requestGroup_replaces x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ requestGroup_groupIdentifier x
            , schemaTypeToXML "status" $ requestGroup_status x
            , schemaTypeToXML "intent" $ requestGroup_intent x
            , maybe [] (schemaTypeToXML "priority") $ requestGroup_priority x
            , maybe [] (schemaTypeToXML "subject") $ requestGroup_subject x
            , maybe [] (schemaTypeToXML "context") $ requestGroup_context x
            , maybe [] (schemaTypeToXML "authoredOn") $ requestGroup_authoredOn x
            , maybe [] (schemaTypeToXML "author") $ requestGroup_author x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ requestGroup_choice20 x
            , concatMap (schemaTypeToXML "note") $ requestGroup_note x
            , concatMap (schemaTypeToXML "action") $ requestGroup_action x
            ]
instance Extension RequestGroup DomainResource where
    supertype (RequestGroup e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RequestGroup Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RequestGroup -> DomainResource)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroupAction = RequestGroupAction
        { requestGroupAction_id :: Maybe String_primitive
        , requestGroupAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroupAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroupAction_label :: Maybe Xsd.XsdString
          -- ^ A user-visible label for the action.
        , requestGroupAction_title :: Maybe Xsd.XsdString
          -- ^ The title of the action displayed to a user.
        , requestGroupAction_description :: Maybe Xsd.XsdString
          -- ^ A short description of the action used to provide a summary 
          --   to display to the user.
        , requestGroupAction_textEquivalent :: Maybe Xsd.XsdString
          -- ^ A text equivalent of the action to be performed. This 
          --   provides a human-interpretable description of the action 
          --   when the definition is consumed by a system that may not be 
          --   capable of interpreting it dynamically.
        , requestGroupAction_code :: [CodeableConcept]
          -- ^ A code that provides meaning for the action or action 
          --   group. For example, a section may have a LOINC code for a 
          --   the section of a documentation template.
        , requestGroupAction_documentation :: [RelatedArtifact]
          -- ^ Didactic or other informational resources associated with 
          --   the action that can be provided to the CDS recipient. 
          --   Information resources can include inline text commentary 
          --   and links to web resources.
        , requestGroupAction_condition :: [RequestGroupCondition]
          -- ^ An expression that describes applicability criteria, or 
          --   start/stop conditions for the action.
        , requestGroupAction_relatedAction :: [RequestGroupRelatedAction]
          -- ^ A relationship to another action such as &quot;before&quot; 
          --   or &quot;30-60 minutes after start of&quot;.
        , requestGroupAction_choice10 :: (Maybe (OneOf5 DateTime Period Duration Range Timing))
          -- ^ An optional value describing when the action should be 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) timingDateTime
          --   
          --   (2) timingPeriod
          --   
          --   (3) timingDuration
          --   
          --   (4) timingRange
          --   
          --   (5) timingTiming
        , requestGroupAction_participant :: [Reference]
          -- ^ The participant that should perform or be responsible for 
          --   this action.
        , requestGroupAction_type :: Maybe Coding
          -- ^ The type of action to perform (create, update, remove).
        , requestGroupAction_groupingBehavior :: Maybe ActionGroupingBehavior
          -- ^ Defines the grouping behavior for the action and its 
          --   children.
        , requestGroupAction_selectionBehavior :: Maybe ActionSelectionBehavior
          -- ^ Defines the selection behavior for the action and its 
          --   children.
        , requestGroupAction_requiredBehavior :: Maybe ActionRequiredBehavior
          -- ^ Defines the requiredness behavior for the action.
        , requestGroupAction_precheckBehavior :: Maybe ActionPrecheckBehavior
          -- ^ Defines whether the action should usually be preselected.
        , requestGroupAction_cardinalityBehavior :: Maybe ActionCardinalityBehavior
          -- ^ Defines whether the action can be selected multiple times.
        , requestGroupAction_resource :: Maybe Reference
          -- ^ The resource that is the target of the action (e.g. 
          --   CommunicationRequest).
        , requestGroupAction_action :: [RequestGroupAction]
          -- ^ Sub actions.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroupAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroupAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "title")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "textEquivalent")
            `apply` many (parseSchemaType "code")
            `apply` many (parseSchemaType "documentation")
            `apply` many (parseSchemaType "condition")
            `apply` many (parseSchemaType "relatedAction")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf5 (parseSchemaType "timingDateTime"))
                                     , ("Period", fmap TwoOf5 (parseSchemaType "timingPeriod"))
                                     , ("Duration", fmap ThreeOf5 (parseSchemaType "timingDuration"))
                                     , ("Range", fmap FourOf5 (parseSchemaType "timingRange"))
                                     , ("Timing", fmap FiveOf5 (parseSchemaType "timingTiming"))
                                     ])
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "groupingBehavior")
            `apply` optional (parseSchemaType "selectionBehavior")
            `apply` optional (parseSchemaType "requiredBehavior")
            `apply` optional (parseSchemaType "precheckBehavior")
            `apply` optional (parseSchemaType "cardinalityBehavior")
            `apply` optional (parseSchemaType "resource")
            `apply` many (parseSchemaType "action")
    schemaTypeToXML s x@RequestGroupAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroupAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroupAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroupAction_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ requestGroupAction_label x
            , maybe [] (schemaTypeToXML "title") $ requestGroupAction_title x
            , maybe [] (schemaTypeToXML "description") $ requestGroupAction_description x
            , maybe [] (schemaTypeToXML "textEquivalent") $ requestGroupAction_textEquivalent x
            , concatMap (schemaTypeToXML "code") $ requestGroupAction_code x
            , concatMap (schemaTypeToXML "documentation") $ requestGroupAction_documentation x
            , concatMap (schemaTypeToXML "condition") $ requestGroupAction_condition x
            , concatMap (schemaTypeToXML "relatedAction") $ requestGroupAction_relatedAction x
            , maybe [] (foldOneOf5  (schemaTypeToXML "timingDateTime")
                                    (schemaTypeToXML "timingPeriod")
                                    (schemaTypeToXML "timingDuration")
                                    (schemaTypeToXML "timingRange")
                                    (schemaTypeToXML "timingTiming")
                                   ) $ requestGroupAction_choice10 x
            , concatMap (schemaTypeToXML "participant") $ requestGroupAction_participant x
            , maybe [] (schemaTypeToXML "type") $ requestGroupAction_type x
            , maybe [] (schemaTypeToXML "groupingBehavior") $ requestGroupAction_groupingBehavior x
            , maybe [] (schemaTypeToXML "selectionBehavior") $ requestGroupAction_selectionBehavior x
            , maybe [] (schemaTypeToXML "requiredBehavior") $ requestGroupAction_requiredBehavior x
            , maybe [] (schemaTypeToXML "precheckBehavior") $ requestGroupAction_precheckBehavior x
            , maybe [] (schemaTypeToXML "cardinalityBehavior") $ requestGroupAction_cardinalityBehavior x
            , maybe [] (schemaTypeToXML "resource") $ requestGroupAction_resource x
            , concatMap (schemaTypeToXML "action") $ requestGroupAction_action x
            ]
instance Extension RequestGroupAction BackboneElement where
    supertype (RequestGroupAction a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               BackboneElement a0 e0 e1
instance Extension RequestGroupAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroupAction -> BackboneElement)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroupCondition = RequestGroupCondition
        { requestGroupCondition_id :: Maybe String_primitive
        , requestGroupCondition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroupCondition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroupCondition_kind :: ActionConditionKind
          -- ^ The kind of condition.
        , requestGroupCondition_description :: Maybe Xsd.XsdString
          -- ^ A brief, natural language description of the condition that 
          --   effectively communicates the intended semantics.
        , requestGroupCondition_language :: Maybe Xsd.XsdString
          -- ^ The media type of the language for the expression.
        , requestGroupCondition_expression :: Maybe Xsd.XsdString
          -- ^ An expression that returns true or false, indicating 
          --   whether or not the condition is satisfied.
        }
        deriving (Eq,Show)
instance SchemaType RequestGroupCondition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroupCondition a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "kind"
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "expression")
    schemaTypeToXML s x@RequestGroupCondition{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroupCondition_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroupCondition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroupCondition_modifierExtension x
            , schemaTypeToXML "kind" $ requestGroupCondition_kind x
            , maybe [] (schemaTypeToXML "description") $ requestGroupCondition_description x
            , maybe [] (schemaTypeToXML "language") $ requestGroupCondition_language x
            , maybe [] (schemaTypeToXML "expression") $ requestGroupCondition_expression x
            ]
instance Extension RequestGroupCondition BackboneElement where
    supertype (RequestGroupCondition a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension RequestGroupCondition Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroupCondition -> BackboneElement)
              
 
-- | A group of related requests that can be used to capture 
--   intended activities that have inter-dependencies such as 
--   &quot;give this medication after that one&quot;.
data RequestGroupRelatedAction = RequestGroupRelatedAction
        { requestGroupRelatedAction_id :: Maybe String_primitive
        , requestGroupRelatedAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , requestGroupRelatedAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , requestGroupRelatedAction_actionId :: Id
          -- ^ The element id of the action this is related to.
        , requestGroupRelatedAction_relationship :: ActionRelationshipType
          -- ^ The relationship of this action to the related action.
        , requestGroupRelatedAction_choice4 :: (Maybe (OneOf2 Duration Range))
          -- ^ A duration or range of durations to apply to the 
          --   relationship. For example, 30-60 minutes before.
          --   
          --   Choice between:
          --   
          --   (1) offsetDuration
          --   
          --   (2) offsetRange
        }
        deriving (Eq,Show)
instance SchemaType RequestGroupRelatedAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RequestGroupRelatedAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "actionId"
            `apply` parseSchemaType "relationship"
            `apply` optional (oneOf' [ ("Duration", fmap OneOf2 (parseSchemaType "offsetDuration"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "offsetRange"))
                                     ])
    schemaTypeToXML s x@RequestGroupRelatedAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ requestGroupRelatedAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ requestGroupRelatedAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ requestGroupRelatedAction_modifierExtension x
            , schemaTypeToXML "actionId" $ requestGroupRelatedAction_actionId x
            , schemaTypeToXML "relationship" $ requestGroupRelatedAction_relationship x
            , maybe [] (foldOneOf2  (schemaTypeToXML "offsetDuration")
                                    (schemaTypeToXML "offsetRange")
                                   ) $ requestGroupRelatedAction_choice4 x
            ]
instance Extension RequestGroupRelatedAction BackboneElement where
    supertype (RequestGroupRelatedAction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension RequestGroupRelatedAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RequestGroupRelatedAction -> BackboneElement)
              
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
elementResearchStudy :: XMLParser ResearchStudy
elementResearchStudy = parseSchemaType "ResearchStudy"
elementToXMLResearchStudy :: ResearchStudy -> [Content ()]
elementToXMLResearchStudy = schemaTypeToXML "ResearchStudy"
 
data ResearchStudy = ResearchStudy
        { researchStudy_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , researchStudy_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , researchStudy_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , researchStudy_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , researchStudy_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , researchStudy_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , researchStudy_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchStudy_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchStudy_identifier :: [Identifier]
          -- ^ Identifiers assigned to this research study by the sponsor 
          --   or other systems.
        , researchStudy_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive user-friendly label for the study.
        , researchStudy_protocol :: [Reference]
          -- ^ The set of steps expected to be performed as part of the 
          --   execution of the study.
        , researchStudy_partOf :: [Reference]
          -- ^ A larger research study of which this particular study is a 
          --   component or step.
        , researchStudy_status :: ResearchStudyStatus
          -- ^ The current state of the study.
        , researchStudy_category :: [CodeableConcept]
          -- ^ Codes categorizing the type of study such as 
          --   investigational vs. observational, type of blinding, type 
          --   of randomization, safety vs. efficacy, etc.
        , researchStudy_focus :: [CodeableConcept]
          -- ^ The condition(s), medication(s), food(s), therapy(ies), 
          --   device(s) or other concerns or interventions that the study 
          --   is seeking to gain more information about.
        , researchStudy_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in learning more about or 
          --   engaging with the study.
        , researchStudy_relatedArtifact :: [RelatedArtifact]
          -- ^ Citations, references and other related documents.
        , researchStudy_keyword :: [CodeableConcept]
          -- ^ Key terms to aid in searching for or filtering the study.
        , researchStudy_jurisdiction :: [CodeableConcept]
          -- ^ Indicates a country, state or other region where the study 
          --   is taking place.
        , researchStudy_description :: Maybe Markdown
          -- ^ A full description of how the study is being conducted.
        , researchStudy_enrollment :: [Reference]
          -- ^ Reference to a Group that defines the criteria for and 
          --   quantity of subjects participating in the study. E.g. 
          --   &quot; 200 female Europeans between the ages of 20 and 45 
          --   with early onset diabetes&quot;.
        , researchStudy_period :: Maybe Period
          -- ^ Identifies the start date and the expected (or actual, 
          --   depending on status) end date for the study.
        , researchStudy_sponsor :: Maybe Reference
          -- ^ The organization responsible for the execution of the 
          --   study.
        , researchStudy_principalInvestigator :: Maybe Reference
          -- ^ Indicates the individual who has primary oversite of the 
          --   execution of the study.
        , researchStudy_site :: [Reference]
          -- ^ Clinic, hospital or other healthcare location that is 
          --   participating in the study.
        , researchStudy_reasonStopped :: Maybe CodeableConcept
          -- ^ A description and/or code explaining the premature 
          --   termination of the study.
        , researchStudy_note :: [Annotation]
          -- ^ Comments made about the event by the performer, subject or 
          --   other participants.
        , researchStudy_arm :: [ResearchStudyArm]
          -- ^ Describes an expected sequence of events for one of the 
          --   participants of a study. E.g. Exposure to drug A, wash-out, 
          --   exposure to drug B, wash-out, follow-up.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudy where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResearchStudy
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "title")
            `apply` many (parseSchemaType "protocol")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "category")
            `apply` many (parseSchemaType "focus")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "keyword")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "enrollment")
            `apply` optional (parseSchemaType "period")
            `apply` optional (parseSchemaType "sponsor")
            `apply` optional (parseSchemaType "principalInvestigator")
            `apply` many (parseSchemaType "site")
            `apply` optional (parseSchemaType "reasonStopped")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "arm")
    schemaTypeToXML s x@ResearchStudy{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ researchStudy_id x
            , maybe [] (schemaTypeToXML "meta") $ researchStudy_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ researchStudy_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ researchStudy_language x
            , maybe [] (schemaTypeToXML "text") $ researchStudy_text x
            , concatMap (schemaTypeToXML "contained") $ researchStudy_contained x
            , concatMap (schemaTypeToXML "extension") $ researchStudy_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchStudy_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ researchStudy_identifier x
            , maybe [] (schemaTypeToXML "title") $ researchStudy_title x
            , concatMap (schemaTypeToXML "protocol") $ researchStudy_protocol x
            , concatMap (schemaTypeToXML "partOf") $ researchStudy_partOf x
            , schemaTypeToXML "status" $ researchStudy_status x
            , concatMap (schemaTypeToXML "category") $ researchStudy_category x
            , concatMap (schemaTypeToXML "focus") $ researchStudy_focus x
            , concatMap (schemaTypeToXML "contact") $ researchStudy_contact x
            , concatMap (schemaTypeToXML "relatedArtifact") $ researchStudy_relatedArtifact x
            , concatMap (schemaTypeToXML "keyword") $ researchStudy_keyword x
            , concatMap (schemaTypeToXML "jurisdiction") $ researchStudy_jurisdiction x
            , maybe [] (schemaTypeToXML "description") $ researchStudy_description x
            , concatMap (schemaTypeToXML "enrollment") $ researchStudy_enrollment x
            , maybe [] (schemaTypeToXML "period") $ researchStudy_period x
            , maybe [] (schemaTypeToXML "sponsor") $ researchStudy_sponsor x
            , maybe [] (schemaTypeToXML "principalInvestigator") $ researchStudy_principalInvestigator x
            , concatMap (schemaTypeToXML "site") $ researchStudy_site x
            , maybe [] (schemaTypeToXML "reasonStopped") $ researchStudy_reasonStopped x
            , concatMap (schemaTypeToXML "note") $ researchStudy_note x
            , concatMap (schemaTypeToXML "arm") $ researchStudy_arm x
            ]
instance Extension ResearchStudy DomainResource where
    supertype (ResearchStudy e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ResearchStudy Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ResearchStudy -> DomainResource)
              
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
data ResearchStudyArm = ResearchStudyArm
        { researchStudyArm_id :: Maybe String_primitive
        , researchStudyArm_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchStudyArm_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchStudyArm_name :: Xsd.XsdString
          -- ^ Unique, human-readable label for this arm of the study.
        , researchStudyArm_code :: Maybe CodeableConcept
          -- ^ Categorization of study arm, e.g. experimental, active 
          --   comparator, placebo comparater.
        , researchStudyArm_description :: Maybe Xsd.XsdString
          -- ^ A succinct description of the path through the study that 
          --   would be followed by a subject adhering to this arm.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudyArm where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ResearchStudyArm a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@ResearchStudyArm{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchStudyArm_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchStudyArm_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchStudyArm_modifierExtension x
            , schemaTypeToXML "name" $ researchStudyArm_name x
            , maybe [] (schemaTypeToXML "code") $ researchStudyArm_code x
            , maybe [] (schemaTypeToXML "description") $ researchStudyArm_description x
            ]
instance Extension ResearchStudyArm BackboneElement where
    supertype (ResearchStudyArm a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ResearchStudyArm Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ResearchStudyArm -> BackboneElement)
              
 
data ResearchStudyStatus_list
    = ResearchStudyStatus_list_Draft
      -- ^ Draft
    | ResearchStudyStatus_list_In_progress
      -- ^ In-progress
    | ResearchStudyStatus_list_Suspended
      -- ^ Suspended
    | ResearchStudyStatus_list_Stopped
      -- ^ Stopped
    | ResearchStudyStatus_list_Completed
      -- ^ Completed
    | ResearchStudyStatus_list_Entered_in_error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType ResearchStudyStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResearchStudyStatus_list where
    acceptingParser =  do literal "draft"; return ResearchStudyStatus_list_Draft
                      `onFail` do literal "in-progress"; return ResearchStudyStatus_list_In_progress
                      `onFail` do literal "suspended"; return ResearchStudyStatus_list_Suspended
                      `onFail` do literal "stopped"; return ResearchStudyStatus_list_Stopped
                      `onFail` do literal "completed"; return ResearchStudyStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return ResearchStudyStatus_list_Entered_in_error
                      
    simpleTypeText ResearchStudyStatus_list_Draft = "draft"
    simpleTypeText ResearchStudyStatus_list_In_progress = "in-progress"
    simpleTypeText ResearchStudyStatus_list_Suspended = "suspended"
    simpleTypeText ResearchStudyStatus_list_Stopped = "stopped"
    simpleTypeText ResearchStudyStatus_list_Completed = "completed"
    simpleTypeText ResearchStudyStatus_list_Entered_in_error = "entered-in-error"
 
data ResearchStudyStatus = ResearchStudyStatus
        { researchStudyStatus_id :: Maybe String_primitive
        , researchStudyStatus_value :: Maybe ResearchStudyStatus_list
        , researchStudyStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResearchStudyStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResearchStudyStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResearchStudyStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchStudyStatus_id x
                       , maybe [] (toXMLAttribute "value") $ researchStudyStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchStudyStatus_extension x
            ]
instance Extension ResearchStudyStatus Element where
    supertype (ResearchStudyStatus a0 a1 e0) =
               Element a0 e0
 
-- | A process where a researcher or organization plans and then 
--   executes a series of steps intended to increase the field 
--   of healthcare-related knowledge. This includes studies of 
--   safety, efficacy, comparative effectiveness and other 
--   information about medications, devices, therapies and other 
--   interventional and investigative techniques. A 
--   ResearchStudy involves the gathering of information about 
--   human or animal subjects.
elementResearchSubject :: XMLParser ResearchSubject
elementResearchSubject = parseSchemaType "ResearchSubject"
elementToXMLResearchSubject :: ResearchSubject -> [Content ()]
elementToXMLResearchSubject = schemaTypeToXML "ResearchSubject"
 
data ResearchSubject = ResearchSubject
        { researchSubject_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , researchSubject_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , researchSubject_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , researchSubject_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , researchSubject_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , researchSubject_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , researchSubject_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , researchSubject_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , researchSubject_identifier :: Maybe Identifier
          -- ^ Identifiers assigned to this research study by the sponsor 
          --   or other systems.
        , researchSubject_status :: ResearchSubjectStatus
          -- ^ The current state of the subject.
        , researchSubject_period :: Maybe Period
          -- ^ The dates the subject began and ended their participation 
          --   in the study.
        , researchSubject_study :: Reference
          -- ^ Reference to the study the subject is participating in.
        , researchSubject_individual :: Reference
          -- ^ The record of the person or animal who is involved in the 
          --   study.
        , researchSubject_assignedArm :: Maybe Xsd.XsdString
          -- ^ The name of the arm in the study the subject is expected to 
          --   follow as part of this study.
        , researchSubject_actualArm :: Maybe Xsd.XsdString
          -- ^ The name of the arm in the study the subject actually 
          --   followed as part of this study.
        , researchSubject_consent :: Maybe Reference
          -- ^ A record of the patient's informed agreement to participate 
          --   in the study.
        }
        deriving (Eq,Show)
instance SchemaType ResearchSubject where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ResearchSubject
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "period")
            `apply` parseSchemaType "study"
            `apply` parseSchemaType "individual"
            `apply` optional (parseSchemaType "assignedArm")
            `apply` optional (parseSchemaType "actualArm")
            `apply` optional (parseSchemaType "consent")
    schemaTypeToXML s x@ResearchSubject{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ researchSubject_id x
            , maybe [] (schemaTypeToXML "meta") $ researchSubject_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ researchSubject_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ researchSubject_language x
            , maybe [] (schemaTypeToXML "text") $ researchSubject_text x
            , concatMap (schemaTypeToXML "contained") $ researchSubject_contained x
            , concatMap (schemaTypeToXML "extension") $ researchSubject_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ researchSubject_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ researchSubject_identifier x
            , schemaTypeToXML "status" $ researchSubject_status x
            , maybe [] (schemaTypeToXML "period") $ researchSubject_period x
            , schemaTypeToXML "study" $ researchSubject_study x
            , schemaTypeToXML "individual" $ researchSubject_individual x
            , maybe [] (schemaTypeToXML "assignedArm") $ researchSubject_assignedArm x
            , maybe [] (schemaTypeToXML "actualArm") $ researchSubject_actualArm x
            , maybe [] (schemaTypeToXML "consent") $ researchSubject_consent x
            ]
instance Extension ResearchSubject DomainResource where
    supertype (ResearchSubject e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ResearchSubject Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ResearchSubject -> DomainResource)
              
 
data ResearchSubjectStatus_list
    = ResearchSubjectStatus_list_Candidate
      -- ^ Candidate
    | ResearchSubjectStatus_list_Enrolled
      -- ^ Enrolled
    | ResearchSubjectStatus_list_Active
      -- ^ Active
    | ResearchSubjectStatus_list_Suspended
      -- ^ Suspended
    | ResearchSubjectStatus_list_Withdrawn
      -- ^ Withdrawn
    | ResearchSubjectStatus_list_Completed
      -- ^ Completed
    deriving (Eq,Show,Enum)
instance SchemaType ResearchSubjectStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ResearchSubjectStatus_list where
    acceptingParser =  do literal "candidate"; return ResearchSubjectStatus_list_Candidate
                      `onFail` do literal "enrolled"; return ResearchSubjectStatus_list_Enrolled
                      `onFail` do literal "active"; return ResearchSubjectStatus_list_Active
                      `onFail` do literal "suspended"; return ResearchSubjectStatus_list_Suspended
                      `onFail` do literal "withdrawn"; return ResearchSubjectStatus_list_Withdrawn
                      `onFail` do literal "completed"; return ResearchSubjectStatus_list_Completed
                      
    simpleTypeText ResearchSubjectStatus_list_Candidate = "candidate"
    simpleTypeText ResearchSubjectStatus_list_Enrolled = "enrolled"
    simpleTypeText ResearchSubjectStatus_list_Active = "active"
    simpleTypeText ResearchSubjectStatus_list_Suspended = "suspended"
    simpleTypeText ResearchSubjectStatus_list_Withdrawn = "withdrawn"
    simpleTypeText ResearchSubjectStatus_list_Completed = "completed"
 
data ResearchSubjectStatus = ResearchSubjectStatus
        { researchSubjectStatus_id :: Maybe String_primitive
        , researchSubjectStatus_value :: Maybe ResearchSubjectStatus_list
        , researchSubjectStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ResearchSubjectStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ResearchSubjectStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ResearchSubjectStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ researchSubjectStatus_id x
                       , maybe [] (toXMLAttribute "value") $ researchSubjectStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ researchSubjectStatus_extension x
            ]
instance Extension ResearchSubjectStatus Element where
    supertype (ResearchSubjectStatus a0 a1 e0) =
               Element a0 e0
 
-- | An assessment of the likely outcome(s) for a patient or 
--   other subject as well as the likelihood of each outcome.
elementRiskAssessment :: XMLParser RiskAssessment
elementRiskAssessment = parseSchemaType "RiskAssessment"
elementToXMLRiskAssessment :: RiskAssessment -> [Content ()]
elementToXMLRiskAssessment = schemaTypeToXML "RiskAssessment"
 
data RiskAssessment = RiskAssessment
        { riskAssessment_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , riskAssessment_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , riskAssessment_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , riskAssessment_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , riskAssessment_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , riskAssessment_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , riskAssessment_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , riskAssessment_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , riskAssessment_identifier :: Maybe Identifier
          -- ^ Business identifier assigned to the risk assessment.
        , riskAssessment_basedOn :: Maybe Reference
          -- ^ A reference to the request that is fulfilled by this risk 
          --   assessment.
        , riskAssessment_parent :: Maybe Reference
          -- ^ A reference to a resource that this risk assessment is part 
          --   of, such as a Procedure.
        , riskAssessment_status :: ObservationStatus
          -- ^ The status of the RiskAssessment, using the same statuses 
          --   as an Observation.
        , riskAssessment_method :: Maybe CodeableConcept
          -- ^ The algorithm, process or mechanism used to evaluate the 
          --   risk.
        , riskAssessment_code :: Maybe CodeableConcept
          -- ^ The type of the risk assessment performed.
        , riskAssessment_subject :: Maybe Reference
          -- ^ The patient or group the risk assessment applies to.
        , riskAssessment_context :: Maybe Reference
          -- ^ The encounter where the assessment was performed.
        , riskAssessment_choice16 :: (Maybe (OneOf2 DateTime Period))
          -- ^ The date (and possibly time) the risk assessment was 
          --   performed.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
        , riskAssessment_condition :: Maybe Reference
          -- ^ For assessments or prognosis specific to a particular 
          --   condition, indicates the condition being assessed.
        , riskAssessment_performer :: Maybe Reference
          -- ^ The provider or software application that performed the 
          --   assessment.
        , riskAssessment_choice19 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ The reason the risk assessment was performed.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , riskAssessment_basis :: [Reference]
          -- ^ Indicates the source data considered as part of the 
          --   assessment (FamilyHistory, Observations, Procedures, 
          --   Conditions, etc.).
        , riskAssessment_prediction :: [RiskAssessmentPrediction]
          -- ^ Describes the expected outcome for the subject.
        , riskAssessment_mitigation :: Maybe Xsd.XsdString
          -- ^ A description of the steps that might be taken to reduce 
          --   the identified risk(s).
        , riskAssessment_comment :: Maybe Xsd.XsdString
          -- ^ Additional comments about the risk assessment.
        }
        deriving (Eq,Show)
instance SchemaType RiskAssessment where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return RiskAssessment
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "parent")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "subject")
            `apply` optional (parseSchemaType "context")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "occurrencePeriod"))
                                     ])
            `apply` optional (parseSchemaType "condition")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "basis")
            `apply` many (parseSchemaType "prediction")
            `apply` optional (parseSchemaType "mitigation")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@RiskAssessment{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ riskAssessment_id x
            , maybe [] (schemaTypeToXML "meta") $ riskAssessment_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ riskAssessment_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ riskAssessment_language x
            , maybe [] (schemaTypeToXML "text") $ riskAssessment_text x
            , concatMap (schemaTypeToXML "contained") $ riskAssessment_contained x
            , concatMap (schemaTypeToXML "extension") $ riskAssessment_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ riskAssessment_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ riskAssessment_identifier x
            , maybe [] (schemaTypeToXML "basedOn") $ riskAssessment_basedOn x
            , maybe [] (schemaTypeToXML "parent") $ riskAssessment_parent x
            , schemaTypeToXML "status" $ riskAssessment_status x
            , maybe [] (schemaTypeToXML "method") $ riskAssessment_method x
            , maybe [] (schemaTypeToXML "code") $ riskAssessment_code x
            , maybe [] (schemaTypeToXML "subject") $ riskAssessment_subject x
            , maybe [] (schemaTypeToXML "context") $ riskAssessment_context x
            , maybe [] (foldOneOf2  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                   ) $ riskAssessment_choice16 x
            , maybe [] (schemaTypeToXML "condition") $ riskAssessment_condition x
            , maybe [] (schemaTypeToXML "performer") $ riskAssessment_performer x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ riskAssessment_choice19 x
            , concatMap (schemaTypeToXML "basis") $ riskAssessment_basis x
            , concatMap (schemaTypeToXML "prediction") $ riskAssessment_prediction x
            , maybe [] (schemaTypeToXML "mitigation") $ riskAssessment_mitigation x
            , maybe [] (schemaTypeToXML "comment") $ riskAssessment_comment x
            ]
instance Extension RiskAssessment DomainResource where
    supertype (RiskAssessment e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension RiskAssessment Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: RiskAssessment -> DomainResource)
              
 
-- | An assessment of the likely outcome(s) for a patient or 
--   other subject as well as the likelihood of each outcome.
data RiskAssessmentPrediction = RiskAssessmentPrediction
        { riskAssessmentPrediction_id :: Maybe String_primitive
        , riskAssessmentPrediction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , riskAssessmentPrediction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , riskAssessmentPrediction_outcome :: CodeableConcept
          -- ^ One of the potential outcomes for the patient (e.g. 
          --   remission, death, a particular condition).
        , riskAssessmentPrediction_choice3 :: (Maybe (OneOf2 Decimal Range))
          -- ^ How likely is the outcome (in the specified timeframe).
          --   
          --   Choice between:
          --   
          --   (1) probabilityDecimal
          --   
          --   (2) probabilityRange
        , riskAssessmentPrediction_qualitativeRisk :: Maybe CodeableConcept
          -- ^ How likely is the outcome (in the specified timeframe), 
          --   expressed as a qualitative value (e.g. low, medium, high).
        , riskAssessmentPrediction_relativeRisk :: Maybe Decimal
          -- ^ Indicates the risk for this particular subject (with their 
          --   specific characteristics) divided by the risk of the 
          --   population in general. (Numbers greater than 1 = higher 
          --   risk than the population, numbers less than 1 = lower 
          --   risk.).
        , riskAssessmentPrediction_choice6 :: (Maybe (OneOf2 Period Range))
          -- ^ Indicates the period of time or age range of the subject to 
          --   which the specified probability applies.
          --   
          --   Choice between:
          --   
          --   (1) whenPeriod
          --   
          --   (2) whenRange
        , riskAssessmentPrediction_rationale :: Maybe Xsd.XsdString
          -- ^ Additional information explaining the basis for the 
          --   prediction.
        }
        deriving (Eq,Show)
instance SchemaType RiskAssessmentPrediction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (RiskAssessmentPrediction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "outcome"
            `apply` optional (oneOf' [ ("Decimal", fmap OneOf2 (parseSchemaType "probabilityDecimal"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "probabilityRange"))
                                     ])
            `apply` optional (parseSchemaType "qualitativeRisk")
            `apply` optional (parseSchemaType "relativeRisk")
            `apply` optional (oneOf' [ ("Period", fmap OneOf2 (parseSchemaType "whenPeriod"))
                                     , ("Range", fmap TwoOf2 (parseSchemaType "whenRange"))
                                     ])
            `apply` optional (parseSchemaType "rationale")
    schemaTypeToXML s x@RiskAssessmentPrediction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ riskAssessmentPrediction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ riskAssessmentPrediction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ riskAssessmentPrediction_modifierExtension x
            , schemaTypeToXML "outcome" $ riskAssessmentPrediction_outcome x
            , maybe [] (foldOneOf2  (schemaTypeToXML "probabilityDecimal")
                                    (schemaTypeToXML "probabilityRange")
                                   ) $ riskAssessmentPrediction_choice3 x
            , maybe [] (schemaTypeToXML "qualitativeRisk") $ riskAssessmentPrediction_qualitativeRisk x
            , maybe [] (schemaTypeToXML "relativeRisk") $ riskAssessmentPrediction_relativeRisk x
            , maybe [] (foldOneOf2  (schemaTypeToXML "whenPeriod")
                                    (schemaTypeToXML "whenRange")
                                   ) $ riskAssessmentPrediction_choice6 x
            , maybe [] (schemaTypeToXML "rationale") $ riskAssessmentPrediction_rationale x
            ]
instance Extension RiskAssessmentPrediction BackboneElement where
    supertype (RiskAssessmentPrediction a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension RiskAssessmentPrediction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: RiskAssessmentPrediction -> BackboneElement)
              
 
-- | A container for slots of time that may be available for 
--   booking appointments.
elementSchedule :: XMLParser Schedule
elementSchedule = parseSchemaType "Schedule"
elementToXMLSchedule :: Schedule -> [Content ()]
elementToXMLSchedule = schemaTypeToXML "Schedule"
 
data Schedule = Schedule
        { schedule_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , schedule_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , schedule_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , schedule_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , schedule_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , schedule_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , schedule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , schedule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , schedule_identifier :: [Identifier]
          -- ^ External Ids for this item.
        , schedule_active :: Maybe Boolean
          -- ^ Whether this schedule record is in active use, or should 
          --   not be used (such as was entered in error).
        , schedule_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , schedule_serviceType :: [CodeableConcept]
          -- ^ The specific service that is to be performed during this 
          --   appointment.
        , schedule_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , schedule_actor :: [Reference]
          -- ^ The resource this Schedule resource is providing 
          --   availability information for. These are expected to usually 
          --   be one of HealthcareService, Location, Practitioner, 
          --   PractitionerRole, Device, Patient or RelatedPerson.
        , schedule_planningHorizon :: Maybe Period
          -- ^ The period of time that the slots that are attached to this 
          --   Schedule resource cover (even if none exist). These cover 
          --   the amount of time that an organization's planning horizon; 
          --   the interval for which they are currently accepting 
          --   appointments. This does not define a &quot;template&quot; 
          --   for planning outside these dates.
        , schedule_comment :: Maybe Xsd.XsdString
          -- ^ Comments on the availability to describe any extended 
          --   information. Such as custom constraints on the slots that 
          --   may be associated.
        }
        deriving (Eq,Show)
instance SchemaType Schedule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Schedule
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "active")
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` many1 (parseSchemaType "actor")
            `apply` optional (parseSchemaType "planningHorizon")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@Schedule{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ schedule_id x
            , maybe [] (schemaTypeToXML "meta") $ schedule_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ schedule_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ schedule_language x
            , maybe [] (schemaTypeToXML "text") $ schedule_text x
            , concatMap (schemaTypeToXML "contained") $ schedule_contained x
            , concatMap (schemaTypeToXML "extension") $ schedule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ schedule_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ schedule_identifier x
            , maybe [] (schemaTypeToXML "active") $ schedule_active x
            , maybe [] (schemaTypeToXML "serviceCategory") $ schedule_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ schedule_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ schedule_specialty x
            , concatMap (schemaTypeToXML "actor") $ schedule_actor x
            , maybe [] (schemaTypeToXML "planningHorizon") $ schedule_planningHorizon x
            , maybe [] (schemaTypeToXML "comment") $ schedule_comment x
            ]
instance Extension Schedule DomainResource where
    supertype (Schedule e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Schedule Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Schedule -> DomainResource)
              
 
-- | A search parameter that defines a named search item that 
--   can be used to search/filter on a resource.
elementSearchParameter :: XMLParser SearchParameter
elementSearchParameter = parseSchemaType "SearchParameter"
elementToXMLSearchParameter :: SearchParameter -> [Content ()]
elementToXMLSearchParameter = schemaTypeToXML "SearchParameter"
 
data SearchParameter = SearchParameter
        { searchParameter_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , searchParameter_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , searchParameter_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , searchParameter_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , searchParameter_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , searchParameter_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , searchParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , searchParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , searchParameter_url :: Uri
          -- ^ An absolute URI that is used to identify this search 
          --   parameter when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   search parameter is (or will be) published. The URL SHOULD 
          --   include the major version of the search parameter. For more 
          --   information see [Technical and Business 
          --   Versions](resource.html#versions).
        , searchParameter_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   search parameter when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the search parameter author and is not expected 
          --   to be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , searchParameter_name :: Xsd.XsdString
          -- ^ A natural language name identifying the search parameter. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , searchParameter_status :: PublicationStatus
          -- ^ The status of this search parameter. Enables tracking the 
          --   life-cycle of the content.
        , searchParameter_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this search parameter is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , searchParameter_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the search parameter 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the search parameter changes.
        , searchParameter_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the search parameter.
        , searchParameter_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , searchParameter_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   search parameter instances.
        , searchParameter_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the search parameter 
          --   is intended to be used.
        , searchParameter_purpose :: Maybe Markdown
          -- ^ Explaination of why this search parameter is needed and why 
          --   it has been designed as it has.
        , searchParameter_code :: Code
          -- ^ The code used in the URL or the parameter name in a 
          --   parameters resource for this search parameter.
        , searchParameter_base :: [ResourceType]
          -- ^ The base resource type(s) that this search parameter can be 
          --   used against.
        , searchParameter_type :: SearchParamType
          -- ^ The type of value a search parameter refers to, and how the 
          --   content is interpreted.
        , searchParameter_derivedFrom :: Maybe Uri
          -- ^ Where this search parameter is originally defined. If a 
          --   derivedFrom is provided, then the details in the search 
          --   parameter must be consistent with the definition from which 
          --   it is defined. I.e. the parameter should have the same 
          --   meaning, and (usually) the functionality should be a proper 
          --   subset of the underlying search parameter.
        , searchParameter_description :: Markdown
          -- ^ A free text natural language description of the search 
          --   parameter from a consumer's perspective. and how it used.
        , searchParameter_expression :: Maybe Xsd.XsdString
          -- ^ A FHIRPath expression that returns a set of elements for 
          --   the search parameter.
        , searchParameter_xpath :: Maybe Xsd.XsdString
          -- ^ An XPath expression that returns a set of elements for the 
          --   search parameter.
        , searchParameter_xpathUsage :: Maybe XPathUsageType
          -- ^ How the search parameter relates to the set of elements 
          --   returned by evaluating the xpath query.
        , searchParameter_target :: [ResourceType]
          -- ^ Types of resource (if a resource is referenced).
        , searchParameter_comparator :: [SearchComparator]
          -- ^ Comparators supported for the search parameter.
        , searchParameter_modifier :: [SearchModifierCode]
          -- ^ A modifier supported for the search parameter.
        , searchParameter_chain :: [Xsd.XsdString]
          -- ^ Contains the names of any search parameters which may be 
          --   chained to the containing search parameter. Chained 
          --   parameters may be added to search parameters of type 
          --   reference, and specify that resources will only be returned 
          --   if they contain a reference to a resource which matches the 
          --   chained parameter value. Values for this field should be 
          --   drawn from SearchParameter.code for a parameter on the 
          --   target resource type.
        , searchParameter_component :: [SearchParameterComponent]
          -- ^ Used to define the parts of a composite search parameter.
        }
        deriving (Eq,Show)
instance SchemaType SearchParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SearchParameter
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` parseSchemaType "code"
            `apply` many1 (parseSchemaType "base")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "derivedFrom")
            `apply` parseSchemaType "description"
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "xpath")
            `apply` optional (parseSchemaType "xpathUsage")
            `apply` many (parseSchemaType "target")
            `apply` many (parseSchemaType "comparator")
            `apply` many (parseSchemaType "modifier")
            `apply` many (parseSchemaType "chain")
            `apply` many (parseSchemaType "component")
    schemaTypeToXML s x@SearchParameter{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ searchParameter_id x
            , maybe [] (schemaTypeToXML "meta") $ searchParameter_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ searchParameter_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ searchParameter_language x
            , maybe [] (schemaTypeToXML "text") $ searchParameter_text x
            , concatMap (schemaTypeToXML "contained") $ searchParameter_contained x
            , concatMap (schemaTypeToXML "extension") $ searchParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ searchParameter_modifierExtension x
            , schemaTypeToXML "url" $ searchParameter_url x
            , maybe [] (schemaTypeToXML "version") $ searchParameter_version x
            , schemaTypeToXML "name" $ searchParameter_name x
            , schemaTypeToXML "status" $ searchParameter_status x
            , maybe [] (schemaTypeToXML "experimental") $ searchParameter_experimental x
            , maybe [] (schemaTypeToXML "date") $ searchParameter_date x
            , maybe [] (schemaTypeToXML "publisher") $ searchParameter_publisher x
            , concatMap (schemaTypeToXML "contact") $ searchParameter_contact x
            , concatMap (schemaTypeToXML "useContext") $ searchParameter_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ searchParameter_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ searchParameter_purpose x
            , schemaTypeToXML "code" $ searchParameter_code x
            , concatMap (schemaTypeToXML "base") $ searchParameter_base x
            , schemaTypeToXML "type" $ searchParameter_type x
            , maybe [] (schemaTypeToXML "derivedFrom") $ searchParameter_derivedFrom x
            , schemaTypeToXML "description" $ searchParameter_description x
            , maybe [] (schemaTypeToXML "expression") $ searchParameter_expression x
            , maybe [] (schemaTypeToXML "xpath") $ searchParameter_xpath x
            , maybe [] (schemaTypeToXML "xpathUsage") $ searchParameter_xpathUsage x
            , concatMap (schemaTypeToXML "target") $ searchParameter_target x
            , concatMap (schemaTypeToXML "comparator") $ searchParameter_comparator x
            , concatMap (schemaTypeToXML "modifier") $ searchParameter_modifier x
            , concatMap (schemaTypeToXML "chain") $ searchParameter_chain x
            , concatMap (schemaTypeToXML "component") $ searchParameter_component x
            ]
instance Extension SearchParameter DomainResource where
    supertype (SearchParameter e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SearchParameter Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SearchParameter -> DomainResource)
              
 
-- | A search parameter that defines a named search item that 
--   can be used to search/filter on a resource.
data SearchParameterComponent = SearchParameterComponent
        { searchParameterComponent_id :: Maybe String_primitive
        , searchParameterComponent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , searchParameterComponent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , searchParameterComponent_definition :: Reference
          -- ^ The definition of the search parameter that describes this 
          --   part.
        , searchParameterComponent_expression :: Xsd.XsdString
          -- ^ A sub-expression that defines how to extract values for 
          --   this component from the output of the main 
          --   SearchParameter.expression.
        }
        deriving (Eq,Show)
instance SchemaType SearchParameterComponent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SearchParameterComponent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "definition"
            `apply` parseSchemaType "expression"
    schemaTypeToXML s x@SearchParameterComponent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchParameterComponent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchParameterComponent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ searchParameterComponent_modifierExtension x
            , schemaTypeToXML "definition" $ searchParameterComponent_definition x
            , schemaTypeToXML "expression" $ searchParameterComponent_expression x
            ]
instance Extension SearchParameterComponent BackboneElement where
    supertype (SearchParameterComponent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SearchParameterComponent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SearchParameterComponent -> BackboneElement)
              
 
data XPathUsageType_list
    = XPathUsageType_list_Normal
      -- ^ Normal
    | XPathUsageType_list_Phonetic
      -- ^ Phonetic
    | XPathUsageType_list_Nearby
      -- ^ Nearby
    | XPathUsageType_list_Distance
      -- ^ Distance
    | XPathUsageType_list_Other
      -- ^ Other
    deriving (Eq,Show,Enum)
instance SchemaType XPathUsageType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType XPathUsageType_list where
    acceptingParser =  do literal "normal"; return XPathUsageType_list_Normal
                      `onFail` do literal "phonetic"; return XPathUsageType_list_Phonetic
                      `onFail` do literal "nearby"; return XPathUsageType_list_Nearby
                      `onFail` do literal "distance"; return XPathUsageType_list_Distance
                      `onFail` do literal "other"; return XPathUsageType_list_Other
                      
    simpleTypeText XPathUsageType_list_Normal = "normal"
    simpleTypeText XPathUsageType_list_Phonetic = "phonetic"
    simpleTypeText XPathUsageType_list_Nearby = "nearby"
    simpleTypeText XPathUsageType_list_Distance = "distance"
    simpleTypeText XPathUsageType_list_Other = "other"
 
data XPathUsageType = XPathUsageType
        { xPathUsageType_id :: Maybe String_primitive
        , xPathUsageType_value :: Maybe XPathUsageType_list
        , xPathUsageType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType XPathUsageType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (XPathUsageType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@XPathUsageType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ xPathUsageType_id x
                       , maybe [] (toXMLAttribute "value") $ xPathUsageType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ xPathUsageType_extension x
            ]
instance Extension XPathUsageType Element where
    supertype (XPathUsageType a0 a1 e0) =
               Element a0 e0
 
data SearchModifierCode_list
    = SearchModifierCode_list_Missing
      -- ^ Missing
    | SearchModifierCode_list_Exact
      -- ^ Exact
    | SearchModifierCode_list_Contains
      -- ^ Contains
    | SearchModifierCode_list_Not
      -- ^ Not
    | SearchModifierCode_list_Text
      -- ^ Text
    | SearchModifierCode_list_In
      -- ^ In
    | SearchModifierCode_list_Not_in
      -- ^ Not In
    | SearchModifierCode_list_Below
      -- ^ Below
    | SearchModifierCode_list_Above
      -- ^ Above
    | SearchModifierCode_list_Type
      -- ^ Type
    deriving (Eq,Show,Enum)
instance SchemaType SearchModifierCode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchModifierCode_list where
    acceptingParser =  do literal "missing"; return SearchModifierCode_list_Missing
                      `onFail` do literal "exact"; return SearchModifierCode_list_Exact
                      `onFail` do literal "contains"; return SearchModifierCode_list_Contains
                      `onFail` do literal "not"; return SearchModifierCode_list_Not
                      `onFail` do literal "text"; return SearchModifierCode_list_Text
                      `onFail` do literal "in"; return SearchModifierCode_list_In
                      `onFail` do literal "not-in"; return SearchModifierCode_list_Not_in
                      `onFail` do literal "below"; return SearchModifierCode_list_Below
                      `onFail` do literal "above"; return SearchModifierCode_list_Above
                      `onFail` do literal "type"; return SearchModifierCode_list_Type
                      
    simpleTypeText SearchModifierCode_list_Missing = "missing"
    simpleTypeText SearchModifierCode_list_Exact = "exact"
    simpleTypeText SearchModifierCode_list_Contains = "contains"
    simpleTypeText SearchModifierCode_list_Not = "not"
    simpleTypeText SearchModifierCode_list_Text = "text"
    simpleTypeText SearchModifierCode_list_In = "in"
    simpleTypeText SearchModifierCode_list_Not_in = "not-in"
    simpleTypeText SearchModifierCode_list_Below = "below"
    simpleTypeText SearchModifierCode_list_Above = "above"
    simpleTypeText SearchModifierCode_list_Type = "type"
 
data SearchModifierCode = SearchModifierCode
        { searchModifierCode_id :: Maybe String_primitive
        , searchModifierCode_value :: Maybe SearchModifierCode_list
        , searchModifierCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchModifierCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchModifierCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchModifierCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchModifierCode_id x
                       , maybe [] (toXMLAttribute "value") $ searchModifierCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchModifierCode_extension x
            ]
instance Extension SearchModifierCode Element where
    supertype (SearchModifierCode a0 a1 e0) =
               Element a0 e0
 
data SearchComparator_list
    = SearchComparator_list_Eq
      -- ^ Equals
    | SearchComparator_list_Ne
      -- ^ Not Equals
    | SearchComparator_list_Gt
      -- ^ Greater Than
    | SearchComparator_list_Lt
      -- ^ Less Then
    | SearchComparator_list_Ge
      -- ^ Greater or Equals
    | SearchComparator_list_Le
      -- ^ Less of Equal
    | SearchComparator_list_Sa
      -- ^ Starts After
    | SearchComparator_list_Eb
      -- ^ Ends Before
    | SearchComparator_list_Ap
      -- ^ Approximately
    deriving (Eq,Show,Enum)
instance SchemaType SearchComparator_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SearchComparator_list where
    acceptingParser =  do literal "eq"; return SearchComparator_list_Eq
                      `onFail` do literal "ne"; return SearchComparator_list_Ne
                      `onFail` do literal "gt"; return SearchComparator_list_Gt
                      `onFail` do literal "lt"; return SearchComparator_list_Lt
                      `onFail` do literal "ge"; return SearchComparator_list_Ge
                      `onFail` do literal "le"; return SearchComparator_list_Le
                      `onFail` do literal "sa"; return SearchComparator_list_Sa
                      `onFail` do literal "eb"; return SearchComparator_list_Eb
                      `onFail` do literal "ap"; return SearchComparator_list_Ap
                      
    simpleTypeText SearchComparator_list_Eq = "eq"
    simpleTypeText SearchComparator_list_Ne = "ne"
    simpleTypeText SearchComparator_list_Gt = "gt"
    simpleTypeText SearchComparator_list_Lt = "lt"
    simpleTypeText SearchComparator_list_Ge = "ge"
    simpleTypeText SearchComparator_list_Le = "le"
    simpleTypeText SearchComparator_list_Sa = "sa"
    simpleTypeText SearchComparator_list_Eb = "eb"
    simpleTypeText SearchComparator_list_Ap = "ap"
 
data SearchComparator = SearchComparator
        { searchComparator_id :: Maybe String_primitive
        , searchComparator_value :: Maybe SearchComparator_list
        , searchComparator_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SearchComparator where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SearchComparator a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SearchComparator{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ searchComparator_id x
                       , maybe [] (toXMLAttribute "value") $ searchComparator_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ searchComparator_extension x
            ]
instance Extension SearchComparator Element where
    supertype (SearchComparator a0 a1 e0) =
               Element a0 e0
 
-- | Raw data describing a biological sequence.
elementSequence :: XMLParser Sequence
elementSequence = parseSchemaType "Sequence"
elementToXMLSequence :: Sequence -> [Content ()]
elementToXMLSequence = schemaTypeToXML "Sequence"
 
data Sequence = Sequence
        { sequence_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , sequence_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , sequence_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , sequence_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , sequence_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , sequence_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , sequence_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequence_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequence_identifier :: [Identifier]
          -- ^ A unique identifier for this particular sequence instance. 
          --   This is a FHIR-defined id.
        , sequence_type :: Maybe Code
          -- ^ Amino Acid Sequence/ DNA Sequence / RNA Sequence.
        , sequence_coordinateSystem :: Integer
          -- ^ Whether the sequence is numbered starting at 0 (0-based 
          --   numbering or coordinates, inclusive start, exclusive end) 
          --   or starting at 1 (1-based numbering, inclusive start and 
          --   inclusive end).
        , sequence_patient :: Maybe Reference
          -- ^ The patient whose sequencing results are described by this 
          --   resource.
        , sequence_specimen :: Maybe Reference
          -- ^ Specimen used for sequencing.
        , sequence_device :: Maybe Reference
          -- ^ The method for sequencing, for example, chip information.
        , sequence_performer :: Maybe Reference
          -- ^ The organization or lab that should be responsible for this 
          --   result.
        , sequence_quantity :: Maybe Quantity
          -- ^ The number of copies of the seqeunce of interest. (RNASeq).
        , sequence_referenceSeq :: Maybe SequenceReferenceSeq
          -- ^ A sequence that is used as a reference to describe variants 
          --   that are present in a sequence analyzed.
        , sequence_variant :: [SequenceVariant]
          -- ^ The definition of variant here originates from Sequence 
          --   ontology 
          --   ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). 
          --   This element can represent amino acid or nucleic sequence 
          --   change(including insertion,deletion,SNP,etc.) It can 
          --   represent some complex mutation or segment variation with 
          --   the assist of CIGAR string.
        , sequence_observedSeq :: Maybe Xsd.XsdString
          -- ^ Sequence that was observed. It is the result marked by 
          --   referenceSeq along with variant records on referenceSeq. 
          --   This shall starts from referenceSeq.windowStart and end by 
          --   referenceSeq.windowEnd.
        , sequence_quality :: [SequenceQuality]
          -- ^ An experimental feature attribute that defines the quality 
          --   of the feature in a quantitative way, such as a phred 
          --   quality score 
          --   ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
        , sequence_readCoverage :: Maybe Integer
          -- ^ Coverage (read depth or depth) is the average number of 
          --   reads representing a given nucleotide in the reconstructed 
          --   sequence.
        , sequence_repository :: [SequenceRepository]
          -- ^ Configurations of the external repository. The repository 
          --   shall store target's observedSeq or records related with 
          --   target's observedSeq.
        , sequence_pointer :: [Reference]
          -- ^ Pointer to next atomic sequence which at most contains one 
          --   variant.
        }
        deriving (Eq,Show)
instance SchemaType Sequence where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Sequence
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "coordinateSystem"
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "specimen")
            `apply` optional (parseSchemaType "device")
            `apply` optional (parseSchemaType "performer")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "referenceSeq")
            `apply` many (parseSchemaType "variant")
            `apply` optional (parseSchemaType "observedSeq")
            `apply` many (parseSchemaType "quality")
            `apply` optional (parseSchemaType "readCoverage")
            `apply` many (parseSchemaType "repository")
            `apply` many (parseSchemaType "pointer")
    schemaTypeToXML s x@Sequence{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ sequence_id x
            , maybe [] (schemaTypeToXML "meta") $ sequence_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ sequence_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ sequence_language x
            , maybe [] (schemaTypeToXML "text") $ sequence_text x
            , concatMap (schemaTypeToXML "contained") $ sequence_contained x
            , concatMap (schemaTypeToXML "extension") $ sequence_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequence_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ sequence_identifier x
            , maybe [] (schemaTypeToXML "type") $ sequence_type x
            , schemaTypeToXML "coordinateSystem" $ sequence_coordinateSystem x
            , maybe [] (schemaTypeToXML "patient") $ sequence_patient x
            , maybe [] (schemaTypeToXML "specimen") $ sequence_specimen x
            , maybe [] (schemaTypeToXML "device") $ sequence_device x
            , maybe [] (schemaTypeToXML "performer") $ sequence_performer x
            , maybe [] (schemaTypeToXML "quantity") $ sequence_quantity x
            , maybe [] (schemaTypeToXML "referenceSeq") $ sequence_referenceSeq x
            , concatMap (schemaTypeToXML "variant") $ sequence_variant x
            , maybe [] (schemaTypeToXML "observedSeq") $ sequence_observedSeq x
            , concatMap (schemaTypeToXML "quality") $ sequence_quality x
            , maybe [] (schemaTypeToXML "readCoverage") $ sequence_readCoverage x
            , concatMap (schemaTypeToXML "repository") $ sequence_repository x
            , concatMap (schemaTypeToXML "pointer") $ sequence_pointer x
            ]
instance Extension Sequence DomainResource where
    supertype (Sequence e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Sequence Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Sequence -> DomainResource)
              
 
-- | Raw data describing a biological sequence.
data SequenceReferenceSeq = SequenceReferenceSeq
        { sequenceReferenceSeq_id :: Maybe String_primitive
        , sequenceReferenceSeq_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequenceReferenceSeq_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequenceReferenceSeq_chromosome :: Maybe CodeableConcept
          -- ^ Structural unit composed of a nucleic acid molecule which 
          --   controls its own replication through the interaction of 
          --   specific proteins at one or more origins of replication 
          --   ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
        , sequenceReferenceSeq_genomeBuild :: Maybe Xsd.XsdString
          -- ^ The Genome Build used for reference, following GRCh build 
          --   versions e.g. 'GRCh 37'. Version number must be included if 
          --   a versioned release of a primary build was used.
        , sequenceReferenceSeq_referenceSeqId :: Maybe CodeableConcept
          -- ^ Reference identifier of reference sequence submitted to 
          --   NCBI. It must match the type in the Sequence.type field. 
          --   For example, the prefix, â€œNG_â€ identifies reference 
          --   sequence for genes, â€œNM_â€ for messenger RNA transcripts, 
          --   and â€œNP_â€ for amino acid sequences.
        , sequenceReferenceSeq_referenceSeqPointer :: Maybe Reference
          -- ^ A Pointer to another Sequence entity as reference sequence.
        , sequenceReferenceSeq_referenceSeqString :: Maybe Xsd.XsdString
          -- ^ A string like &quot;ACGT&quot;.
        , sequenceReferenceSeq_strand :: Maybe Integer
          -- ^ Directionality of DNA sequence. Available values are 
          --   &quot;1&quot; for the plus strand (5' to 
          --   3')/Watson/Sense/positive and &quot;-1&quot; for the minus 
          --   strand(3' to 5')/Crick/Antisense/negative.
        , sequenceReferenceSeq_windowStart :: Integer
          -- ^ Start position of the window on the reference sequence. If 
          --   the coordinate system is either 0-based or 1-based, then 
          --   start position is inclusive.
        , sequenceReferenceSeq_windowEnd :: Integer
          -- ^ End position of the window on the reference sequence. If 
          --   the coordinate system is 0-based then end is is exclusive 
          --   and does not include the last position. If the coordinate 
          --   system is 1-base, then end is inclusive and includes the 
          --   last position.
        }
        deriving (Eq,Show)
instance SchemaType SequenceReferenceSeq where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SequenceReferenceSeq a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "chromosome")
            `apply` optional (parseSchemaType "genomeBuild")
            `apply` optional (parseSchemaType "referenceSeqId")
            `apply` optional (parseSchemaType "referenceSeqPointer")
            `apply` optional (parseSchemaType "referenceSeqString")
            `apply` optional (parseSchemaType "strand")
            `apply` parseSchemaType "windowStart"
            `apply` parseSchemaType "windowEnd"
    schemaTypeToXML s x@SequenceReferenceSeq{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequenceReferenceSeq_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequenceReferenceSeq_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequenceReferenceSeq_modifierExtension x
            , maybe [] (schemaTypeToXML "chromosome") $ sequenceReferenceSeq_chromosome x
            , maybe [] (schemaTypeToXML "genomeBuild") $ sequenceReferenceSeq_genomeBuild x
            , maybe [] (schemaTypeToXML "referenceSeqId") $ sequenceReferenceSeq_referenceSeqId x
            , maybe [] (schemaTypeToXML "referenceSeqPointer") $ sequenceReferenceSeq_referenceSeqPointer x
            , maybe [] (schemaTypeToXML "referenceSeqString") $ sequenceReferenceSeq_referenceSeqString x
            , maybe [] (schemaTypeToXML "strand") $ sequenceReferenceSeq_strand x
            , schemaTypeToXML "windowStart" $ sequenceReferenceSeq_windowStart x
            , schemaTypeToXML "windowEnd" $ sequenceReferenceSeq_windowEnd x
            ]
instance Extension SequenceReferenceSeq BackboneElement where
    supertype (SequenceReferenceSeq a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension SequenceReferenceSeq Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SequenceReferenceSeq -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data SequenceVariant = SequenceVariant
        { sequenceVariant_id :: Maybe String_primitive
        , sequenceVariant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequenceVariant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequenceVariant_start :: Maybe Integer
          -- ^ Start position of the variant on the reference sequence.If 
          --   the coordinate system is either 0-based or 1-based, then 
          --   start position is inclusive.
        , sequenceVariant_end :: Maybe Integer
          -- ^ End position of the variant on the reference sequence.If 
          --   the coordinate system is 0-based then end is is exclusive 
          --   and does not include the last position. If the coordinate 
          --   system is 1-base, then end is inclusive and includes the 
          --   last position.
        , sequenceVariant_observedAllele :: Maybe Xsd.XsdString
          -- ^ An allele is one of a set of coexisting sequence variants 
          --   of a gene 
          --   ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). 
          --   Nucleotide(s)/amino acids from start position of sequence 
          --   to stop position of sequence on the positive (+) strand of 
          --   the observed sequence. When the sequence type is DNA, it 
          --   should be the sequence on the positive (+) strand. This 
          --   will lay in the range between variant.start and 
          --   variant.end.
        , sequenceVariant_referenceAllele :: Maybe Xsd.XsdString
          -- ^ An allele is one of a set of coexisting sequence variants 
          --   of a gene 
          --   ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). 
          --   Nucleotide(s)/amino acids from start position of sequence 
          --   to stop position of sequence on the positive (+) strand of 
          --   the reference sequence. When the sequence type is DNA, it 
          --   should be the sequence on the positive (+) strand. This 
          --   will lay in the range between variant.start and 
          --   variant.end.
        , sequenceVariant_cigar :: Maybe Xsd.XsdString
          -- ^ Extended CIGAR string for aligning the sequence with 
          --   reference bases. See detailed documentation 
          --   [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
        , sequenceVariant_variantPointer :: Maybe Reference
          -- ^ A pointer to an Observation containing variant information.
        }
        deriving (Eq,Show)
instance SchemaType SequenceVariant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SequenceVariant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "observedAllele")
            `apply` optional (parseSchemaType "referenceAllele")
            `apply` optional (parseSchemaType "cigar")
            `apply` optional (parseSchemaType "variantPointer")
    schemaTypeToXML s x@SequenceVariant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequenceVariant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequenceVariant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequenceVariant_modifierExtension x
            , maybe [] (schemaTypeToXML "start") $ sequenceVariant_start x
            , maybe [] (schemaTypeToXML "end") $ sequenceVariant_end x
            , maybe [] (schemaTypeToXML "observedAllele") $ sequenceVariant_observedAllele x
            , maybe [] (schemaTypeToXML "referenceAllele") $ sequenceVariant_referenceAllele x
            , maybe [] (schemaTypeToXML "cigar") $ sequenceVariant_cigar x
            , maybe [] (schemaTypeToXML "variantPointer") $ sequenceVariant_variantPointer x
            ]
instance Extension SequenceVariant BackboneElement where
    supertype (SequenceVariant a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension SequenceVariant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SequenceVariant -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data SequenceQuality = SequenceQuality
        { sequenceQuality_id :: Maybe String_primitive
        , sequenceQuality_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequenceQuality_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequenceQuality_type :: QualityType
          -- ^ INDEL / SNP / Undefined variant.
        , sequenceQuality_standardSequence :: Maybe CodeableConcept
          -- ^ Gold standard sequence used for comparing against.
        , sequenceQuality_start :: Maybe Integer
          -- ^ Start position of the sequence. If the coordinate system is 
          --   either 0-based or 1-based, then start position is 
          --   inclusive.
        , sequenceQuality_end :: Maybe Integer
          -- ^ End position of the sequence.If the coordinate system is 
          --   0-based then end is is exclusive and does not include the 
          --   last position. If the coordinate system is 1-base, then end 
          --   is inclusive and includes the last position.
        , sequenceQuality_score :: Maybe Quantity
          -- ^ The score of an experimentally derived feature such as a 
          --   p-value 
          --   ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
        , sequenceQuality_method :: Maybe CodeableConcept
          -- ^ Which method is used to get sequence quality.
        , sequenceQuality_truthTP :: Maybe Decimal
          -- ^ True positives, from the perspective of the truth data, 
          --   i.e. the number of sites in the Truth Call Set for which 
          --   there are paths through the Query Call Set that are 
          --   consistent with all of the alleles at this site, and for 
          --   which there is an accurate genotype call for the event.
        , sequenceQuality_queryTP :: Maybe Decimal
          -- ^ True positives, from the perspective of the query data, 
          --   i.e. the number of sites in the Query Call Set for which 
          --   there are paths through the Truth Call Set that are 
          --   consistent with all of the alleles at this site, and for 
          --   which there is an accurate genotype call for the event.
        , sequenceQuality_truthFN :: Maybe Decimal
          -- ^ False negatives, i.e. the number of sites in the Truth Call 
          --   Set for which there is no path through the Query Call Set 
          --   that is consistent with all of the alleles at this site, or 
          --   sites for which there is an inaccurate genotype call for 
          --   the event. Sites with correct variant but incorrect 
          --   genotype are counted here.
        , sequenceQuality_queryFP :: Maybe Decimal
          -- ^ False positives, i.e. the number of sites in the Query Call 
          --   Set for which there is no path through the Truth Call Set 
          --   that is consistent with this site. Sites with correct 
          --   variant but incorrect genotype are counted here.
        , sequenceQuality_gtFP :: Maybe Decimal
          -- ^ The number of false positives where the non-REF alleles in 
          --   the Truth and Query Call Sets match (i.e. cases where the 
          --   truth is 1/1 and the query is 0/1 or similar).
        , sequenceQuality_precision :: Maybe Decimal
          -- ^ QUERY.TP / (QUERY.TP + QUERY.FP).
        , sequenceQuality_recall :: Maybe Decimal
          -- ^ TRUTH.TP / (TRUTH.TP + TRUTH.FN).
        , sequenceQuality_fScore :: Maybe Decimal
          -- ^ Harmonic mean of Recall and Precision, computed as: 2 * 
          --   precision * recall / (precision + recall).
        }
        deriving (Eq,Show)
instance SchemaType SequenceQuality where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SequenceQuality a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "standardSequence")
            `apply` optional (parseSchemaType "start")
            `apply` optional (parseSchemaType "end")
            `apply` optional (parseSchemaType "score")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "truthTP")
            `apply` optional (parseSchemaType "queryTP")
            `apply` optional (parseSchemaType "truthFN")
            `apply` optional (parseSchemaType "queryFP")
            `apply` optional (parseSchemaType "gtFP")
            `apply` optional (parseSchemaType "precision")
            `apply` optional (parseSchemaType "recall")
            `apply` optional (parseSchemaType "fScore")
    schemaTypeToXML s x@SequenceQuality{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequenceQuality_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequenceQuality_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequenceQuality_modifierExtension x
            , schemaTypeToXML "type" $ sequenceQuality_type x
            , maybe [] (schemaTypeToXML "standardSequence") $ sequenceQuality_standardSequence x
            , maybe [] (schemaTypeToXML "start") $ sequenceQuality_start x
            , maybe [] (schemaTypeToXML "end") $ sequenceQuality_end x
            , maybe [] (schemaTypeToXML "score") $ sequenceQuality_score x
            , maybe [] (schemaTypeToXML "method") $ sequenceQuality_method x
            , maybe [] (schemaTypeToXML "truthTP") $ sequenceQuality_truthTP x
            , maybe [] (schemaTypeToXML "queryTP") $ sequenceQuality_queryTP x
            , maybe [] (schemaTypeToXML "truthFN") $ sequenceQuality_truthFN x
            , maybe [] (schemaTypeToXML "queryFP") $ sequenceQuality_queryFP x
            , maybe [] (schemaTypeToXML "gtFP") $ sequenceQuality_gtFP x
            , maybe [] (schemaTypeToXML "precision") $ sequenceQuality_precision x
            , maybe [] (schemaTypeToXML "recall") $ sequenceQuality_recall x
            , maybe [] (schemaTypeToXML "fScore") $ sequenceQuality_fScore x
            ]
instance Extension SequenceQuality BackboneElement where
    supertype (SequenceQuality a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               BackboneElement a0 e0 e1
instance Extension SequenceQuality Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SequenceQuality -> BackboneElement)
              
 
-- | Raw data describing a biological sequence.
data SequenceRepository = SequenceRepository
        { sequenceRepository_id :: Maybe String_primitive
        , sequenceRepository_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , sequenceRepository_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , sequenceRepository_type :: RepositoryType
          -- ^ Click and see / RESTful API / Need login to see / RESTful 
          --   API with authentication / Other ways to see resource.
        , sequenceRepository_url :: Maybe Uri
          -- ^ URI of an external repository which contains further 
          --   details about the genetics data.
        , sequenceRepository_name :: Maybe Xsd.XsdString
          -- ^ URI of an external repository which contains further 
          --   details about the genetics data.
        , sequenceRepository_datasetId :: Maybe Xsd.XsdString
          -- ^ Id of the variant in this external repository. The server 
          --   will understand how to use this id to call for more info 
          --   about datasets in external repository.
        , sequenceRepository_variantsetId :: Maybe Xsd.XsdString
          -- ^ Id of the variantset in this external repository. The 
          --   server will understand how to use this id to call for more 
          --   info about variantsets in external repository.
        , sequenceRepository_readsetId :: Maybe Xsd.XsdString
          -- ^ Id of the read in this external repository.
        }
        deriving (Eq,Show)
instance SchemaType SequenceRepository where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SequenceRepository a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "url")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "datasetId")
            `apply` optional (parseSchemaType "variantsetId")
            `apply` optional (parseSchemaType "readsetId")
    schemaTypeToXML s x@SequenceRepository{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ sequenceRepository_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ sequenceRepository_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ sequenceRepository_modifierExtension x
            , schemaTypeToXML "type" $ sequenceRepository_type x
            , maybe [] (schemaTypeToXML "url") $ sequenceRepository_url x
            , maybe [] (schemaTypeToXML "name") $ sequenceRepository_name x
            , maybe [] (schemaTypeToXML "datasetId") $ sequenceRepository_datasetId x
            , maybe [] (schemaTypeToXML "variantsetId") $ sequenceRepository_variantsetId x
            , maybe [] (schemaTypeToXML "readsetId") $ sequenceRepository_readsetId x
            ]
instance Extension SequenceRepository BackboneElement where
    supertype (SequenceRepository a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension SequenceRepository Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SequenceRepository -> BackboneElement)
              
 
data RepositoryType_list
    = RepositoryType_list_Directlink
      -- ^ Click and see
    | RepositoryType_list_Openapi
      -- ^ The URL is the RESTful or other kind of API that can access 
      --   to the result.
    | RepositoryType_list_Login
      -- ^ Result cannot be access unless an account is logged in
    | RepositoryType_list_Oauth
      -- ^ Result need to be fetched with API and need LOGIN( or 
      --   cookies are required when visiting the link of resource)
    | RepositoryType_list_Other
      -- ^ Some other complicated or particular way to get resource 
      --   from URL.
    deriving (Eq,Show,Enum)
instance SchemaType RepositoryType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType RepositoryType_list where
    acceptingParser =  do literal "directlink"; return RepositoryType_list_Directlink
                      `onFail` do literal "openapi"; return RepositoryType_list_Openapi
                      `onFail` do literal "login"; return RepositoryType_list_Login
                      `onFail` do literal "oauth"; return RepositoryType_list_Oauth
                      `onFail` do literal "other"; return RepositoryType_list_Other
                      
    simpleTypeText RepositoryType_list_Directlink = "directlink"
    simpleTypeText RepositoryType_list_Openapi = "openapi"
    simpleTypeText RepositoryType_list_Login = "login"
    simpleTypeText RepositoryType_list_Oauth = "oauth"
    simpleTypeText RepositoryType_list_Other = "other"
 
data RepositoryType = RepositoryType
        { repositoryType_id :: Maybe String_primitive
        , repositoryType_value :: Maybe RepositoryType_list
        , repositoryType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType RepositoryType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (RepositoryType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@RepositoryType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ repositoryType_id x
                       , maybe [] (toXMLAttribute "value") $ repositoryType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ repositoryType_extension x
            ]
instance Extension RepositoryType Element where
    supertype (RepositoryType a0 a1 e0) =
               Element a0 e0
 
data QualityType_list
    = QualityType_list_Indel
      -- ^ INDEL Comparison
    | QualityType_list_Snp
      -- ^ SNP Comparison
    | QualityType_list_Unknown
      -- ^ UNKNOWN Comparison
    deriving (Eq,Show,Enum)
instance SchemaType QualityType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType QualityType_list where
    acceptingParser =  do literal "indel"; return QualityType_list_Indel
                      `onFail` do literal "snp"; return QualityType_list_Snp
                      `onFail` do literal "unknown"; return QualityType_list_Unknown
                      
    simpleTypeText QualityType_list_Indel = "indel"
    simpleTypeText QualityType_list_Snp = "snp"
    simpleTypeText QualityType_list_Unknown = "unknown"
 
data QualityType = QualityType
        { qualityType_id :: Maybe String_primitive
        , qualityType_value :: Maybe QualityType_list
        , qualityType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType QualityType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (QualityType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@QualityType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ qualityType_id x
                       , maybe [] (toXMLAttribute "value") $ qualityType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ qualityType_extension x
            ]
instance Extension QualityType Element where
    supertype (QualityType a0 a1 e0) =
               Element a0 e0
 
-- | The ServiceDefinition describes a unit of decision support 
--   functionality that is made available as a service, such as 
--   immunization modules or drug-drug interaction checking.
elementServiceDefinition :: XMLParser ServiceDefinition
elementServiceDefinition = parseSchemaType "ServiceDefinition"
elementToXMLServiceDefinition :: ServiceDefinition -> [Content ()]
elementToXMLServiceDefinition = schemaTypeToXML "ServiceDefinition"
 
data ServiceDefinition = ServiceDefinition
        { serviceDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , serviceDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , serviceDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , serviceDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , serviceDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , serviceDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , serviceDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , serviceDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , serviceDefinition_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this service 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   service definition is (or will be) published. The URL 
          --   SHOULD include the major version of the service definition. 
          --   For more information see [Technical and Business 
          --   Versions](resource.html#versions).
        , serviceDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this service 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance. This is used for CMS or NQF identifiers for a 
          --   measure artifact. Note that at least one identifier is 
          --   required for non-experimental active artifacts.
        , serviceDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   service definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the service definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , serviceDefinition_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the service definition. 
          --   This name should be usable as an identifier for the module 
          --   by machine processing applications such as code generation.
        , serviceDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the service 
          --   definition.
        , serviceDefinition_status :: PublicationStatus
          -- ^ The status of this service definition. Enables tracking the 
          --   life-cycle of the content.
        , serviceDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this service definition is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , serviceDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the service definition 
          --   was published. The date must change if and when the 
          --   business version changes and it must change if the status 
          --   code changes. In addition, it should change when the 
          --   substantive content of the service definition changes.
        , serviceDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the service definition.
        , serviceDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the service 
          --   definition from a consumer's perspective.
        , serviceDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this service definition is needed and 
          --   why it has been designed as it has.
        , serviceDefinition_usage :: Maybe Xsd.XsdString
          -- ^ A detailed description of how the module is used from a 
          --   clinical perspective.
        , serviceDefinition_approvalDate :: Maybe Date
          -- ^ The date on which the resource content was approved by the 
          --   publisher. Approval happens once when the content is 
          --   officially approved for usage.
        , serviceDefinition_lastReviewDate :: Maybe Date
          -- ^ The date on which the resource content was last reviewed. 
          --   Review happens periodically after approval, but doesn't 
          --   change the original approval date.
        , serviceDefinition_effectivePeriod :: Maybe Period
          -- ^ The period during which the service definition content was 
          --   or is planned to be in active use.
        , serviceDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   service definition instances.
        , serviceDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the service 
          --   definition is intended to be used.
        , serviceDefinition_topic :: [CodeableConcept]
          -- ^ Descriptive topics related to the module. Topics provide a 
          --   high-level categorization of the module that can be useful 
          --   for filtering and searching.
        , serviceDefinition_contributor :: [Contributor]
          -- ^ A contributor to the content of the module, including 
          --   authors, editors, reviewers, and endorsers.
        , serviceDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , serviceDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the service definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the service 
          --   definition.
        , serviceDefinition_relatedArtifact :: [RelatedArtifact]
          -- ^ Related resources such as additional documentation, 
          --   justification, or bibliographic references.
        , serviceDefinition_trigger :: [TriggerDefinition]
          -- ^ The trigger element defines when the rule should be 
          --   invoked. This information is used by consumers of the rule 
          --   to determine how to integrate the rule into a specific 
          --   workflow.
        , serviceDefinition_dataRequirement :: [DataRequirement]
          -- ^ Data requirements are a machine processable description of 
          --   the data required by the module in order to perform a 
          --   successful evaluation.
        , serviceDefinition_operationDefinition :: Maybe Reference
          -- ^ A reference to the operation that is used to invoke this 
          --   service.
        }
        deriving (Eq,Show)
instance SchemaType ServiceDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ServiceDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "usage")
            `apply` optional (parseSchemaType "approvalDate")
            `apply` optional (parseSchemaType "lastReviewDate")
            `apply` optional (parseSchemaType "effectivePeriod")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` many (parseSchemaType "topic")
            `apply` many (parseSchemaType "contributor")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "relatedArtifact")
            `apply` many (parseSchemaType "trigger")
            `apply` many (parseSchemaType "dataRequirement")
            `apply` optional (parseSchemaType "operationDefinition")
    schemaTypeToXML s x@ServiceDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ serviceDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ serviceDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ serviceDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ serviceDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ serviceDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ serviceDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ serviceDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ serviceDefinition_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ serviceDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ serviceDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ serviceDefinition_version x
            , maybe [] (schemaTypeToXML "name") $ serviceDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ serviceDefinition_title x
            , schemaTypeToXML "status" $ serviceDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ serviceDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ serviceDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ serviceDefinition_publisher x
            , maybe [] (schemaTypeToXML "description") $ serviceDefinition_description x
            , maybe [] (schemaTypeToXML "purpose") $ serviceDefinition_purpose x
            , maybe [] (schemaTypeToXML "usage") $ serviceDefinition_usage x
            , maybe [] (schemaTypeToXML "approvalDate") $ serviceDefinition_approvalDate x
            , maybe [] (schemaTypeToXML "lastReviewDate") $ serviceDefinition_lastReviewDate x
            , maybe [] (schemaTypeToXML "effectivePeriod") $ serviceDefinition_effectivePeriod x
            , concatMap (schemaTypeToXML "useContext") $ serviceDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ serviceDefinition_jurisdiction x
            , concatMap (schemaTypeToXML "topic") $ serviceDefinition_topic x
            , concatMap (schemaTypeToXML "contributor") $ serviceDefinition_contributor x
            , concatMap (schemaTypeToXML "contact") $ serviceDefinition_contact x
            , maybe [] (schemaTypeToXML "copyright") $ serviceDefinition_copyright x
            , concatMap (schemaTypeToXML "relatedArtifact") $ serviceDefinition_relatedArtifact x
            , concatMap (schemaTypeToXML "trigger") $ serviceDefinition_trigger x
            , concatMap (schemaTypeToXML "dataRequirement") $ serviceDefinition_dataRequirement x
            , maybe [] (schemaTypeToXML "operationDefinition") $ serviceDefinition_operationDefinition x
            ]
instance Extension ServiceDefinition DomainResource where
    supertype (ServiceDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ServiceDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ServiceDefinition -> DomainResource)
              
 
-- | A slot of time on a schedule that may be available for 
--   booking appointments.
elementSlot :: XMLParser Slot
elementSlot = parseSchemaType "Slot"
elementToXMLSlot :: Slot -> [Content ()]
elementToXMLSlot = schemaTypeToXML "Slot"
 
data Slot = Slot
        { slot_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , slot_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , slot_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , slot_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , slot_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , slot_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , slot_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , slot_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , slot_identifier :: [Identifier]
          -- ^ External Ids for this item.
        , slot_serviceCategory :: Maybe CodeableConcept
          -- ^ A broad categorisation of the service that is to be 
          --   performed during this appointment.
        , slot_serviceType :: [CodeableConcept]
          -- ^ The type of appointments that can be booked into this slot 
          --   (ideally this would be an identifiable service - which is 
          --   at a location, rather than the location itself). If 
          --   provided then this overrides the value provided on the 
          --   availability resource.
        , slot_specialty :: [CodeableConcept]
          -- ^ The specialty of a practitioner that would be required to 
          --   perform the service requested in this appointment.
        , slot_appointmentType :: Maybe CodeableConcept
          -- ^ The style of appointment or patient that may be booked in 
          --   the slot (not service type).
        , slot_schedule :: Reference
          -- ^ The schedule resource that this slot defines an interval of 
          --   status information.
        , slot_status :: SlotStatus
          -- ^ busy | free | busy-unavailable | busy-tentative | 
          --   entered-in-error.
        , slot_start :: Instant
          -- ^ Date/Time that the slot is to begin.
        , slot_end :: Instant
          -- ^ Date/Time that the slot is to conclude.
        , slot_overbooked :: Maybe Boolean
          -- ^ This slot has already been overbooked, appointments are 
          --   unlikely to be accepted for this time.
        , slot_comment :: Maybe Xsd.XsdString
          -- ^ Comments on the slot to describe any extended information. 
          --   Such as custom constraints on the slot.
        }
        deriving (Eq,Show)
instance SchemaType Slot where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Slot
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "serviceCategory")
            `apply` many (parseSchemaType "serviceType")
            `apply` many (parseSchemaType "specialty")
            `apply` optional (parseSchemaType "appointmentType")
            `apply` parseSchemaType "schedule"
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "start"
            `apply` parseSchemaType "end"
            `apply` optional (parseSchemaType "overbooked")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@Slot{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ slot_id x
            , maybe [] (schemaTypeToXML "meta") $ slot_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ slot_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ slot_language x
            , maybe [] (schemaTypeToXML "text") $ slot_text x
            , concatMap (schemaTypeToXML "contained") $ slot_contained x
            , concatMap (schemaTypeToXML "extension") $ slot_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ slot_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ slot_identifier x
            , maybe [] (schemaTypeToXML "serviceCategory") $ slot_serviceCategory x
            , concatMap (schemaTypeToXML "serviceType") $ slot_serviceType x
            , concatMap (schemaTypeToXML "specialty") $ slot_specialty x
            , maybe [] (schemaTypeToXML "appointmentType") $ slot_appointmentType x
            , schemaTypeToXML "schedule" $ slot_schedule x
            , schemaTypeToXML "status" $ slot_status x
            , schemaTypeToXML "start" $ slot_start x
            , schemaTypeToXML "end" $ slot_end x
            , maybe [] (schemaTypeToXML "overbooked") $ slot_overbooked x
            , maybe [] (schemaTypeToXML "comment") $ slot_comment x
            ]
instance Extension Slot DomainResource where
    supertype (Slot e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Slot Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Slot -> DomainResource)
              
 
data SlotStatus_list
    = SlotStatus_list_Busy
      -- ^ Busy
    | SlotStatus_list_Free
      -- ^ Free
    | SlotStatus_list_Busy_unavailable
      -- ^ Busy (Unavailable)
    | SlotStatus_list_Busy_tentative
      -- ^ Busy (Tentative)
    | SlotStatus_list_Entered_in_error
      -- ^ Entered in error
    deriving (Eq,Show,Enum)
instance SchemaType SlotStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SlotStatus_list where
    acceptingParser =  do literal "busy"; return SlotStatus_list_Busy
                      `onFail` do literal "free"; return SlotStatus_list_Free
                      `onFail` do literal "busy-unavailable"; return SlotStatus_list_Busy_unavailable
                      `onFail` do literal "busy-tentative"; return SlotStatus_list_Busy_tentative
                      `onFail` do literal "entered-in-error"; return SlotStatus_list_Entered_in_error
                      
    simpleTypeText SlotStatus_list_Busy = "busy"
    simpleTypeText SlotStatus_list_Free = "free"
    simpleTypeText SlotStatus_list_Busy_unavailable = "busy-unavailable"
    simpleTypeText SlotStatus_list_Busy_tentative = "busy-tentative"
    simpleTypeText SlotStatus_list_Entered_in_error = "entered-in-error"
 
data SlotStatus = SlotStatus
        { slotStatus_id :: Maybe String_primitive
        , slotStatus_value :: Maybe SlotStatus_list
        , slotStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SlotStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SlotStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SlotStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ slotStatus_id x
                       , maybe [] (toXMLAttribute "value") $ slotStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ slotStatus_extension x
            ]
instance Extension SlotStatus Element where
    supertype (SlotStatus a0 a1 e0) =
               Element a0 e0
 
-- | A sample to be used for analysis.
elementSpecimen :: XMLParser Specimen
elementSpecimen = parseSchemaType "Specimen"
elementToXMLSpecimen :: Specimen -> [Content ()]
elementToXMLSpecimen = schemaTypeToXML "Specimen"
 
data Specimen = Specimen
        { specimen_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , specimen_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , specimen_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , specimen_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , specimen_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , specimen_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , specimen_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimen_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimen_identifier :: [Identifier]
          -- ^ Id for specimen.
        , specimen_accessionIdentifier :: Maybe Identifier
          -- ^ The identifier assigned by the lab when accessioning 
          --   specimen(s). This is not necessarily the same as the 
          --   specimen identifier, depending on local lab procedures.
        , specimen_status :: Maybe SpecimenStatus
          -- ^ The availability of the specimen.
        , specimen_type :: Maybe CodeableConcept
          -- ^ The kind of material that forms the specimen.
        , specimen_subject :: Reference
          -- ^ Where the specimen came from. This may be from the 
          --   patient(s) or from the environment or a device.
        , specimen_receivedTime :: Maybe DateTime
          -- ^ Time when specimen was received for processing or testing.
        , specimen_parent :: [Reference]
          -- ^ Reference to the parent (source) specimen which is used 
          --   when the specimen was either derived from or a component of 
          --   another specimen.
        , specimen_request :: [Reference]
          -- ^ Details concerning a test or procedure request that 
          --   required a specimen to be collected.
        , specimen_collection :: Maybe SpecimenCollection
          -- ^ Details concerning the specimen collection.
        , specimen_processing :: [SpecimenProcessing]
          -- ^ Details concerning processing and processing steps for the 
          --   specimen.
        , specimen_container :: [SpecimenContainer]
          -- ^ The container holding the specimen. The recursive nature of 
          --   containers; i.e. blood in tube in tray in rack is not 
          --   addressed here.
        , specimen_note :: [Annotation]
          -- ^ To communicate any details or issues about the specimen or 
          --   during the specimen collection. (for example: broken vial, 
          --   sent with patient, frozen).
        }
        deriving (Eq,Show)
instance SchemaType Specimen where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Specimen
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "accessionIdentifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "subject"
            `apply` optional (parseSchemaType "receivedTime")
            `apply` many (parseSchemaType "parent")
            `apply` many (parseSchemaType "request")
            `apply` optional (parseSchemaType "collection")
            `apply` many (parseSchemaType "processing")
            `apply` many (parseSchemaType "container")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@Specimen{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ specimen_id x
            , maybe [] (schemaTypeToXML "meta") $ specimen_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ specimen_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ specimen_language x
            , maybe [] (schemaTypeToXML "text") $ specimen_text x
            , concatMap (schemaTypeToXML "contained") $ specimen_contained x
            , concatMap (schemaTypeToXML "extension") $ specimen_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimen_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ specimen_identifier x
            , maybe [] (schemaTypeToXML "accessionIdentifier") $ specimen_accessionIdentifier x
            , maybe [] (schemaTypeToXML "status") $ specimen_status x
            , maybe [] (schemaTypeToXML "type") $ specimen_type x
            , schemaTypeToXML "subject" $ specimen_subject x
            , maybe [] (schemaTypeToXML "receivedTime") $ specimen_receivedTime x
            , concatMap (schemaTypeToXML "parent") $ specimen_parent x
            , concatMap (schemaTypeToXML "request") $ specimen_request x
            , maybe [] (schemaTypeToXML "collection") $ specimen_collection x
            , concatMap (schemaTypeToXML "processing") $ specimen_processing x
            , concatMap (schemaTypeToXML "container") $ specimen_container x
            , concatMap (schemaTypeToXML "note") $ specimen_note x
            ]
instance Extension Specimen DomainResource where
    supertype (Specimen e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Specimen Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Specimen -> DomainResource)
              
 
-- | A sample to be used for analysis.
data SpecimenCollection = SpecimenCollection
        { specimenCollection_id :: Maybe String_primitive
        , specimenCollection_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimenCollection_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimenCollection_collector :: Maybe Reference
          -- ^ Person who collected the specimen.
        , specimenCollection_choice3 :: (Maybe (OneOf2 DateTime Period))
          -- ^ Time when specimen was collected from subject - the 
          --   physiologically relevant time.
          --   
          --   Choice between:
          --   
          --   (1) collectedDateTime
          --   
          --   (2) collectedPeriod
        , specimenCollection_quantity :: Maybe Quantity
          -- ^ The quantity of specimen collected; for instance the volume 
          --   of a blood sample, or the physical measurement of an 
          --   anatomic pathology sample.
        , specimenCollection_method :: Maybe CodeableConcept
          -- ^ A coded value specifying the technique that is used to 
          --   perform the procedure.
        , specimenCollection_bodySite :: Maybe CodeableConcept
          -- ^ Anatomical location from which the specimen was collected 
          --   (if subject is a patient). This is the target site. This 
          --   element is not used for environmental specimens.
        }
        deriving (Eq,Show)
instance SchemaType SpecimenCollection where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SpecimenCollection a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "collector")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "collectedDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "collectedPeriod"))
                                     ])
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (parseSchemaType "method")
            `apply` optional (parseSchemaType "bodySite")
    schemaTypeToXML s x@SpecimenCollection{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimenCollection_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimenCollection_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimenCollection_modifierExtension x
            , maybe [] (schemaTypeToXML "collector") $ specimenCollection_collector x
            , maybe [] (foldOneOf2  (schemaTypeToXML "collectedDateTime")
                                    (schemaTypeToXML "collectedPeriod")
                                   ) $ specimenCollection_choice3 x
            , maybe [] (schemaTypeToXML "quantity") $ specimenCollection_quantity x
            , maybe [] (schemaTypeToXML "method") $ specimenCollection_method x
            , maybe [] (schemaTypeToXML "bodySite") $ specimenCollection_bodySite x
            ]
instance Extension SpecimenCollection BackboneElement where
    supertype (SpecimenCollection a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension SpecimenCollection Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SpecimenCollection -> BackboneElement)
              
 
-- | A sample to be used for analysis.
data SpecimenProcessing = SpecimenProcessing
        { specimenProcessing_id :: Maybe String_primitive
        , specimenProcessing_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimenProcessing_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimenProcessing_description :: Maybe Xsd.XsdString
          -- ^ Textual description of procedure.
        , specimenProcessing_procedure :: Maybe CodeableConcept
          -- ^ A coded value specifying the procedure used to process the 
          --   specimen.
        , specimenProcessing_additive :: [Reference]
          -- ^ Material used in the processing step.
        , specimenProcessing_choice5 :: (Maybe (OneOf2 DateTime Period))
          -- ^ A record of the time or period when the specimen processing 
          --   occurred. For example the time of sample fixation or the 
          --   period of time the sample was in formalin.
          --   
          --   Choice between:
          --   
          --   (1) timeDateTime
          --   
          --   (2) timePeriod
        }
        deriving (Eq,Show)
instance SchemaType SpecimenProcessing where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SpecimenProcessing a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "procedure")
            `apply` many (parseSchemaType "additive")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf2 (parseSchemaType "timeDateTime"))
                                     , ("Period", fmap TwoOf2 (parseSchemaType "timePeriod"))
                                     ])
    schemaTypeToXML s x@SpecimenProcessing{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimenProcessing_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimenProcessing_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimenProcessing_modifierExtension x
            , maybe [] (schemaTypeToXML "description") $ specimenProcessing_description x
            , maybe [] (schemaTypeToXML "procedure") $ specimenProcessing_procedure x
            , concatMap (schemaTypeToXML "additive") $ specimenProcessing_additive x
            , maybe [] (foldOneOf2  (schemaTypeToXML "timeDateTime")
                                    (schemaTypeToXML "timePeriod")
                                   ) $ specimenProcessing_choice5 x
            ]
instance Extension SpecimenProcessing BackboneElement where
    supertype (SpecimenProcessing a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension SpecimenProcessing Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SpecimenProcessing -> BackboneElement)
              
 
-- | A sample to be used for analysis.
data SpecimenContainer = SpecimenContainer
        { specimenContainer_id :: Maybe String_primitive
        , specimenContainer_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , specimenContainer_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , specimenContainer_identifier :: [Identifier]
          -- ^ Id for container. There may be multiple; a manufacturer's 
          --   bar code, lab assigned identifier, etc. The container ID 
          --   may differ from the specimen id in some circumstances.
        , specimenContainer_description :: Maybe Xsd.XsdString
          -- ^ Textual description of the container.
        , specimenContainer_type :: Maybe CodeableConcept
          -- ^ The type of container associated with the specimen (e.g. 
          --   slide, aliquot, etc.).
        , specimenContainer_capacity :: Maybe Quantity
          -- ^ The capacity (volume or other measure) the container may 
          --   contain.
        , specimenContainer_specimenQuantity :: Maybe Quantity
          -- ^ The quantity of specimen in the container; may be volume, 
          --   dimensions, or other appropriate measurements, depending on 
          --   the specimen type.
        , specimenContainer_choice7 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Introduced substance to preserve, maintain or enhance the 
          --   specimen. Examples: Formalin, Citrate, EDTA.
          --   
          --   Choice between:
          --   
          --   (1) additiveCodeableConcept
          --   
          --   (2) additiveReference
        }
        deriving (Eq,Show)
instance SchemaType SpecimenContainer where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SpecimenContainer a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "capacity")
            `apply` optional (parseSchemaType "specimenQuantity")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "additiveCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "additiveReference"))
                                     ])
    schemaTypeToXML s x@SpecimenContainer{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimenContainer_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimenContainer_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ specimenContainer_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ specimenContainer_identifier x
            , maybe [] (schemaTypeToXML "description") $ specimenContainer_description x
            , maybe [] (schemaTypeToXML "type") $ specimenContainer_type x
            , maybe [] (schemaTypeToXML "capacity") $ specimenContainer_capacity x
            , maybe [] (schemaTypeToXML "specimenQuantity") $ specimenContainer_specimenQuantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "additiveCodeableConcept")
                                    (schemaTypeToXML "additiveReference")
                                   ) $ specimenContainer_choice7 x
            ]
instance Extension SpecimenContainer BackboneElement where
    supertype (SpecimenContainer a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension SpecimenContainer Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SpecimenContainer -> BackboneElement)
              
 
data SpecimenStatus_list
    = SpecimenStatus_list_Available
      -- ^ Available
    | SpecimenStatus_list_Unavailable
      -- ^ Unavailable
    | SpecimenStatus_list_Unsatisfactory
      -- ^ Unsatisfactory
    | SpecimenStatus_list_Entered_in_error
      -- ^ Entered-in-error
    deriving (Eq,Show,Enum)
instance SchemaType SpecimenStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SpecimenStatus_list where
    acceptingParser =  do literal "available"; return SpecimenStatus_list_Available
                      `onFail` do literal "unavailable"; return SpecimenStatus_list_Unavailable
                      `onFail` do literal "unsatisfactory"; return SpecimenStatus_list_Unsatisfactory
                      `onFail` do literal "entered-in-error"; return SpecimenStatus_list_Entered_in_error
                      
    simpleTypeText SpecimenStatus_list_Available = "available"
    simpleTypeText SpecimenStatus_list_Unavailable = "unavailable"
    simpleTypeText SpecimenStatus_list_Unsatisfactory = "unsatisfactory"
    simpleTypeText SpecimenStatus_list_Entered_in_error = "entered-in-error"
 
data SpecimenStatus = SpecimenStatus
        { specimenStatus_id :: Maybe String_primitive
        , specimenStatus_value :: Maybe SpecimenStatus_list
        , specimenStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SpecimenStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SpecimenStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SpecimenStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ specimenStatus_id x
                       , maybe [] (toXMLAttribute "value") $ specimenStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ specimenStatus_extension x
            ]
instance Extension SpecimenStatus Element where
    supertype (SpecimenStatus a0 a1 e0) =
               Element a0 e0
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
elementStructureDefinition :: XMLParser StructureDefinition
elementStructureDefinition = parseSchemaType "StructureDefinition"
elementToXMLStructureDefinition :: StructureDefinition -> [Content ()]
elementToXMLStructureDefinition = schemaTypeToXML "StructureDefinition"
 
data StructureDefinition = StructureDefinition
        { structureDefinition_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , structureDefinition_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , structureDefinition_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , structureDefinition_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , structureDefinition_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , structureDefinition_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , structureDefinition_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinition_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinition_url :: Uri
          -- ^ An absolute URI that is used to identify this structure 
          --   definition when it is referenced in a specification, model, 
          --   design or an instance. This SHALL be a URL, SHOULD be 
          --   globally unique, and SHOULD be an address at which this 
          --   structure definition is (or will be) published. The URL 
          --   SHOULD include the major version of the structure 
          --   definition. For more information see [Technical and 
          --   Business Versions](resource.html#versions).
        , structureDefinition_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this structure 
          --   definition when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , structureDefinition_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   structure definition when it is referenced in a 
          --   specification, model, design or instance. This is an 
          --   arbitrary value managed by the structure definition author 
          --   and is not expected to be globally unique. For example, it 
          --   might be a timestamp (e.g. yyyymmdd) if a managed version 
          --   is not available. There is also no expectation that 
          --   versions can be placed in a lexicographical sequence.
        , structureDefinition_name :: Xsd.XsdString
          -- ^ A natural language name identifying the structure 
          --   definition. This name should be usable as an identifier for 
          --   the module by machine processing applications such as code 
          --   generation.
        , structureDefinition_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the structure 
          --   definition.
        , structureDefinition_status :: PublicationStatus
          -- ^ The status of this structure definition. Enables tracking 
          --   the life-cycle of the content.
        , structureDefinition_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this structure definition 
          --   is authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , structureDefinition_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the structure 
          --   definition was published. The date must change if and when 
          --   the business version changes and it must change if the 
          --   status code changes. In addition, it should change when the 
          --   substantive content of the structure definition changes.
        , structureDefinition_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the structure definition.
        , structureDefinition_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , structureDefinition_description :: Maybe Markdown
          -- ^ A free text natural language description of the structure 
          --   definition from a consumer's perspective.
        , structureDefinition_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   structure definition instances.
        , structureDefinition_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the structure 
          --   definition is intended to be used.
        , structureDefinition_purpose :: Maybe Markdown
          -- ^ Explaination of why this structure definition is needed and 
          --   why it has been designed as it has.
        , structureDefinition_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the structure definition 
          --   and/or its contents. Copyright statements are generally 
          --   legal restrictions on the use and publishing of the 
          --   structure definition.
        , structureDefinition_keyword :: [Coding]
          -- ^ A set of key words or terms from external terminologies 
          --   that may be used to assist with indexing and searching of 
          --   templates.
        , structureDefinition_fhirVersion :: Maybe Id
          -- ^ The version of the FHIR specification on which this 
          --   StructureDefinition is based - this is the formal version 
          --   of the specification, without the revision number, e.g. 
          --   [publication].[major].[minor], which is 3.0.1 for this 
          --   version.
        , structureDefinition_mapping :: [StructureDefinitionMapping]
          -- ^ An external specification that the content is mapped to.
        , structureDefinition_kind :: StructureDefinitionKind
          -- ^ Defines the kind of structure that this definition is 
          --   describing.
        , structureDefinition_abstract :: Boolean
          -- ^ Whether structure this definition describes is abstract or 
          --   not - that is, whether the structure is not intended to be 
          --   instantiated. For Resources and Data types, abstract types 
          --   will never be exchanged between systems.
        , structureDefinition_contextType :: Maybe ExtensionContext
          -- ^ If this is an extension, Identifies the context within FHIR 
          --   resources where the extension can be used.
        , structureDefinition_context :: [Xsd.XsdString]
          -- ^ Identifies the types of resource or data type elements to 
          --   which the extension can be applied.
        , structureDefinition_contextInvariant :: [Xsd.XsdString]
          -- ^ A set of rules as Fluent Invariants about when the 
          --   extension can be used (e.g. co-occurrence variants for the 
          --   extension).
        , structureDefinition_type :: Code
          -- ^ The type this structure describes. If the derivation kind 
          --   is 'specialization' then this is the master definition for 
          --   a type, and there is always one of these (a data type, an 
          --   extension, a resource, including abstract ones). Otherwise 
          --   the structure definition is a constraint on the stated type 
          --   (and in this case, the type cannot be an abstract type).
        , structureDefinition_baseDefinition :: Maybe Uri
          -- ^ An absolute URI that is the base structure from which this 
          --   type is derived, either by specialization or constraint.
        , structureDefinition_derivation :: Maybe TypeDerivationRule
          -- ^ How the type relates to the baseDefinition.
        , structureDefinition_snapshot :: Maybe StructureDefinitionSnapshot
          -- ^ A snapshot view is expressed in a stand alone form that can 
          --   be used and interpreted without considering the base 
          --   StructureDefinition.
        , structureDefinition_differential :: Maybe StructureDefinitionDifferential
          -- ^ A differential view is expressed relative to the base 
          --   StructureDefinition - a statement of differences that it 
          --   applies.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinition where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return StructureDefinition
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "keyword")
            `apply` optional (parseSchemaType "fhirVersion")
            `apply` many (parseSchemaType "mapping")
            `apply` parseSchemaType "kind"
            `apply` parseSchemaType "abstract"
            `apply` optional (parseSchemaType "contextType")
            `apply` many (parseSchemaType "context")
            `apply` many (parseSchemaType "contextInvariant")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "baseDefinition")
            `apply` optional (parseSchemaType "derivation")
            `apply` optional (parseSchemaType "snapshot")
            `apply` optional (parseSchemaType "differential")
    schemaTypeToXML s x@StructureDefinition{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ structureDefinition_id x
            , maybe [] (schemaTypeToXML "meta") $ structureDefinition_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ structureDefinition_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ structureDefinition_language x
            , maybe [] (schemaTypeToXML "text") $ structureDefinition_text x
            , concatMap (schemaTypeToXML "contained") $ structureDefinition_contained x
            , concatMap (schemaTypeToXML "extension") $ structureDefinition_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinition_modifierExtension x
            , schemaTypeToXML "url" $ structureDefinition_url x
            , concatMap (schemaTypeToXML "identifier") $ structureDefinition_identifier x
            , maybe [] (schemaTypeToXML "version") $ structureDefinition_version x
            , schemaTypeToXML "name" $ structureDefinition_name x
            , maybe [] (schemaTypeToXML "title") $ structureDefinition_title x
            , schemaTypeToXML "status" $ structureDefinition_status x
            , maybe [] (schemaTypeToXML "experimental") $ structureDefinition_experimental x
            , maybe [] (schemaTypeToXML "date") $ structureDefinition_date x
            , maybe [] (schemaTypeToXML "publisher") $ structureDefinition_publisher x
            , concatMap (schemaTypeToXML "contact") $ structureDefinition_contact x
            , maybe [] (schemaTypeToXML "description") $ structureDefinition_description x
            , concatMap (schemaTypeToXML "useContext") $ structureDefinition_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ structureDefinition_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ structureDefinition_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ structureDefinition_copyright x
            , concatMap (schemaTypeToXML "keyword") $ structureDefinition_keyword x
            , maybe [] (schemaTypeToXML "fhirVersion") $ structureDefinition_fhirVersion x
            , concatMap (schemaTypeToXML "mapping") $ structureDefinition_mapping x
            , schemaTypeToXML "kind" $ structureDefinition_kind x
            , schemaTypeToXML "abstract" $ structureDefinition_abstract x
            , maybe [] (schemaTypeToXML "contextType") $ structureDefinition_contextType x
            , concatMap (schemaTypeToXML "context") $ structureDefinition_context x
            , concatMap (schemaTypeToXML "contextInvariant") $ structureDefinition_contextInvariant x
            , schemaTypeToXML "type" $ structureDefinition_type x
            , maybe [] (schemaTypeToXML "baseDefinition") $ structureDefinition_baseDefinition x
            , maybe [] (schemaTypeToXML "derivation") $ structureDefinition_derivation x
            , maybe [] (schemaTypeToXML "snapshot") $ structureDefinition_snapshot x
            , maybe [] (schemaTypeToXML "differential") $ structureDefinition_differential x
            ]
instance Extension StructureDefinition DomainResource where
    supertype (StructureDefinition e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34 e35) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension StructureDefinition Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: StructureDefinition -> DomainResource)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinitionMapping = StructureDefinitionMapping
        { structureDefinitionMapping_id :: Maybe String_primitive
        , structureDefinitionMapping_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinitionMapping_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinitionMapping_identity :: Id
          -- ^ An Internal id that is used to identify this mapping set 
          --   when specific mappings are made.
        , structureDefinitionMapping_uri :: Maybe Uri
          -- ^ An absolute URI that identifies the specification that this 
          --   mapping is expressed to.
        , structureDefinitionMapping_name :: Maybe Xsd.XsdString
          -- ^ A name for the specification that is being mapped to.
        , structureDefinitionMapping_comment :: Maybe Xsd.XsdString
          -- ^ Comments about this mapping, including version notes, 
          --   issues, scope limitations, and other important notes for 
          --   usage.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinitionMapping where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinitionMapping a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identity"
            `apply` optional (parseSchemaType "uri")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "comment")
    schemaTypeToXML s x@StructureDefinitionMapping{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinitionMapping_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinitionMapping_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinitionMapping_modifierExtension x
            , schemaTypeToXML "identity" $ structureDefinitionMapping_identity x
            , maybe [] (schemaTypeToXML "uri") $ structureDefinitionMapping_uri x
            , maybe [] (schemaTypeToXML "name") $ structureDefinitionMapping_name x
            , maybe [] (schemaTypeToXML "comment") $ structureDefinitionMapping_comment x
            ]
instance Extension StructureDefinitionMapping BackboneElement where
    supertype (StructureDefinitionMapping a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinitionMapping Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinitionMapping -> BackboneElement)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinitionSnapshot = StructureDefinitionSnapshot
        { structureDefinitionSnapshot_id :: Maybe String_primitive
        , structureDefinitionSnapshot_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinitionSnapshot_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinitionSnapshot_element :: [ElementDefinition]
          -- ^ Captures constraints on each element within the resource.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinitionSnapshot where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinitionSnapshot a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@StructureDefinitionSnapshot{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinitionSnapshot_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinitionSnapshot_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinitionSnapshot_modifierExtension x
            , concatMap (schemaTypeToXML "element") $ structureDefinitionSnapshot_element x
            ]
instance Extension StructureDefinitionSnapshot BackboneElement where
    supertype (StructureDefinitionSnapshot a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinitionSnapshot Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinitionSnapshot -> BackboneElement)
              
 
-- | A definition of a FHIR structure. This resource is used to 
--   describe the underlying resources, data types defined in 
--   FHIR, and also for describing extensions and constraints on 
--   resources and data types.
data StructureDefinitionDifferential = StructureDefinitionDifferential
        { structureDefinitionDifferential_id :: Maybe String_primitive
        , structureDefinitionDifferential_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureDefinitionDifferential_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureDefinitionDifferential_element :: [ElementDefinition]
          -- ^ Captures constraints on each element within the resource.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinitionDifferential where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureDefinitionDifferential a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "element")
    schemaTypeToXML s x@StructureDefinitionDifferential{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinitionDifferential_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinitionDifferential_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureDefinitionDifferential_modifierExtension x
            , concatMap (schemaTypeToXML "element") $ structureDefinitionDifferential_element x
            ]
instance Extension StructureDefinitionDifferential BackboneElement where
    supertype (StructureDefinitionDifferential a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureDefinitionDifferential Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureDefinitionDifferential -> BackboneElement)
              
 
data StructureDefinitionKind_list
    = StructureDefinitionKind_list_Primitive_type
      -- ^ Primitive Data Type
    | StructureDefinitionKind_list_Complex_type
      -- ^ Complex Data Type
    | StructureDefinitionKind_list_Resource
      -- ^ Resource
    | StructureDefinitionKind_list_Logical
      -- ^ Logical Model
    deriving (Eq,Show,Enum)
instance SchemaType StructureDefinitionKind_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureDefinitionKind_list where
    acceptingParser =  do literal "primitive-type"; return StructureDefinitionKind_list_Primitive_type
                      `onFail` do literal "complex-type"; return StructureDefinitionKind_list_Complex_type
                      `onFail` do literal "resource"; return StructureDefinitionKind_list_Resource
                      `onFail` do literal "logical"; return StructureDefinitionKind_list_Logical
                      
    simpleTypeText StructureDefinitionKind_list_Primitive_type = "primitive-type"
    simpleTypeText StructureDefinitionKind_list_Complex_type = "complex-type"
    simpleTypeText StructureDefinitionKind_list_Resource = "resource"
    simpleTypeText StructureDefinitionKind_list_Logical = "logical"
 
data StructureDefinitionKind = StructureDefinitionKind
        { structureDefinitionKind_id :: Maybe String_primitive
        , structureDefinitionKind_value :: Maybe StructureDefinitionKind_list
        , structureDefinitionKind_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureDefinitionKind where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureDefinitionKind a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureDefinitionKind{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureDefinitionKind_id x
                       , maybe [] (toXMLAttribute "value") $ structureDefinitionKind_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureDefinitionKind_extension x
            ]
instance Extension StructureDefinitionKind Element where
    supertype (StructureDefinitionKind a0 a1 e0) =
               Element a0 e0
 
data TypeDerivationRule_list
    = TypeDerivationRule_list_Specialization
      -- ^ Specialization
    | TypeDerivationRule_list_Constraint
      -- ^ Constraint
    deriving (Eq,Show,Enum)
instance SchemaType TypeDerivationRule_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TypeDerivationRule_list where
    acceptingParser =  do literal "specialization"; return TypeDerivationRule_list_Specialization
                      `onFail` do literal "constraint"; return TypeDerivationRule_list_Constraint
                      
    simpleTypeText TypeDerivationRule_list_Specialization = "specialization"
    simpleTypeText TypeDerivationRule_list_Constraint = "constraint"
 
data TypeDerivationRule = TypeDerivationRule
        { typeDerivationRule_id :: Maybe String_primitive
        , typeDerivationRule_value :: Maybe TypeDerivationRule_list
        , typeDerivationRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TypeDerivationRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TypeDerivationRule a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TypeDerivationRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ typeDerivationRule_id x
                       , maybe [] (toXMLAttribute "value") $ typeDerivationRule_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ typeDerivationRule_extension x
            ]
instance Extension TypeDerivationRule Element where
    supertype (TypeDerivationRule a0 a1 e0) =
               Element a0 e0
 
data ExtensionContext_list
    = ExtensionContext_list_Resource
      -- ^ Resource
    | ExtensionContext_list_Datatype
      -- ^ Datatype
    | ExtensionContext_list_Extension
      -- ^ Extension
    deriving (Eq,Show,Enum)
instance SchemaType ExtensionContext_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ExtensionContext_list where
    acceptingParser =  do literal "resource"; return ExtensionContext_list_Resource
                      `onFail` do literal "datatype"; return ExtensionContext_list_Datatype
                      `onFail` do literal "extension"; return ExtensionContext_list_Extension
                      
    simpleTypeText ExtensionContext_list_Resource = "resource"
    simpleTypeText ExtensionContext_list_Datatype = "datatype"
    simpleTypeText ExtensionContext_list_Extension = "extension"
 
data ExtensionContext = ExtensionContext
        { extensionContext_id :: Maybe String_primitive
        , extensionContext_value :: Maybe ExtensionContext_list
        , extensionContext_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ExtensionContext where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ExtensionContext a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ExtensionContext{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ extensionContext_id x
                       , maybe [] (toXMLAttribute "value") $ extensionContext_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ extensionContext_extension x
            ]
instance Extension ExtensionContext Element where
    supertype (ExtensionContext a0 a1 e0) =
               Element a0 e0
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
elementStructureMap :: XMLParser StructureMap
elementStructureMap = parseSchemaType "StructureMap"
elementToXMLStructureMap :: StructureMap -> [Content ()]
elementToXMLStructureMap = schemaTypeToXML "StructureMap"
 
data StructureMap = StructureMap
        { structureMap_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , structureMap_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , structureMap_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , structureMap_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , structureMap_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , structureMap_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , structureMap_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMap_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMap_url :: Uri
          -- ^ An absolute URI that is used to identify this structure map 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this structure 
          --   map is (or will be) published. The URL SHOULD include the 
          --   major version of the structure map. For more information 
          --   see [Technical and Business 
          --   Versions](resource.html#versions).
        , structureMap_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this structure 
          --   map when it is represented in other formats, or referenced 
          --   in a specification, model, design or an instance.
        , structureMap_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   structure map when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the structure map author and is not expected to 
          --   be globally unique. For example, it might be a timestamp 
          --   (e.g. yyyymmdd) if a managed version is not available. 
          --   There is also no expectation that versions can be placed in 
          --   a lexicographical sequence.
        , structureMap_name :: Xsd.XsdString
          -- ^ A natural language name identifying the structure map. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , structureMap_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the structure 
          --   map.
        , structureMap_status :: PublicationStatus
          -- ^ The status of this structure map. Enables tracking the 
          --   life-cycle of the content.
        , structureMap_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this structure map is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , structureMap_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the structure map was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the structure map changes.
        , structureMap_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the structure map.
        , structureMap_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , structureMap_description :: Maybe Markdown
          -- ^ A free text natural language description of the structure 
          --   map from a consumer's perspective.
        , structureMap_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   structure map instances.
        , structureMap_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the structure map is 
          --   intended to be used.
        , structureMap_purpose :: Maybe Markdown
          -- ^ Explaination of why this structure map is needed and why it 
          --   has been designed as it has.
        , structureMap_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the structure map and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the structure 
          --   map.
        , structureMap_structure :: [StructureMapStructure]
          -- ^ A structure definition used by this map. The structure 
          --   definition may describe instances that are converted, or 
          --   the instances that are produced.
        , structureMap_import :: [Uri]
          -- ^ Other maps used by this map (canonical URLs).
        , structureMap_group :: [StructureMapGroup]
          -- ^ Organizes the mapping into managable chunks for human 
          --   review/ease of maintenance.
        }
        deriving (Eq,Show)
instance SchemaType StructureMap where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return StructureMap
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "structure")
            `apply` many (parseSchemaType "import")
            `apply` many1 (parseSchemaType "group")
    schemaTypeToXML s x@StructureMap{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ structureMap_id x
            , maybe [] (schemaTypeToXML "meta") $ structureMap_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ structureMap_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ structureMap_language x
            , maybe [] (schemaTypeToXML "text") $ structureMap_text x
            , concatMap (schemaTypeToXML "contained") $ structureMap_contained x
            , concatMap (schemaTypeToXML "extension") $ structureMap_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMap_modifierExtension x
            , schemaTypeToXML "url" $ structureMap_url x
            , concatMap (schemaTypeToXML "identifier") $ structureMap_identifier x
            , maybe [] (schemaTypeToXML "version") $ structureMap_version x
            , schemaTypeToXML "name" $ structureMap_name x
            , maybe [] (schemaTypeToXML "title") $ structureMap_title x
            , schemaTypeToXML "status" $ structureMap_status x
            , maybe [] (schemaTypeToXML "experimental") $ structureMap_experimental x
            , maybe [] (schemaTypeToXML "date") $ structureMap_date x
            , maybe [] (schemaTypeToXML "publisher") $ structureMap_publisher x
            , concatMap (schemaTypeToXML "contact") $ structureMap_contact x
            , maybe [] (schemaTypeToXML "description") $ structureMap_description x
            , concatMap (schemaTypeToXML "useContext") $ structureMap_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ structureMap_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ structureMap_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ structureMap_copyright x
            , concatMap (schemaTypeToXML "structure") $ structureMap_structure x
            , concatMap (schemaTypeToXML "import") $ structureMap_import x
            , concatMap (schemaTypeToXML "group") $ structureMap_group x
            ]
instance Extension StructureMap DomainResource where
    supertype (StructureMap e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension StructureMap Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: StructureMap -> DomainResource)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapStructure = StructureMapStructure
        { structureMapStructure_id :: Maybe String_primitive
        , structureMapStructure_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapStructure_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapStructure_url :: Uri
          -- ^ The canonical URL that identifies the structure.
        , structureMapStructure_mode :: StructureMapModelMode
          -- ^ How the referenced structure is used in this mapping.
        , structureMapStructure_alias :: Maybe Xsd.XsdString
          -- ^ The name used for this type in the map.
        , structureMapStructure_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation that describes how the structure is used in 
          --   the mapping.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapStructure where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapStructure a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "alias")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMapStructure{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapStructure_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapStructure_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapStructure_modifierExtension x
            , schemaTypeToXML "url" $ structureMapStructure_url x
            , schemaTypeToXML "mode" $ structureMapStructure_mode x
            , maybe [] (schemaTypeToXML "alias") $ structureMapStructure_alias x
            , maybe [] (schemaTypeToXML "documentation") $ structureMapStructure_documentation x
            ]
instance Extension StructureMapStructure BackboneElement where
    supertype (StructureMapStructure a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureMapStructure Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapStructure -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapGroup = StructureMapGroup
        { structureMapGroup_id :: Maybe String_primitive
        , structureMapGroup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapGroup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapGroup_name :: Id
          -- ^ A unique name for the group for the convenience of human 
          --   readers.
        , structureMapGroup_extends :: Maybe Id
          -- ^ Another group that this group adds rules to.
        , structureMapGroup_typeMode :: StructureMapGroupTypeMode
          -- ^ If this is the default rule set to apply for thie source 
          --   type, or this combination of types.
        , structureMapGroup_documentation :: Maybe Xsd.XsdString
          -- ^ Additional supporting documentation that explains the 
          --   purpose of the group and the types of mappings within it.
        , structureMapGroup_input :: [StructureMapInput]
          -- ^ A name assigned to an instance of data. The instance must 
          --   be provided when the mapping is invoked.
        , structureMapGroup_rule :: [StructureMapRule]
          -- ^ Transform Rule from source to target.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapGroup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapGroup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "extends")
            `apply` parseSchemaType "typeMode"
            `apply` optional (parseSchemaType "documentation")
            `apply` many1 (parseSchemaType "input")
            `apply` many1 (parseSchemaType "rule")
    schemaTypeToXML s x@StructureMapGroup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapGroup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapGroup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapGroup_modifierExtension x
            , schemaTypeToXML "name" $ structureMapGroup_name x
            , maybe [] (schemaTypeToXML "extends") $ structureMapGroup_extends x
            , schemaTypeToXML "typeMode" $ structureMapGroup_typeMode x
            , maybe [] (schemaTypeToXML "documentation") $ structureMapGroup_documentation x
            , concatMap (schemaTypeToXML "input") $ structureMapGroup_input x
            , concatMap (schemaTypeToXML "rule") $ structureMapGroup_rule x
            ]
instance Extension StructureMapGroup BackboneElement where
    supertype (StructureMapGroup a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension StructureMapGroup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapGroup -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapInput = StructureMapInput
        { structureMapInput_id :: Maybe String_primitive
        , structureMapInput_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapInput_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapInput_name :: Id
          -- ^ Name for this instance of data.
        , structureMapInput_type :: Maybe Xsd.XsdString
          -- ^ Type for this instance of data.
        , structureMapInput_mode :: StructureMapInputMode
          -- ^ Mode for this instance of data.
        , structureMapInput_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation for this instance of data.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapInput where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapInput a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "type")
            `apply` parseSchemaType "mode"
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMapInput{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapInput_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapInput_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapInput_modifierExtension x
            , schemaTypeToXML "name" $ structureMapInput_name x
            , maybe [] (schemaTypeToXML "type") $ structureMapInput_type x
            , schemaTypeToXML "mode" $ structureMapInput_mode x
            , maybe [] (schemaTypeToXML "documentation") $ structureMapInput_documentation x
            ]
instance Extension StructureMapInput BackboneElement where
    supertype (StructureMapInput a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension StructureMapInput Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapInput -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapRule = StructureMapRule
        { structureMapRule_id :: Maybe String_primitive
        , structureMapRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapRule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapRule_name :: Id
          -- ^ Name of the rule for internal references.
        , structureMapRule_source :: [StructureMapSource]
          -- ^ Source inputs to the mapping.
        , structureMapRule_target :: [StructureMapTarget]
          -- ^ Content to create because of this mapping rule.
        , structureMapRule_rule :: [StructureMapRule]
          -- ^ Rules contained in this rule.
        , structureMapRule_dependent :: [StructureMapDependent]
          -- ^ Which other rules to apply in the context of this rule.
        , structureMapRule_documentation :: Maybe Xsd.XsdString
          -- ^ Documentation for this instance of data.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapRule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` many1 (parseSchemaType "source")
            `apply` many (parseSchemaType "target")
            `apply` many (parseSchemaType "rule")
            `apply` many (parseSchemaType "dependent")
            `apply` optional (parseSchemaType "documentation")
    schemaTypeToXML s x@StructureMapRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapRule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapRule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapRule_modifierExtension x
            , schemaTypeToXML "name" $ structureMapRule_name x
            , concatMap (schemaTypeToXML "source") $ structureMapRule_source x
            , concatMap (schemaTypeToXML "target") $ structureMapRule_target x
            , concatMap (schemaTypeToXML "rule") $ structureMapRule_rule x
            , concatMap (schemaTypeToXML "dependent") $ structureMapRule_dependent x
            , maybe [] (schemaTypeToXML "documentation") $ structureMapRule_documentation x
            ]
instance Extension StructureMapRule BackboneElement where
    supertype (StructureMapRule a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension StructureMapRule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapRule -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapSource = StructureMapSource
        { structureMapSource_id :: Maybe String_primitive
        , structureMapSource_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapSource_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapSource_context :: Id
          -- ^ Type or variable this rule applies to.
        , structureMapSource_min :: Maybe Integer
          -- ^ Specified minimum cardinality for the element. This is 
          --   optional; if present, it acts an implicit check on the 
          --   input content.
        , structureMapSource_max :: Maybe Xsd.XsdString
          -- ^ Specified maximum cardinality for the element - a number or 
          --   a &quot;*&quot;. This is optional; if present, it acts an 
          --   implicit check on the input content (* just serves as 
          --   documentation; it's the default value).
        , structureMapSource_type :: Maybe Xsd.XsdString
          -- ^ Specified type for the element. This works as a condition 
          --   on the mapping - use for polymorphic elements.
        , structureMapSource_choice6 :: (Maybe (OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta))
          -- ^ A value to use if there is no existing value in the source 
          --   object.
          --   
          --   Choice between:
          --   
          --   (1) defaultValueBase64Binary
          --   
          --   (2) defaultValueBoolean
          --   
          --   (3) defaultValueCode
          --   
          --   (4) defaultValueDate
          --   
          --   (5) defaultValueDateTime
          --   
          --   (6) defaultValueDecimal
          --   
          --   (7) defaultValueId
          --   
          --   (8) defaultValueInstant
          --   
          --   (9) defaultValueInteger
          --   
          --   (10) defaultValueMarkdown
          --   
          --   (11) defaultValueOid
          --   
          --   (12) defaultValuePositiveInt
          --   
          --   (13) defaultValueString
          --   
          --   (14) defaultValueTime
          --   
          --   (15) defaultValueUnsignedInt
          --   
          --   (16) defaultValueUri
          --   
          --   (17) defaultValueAddress
          --   
          --   (18) defaultValueAge
          --   
          --   (19) defaultValueAnnotation
          --   
          --   (20) defaultValueAttachment
          --   
          --   (21) defaultValueCodeableConcept
          --   
          --   (22) defaultValueCoding
          --   
          --   (23) defaultValueContactPoint
          --   
          --   (24) defaultValueCount
          --   
          --   (25) defaultValueDistance
          --   
          --   (26) defaultValueDuration
          --   
          --   (27) defaultValueHumanName
          --   
          --   (28) defaultValueIdentifier
          --   
          --   (29) defaultValueMoney
          --   
          --   (30) defaultValuePeriod
          --   
          --   (31) defaultValueQuantity
          --   
          --   (32) defaultValueRange
          --   
          --   (33) defaultValueRatio
          --   
          --   (34) defaultValueReference
          --   
          --   (35) defaultValueSampledData
          --   
          --   (36) defaultValueSignature
          --   
          --   (37) defaultValueTiming
          --   
          --   (38) defaultValueMeta
        , structureMapSource_element :: Maybe Xsd.XsdString
          -- ^ Optional field for this source.
        , structureMapSource_listMode :: Maybe StructureMapSourceListMode
          -- ^ How to handle the list mode for this element.
        , structureMapSource_variable :: Maybe Id
          -- ^ Named context for field, if a field is specified.
        , structureMapSource_condition :: Maybe Xsd.XsdString
          -- ^ FHIRPath expression - must be true or the rule does not 
          --   apply.
        , structureMapSource_check :: Maybe Xsd.XsdString
          -- ^ FHIRPath expression - must be true or the mapping engine 
          --   throws an error instead of completing.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapSource where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapSource a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "context"
            `apply` optional (parseSchemaType "min")
            `apply` optional (parseSchemaType "max")
            `apply` optional (parseSchemaType "type")
            `apply` optional (oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "defaultValueBase64Binary"))
                                     , ("Boolean", fmap TwoOf38 (parseSchemaType "defaultValueBoolean"))
                                     , ("Code", fmap ThreeOf38 (parseSchemaType "defaultValueCode"))
                                     , ("Date", fmap FourOf38 (parseSchemaType "defaultValueDate"))
                                     , ("DateTime", fmap FiveOf38 (parseSchemaType "defaultValueDateTime"))
                                     , ("Decimal", fmap SixOf38 (parseSchemaType "defaultValueDecimal"))
                                     , ("Id", fmap SevenOf38 (parseSchemaType "defaultValueId"))
                                     , ("Instant", fmap EightOf38 (parseSchemaType "defaultValueInstant"))
                                     , ("Integer", fmap NineOf38 (parseSchemaType "defaultValueInteger"))
                                     , ("Markdown", fmap TenOf38 (parseSchemaType "defaultValueMarkdown"))
                                     , ("Oid", fmap ElevenOf38 (parseSchemaType "defaultValueOid"))
                                     , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "defaultValuePositiveInt"))
                                     , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "defaultValueString"))
                                     , ("Time", fmap FourteenOf38 (parseSchemaType "defaultValueTime"))
                                     , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "defaultValueUnsignedInt"))
                                     , ("Uri", fmap SixteenOf38 (parseSchemaType "defaultValueUri"))
                                     , ("Address", fmap SeventeenOf38 (parseSchemaType "defaultValueAddress"))
                                     , ("Age", fmap EighteenOf38 (parseSchemaType "defaultValueAge"))
                                     , ("Annotation", fmap NineteenOf38 (parseSchemaType "defaultValueAnnotation"))
                                     , ("Attachment", fmap TwentyOf38 (parseSchemaType "defaultValueAttachment"))
                                     , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "defaultValueCodeableConcept"))
                                     , ("Coding", fmap Choice22Of38 (parseSchemaType "defaultValueCoding"))
                                     , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "defaultValueContactPoint"))
                                     , ("Count", fmap Choice24Of38 (parseSchemaType "defaultValueCount"))
                                     , ("Distance", fmap Choice25Of38 (parseSchemaType "defaultValueDistance"))
                                     , ("Duration", fmap Choice26Of38 (parseSchemaType "defaultValueDuration"))
                                     , ("HumanName", fmap Choice27Of38 (parseSchemaType "defaultValueHumanName"))
                                     , ("Identifier", fmap Choice28Of38 (parseSchemaType "defaultValueIdentifier"))
                                     , ("Money", fmap Choice29Of38 (parseSchemaType "defaultValueMoney"))
                                     , ("Period", fmap Choice30Of38 (parseSchemaType "defaultValuePeriod"))
                                     , ("Quantity", fmap Choice31Of38 (parseSchemaType "defaultValueQuantity"))
                                     , ("Range", fmap Choice32Of38 (parseSchemaType "defaultValueRange"))
                                     , ("Ratio", fmap Choice33Of38 (parseSchemaType "defaultValueRatio"))
                                     , ("Reference", fmap Choice34Of38 (parseSchemaType "defaultValueReference"))
                                     , ("SampledData", fmap Choice35Of38 (parseSchemaType "defaultValueSampledData"))
                                     , ("Signature", fmap Choice36Of38 (parseSchemaType "defaultValueSignature"))
                                     , ("Timing", fmap Choice37Of38 (parseSchemaType "defaultValueTiming"))
                                     , ("Meta", fmap Choice38Of38 (parseSchemaType "defaultValueMeta"))
                                     ])
            `apply` optional (parseSchemaType "element")
            `apply` optional (parseSchemaType "listMode")
            `apply` optional (parseSchemaType "variable")
            `apply` optional (parseSchemaType "condition")
            `apply` optional (parseSchemaType "check")
    schemaTypeToXML s x@StructureMapSource{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapSource_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapSource_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapSource_modifierExtension x
            , schemaTypeToXML "context" $ structureMapSource_context x
            , maybe [] (schemaTypeToXML "min") $ structureMapSource_min x
            , maybe [] (schemaTypeToXML "max") $ structureMapSource_max x
            , maybe [] (schemaTypeToXML "type") $ structureMapSource_type x
            , maybe [] (foldOneOf38  (schemaTypeToXML "defaultValueBase64Binary")
                                     (schemaTypeToXML "defaultValueBoolean")
                                     (schemaTypeToXML "defaultValueCode")
                                     (schemaTypeToXML "defaultValueDate")
                                     (schemaTypeToXML "defaultValueDateTime")
                                     (schemaTypeToXML "defaultValueDecimal")
                                     (schemaTypeToXML "defaultValueId")
                                     (schemaTypeToXML "defaultValueInstant")
                                     (schemaTypeToXML "defaultValueInteger")
                                     (schemaTypeToXML "defaultValueMarkdown")
                                     (schemaTypeToXML "defaultValueOid")
                                     (schemaTypeToXML "defaultValuePositiveInt")
                                     (schemaTypeToXML "defaultValueString")
                                     (schemaTypeToXML "defaultValueTime")
                                     (schemaTypeToXML "defaultValueUnsignedInt")
                                     (schemaTypeToXML "defaultValueUri")
                                     (schemaTypeToXML "defaultValueAddress")
                                     (schemaTypeToXML "defaultValueAge")
                                     (schemaTypeToXML "defaultValueAnnotation")
                                     (schemaTypeToXML "defaultValueAttachment")
                                     (schemaTypeToXML "defaultValueCodeableConcept")
                                     (schemaTypeToXML "defaultValueCoding")
                                     (schemaTypeToXML "defaultValueContactPoint")
                                     (schemaTypeToXML "defaultValueCount")
                                     (schemaTypeToXML "defaultValueDistance")
                                     (schemaTypeToXML "defaultValueDuration")
                                     (schemaTypeToXML "defaultValueHumanName")
                                     (schemaTypeToXML "defaultValueIdentifier")
                                     (schemaTypeToXML "defaultValueMoney")
                                     (schemaTypeToXML "defaultValuePeriod")
                                     (schemaTypeToXML "defaultValueQuantity")
                                     (schemaTypeToXML "defaultValueRange")
                                     (schemaTypeToXML "defaultValueRatio")
                                     (schemaTypeToXML "defaultValueReference")
                                     (schemaTypeToXML "defaultValueSampledData")
                                     (schemaTypeToXML "defaultValueSignature")
                                     (schemaTypeToXML "defaultValueTiming")
                                     (schemaTypeToXML "defaultValueMeta")
                                    ) $ structureMapSource_choice6 x
            , maybe [] (schemaTypeToXML "element") $ structureMapSource_element x
            , maybe [] (schemaTypeToXML "listMode") $ structureMapSource_listMode x
            , maybe [] (schemaTypeToXML "variable") $ structureMapSource_variable x
            , maybe [] (schemaTypeToXML "condition") $ structureMapSource_condition x
            , maybe [] (schemaTypeToXML "check") $ structureMapSource_check x
            ]
instance Extension StructureMapSource BackboneElement where
    supertype (StructureMapSource a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11) =
               BackboneElement a0 e0 e1
instance Extension StructureMapSource Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapSource -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapTarget = StructureMapTarget
        { structureMapTarget_id :: Maybe String_primitive
        , structureMapTarget_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapTarget_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapTarget_context :: Maybe Id
          -- ^ Type or variable this rule applies to.
        , structureMapTarget_contextType :: Maybe StructureMapContextType
          -- ^ How to interpret the context.
        , structureMapTarget_element :: Maybe Xsd.XsdString
          -- ^ Field to create in the context.
        , structureMapTarget_variable :: Maybe Id
          -- ^ Named context for field, if desired, and a field is 
          --   specified.
        , structureMapTarget_listMode :: [StructureMapTargetListMode]
          -- ^ If field is a list, how to manage the list.
        , structureMapTarget_listRuleId :: Maybe Id
          -- ^ Internal rule reference for shared list items.
        , structureMapTarget_transform :: Maybe StructureMapTransform
          -- ^ How the data is copied / created.
        , structureMapTarget_parameter :: [StructureMapParameter]
          -- ^ Parameters to the transform.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapTarget where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapTarget a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "contextType")
            `apply` optional (parseSchemaType "element")
            `apply` optional (parseSchemaType "variable")
            `apply` many (parseSchemaType "listMode")
            `apply` optional (parseSchemaType "listRuleId")
            `apply` optional (parseSchemaType "transform")
            `apply` many (parseSchemaType "parameter")
    schemaTypeToXML s x@StructureMapTarget{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapTarget_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapTarget_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapTarget_modifierExtension x
            , maybe [] (schemaTypeToXML "context") $ structureMapTarget_context x
            , maybe [] (schemaTypeToXML "contextType") $ structureMapTarget_contextType x
            , maybe [] (schemaTypeToXML "element") $ structureMapTarget_element x
            , maybe [] (schemaTypeToXML "variable") $ structureMapTarget_variable x
            , concatMap (schemaTypeToXML "listMode") $ structureMapTarget_listMode x
            , maybe [] (schemaTypeToXML "listRuleId") $ structureMapTarget_listRuleId x
            , maybe [] (schemaTypeToXML "transform") $ structureMapTarget_transform x
            , concatMap (schemaTypeToXML "parameter") $ structureMapTarget_parameter x
            ]
instance Extension StructureMapTarget BackboneElement where
    supertype (StructureMapTarget a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension StructureMapTarget Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapTarget -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapParameter = StructureMapParameter
        { structureMapParameter_id :: Maybe String_primitive
        , structureMapParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapParameter_choice2 :: OneOf5 Id Xsd.XsdString Boolean Integer Decimal
          -- ^ Parameter value - variable or literal.
          --   
          --   Choice between:
          --   
          --   (1) valueId
          --   
          --   (2) valueString
          --   
          --   (3) valueBoolean
          --   
          --   (4) valueInteger
          --   
          --   (5) valueDecimal
        }
        deriving (Eq,Show)
instance SchemaType StructureMapParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapParameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` oneOf' [ ("Id", fmap OneOf5 (parseSchemaType "valueId"))
                           , ("Xsd.XsdString", fmap TwoOf5 (parseSchemaType "valueString"))
                           , ("Boolean", fmap ThreeOf5 (parseSchemaType "valueBoolean"))
                           , ("Integer", fmap FourOf5 (parseSchemaType "valueInteger"))
                           , ("Decimal", fmap FiveOf5 (parseSchemaType "valueDecimal"))
                           ]
    schemaTypeToXML s x@StructureMapParameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapParameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapParameter_modifierExtension x
            , foldOneOf5  (schemaTypeToXML "valueId")
                          (schemaTypeToXML "valueString")
                          (schemaTypeToXML "valueBoolean")
                          (schemaTypeToXML "valueInteger")
                          (schemaTypeToXML "valueDecimal")
                          $ structureMapParameter_choice2 x
            ]
instance Extension StructureMapParameter BackboneElement where
    supertype (StructureMapParameter a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension StructureMapParameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapParameter -> BackboneElement)
              
 
-- | A Map of relationships between 2 structures that can be 
--   used to transform data.
data StructureMapDependent = StructureMapDependent
        { structureMapDependent_id :: Maybe String_primitive
        , structureMapDependent_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , structureMapDependent_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , structureMapDependent_name :: Id
          -- ^ Name of a rule or group to apply.
        , structureMapDependent_variable :: [Xsd.XsdString]
          -- ^ Variable to pass to the rule or group.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapDependent where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (StructureMapDependent a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` many1 (parseSchemaType "variable")
    schemaTypeToXML s x@StructureMapDependent{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapDependent_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapDependent_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ structureMapDependent_modifierExtension x
            , schemaTypeToXML "name" $ structureMapDependent_name x
            , concatMap (schemaTypeToXML "variable") $ structureMapDependent_variable x
            ]
instance Extension StructureMapDependent BackboneElement where
    supertype (StructureMapDependent a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension StructureMapDependent Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: StructureMapDependent -> BackboneElement)
              
 
data StructureMapInputMode_list
    = StructureMapInputMode_list_Source
      -- ^ Source Instance
    | StructureMapInputMode_list_Target
      -- ^ Target Instance
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapInputMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapInputMode_list where
    acceptingParser =  do literal "source"; return StructureMapInputMode_list_Source
                      `onFail` do literal "target"; return StructureMapInputMode_list_Target
                      
    simpleTypeText StructureMapInputMode_list_Source = "source"
    simpleTypeText StructureMapInputMode_list_Target = "target"
 
data StructureMapInputMode = StructureMapInputMode
        { structureMapInputMode_id :: Maybe String_primitive
        , structureMapInputMode_value :: Maybe StructureMapInputMode_list
        , structureMapInputMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapInputMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapInputMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapInputMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapInputMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapInputMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapInputMode_extension x
            ]
instance Extension StructureMapInputMode Element where
    supertype (StructureMapInputMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapContextType_list
    = StructureMapContextType_list_Type
      -- ^ Type
    | StructureMapContextType_list_Variable
      -- ^ Variable
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapContextType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapContextType_list where
    acceptingParser =  do literal "type"; return StructureMapContextType_list_Type
                      `onFail` do literal "variable"; return StructureMapContextType_list_Variable
                      
    simpleTypeText StructureMapContextType_list_Type = "type"
    simpleTypeText StructureMapContextType_list_Variable = "variable"
 
data StructureMapContextType = StructureMapContextType
        { structureMapContextType_id :: Maybe String_primitive
        , structureMapContextType_value :: Maybe StructureMapContextType_list
        , structureMapContextType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapContextType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapContextType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapContextType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapContextType_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapContextType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapContextType_extension x
            ]
instance Extension StructureMapContextType Element where
    supertype (StructureMapContextType a0 a1 e0) =
               Element a0 e0
 
data StructureMapTargetListMode_list
    = StructureMapTargetListMode_list_First
      -- ^ First
    | StructureMapTargetListMode_list_Share
      -- ^ Share
    | StructureMapTargetListMode_list_Last
      -- ^ Last
    | StructureMapTargetListMode_list_Collate
      -- ^ Collate
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapTargetListMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapTargetListMode_list where
    acceptingParser =  do literal "first"; return StructureMapTargetListMode_list_First
                      `onFail` do literal "share"; return StructureMapTargetListMode_list_Share
                      `onFail` do literal "last"; return StructureMapTargetListMode_list_Last
                      `onFail` do literal "collate"; return StructureMapTargetListMode_list_Collate
                      
    simpleTypeText StructureMapTargetListMode_list_First = "first"
    simpleTypeText StructureMapTargetListMode_list_Share = "share"
    simpleTypeText StructureMapTargetListMode_list_Last = "last"
    simpleTypeText StructureMapTargetListMode_list_Collate = "collate"
 
data StructureMapTargetListMode = StructureMapTargetListMode
        { structureMapTargetListMode_id :: Maybe String_primitive
        , structureMapTargetListMode_value :: Maybe StructureMapTargetListMode_list
        , structureMapTargetListMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapTargetListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapTargetListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapTargetListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapTargetListMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapTargetListMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapTargetListMode_extension x
            ]
instance Extension StructureMapTargetListMode Element where
    supertype (StructureMapTargetListMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapTransform_list
    = StructureMapTransform_list_Create
      -- ^ create
    | StructureMapTransform_list_Copy
      -- ^ copy
    | StructureMapTransform_list_Truncate
      -- ^ truncate
    | StructureMapTransform_list_Escape
      -- ^ escape
    | StructureMapTransform_list_Cast
      -- ^ cast
    | StructureMapTransform_list_Append
      -- ^ append
    | StructureMapTransform_list_Translate
      -- ^ translate
    | StructureMapTransform_list_Reference
      -- ^ reference
    | StructureMapTransform_list_DateOp
      -- ^ dateOp
    | StructureMapTransform_list_Uuid
      -- ^ uuid
    | StructureMapTransform_list_Pointer
      -- ^ pointer
    | StructureMapTransform_list_Evaluate
      -- ^ evaluate
    | StructureMapTransform_list_Cc
      -- ^ cc
    | StructureMapTransform_list_C
      -- ^ c
    | StructureMapTransform_list_Qty
      -- ^ qty
    | StructureMapTransform_list_Id
      -- ^ id
    | StructureMapTransform_list_Cp
      -- ^ cp
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapTransform_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapTransform_list where
    acceptingParser =  do literal "create"; return StructureMapTransform_list_Create
                      `onFail` do literal "copy"; return StructureMapTransform_list_Copy
                      `onFail` do literal "truncate"; return StructureMapTransform_list_Truncate
                      `onFail` do literal "escape"; return StructureMapTransform_list_Escape
                      `onFail` do literal "cast"; return StructureMapTransform_list_Cast
                      `onFail` do literal "append"; return StructureMapTransform_list_Append
                      `onFail` do literal "translate"; return StructureMapTransform_list_Translate
                      `onFail` do literal "reference"; return StructureMapTransform_list_Reference
                      `onFail` do literal "dateOp"; return StructureMapTransform_list_DateOp
                      `onFail` do literal "uuid"; return StructureMapTransform_list_Uuid
                      `onFail` do literal "pointer"; return StructureMapTransform_list_Pointer
                      `onFail` do literal "evaluate"; return StructureMapTransform_list_Evaluate
                      `onFail` do literal "cc"; return StructureMapTransform_list_Cc
                      `onFail` do literal "c"; return StructureMapTransform_list_C
                      `onFail` do literal "qty"; return StructureMapTransform_list_Qty
                      `onFail` do literal "id"; return StructureMapTransform_list_Id
                      `onFail` do literal "cp"; return StructureMapTransform_list_Cp
                      
    simpleTypeText StructureMapTransform_list_Create = "create"
    simpleTypeText StructureMapTransform_list_Copy = "copy"
    simpleTypeText StructureMapTransform_list_Truncate = "truncate"
    simpleTypeText StructureMapTransform_list_Escape = "escape"
    simpleTypeText StructureMapTransform_list_Cast = "cast"
    simpleTypeText StructureMapTransform_list_Append = "append"
    simpleTypeText StructureMapTransform_list_Translate = "translate"
    simpleTypeText StructureMapTransform_list_Reference = "reference"
    simpleTypeText StructureMapTransform_list_DateOp = "dateOp"
    simpleTypeText StructureMapTransform_list_Uuid = "uuid"
    simpleTypeText StructureMapTransform_list_Pointer = "pointer"
    simpleTypeText StructureMapTransform_list_Evaluate = "evaluate"
    simpleTypeText StructureMapTransform_list_Cc = "cc"
    simpleTypeText StructureMapTransform_list_C = "c"
    simpleTypeText StructureMapTransform_list_Qty = "qty"
    simpleTypeText StructureMapTransform_list_Id = "id"
    simpleTypeText StructureMapTransform_list_Cp = "cp"
 
data StructureMapTransform = StructureMapTransform
        { structureMapTransform_id :: Maybe String_primitive
        , structureMapTransform_value :: Maybe StructureMapTransform_list
        , structureMapTransform_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapTransform where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapTransform a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapTransform{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapTransform_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapTransform_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapTransform_extension x
            ]
instance Extension StructureMapTransform Element where
    supertype (StructureMapTransform a0 a1 e0) =
               Element a0 e0
 
data StructureMapSourceListMode_list
    = StructureMapSourceListMode_list_First
      -- ^ First
    | StructureMapSourceListMode_list_Not_first
      -- ^ All but the first
    | StructureMapSourceListMode_list_Last
      -- ^ Last
    | StructureMapSourceListMode_list_Not_last
      -- ^ All but the last
    | StructureMapSourceListMode_list_Only_one
      -- ^ Enforce only one
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapSourceListMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapSourceListMode_list where
    acceptingParser =  do literal "first"; return StructureMapSourceListMode_list_First
                      `onFail` do literal "not_first"; return StructureMapSourceListMode_list_Not_first
                      `onFail` do literal "last"; return StructureMapSourceListMode_list_Last
                      `onFail` do literal "not_last"; return StructureMapSourceListMode_list_Not_last
                      `onFail` do literal "only_one"; return StructureMapSourceListMode_list_Only_one
                      
    simpleTypeText StructureMapSourceListMode_list_First = "first"
    simpleTypeText StructureMapSourceListMode_list_Not_first = "not_first"
    simpleTypeText StructureMapSourceListMode_list_Last = "last"
    simpleTypeText StructureMapSourceListMode_list_Not_last = "not_last"
    simpleTypeText StructureMapSourceListMode_list_Only_one = "only_one"
 
data StructureMapSourceListMode = StructureMapSourceListMode
        { structureMapSourceListMode_id :: Maybe String_primitive
        , structureMapSourceListMode_value :: Maybe StructureMapSourceListMode_list
        , structureMapSourceListMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapSourceListMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapSourceListMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapSourceListMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapSourceListMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapSourceListMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapSourceListMode_extension x
            ]
instance Extension StructureMapSourceListMode Element where
    supertype (StructureMapSourceListMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapGroupTypeMode_list
    = StructureMapGroupTypeMode_list_None
      -- ^ Not a Default
    | StructureMapGroupTypeMode_list_Types
      -- ^ Default for Type Combination
    | StructureMapGroupTypeMode_list_Type_and_types
      -- ^ Default for type + combination
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapGroupTypeMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapGroupTypeMode_list where
    acceptingParser =  do literal "none"; return StructureMapGroupTypeMode_list_None
                      `onFail` do literal "types"; return StructureMapGroupTypeMode_list_Types
                      `onFail` do literal "type-and-types"; return StructureMapGroupTypeMode_list_Type_and_types
                      
    simpleTypeText StructureMapGroupTypeMode_list_None = "none"
    simpleTypeText StructureMapGroupTypeMode_list_Types = "types"
    simpleTypeText StructureMapGroupTypeMode_list_Type_and_types = "type-and-types"
 
data StructureMapGroupTypeMode = StructureMapGroupTypeMode
        { structureMapGroupTypeMode_id :: Maybe String_primitive
        , structureMapGroupTypeMode_value :: Maybe StructureMapGroupTypeMode_list
        , structureMapGroupTypeMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapGroupTypeMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapGroupTypeMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapGroupTypeMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapGroupTypeMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapGroupTypeMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapGroupTypeMode_extension x
            ]
instance Extension StructureMapGroupTypeMode Element where
    supertype (StructureMapGroupTypeMode a0 a1 e0) =
               Element a0 e0
 
data StructureMapModelMode_list
    = StructureMapModelMode_list_Source
      -- ^ Source Structure Definition
    | StructureMapModelMode_list_Queried
      -- ^ Queried Structure Definition
    | StructureMapModelMode_list_Target
      -- ^ Target Structure Definition
    | StructureMapModelMode_list_Produced
      -- ^ Produced Structure Definition
    deriving (Eq,Show,Enum)
instance SchemaType StructureMapModelMode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType StructureMapModelMode_list where
    acceptingParser =  do literal "source"; return StructureMapModelMode_list_Source
                      `onFail` do literal "queried"; return StructureMapModelMode_list_Queried
                      `onFail` do literal "target"; return StructureMapModelMode_list_Target
                      `onFail` do literal "produced"; return StructureMapModelMode_list_Produced
                      
    simpleTypeText StructureMapModelMode_list_Source = "source"
    simpleTypeText StructureMapModelMode_list_Queried = "queried"
    simpleTypeText StructureMapModelMode_list_Target = "target"
    simpleTypeText StructureMapModelMode_list_Produced = "produced"
 
data StructureMapModelMode = StructureMapModelMode
        { structureMapModelMode_id :: Maybe String_primitive
        , structureMapModelMode_value :: Maybe StructureMapModelMode_list
        , structureMapModelMode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType StructureMapModelMode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (StructureMapModelMode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@StructureMapModelMode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ structureMapModelMode_id x
                       , maybe [] (toXMLAttribute "value") $ structureMapModelMode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ structureMapModelMode_extension x
            ]
instance Extension StructureMapModelMode Element where
    supertype (StructureMapModelMode a0 a1 e0) =
               Element a0 e0
 
-- | The subscription resource is used to define a push based 
--   subscription from a server to another system. Once a 
--   subscription is registered with the server, the server 
--   checks every resource that is created or updated, and if 
--   the resource matches the given criteria, it sends a message 
--   on the defined &quot;channel&quot; so that another system 
--   is able to take an appropriate action.
elementSubscription :: XMLParser Subscription
elementSubscription = parseSchemaType "Subscription"
elementToXMLSubscription :: Subscription -> [Content ()]
elementToXMLSubscription = schemaTypeToXML "Subscription"
 
data Subscription = Subscription
        { subscription_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , subscription_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , subscription_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , subscription_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , subscription_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , subscription_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , subscription_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , subscription_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , subscription_status :: SubscriptionStatus
          -- ^ The status of the subscription, which marks the server 
          --   state for managing the subscription.
        , subscription_contact :: [ContactPoint]
          -- ^ Contact details for a human to contact about the 
          --   subscription. The primary use of this for system 
          --   administrator troubleshooting.
        , subscription_end :: Maybe Instant
          -- ^ The time for the server to turn the subscription off.
        , subscription_reason :: Xsd.XsdString
          -- ^ A description of why this subscription is defined.
        , subscription_criteria :: Xsd.XsdString
          -- ^ The rules that the server should use to determine when to 
          --   generate notifications for this subscription.
        , subscription_error :: Maybe Xsd.XsdString
          -- ^ A record of the last error that occurred when the server 
          --   processed a notification.
        , subscription_channel :: SubscriptionChannel
          -- ^ Details where to send notifications when resources are 
          --   received that meet the criteria.
        , subscription_tag :: [Coding]
          -- ^ A tag to add to any resource that matches the criteria, 
          --   after the subscription is processed.
        }
        deriving (Eq,Show)
instance SchemaType Subscription where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Subscription
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "status"
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "end")
            `apply` parseSchemaType "reason"
            `apply` parseSchemaType "criteria"
            `apply` optional (parseSchemaType "error")
            `apply` parseSchemaType "channel"
            `apply` many (parseSchemaType "tag")
    schemaTypeToXML s x@Subscription{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ subscription_id x
            , maybe [] (schemaTypeToXML "meta") $ subscription_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ subscription_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ subscription_language x
            , maybe [] (schemaTypeToXML "text") $ subscription_text x
            , concatMap (schemaTypeToXML "contained") $ subscription_contained x
            , concatMap (schemaTypeToXML "extension") $ subscription_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ subscription_modifierExtension x
            , schemaTypeToXML "status" $ subscription_status x
            , concatMap (schemaTypeToXML "contact") $ subscription_contact x
            , maybe [] (schemaTypeToXML "end") $ subscription_end x
            , schemaTypeToXML "reason" $ subscription_reason x
            , schemaTypeToXML "criteria" $ subscription_criteria x
            , maybe [] (schemaTypeToXML "error") $ subscription_error x
            , schemaTypeToXML "channel" $ subscription_channel x
            , concatMap (schemaTypeToXML "tag") $ subscription_tag x
            ]
instance Extension Subscription DomainResource where
    supertype (Subscription e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Subscription Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Subscription -> DomainResource)
              
 
-- | The subscription resource is used to define a push based 
--   subscription from a server to another system. Once a 
--   subscription is registered with the server, the server 
--   checks every resource that is created or updated, and if 
--   the resource matches the given criteria, it sends a message 
--   on the defined &quot;channel&quot; so that another system 
--   is able to take an appropriate action.
data SubscriptionChannel = SubscriptionChannel
        { subscriptionChannel_id :: Maybe String_primitive
        , subscriptionChannel_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , subscriptionChannel_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , subscriptionChannel_type :: SubscriptionChannelType
          -- ^ The type of channel to send notifications on.
        , subscriptionChannel_endpoint :: Maybe Uri
          -- ^ The uri that describes the actual end-point to send 
          --   messages to.
        , subscriptionChannel_payload :: Maybe Xsd.XsdString
          -- ^ The mime type to send the payload in - either 
          --   application/fhir+xml, or application/fhir+json. If the 
          --   payload is not present, then there is no payload in the 
          --   notification, just a notification.
        , subscriptionChannel_header :: [Xsd.XsdString]
          -- ^ Additional headers / information to send as part of the 
          --   notification.
        }
        deriving (Eq,Show)
instance SchemaType SubscriptionChannel where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SubscriptionChannel a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` optional (parseSchemaType "endpoint")
            `apply` optional (parseSchemaType "payload")
            `apply` many (parseSchemaType "header")
    schemaTypeToXML s x@SubscriptionChannel{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscriptionChannel_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscriptionChannel_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ subscriptionChannel_modifierExtension x
            , schemaTypeToXML "type" $ subscriptionChannel_type x
            , maybe [] (schemaTypeToXML "endpoint") $ subscriptionChannel_endpoint x
            , maybe [] (schemaTypeToXML "payload") $ subscriptionChannel_payload x
            , concatMap (schemaTypeToXML "header") $ subscriptionChannel_header x
            ]
instance Extension SubscriptionChannel BackboneElement where
    supertype (SubscriptionChannel a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension SubscriptionChannel Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SubscriptionChannel -> BackboneElement)
              
 
data SubscriptionStatus_list
    = SubscriptionStatus_list_Requested
      -- ^ Requested
    | SubscriptionStatus_list_Active
      -- ^ Active
    | SubscriptionStatus_list_Error
      -- ^ Error
    | SubscriptionStatus_list_Off
      -- ^ Off
    deriving (Eq,Show,Enum)
instance SchemaType SubscriptionStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SubscriptionStatus_list where
    acceptingParser =  do literal "requested"; return SubscriptionStatus_list_Requested
                      `onFail` do literal "active"; return SubscriptionStatus_list_Active
                      `onFail` do literal "error"; return SubscriptionStatus_list_Error
                      `onFail` do literal "off"; return SubscriptionStatus_list_Off
                      
    simpleTypeText SubscriptionStatus_list_Requested = "requested"
    simpleTypeText SubscriptionStatus_list_Active = "active"
    simpleTypeText SubscriptionStatus_list_Error = "error"
    simpleTypeText SubscriptionStatus_list_Off = "off"
 
data SubscriptionStatus = SubscriptionStatus
        { subscriptionStatus_id :: Maybe String_primitive
        , subscriptionStatus_value :: Maybe SubscriptionStatus_list
        , subscriptionStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SubscriptionStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SubscriptionStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SubscriptionStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscriptionStatus_id x
                       , maybe [] (toXMLAttribute "value") $ subscriptionStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscriptionStatus_extension x
            ]
instance Extension SubscriptionStatus Element where
    supertype (SubscriptionStatus a0 a1 e0) =
               Element a0 e0
 
data SubscriptionChannelType_list
    = SubscriptionChannelType_list_Rest_hook
      -- ^ Rest Hook
    | SubscriptionChannelType_list_Websocket
      -- ^ Websocket
    | SubscriptionChannelType_list_Email
      -- ^ Email
    | SubscriptionChannelType_list_Sms
      -- ^ SMS
    | SubscriptionChannelType_list_Message
      -- ^ Message
    deriving (Eq,Show,Enum)
instance SchemaType SubscriptionChannelType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SubscriptionChannelType_list where
    acceptingParser =  do literal "rest-hook"; return SubscriptionChannelType_list_Rest_hook
                      `onFail` do literal "websocket"; return SubscriptionChannelType_list_Websocket
                      `onFail` do literal "email"; return SubscriptionChannelType_list_Email
                      `onFail` do literal "sms"; return SubscriptionChannelType_list_Sms
                      `onFail` do literal "message"; return SubscriptionChannelType_list_Message
                      
    simpleTypeText SubscriptionChannelType_list_Rest_hook = "rest-hook"
    simpleTypeText SubscriptionChannelType_list_Websocket = "websocket"
    simpleTypeText SubscriptionChannelType_list_Email = "email"
    simpleTypeText SubscriptionChannelType_list_Sms = "sms"
    simpleTypeText SubscriptionChannelType_list_Message = "message"
 
data SubscriptionChannelType = SubscriptionChannelType
        { subscriptionChannelType_id :: Maybe String_primitive
        , subscriptionChannelType_value :: Maybe SubscriptionChannelType_list
        , subscriptionChannelType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SubscriptionChannelType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SubscriptionChannelType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SubscriptionChannelType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ subscriptionChannelType_id x
                       , maybe [] (toXMLAttribute "value") $ subscriptionChannelType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ subscriptionChannelType_extension x
            ]
instance Extension SubscriptionChannelType Element where
    supertype (SubscriptionChannelType a0 a1 e0) =
               Element a0 e0
 
-- | A homogeneous material with a definite composition.
elementSubstance :: XMLParser Substance
elementSubstance = parseSchemaType "Substance"
elementToXMLSubstance :: Substance -> [Content ()]
elementToXMLSubstance = schemaTypeToXML "Substance"
 
data Substance = Substance
        { substance_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , substance_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , substance_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , substance_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , substance_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , substance_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , substance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substance_identifier :: [Identifier]
          -- ^ Unique identifier for the substance.
        , substance_status :: Maybe FHIRSubstanceStatus
          -- ^ A code to indicate if the substance is actively used.
        , substance_category :: [CodeableConcept]
          -- ^ A code that classifies the general type of substance. This 
          --   is used for searching, sorting and display purposes.
        , substance_code :: CodeableConcept
          -- ^ A code (or set of codes) that identify this substance.
        , substance_description :: Maybe Xsd.XsdString
          -- ^ A description of the substance - its appearance, handling 
          --   requirements, and other usage notes.
        , substance_instance :: [SubstanceInstance]
          -- ^ Substance may be used to describe a kind of substance, or a 
          --   specific package/container of the substance: an instance.
        , substance_ingredient :: [SubstanceIngredient]
          -- ^ A substance can be composed of other substances.
        }
        deriving (Eq,Show)
instance SchemaType Substance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Substance
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` many (parseSchemaType "category")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "instance")
            `apply` many (parseSchemaType "ingredient")
    schemaTypeToXML s x@Substance{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ substance_id x
            , maybe [] (schemaTypeToXML "meta") $ substance_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ substance_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ substance_language x
            , maybe [] (schemaTypeToXML "text") $ substance_text x
            , concatMap (schemaTypeToXML "contained") $ substance_contained x
            , concatMap (schemaTypeToXML "extension") $ substance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substance_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ substance_identifier x
            , maybe [] (schemaTypeToXML "status") $ substance_status x
            , concatMap (schemaTypeToXML "category") $ substance_category x
            , schemaTypeToXML "code" $ substance_code x
            , maybe [] (schemaTypeToXML "description") $ substance_description x
            , concatMap (schemaTypeToXML "instance") $ substance_instance x
            , concatMap (schemaTypeToXML "ingredient") $ substance_ingredient x
            ]
instance Extension Substance DomainResource where
    supertype (Substance e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Substance Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Substance -> DomainResource)
              
 
-- | A homogeneous material with a definite composition.
data SubstanceInstance = SubstanceInstance
        { substanceInstance_id :: Maybe String_primitive
        , substanceInstance_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substanceInstance_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substanceInstance_identifier :: Maybe Identifier
          -- ^ Identifier associated with the package/container (usually a 
          --   label affixed directly).
        , substanceInstance_expiry :: Maybe DateTime
          -- ^ When the substance is no longer valid to use. For some 
          --   substances, a single arbitrary date is used for expiry.
        , substanceInstance_quantity :: Maybe Quantity
          -- ^ The amount of the substance.
        }
        deriving (Eq,Show)
instance SchemaType SubstanceInstance where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SubstanceInstance a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "expiry")
            `apply` optional (parseSchemaType "quantity")
    schemaTypeToXML s x@SubstanceInstance{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ substanceInstance_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ substanceInstance_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substanceInstance_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ substanceInstance_identifier x
            , maybe [] (schemaTypeToXML "expiry") $ substanceInstance_expiry x
            , maybe [] (schemaTypeToXML "quantity") $ substanceInstance_quantity x
            ]
instance Extension SubstanceInstance BackboneElement where
    supertype (SubstanceInstance a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension SubstanceInstance Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SubstanceInstance -> BackboneElement)
              
 
-- | A homogeneous material with a definite composition.
data SubstanceIngredient = SubstanceIngredient
        { substanceIngredient_id :: Maybe String_primitive
        , substanceIngredient_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , substanceIngredient_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , substanceIngredient_quantity :: Maybe Ratio
          -- ^ The amount of the ingredient in the substance - a 
          --   concentration ratio.
        , substanceIngredient_choice3 :: OneOf2 CodeableConcept Reference
          -- ^ Another substance that is a component of this substance.
          --   
          --   Choice between:
          --   
          --   (1) substanceCodeableConcept
          --   
          --   (2) substanceReference
        }
        deriving (Eq,Show)
instance SchemaType SubstanceIngredient where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SubstanceIngredient a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "quantity")
            `apply` oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "substanceCodeableConcept"))
                           , ("Reference", fmap TwoOf2 (parseSchemaType "substanceReference"))
                           ]
    schemaTypeToXML s x@SubstanceIngredient{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ substanceIngredient_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ substanceIngredient_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ substanceIngredient_modifierExtension x
            , maybe [] (schemaTypeToXML "quantity") $ substanceIngredient_quantity x
            , foldOneOf2  (schemaTypeToXML "substanceCodeableConcept")
                          (schemaTypeToXML "substanceReference")
                          $ substanceIngredient_choice3 x
            ]
instance Extension SubstanceIngredient BackboneElement where
    supertype (SubstanceIngredient a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SubstanceIngredient Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SubstanceIngredient -> BackboneElement)
              
 
data FHIRSubstanceStatus_list
    = FHIRSubstanceStatus_list_Active
      -- ^ Active
    | FHIRSubstanceStatus_list_Inactive
      -- ^ Inactive
    | FHIRSubstanceStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType FHIRSubstanceStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRSubstanceStatus_list where
    acceptingParser =  do literal "active"; return FHIRSubstanceStatus_list_Active
                      `onFail` do literal "inactive"; return FHIRSubstanceStatus_list_Inactive
                      `onFail` do literal "entered-in-error"; return FHIRSubstanceStatus_list_Entered_in_error
                      
    simpleTypeText FHIRSubstanceStatus_list_Active = "active"
    simpleTypeText FHIRSubstanceStatus_list_Inactive = "inactive"
    simpleTypeText FHIRSubstanceStatus_list_Entered_in_error = "entered-in-error"
 
data FHIRSubstanceStatus = FHIRSubstanceStatus
        { fHIRSubstanceStatus_id :: Maybe String_primitive
        , fHIRSubstanceStatus_value :: Maybe FHIRSubstanceStatus_list
        , fHIRSubstanceStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRSubstanceStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRSubstanceStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRSubstanceStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRSubstanceStatus_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRSubstanceStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRSubstanceStatus_extension x
            ]
instance Extension FHIRSubstanceStatus Element where
    supertype (FHIRSubstanceStatus a0 a1 e0) =
               Element a0 e0
 
-- | Record of delivery of what is supplied.
elementSupplyDelivery :: XMLParser SupplyDelivery
elementSupplyDelivery = parseSchemaType "SupplyDelivery"
elementToXMLSupplyDelivery :: SupplyDelivery -> [Content ()]
elementToXMLSupplyDelivery = schemaTypeToXML "SupplyDelivery"
 
data SupplyDelivery = SupplyDelivery
        { supplyDelivery_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , supplyDelivery_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , supplyDelivery_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , supplyDelivery_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , supplyDelivery_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , supplyDelivery_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , supplyDelivery_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyDelivery_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyDelivery_identifier :: Maybe Identifier
          -- ^ Identifier assigned by the dispensing facility when the 
          --   item(s) is dispensed.
        , supplyDelivery_basedOn :: [Reference]
          -- ^ A plan, proposal or order that is fulfilled in whole or in 
          --   part by this event.
        , supplyDelivery_partOf :: [Reference]
          -- ^ A larger event of which this particular event is a 
          --   component or step.
        , supplyDelivery_status :: Maybe SupplyDeliveryStatus
          -- ^ A code specifying the state of the dispense event.
        , supplyDelivery_patient :: Maybe Reference
          -- ^ A link to a resource representing the person whom the 
          --   delivered item is for.
        , supplyDelivery_type :: Maybe CodeableConcept
          -- ^ Indicates the type of dispensing event that is performed. 
          --   Examples include: Trial Fill, Completion of Trial, Partial 
          --   Fill, Emergency Fill, Samples, etc.
        , supplyDelivery_suppliedItem :: Maybe SupplyDeliverySuppliedItem
          -- ^ The item that is being delivered or has been supplied.
        , supplyDelivery_choice15 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ The date or time(s) the activity occurred.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , supplyDelivery_supplier :: Maybe Reference
          -- ^ The individual responsible for dispensing the medication, 
          --   supplier or device.
        , supplyDelivery_destination :: Maybe Reference
          -- ^ Identification of the facility/location where the Supply 
          --   was shipped to, as part of the dispense event.
        , supplyDelivery_receiver :: [Reference]
          -- ^ Identifies the person who picked up the Supply.
        }
        deriving (Eq,Show)
instance SchemaType SupplyDelivery where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SupplyDelivery
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` many (parseSchemaType "basedOn")
            `apply` many (parseSchemaType "partOf")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "suppliedItem")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "supplier")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "receiver")
    schemaTypeToXML s x@SupplyDelivery{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ supplyDelivery_id x
            , maybe [] (schemaTypeToXML "meta") $ supplyDelivery_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ supplyDelivery_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ supplyDelivery_language x
            , maybe [] (schemaTypeToXML "text") $ supplyDelivery_text x
            , concatMap (schemaTypeToXML "contained") $ supplyDelivery_contained x
            , concatMap (schemaTypeToXML "extension") $ supplyDelivery_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyDelivery_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ supplyDelivery_identifier x
            , concatMap (schemaTypeToXML "basedOn") $ supplyDelivery_basedOn x
            , concatMap (schemaTypeToXML "partOf") $ supplyDelivery_partOf x
            , maybe [] (schemaTypeToXML "status") $ supplyDelivery_status x
            , maybe [] (schemaTypeToXML "patient") $ supplyDelivery_patient x
            , maybe [] (schemaTypeToXML "type") $ supplyDelivery_type x
            , maybe [] (schemaTypeToXML "suppliedItem") $ supplyDelivery_suppliedItem x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ supplyDelivery_choice15 x
            , maybe [] (schemaTypeToXML "supplier") $ supplyDelivery_supplier x
            , maybe [] (schemaTypeToXML "destination") $ supplyDelivery_destination x
            , concatMap (schemaTypeToXML "receiver") $ supplyDelivery_receiver x
            ]
instance Extension SupplyDelivery DomainResource where
    supertype (SupplyDelivery e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SupplyDelivery Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SupplyDelivery -> DomainResource)
              
 
-- | Record of delivery of what is supplied.
data SupplyDeliverySuppliedItem = SupplyDeliverySuppliedItem
        { supplyDeliverySuppliedItem_id :: Maybe String_primitive
        , supplyDeliverySuppliedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyDeliverySuppliedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyDeliverySuppliedItem_quantity :: Maybe Quantity
          -- ^ The amount of supply that has been dispensed. Includes unit 
          --   of measure.
        , supplyDeliverySuppliedItem_choice3 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Identifies the medication, substance or device being 
          --   dispensed. This is either a link to a resource representing 
          --   the details of the item or a code that identifies the item 
          --   from a known list.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        }
        deriving (Eq,Show)
instance SchemaType SupplyDeliverySuppliedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyDeliverySuppliedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "quantity")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                                     ])
    schemaTypeToXML s x@SupplyDeliverySuppliedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyDeliverySuppliedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyDeliverySuppliedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyDeliverySuppliedItem_modifierExtension x
            , maybe [] (schemaTypeToXML "quantity") $ supplyDeliverySuppliedItem_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                                    (schemaTypeToXML "itemReference")
                                   ) $ supplyDeliverySuppliedItem_choice3 x
            ]
instance Extension SupplyDeliverySuppliedItem BackboneElement where
    supertype (SupplyDeliverySuppliedItem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyDeliverySuppliedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyDeliverySuppliedItem -> BackboneElement)
              
 
data SupplyDeliveryStatus_list
    = SupplyDeliveryStatus_list_In_progress
      -- ^ In Progress
    | SupplyDeliveryStatus_list_Completed
      -- ^ Delivered
    | SupplyDeliveryStatus_list_Abandoned
      -- ^ Abandoned
    | SupplyDeliveryStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType SupplyDeliveryStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SupplyDeliveryStatus_list where
    acceptingParser =  do literal "in-progress"; return SupplyDeliveryStatus_list_In_progress
                      `onFail` do literal "completed"; return SupplyDeliveryStatus_list_Completed
                      `onFail` do literal "abandoned"; return SupplyDeliveryStatus_list_Abandoned
                      `onFail` do literal "entered-in-error"; return SupplyDeliveryStatus_list_Entered_in_error
                      
    simpleTypeText SupplyDeliveryStatus_list_In_progress = "in-progress"
    simpleTypeText SupplyDeliveryStatus_list_Completed = "completed"
    simpleTypeText SupplyDeliveryStatus_list_Abandoned = "abandoned"
    simpleTypeText SupplyDeliveryStatus_list_Entered_in_error = "entered-in-error"
 
data SupplyDeliveryStatus = SupplyDeliveryStatus
        { supplyDeliveryStatus_id :: Maybe String_primitive
        , supplyDeliveryStatus_value :: Maybe SupplyDeliveryStatus_list
        , supplyDeliveryStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SupplyDeliveryStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SupplyDeliveryStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SupplyDeliveryStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyDeliveryStatus_id x
                       , maybe [] (toXMLAttribute "value") $ supplyDeliveryStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyDeliveryStatus_extension x
            ]
instance Extension SupplyDeliveryStatus Element where
    supertype (SupplyDeliveryStatus a0 a1 e0) =
               Element a0 e0
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
elementSupplyRequest :: XMLParser SupplyRequest
elementSupplyRequest = parseSchemaType "SupplyRequest"
elementToXMLSupplyRequest :: SupplyRequest -> [Content ()]
elementToXMLSupplyRequest = schemaTypeToXML "SupplyRequest"
 
data SupplyRequest = SupplyRequest
        { supplyRequest_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , supplyRequest_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , supplyRequest_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , supplyRequest_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , supplyRequest_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , supplyRequest_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , supplyRequest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequest_identifier :: Maybe Identifier
          -- ^ Unique identifier for this supply request.
        , supplyRequest_status :: Maybe SupplyRequestStatus
          -- ^ Status of the supply request.
        , supplyRequest_category :: Maybe CodeableConcept
          -- ^ Category of supply, e.g. central, non-stock, etc. This is 
          --   used to support work flows associated with the supply 
          --   process.
        , supplyRequest_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly this SupplyRequest should be 
          --   addressed with respect to other requests.
        , supplyRequest_orderedItem :: Maybe SupplyRequestOrderedItem
          -- ^ The item being requested.
        , supplyRequest_choice13 :: (Maybe (OneOf3 DateTime Period Timing))
          -- ^ When the request should be fulfilled.
          --   
          --   Choice between:
          --   
          --   (1) occurrenceDateTime
          --   
          --   (2) occurrencePeriod
          --   
          --   (3) occurrenceTiming
        , supplyRequest_authoredOn :: Maybe DateTime
          -- ^ When the request was made.
        , supplyRequest_requester :: Maybe SupplyRequestRequester
          -- ^ The individual who initiated the request and has 
          --   responsibility for its activation.
        , supplyRequest_supplier :: [Reference]
          -- ^ Who is intended to fulfill the request.
        , supplyRequest_choice17 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Why the supply item was requested.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , supplyRequest_deliverFrom :: Maybe Reference
          -- ^ Where the supply is expected to come from.
        , supplyRequest_deliverTo :: Maybe Reference
          -- ^ Where the supply is destined to go.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return SupplyRequest
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "category")
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "orderedItem")
            `apply` optional (oneOf' [ ("DateTime", fmap OneOf3 (parseSchemaType "occurrenceDateTime"))
                                     , ("Period", fmap TwoOf3 (parseSchemaType "occurrencePeriod"))
                                     , ("Timing", fmap ThreeOf3 (parseSchemaType "occurrenceTiming"))
                                     ])
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "supplier")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` optional (parseSchemaType "deliverFrom")
            `apply` optional (parseSchemaType "deliverTo")
    schemaTypeToXML s x@SupplyRequest{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ supplyRequest_id x
            , maybe [] (schemaTypeToXML "meta") $ supplyRequest_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ supplyRequest_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ supplyRequest_language x
            , maybe [] (schemaTypeToXML "text") $ supplyRequest_text x
            , concatMap (schemaTypeToXML "contained") $ supplyRequest_contained x
            , concatMap (schemaTypeToXML "extension") $ supplyRequest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequest_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ supplyRequest_identifier x
            , maybe [] (schemaTypeToXML "status") $ supplyRequest_status x
            , maybe [] (schemaTypeToXML "category") $ supplyRequest_category x
            , maybe [] (schemaTypeToXML "priority") $ supplyRequest_priority x
            , maybe [] (schemaTypeToXML "orderedItem") $ supplyRequest_orderedItem x
            , maybe [] (foldOneOf3  (schemaTypeToXML "occurrenceDateTime")
                                    (schemaTypeToXML "occurrencePeriod")
                                    (schemaTypeToXML "occurrenceTiming")
                                   ) $ supplyRequest_choice13 x
            , maybe [] (schemaTypeToXML "authoredOn") $ supplyRequest_authoredOn x
            , maybe [] (schemaTypeToXML "requester") $ supplyRequest_requester x
            , concatMap (schemaTypeToXML "supplier") $ supplyRequest_supplier x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ supplyRequest_choice17 x
            , maybe [] (schemaTypeToXML "deliverFrom") $ supplyRequest_deliverFrom x
            , maybe [] (schemaTypeToXML "deliverTo") $ supplyRequest_deliverTo x
            ]
instance Extension SupplyRequest DomainResource where
    supertype (SupplyRequest e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension SupplyRequest Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: SupplyRequest -> DomainResource)
              
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
data SupplyRequestOrderedItem = SupplyRequestOrderedItem
        { supplyRequestOrderedItem_id :: Maybe String_primitive
        , supplyRequestOrderedItem_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequestOrderedItem_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequestOrderedItem_quantity :: Quantity
          -- ^ The amount that is being ordered of the indicated item.
        , supplyRequestOrderedItem_choice3 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ The item that is requested to be supplied. This is either a 
          --   link to a resource representing the details of the item or 
          --   a code that identifies the item from a known list.
          --   
          --   Choice between:
          --   
          --   (1) itemCodeableConcept
          --   
          --   (2) itemReference
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequestOrderedItem where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyRequestOrderedItem a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "quantity"
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "itemCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "itemReference"))
                                     ])
    schemaTypeToXML s x@SupplyRequestOrderedItem{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequestOrderedItem_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequestOrderedItem_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequestOrderedItem_modifierExtension x
            , schemaTypeToXML "quantity" $ supplyRequestOrderedItem_quantity x
            , maybe [] (foldOneOf2  (schemaTypeToXML "itemCodeableConcept")
                                    (schemaTypeToXML "itemReference")
                                   ) $ supplyRequestOrderedItem_choice3 x
            ]
instance Extension SupplyRequestOrderedItem BackboneElement where
    supertype (SupplyRequestOrderedItem a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyRequestOrderedItem Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyRequestOrderedItem -> BackboneElement)
              
 
-- | A record of a request for a medication, substance or device 
--   used in the healthcare setting.
data SupplyRequestRequester = SupplyRequestRequester
        { supplyRequestRequester_id :: Maybe String_primitive
        , supplyRequestRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , supplyRequestRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , supplyRequestRequester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the request.
        , supplyRequestRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequestRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (SupplyRequestRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@SupplyRequestRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequestRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequestRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ supplyRequestRequester_modifierExtension x
            , schemaTypeToXML "agent" $ supplyRequestRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ supplyRequestRequester_onBehalfOf x
            ]
instance Extension SupplyRequestRequester BackboneElement where
    supertype (SupplyRequestRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension SupplyRequestRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: SupplyRequestRequester -> BackboneElement)
              
 
data SupplyRequestStatus_list
    = SupplyRequestStatus_list_Draft
      -- ^ Draft
    | SupplyRequestStatus_list_Active
      -- ^ Active
    | SupplyRequestStatus_list_Suspended
      -- ^ Suspended
    | SupplyRequestStatus_list_Cancelled
      -- ^ Cancelled
    | SupplyRequestStatus_list_Completed
      -- ^ Completed
    | SupplyRequestStatus_list_Entered_in_error
      -- ^ Entered in Error
    | SupplyRequestStatus_list_Unknown
      -- ^ Unknown
    deriving (Eq,Show,Enum)
instance SchemaType SupplyRequestStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType SupplyRequestStatus_list where
    acceptingParser =  do literal "draft"; return SupplyRequestStatus_list_Draft
                      `onFail` do literal "active"; return SupplyRequestStatus_list_Active
                      `onFail` do literal "suspended"; return SupplyRequestStatus_list_Suspended
                      `onFail` do literal "cancelled"; return SupplyRequestStatus_list_Cancelled
                      `onFail` do literal "completed"; return SupplyRequestStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return SupplyRequestStatus_list_Entered_in_error
                      `onFail` do literal "unknown"; return SupplyRequestStatus_list_Unknown
                      
    simpleTypeText SupplyRequestStatus_list_Draft = "draft"
    simpleTypeText SupplyRequestStatus_list_Active = "active"
    simpleTypeText SupplyRequestStatus_list_Suspended = "suspended"
    simpleTypeText SupplyRequestStatus_list_Cancelled = "cancelled"
    simpleTypeText SupplyRequestStatus_list_Completed = "completed"
    simpleTypeText SupplyRequestStatus_list_Entered_in_error = "entered-in-error"
    simpleTypeText SupplyRequestStatus_list_Unknown = "unknown"
 
data SupplyRequestStatus = SupplyRequestStatus
        { supplyRequestStatus_id :: Maybe String_primitive
        , supplyRequestStatus_value :: Maybe SupplyRequestStatus_list
        , supplyRequestStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType SupplyRequestStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (SupplyRequestStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@SupplyRequestStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ supplyRequestStatus_id x
                       , maybe [] (toXMLAttribute "value") $ supplyRequestStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ supplyRequestStatus_extension x
            ]
instance Extension SupplyRequestStatus Element where
    supertype (SupplyRequestStatus a0 a1 e0) =
               Element a0 e0
 
-- | A task to be performed.
elementTask :: XMLParser Task
elementTask = parseSchemaType "Task"
elementToXMLTask :: Task -> [Content ()]
elementToXMLTask = schemaTypeToXML "Task"
 
data Task = Task
        { task_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , task_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , task_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , task_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , task_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , task_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , task_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , task_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , task_identifier :: [Identifier]
          -- ^ The business identifier for this task.
        , task_choice9 :: (Maybe (OneOf2 Uri Reference))
          -- ^ A reference to a formal or informal definition of the task. 
          --   For example, a protocol, a step within a defined workflow 
          --   definition, etc.
          --   
          --   Choice between:
          --   
          --   (1) definitionUri
          --   
          --   (2) definitionReference
        , task_basedOn :: [Reference]
          -- ^ BasedOn refers to a higher-level authorization that 
          --   triggered the creation of the task. It references a 
          --   &quot;request&quot; resource such as a ProcedureRequest, 
          --   MedicationRequest, ProcedureRequest, CarePlan, etc. which 
          --   is distinct from the &quot;request&quot; resource the task 
          --   is seeking to fulfil. This latter resource is referenced by 
          --   FocusOn. For example, based on a ProcedureRequest (= 
          --   BasedOn), a task is created to fulfil a procedureRequest ( 
          --   = FocusOn ) to collect a specimen from a patient.
        , task_groupIdentifier :: Maybe Identifier
          -- ^ An identifier that links together multiple tasks and other 
          --   requests that were created in the same context.
        , task_partOf :: [Reference]
          -- ^ Task that this particular task is part of.
        , task_status :: TaskStatus
          -- ^ The current status of the task.
        , task_statusReason :: Maybe CodeableConcept
          -- ^ An explanation as to why this task is held, failed, was 
          --   refused, etc.
        , task_businessStatus :: Maybe CodeableConcept
          -- ^ Contains business-specific nuances of the business state.
        , task_intent :: RequestIntent
          -- ^ Indicates the &quot;level&quot; of actionability associated 
          --   with the Task. I.e. Is this a proposed task, a planned 
          --   task, an actionable task, etc.
        , task_priority :: Maybe RequestPriority
          -- ^ Indicates how quickly the Task should be addressed with 
          --   respect to other requests.
        , task_code :: Maybe CodeableConcept
          -- ^ A name or code (or both) briefly describing what the task 
          --   involves.
        , task_description :: Maybe Xsd.XsdString
          -- ^ A free-text description of what is to be performed.
        , task_focus :: Maybe Reference
          -- ^ The request being actioned or the resource being 
          --   manipulated by this task.
        , task_for :: Maybe Reference
          -- ^ The entity who benefits from the performance of the service 
          --   specified in the task (e.g., the patient).
        , task_context :: Maybe Reference
          -- ^ The healthcare event (e.g. a patient and healthcare 
          --   provider interaction) during which this task was created.
        , task_executionPeriod :: Maybe Period
          -- ^ Identifies the time action was first taken against the task 
          --   (start) and/or the time final action was taken against the 
          --   task prior to marking it as completed (end).
        , task_authoredOn :: Maybe DateTime
          -- ^ The date and time this task was created.
        , task_lastModified :: Maybe DateTime
          -- ^ The date and time of last modification to this task.
        , task_requester :: Maybe TaskRequester
          -- ^ The creator of the task.
        , task_performerType :: [CodeableConcept]
          -- ^ The type of participant that can execute the task.
        , task_owner :: Maybe Reference
          -- ^ Individual organization or Device currently responsible for 
          --   task execution.
        , task_reason :: Maybe CodeableConcept
          -- ^ A description or code indicating why this task needs to be 
          --   performed.
        , task_note :: [Annotation]
          -- ^ Free-text information captured about the task as it 
          --   progresses.
        , task_relevantHistory :: [Reference]
          -- ^ Links to Provenance records for past versions of this Task 
          --   that identify key state transitions or updates that are 
          --   likely to be relevant to a user looking at the current 
          --   version of the task.
        , task_restriction :: Maybe TaskRestriction
          -- ^ If the Task.focus is a request resource and the task is 
          --   seeking fulfillment (i.e is asking for the request to be 
          --   actioned), this element identifies any limitations on what 
          --   parts of the referenced request should be actioned.
        , task_input :: [TaskInput]
          -- ^ Additional information that may be needed in the execution 
          --   of the task.
        , task_output :: [TaskOutput]
          -- ^ Outputs produced by the Task.
        }
        deriving (Eq,Show)
instance SchemaType Task where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return Task
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (oneOf' [ ("Uri", fmap OneOf2 (parseSchemaType "definitionUri"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "definitionReference"))
                                     ])
            `apply` many (parseSchemaType "basedOn")
            `apply` optional (parseSchemaType "groupIdentifier")
            `apply` many (parseSchemaType "partOf")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "statusReason")
            `apply` optional (parseSchemaType "businessStatus")
            `apply` parseSchemaType "intent"
            `apply` optional (parseSchemaType "priority")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "focus")
            `apply` optional (parseSchemaType "for")
            `apply` optional (parseSchemaType "context")
            `apply` optional (parseSchemaType "executionPeriod")
            `apply` optional (parseSchemaType "authoredOn")
            `apply` optional (parseSchemaType "lastModified")
            `apply` optional (parseSchemaType "requester")
            `apply` many (parseSchemaType "performerType")
            `apply` optional (parseSchemaType "owner")
            `apply` optional (parseSchemaType "reason")
            `apply` many (parseSchemaType "note")
            `apply` many (parseSchemaType "relevantHistory")
            `apply` optional (parseSchemaType "restriction")
            `apply` many (parseSchemaType "input")
            `apply` many (parseSchemaType "output")
    schemaTypeToXML s x@Task{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ task_id x
            , maybe [] (schemaTypeToXML "meta") $ task_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ task_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ task_language x
            , maybe [] (schemaTypeToXML "text") $ task_text x
            , concatMap (schemaTypeToXML "contained") $ task_contained x
            , concatMap (schemaTypeToXML "extension") $ task_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ task_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ task_identifier x
            , maybe [] (foldOneOf2  (schemaTypeToXML "definitionUri")
                                    (schemaTypeToXML "definitionReference")
                                   ) $ task_choice9 x
            , concatMap (schemaTypeToXML "basedOn") $ task_basedOn x
            , maybe [] (schemaTypeToXML "groupIdentifier") $ task_groupIdentifier x
            , concatMap (schemaTypeToXML "partOf") $ task_partOf x
            , schemaTypeToXML "status" $ task_status x
            , maybe [] (schemaTypeToXML "statusReason") $ task_statusReason x
            , maybe [] (schemaTypeToXML "businessStatus") $ task_businessStatus x
            , schemaTypeToXML "intent" $ task_intent x
            , maybe [] (schemaTypeToXML "priority") $ task_priority x
            , maybe [] (schemaTypeToXML "code") $ task_code x
            , maybe [] (schemaTypeToXML "description") $ task_description x
            , maybe [] (schemaTypeToXML "focus") $ task_focus x
            , maybe [] (schemaTypeToXML "for") $ task_for x
            , maybe [] (schemaTypeToXML "context") $ task_context x
            , maybe [] (schemaTypeToXML "executionPeriod") $ task_executionPeriod x
            , maybe [] (schemaTypeToXML "authoredOn") $ task_authoredOn x
            , maybe [] (schemaTypeToXML "lastModified") $ task_lastModified x
            , maybe [] (schemaTypeToXML "requester") $ task_requester x
            , concatMap (schemaTypeToXML "performerType") $ task_performerType x
            , maybe [] (schemaTypeToXML "owner") $ task_owner x
            , maybe [] (schemaTypeToXML "reason") $ task_reason x
            , concatMap (schemaTypeToXML "note") $ task_note x
            , concatMap (schemaTypeToXML "relevantHistory") $ task_relevantHistory x
            , maybe [] (schemaTypeToXML "restriction") $ task_restriction x
            , concatMap (schemaTypeToXML "input") $ task_input x
            , concatMap (schemaTypeToXML "output") $ task_output x
            ]
instance Extension Task DomainResource where
    supertype (Task e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33 e34) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension Task Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: Task -> DomainResource)
              
 
-- | A task to be performed.
data TaskRequester = TaskRequester
        { taskRequester_id :: Maybe String_primitive
        , taskRequester_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , taskRequester_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , taskRequester_agent :: Reference
          -- ^ The device, practitioner, etc. who initiated the task.
        , taskRequester_onBehalfOf :: Maybe Reference
          -- ^ The organization the device or practitioner was acting on 
          --   behalf of when they initiated the task.
        }
        deriving (Eq,Show)
instance SchemaType TaskRequester where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TaskRequester a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "agent"
            `apply` optional (parseSchemaType "onBehalfOf")
    schemaTypeToXML s x@TaskRequester{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskRequester_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskRequester_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ taskRequester_modifierExtension x
            , schemaTypeToXML "agent" $ taskRequester_agent x
            , maybe [] (schemaTypeToXML "onBehalfOf") $ taskRequester_onBehalfOf x
            ]
instance Extension TaskRequester BackboneElement where
    supertype (TaskRequester a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TaskRequester Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TaskRequester -> BackboneElement)
              
 
-- | A task to be performed.
data TaskRestriction = TaskRestriction
        { taskRestriction_id :: Maybe String_primitive
        , taskRestriction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , taskRestriction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , taskRestriction_repetitions :: Maybe PositiveInt
          -- ^ Indicates the number of times the requested action should 
          --   occur.
        , taskRestriction_period :: Maybe Period
          -- ^ Over what time-period is fulfillment sought.
        , taskRestriction_recipient :: [Reference]
          -- ^ For requests that are targeted to more than on potential 
          --   recipient/target, for whom is fulfillment sought?
        }
        deriving (Eq,Show)
instance SchemaType TaskRestriction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TaskRestriction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "repetitions")
            `apply` optional (parseSchemaType "period")
            `apply` many (parseSchemaType "recipient")
    schemaTypeToXML s x@TaskRestriction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskRestriction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskRestriction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ taskRestriction_modifierExtension x
            , maybe [] (schemaTypeToXML "repetitions") $ taskRestriction_repetitions x
            , maybe [] (schemaTypeToXML "period") $ taskRestriction_period x
            , concatMap (schemaTypeToXML "recipient") $ taskRestriction_recipient x
            ]
instance Extension TaskRestriction BackboneElement where
    supertype (TaskRestriction a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TaskRestriction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TaskRestriction -> BackboneElement)
              
 
-- | A task to be performed.
data TaskInput = TaskInput
        { taskInput_id :: Maybe String_primitive
        , taskInput_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , taskInput_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , taskInput_type :: CodeableConcept
          -- ^ A code or description indicating how the input is intended 
          --   to be used as part of the task execution.
        , taskInput_choice3 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The value of the input parameter as a basic type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType TaskInput where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TaskInput a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@TaskInput{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskInput_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskInput_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ taskInput_modifierExtension x
            , schemaTypeToXML "type" $ taskInput_type x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ taskInput_choice3 x
            ]
instance Extension TaskInput BackboneElement where
    supertype (TaskInput a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TaskInput Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TaskInput -> BackboneElement)
              
 
-- | A task to be performed.
data TaskOutput = TaskOutput
        { taskOutput_id :: Maybe String_primitive
        , taskOutput_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , taskOutput_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , taskOutput_type :: CodeableConcept
          -- ^ The name of the Output parameter.
        , taskOutput_choice3 :: OneOf38 Base64Binary Boolean Code Date DateTime Decimal Id Instant Integer Markdown Oid PositiveInt Xsd.XsdString Time UnsignedInt Uri Address Age Annotation Attachment CodeableConcept Coding ContactPoint Count Distance Duration HumanName Identifier Money Period Quantity Range Ratio Reference SampledData Signature Timing Meta
          -- ^ The value of the Output parameter as a basic type.
          --   
          --   Choice between:
          --   
          --   (1) valueBase64Binary
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueCode
          --   
          --   (4) valueDate
          --   
          --   (5) valueDateTime
          --   
          --   (6) valueDecimal
          --   
          --   (7) valueId
          --   
          --   (8) valueInstant
          --   
          --   (9) valueInteger
          --   
          --   (10) valueMarkdown
          --   
          --   (11) valueOid
          --   
          --   (12) valuePositiveInt
          --   
          --   (13) valueString
          --   
          --   (14) valueTime
          --   
          --   (15) valueUnsignedInt
          --   
          --   (16) valueUri
          --   
          --   (17) valueAddress
          --   
          --   (18) valueAge
          --   
          --   (19) valueAnnotation
          --   
          --   (20) valueAttachment
          --   
          --   (21) valueCodeableConcept
          --   
          --   (22) valueCoding
          --   
          --   (23) valueContactPoint
          --   
          --   (24) valueCount
          --   
          --   (25) valueDistance
          --   
          --   (26) valueDuration
          --   
          --   (27) valueHumanName
          --   
          --   (28) valueIdentifier
          --   
          --   (29) valueMoney
          --   
          --   (30) valuePeriod
          --   
          --   (31) valueQuantity
          --   
          --   (32) valueRange
          --   
          --   (33) valueRatio
          --   
          --   (34) valueReference
          --   
          --   (35) valueSampledData
          --   
          --   (36) valueSignature
          --   
          --   (37) valueTiming
          --   
          --   (38) valueMeta
        }
        deriving (Eq,Show)
instance SchemaType TaskOutput where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TaskOutput a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` oneOf' [ ("Base64Binary", fmap OneOf38 (parseSchemaType "valueBase64Binary"))
                           , ("Boolean", fmap TwoOf38 (parseSchemaType "valueBoolean"))
                           , ("Code", fmap ThreeOf38 (parseSchemaType "valueCode"))
                           , ("Date", fmap FourOf38 (parseSchemaType "valueDate"))
                           , ("DateTime", fmap FiveOf38 (parseSchemaType "valueDateTime"))
                           , ("Decimal", fmap SixOf38 (parseSchemaType "valueDecimal"))
                           , ("Id", fmap SevenOf38 (parseSchemaType "valueId"))
                           , ("Instant", fmap EightOf38 (parseSchemaType "valueInstant"))
                           , ("Integer", fmap NineOf38 (parseSchemaType "valueInteger"))
                           , ("Markdown", fmap TenOf38 (parseSchemaType "valueMarkdown"))
                           , ("Oid", fmap ElevenOf38 (parseSchemaType "valueOid"))
                           , ("PositiveInt", fmap TwelveOf38 (parseSchemaType "valuePositiveInt"))
                           , ("Xsd.XsdString", fmap ThirteenOf38 (parseSchemaType "valueString"))
                           , ("Time", fmap FourteenOf38 (parseSchemaType "valueTime"))
                           , ("UnsignedInt", fmap FifteenOf38 (parseSchemaType "valueUnsignedInt"))
                           , ("Uri", fmap SixteenOf38 (parseSchemaType "valueUri"))
                           , ("Address", fmap SeventeenOf38 (parseSchemaType "valueAddress"))
                           , ("Age", fmap EighteenOf38 (parseSchemaType "valueAge"))
                           , ("Annotation", fmap NineteenOf38 (parseSchemaType "valueAnnotation"))
                           , ("Attachment", fmap TwentyOf38 (parseSchemaType "valueAttachment"))
                           , ("CodeableConcept", fmap Choice21Of38 (parseSchemaType "valueCodeableConcept"))
                           , ("Coding", fmap Choice22Of38 (parseSchemaType "valueCoding"))
                           , ("ContactPoint", fmap Choice23Of38 (parseSchemaType "valueContactPoint"))
                           , ("Count", fmap Choice24Of38 (parseSchemaType "valueCount"))
                           , ("Distance", fmap Choice25Of38 (parseSchemaType "valueDistance"))
                           , ("Duration", fmap Choice26Of38 (parseSchemaType "valueDuration"))
                           , ("HumanName", fmap Choice27Of38 (parseSchemaType "valueHumanName"))
                           , ("Identifier", fmap Choice28Of38 (parseSchemaType "valueIdentifier"))
                           , ("Money", fmap Choice29Of38 (parseSchemaType "valueMoney"))
                           , ("Period", fmap Choice30Of38 (parseSchemaType "valuePeriod"))
                           , ("Quantity", fmap Choice31Of38 (parseSchemaType "valueQuantity"))
                           , ("Range", fmap Choice32Of38 (parseSchemaType "valueRange"))
                           , ("Ratio", fmap Choice33Of38 (parseSchemaType "valueRatio"))
                           , ("Reference", fmap Choice34Of38 (parseSchemaType "valueReference"))
                           , ("SampledData", fmap Choice35Of38 (parseSchemaType "valueSampledData"))
                           , ("Signature", fmap Choice36Of38 (parseSchemaType "valueSignature"))
                           , ("Timing", fmap Choice37Of38 (parseSchemaType "valueTiming"))
                           , ("Meta", fmap Choice38Of38 (parseSchemaType "valueMeta"))
                           ]
    schemaTypeToXML s x@TaskOutput{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskOutput_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskOutput_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ taskOutput_modifierExtension x
            , schemaTypeToXML "type" $ taskOutput_type x
            , foldOneOf38  (schemaTypeToXML "valueBase64Binary")
                           (schemaTypeToXML "valueBoolean")
                           (schemaTypeToXML "valueCode")
                           (schemaTypeToXML "valueDate")
                           (schemaTypeToXML "valueDateTime")
                           (schemaTypeToXML "valueDecimal")
                           (schemaTypeToXML "valueId")
                           (schemaTypeToXML "valueInstant")
                           (schemaTypeToXML "valueInteger")
                           (schemaTypeToXML "valueMarkdown")
                           (schemaTypeToXML "valueOid")
                           (schemaTypeToXML "valuePositiveInt")
                           (schemaTypeToXML "valueString")
                           (schemaTypeToXML "valueTime")
                           (schemaTypeToXML "valueUnsignedInt")
                           (schemaTypeToXML "valueUri")
                           (schemaTypeToXML "valueAddress")
                           (schemaTypeToXML "valueAge")
                           (schemaTypeToXML "valueAnnotation")
                           (schemaTypeToXML "valueAttachment")
                           (schemaTypeToXML "valueCodeableConcept")
                           (schemaTypeToXML "valueCoding")
                           (schemaTypeToXML "valueContactPoint")
                           (schemaTypeToXML "valueCount")
                           (schemaTypeToXML "valueDistance")
                           (schemaTypeToXML "valueDuration")
                           (schemaTypeToXML "valueHumanName")
                           (schemaTypeToXML "valueIdentifier")
                           (schemaTypeToXML "valueMoney")
                           (schemaTypeToXML "valuePeriod")
                           (schemaTypeToXML "valueQuantity")
                           (schemaTypeToXML "valueRange")
                           (schemaTypeToXML "valueRatio")
                           (schemaTypeToXML "valueReference")
                           (schemaTypeToXML "valueSampledData")
                           (schemaTypeToXML "valueSignature")
                           (schemaTypeToXML "valueTiming")
                           (schemaTypeToXML "valueMeta")
                           $ taskOutput_choice3 x
            ]
instance Extension TaskOutput BackboneElement where
    supertype (TaskOutput a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TaskOutput Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TaskOutput -> BackboneElement)
              
 
data TaskStatus_list
    = TaskStatus_list_Draft
      -- ^ Draft
    | TaskStatus_list_Requested
      -- ^ Requested
    | TaskStatus_list_Received
      -- ^ Received
    | TaskStatus_list_Accepted
      -- ^ Accepted
    | TaskStatus_list_Rejected
      -- ^ Rejected
    | TaskStatus_list_Ready
      -- ^ Ready
    | TaskStatus_list_Cancelled
      -- ^ Cancelled
    | TaskStatus_list_In_progress
      -- ^ In Progress
    | TaskStatus_list_On_hold
      -- ^ On Hold
    | TaskStatus_list_Failed
      -- ^ Failed
    | TaskStatus_list_Completed
      -- ^ Completed
    | TaskStatus_list_Entered_in_error
      -- ^ Entered in Error
    deriving (Eq,Show,Enum)
instance SchemaType TaskStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TaskStatus_list where
    acceptingParser =  do literal "draft"; return TaskStatus_list_Draft
                      `onFail` do literal "requested"; return TaskStatus_list_Requested
                      `onFail` do literal "received"; return TaskStatus_list_Received
                      `onFail` do literal "accepted"; return TaskStatus_list_Accepted
                      `onFail` do literal "rejected"; return TaskStatus_list_Rejected
                      `onFail` do literal "ready"; return TaskStatus_list_Ready
                      `onFail` do literal "cancelled"; return TaskStatus_list_Cancelled
                      `onFail` do literal "in-progress"; return TaskStatus_list_In_progress
                      `onFail` do literal "on-hold"; return TaskStatus_list_On_hold
                      `onFail` do literal "failed"; return TaskStatus_list_Failed
                      `onFail` do literal "completed"; return TaskStatus_list_Completed
                      `onFail` do literal "entered-in-error"; return TaskStatus_list_Entered_in_error
                      
    simpleTypeText TaskStatus_list_Draft = "draft"
    simpleTypeText TaskStatus_list_Requested = "requested"
    simpleTypeText TaskStatus_list_Received = "received"
    simpleTypeText TaskStatus_list_Accepted = "accepted"
    simpleTypeText TaskStatus_list_Rejected = "rejected"
    simpleTypeText TaskStatus_list_Ready = "ready"
    simpleTypeText TaskStatus_list_Cancelled = "cancelled"
    simpleTypeText TaskStatus_list_In_progress = "in-progress"
    simpleTypeText TaskStatus_list_On_hold = "on-hold"
    simpleTypeText TaskStatus_list_Failed = "failed"
    simpleTypeText TaskStatus_list_Completed = "completed"
    simpleTypeText TaskStatus_list_Entered_in_error = "entered-in-error"
 
data TaskStatus = TaskStatus
        { taskStatus_id :: Maybe String_primitive
        , taskStatus_value :: Maybe TaskStatus_list
        , taskStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TaskStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TaskStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TaskStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ taskStatus_id x
                       , maybe [] (toXMLAttribute "value") $ taskStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ taskStatus_extension x
            ]
instance Extension TaskStatus Element where
    supertype (TaskStatus a0 a1 e0) =
               Element a0 e0
 
-- | A summary of information based on the results of executing 
--   a TestScript.
elementTestReport :: XMLParser TestReport
elementTestReport = parseSchemaType "TestReport"
elementToXMLTestReport :: TestReport -> [Content ()]
elementToXMLTestReport = schemaTypeToXML "TestReport"
 
data TestReport = TestReport
        { testReport_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , testReport_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , testReport_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , testReport_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , testReport_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , testReport_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , testReport_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReport_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReport_identifier :: Maybe Identifier
          -- ^ Identifier for the TestScript assigned for external 
          --   purposes outside the context of FHIR.
        , testReport_name :: Maybe Xsd.XsdString
          -- ^ A free text natural language name identifying the executed 
          --   TestScript.
        , testReport_status :: TestReportStatus
          -- ^ The current state of this test report.
        , testReport_testScript :: Reference
          -- ^ Ideally this is an absolute URL that is used to identify 
          --   the version-specific TestScript that was executed, matching 
          --   the `TestScript.url`.
        , testReport_result :: TestReportResult
          -- ^ The overall result from the execution of the TestScript.
        , testReport_score :: Maybe Decimal
          -- ^ The final score (percentage of tests passed) resulting from 
          --   the execution of the TestScript.
        , testReport_tester :: Maybe Xsd.XsdString
          -- ^ Name of the tester producing this report (Organization or 
          --   individual).
        , testReport_issued :: Maybe DateTime
          -- ^ When the TestScript was executed and this TestReport was 
          --   generated.
        , testReport_participant :: [TestReportParticipant]
          -- ^ A participant in the test execution, either the execution 
          --   engine, a client, or a server.
        , testReport_setup :: Maybe TestReportSetup
          -- ^ The results of the series of required setup operations 
          --   before the tests were executed.
        , testReport_test :: [TestReportTest]
          -- ^ A test executed from the test script.
        , testReport_teardown :: Maybe TestReportTeardown
          -- ^ The results of the series of operations required to clean 
          --   up after the all the tests were executed (successfully or 
          --   otherwise).
        }
        deriving (Eq,Show)
instance SchemaType TestReport where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return TestReport
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "name")
            `apply` parseSchemaType "status"
            `apply` parseSchemaType "testScript"
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "score")
            `apply` optional (parseSchemaType "tester")
            `apply` optional (parseSchemaType "issued")
            `apply` many (parseSchemaType "participant")
            `apply` optional (parseSchemaType "setup")
            `apply` many (parseSchemaType "test")
            `apply` optional (parseSchemaType "teardown")
    schemaTypeToXML s x@TestReport{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ testReport_id x
            , maybe [] (schemaTypeToXML "meta") $ testReport_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ testReport_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ testReport_language x
            , maybe [] (schemaTypeToXML "text") $ testReport_text x
            , concatMap (schemaTypeToXML "contained") $ testReport_contained x
            , concatMap (schemaTypeToXML "extension") $ testReport_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReport_modifierExtension x
            , maybe [] (schemaTypeToXML "identifier") $ testReport_identifier x
            , maybe [] (schemaTypeToXML "name") $ testReport_name x
            , schemaTypeToXML "status" $ testReport_status x
            , schemaTypeToXML "testScript" $ testReport_testScript x
            , schemaTypeToXML "result" $ testReport_result x
            , maybe [] (schemaTypeToXML "score") $ testReport_score x
            , maybe [] (schemaTypeToXML "tester") $ testReport_tester x
            , maybe [] (schemaTypeToXML "issued") $ testReport_issued x
            , concatMap (schemaTypeToXML "participant") $ testReport_participant x
            , maybe [] (schemaTypeToXML "setup") $ testReport_setup x
            , concatMap (schemaTypeToXML "test") $ testReport_test x
            , maybe [] (schemaTypeToXML "teardown") $ testReport_teardown x
            ]
instance Extension TestReport DomainResource where
    supertype (TestReport e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension TestReport Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: TestReport -> DomainResource)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportParticipant = TestReportParticipant
        { testReportParticipant_id :: Maybe String_primitive
        , testReportParticipant_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportParticipant_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportParticipant_type :: TestReportParticipantType
          -- ^ The type of participant.
        , testReportParticipant_uri :: Uri
          -- ^ The uri of the participant. An absolute URL is preferred.
        , testReportParticipant_display :: Maybe Xsd.XsdString
          -- ^ The display name of the participant.
        }
        deriving (Eq,Show)
instance SchemaType TestReportParticipant where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportParticipant a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "type"
            `apply` parseSchemaType "uri"
            `apply` optional (parseSchemaType "display")
    schemaTypeToXML s x@TestReportParticipant{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportParticipant_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportParticipant_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportParticipant_modifierExtension x
            , schemaTypeToXML "type" $ testReportParticipant_type x
            , schemaTypeToXML "uri" $ testReportParticipant_uri x
            , maybe [] (schemaTypeToXML "display") $ testReportParticipant_display x
            ]
instance Extension TestReportParticipant BackboneElement where
    supertype (TestReportParticipant a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReportParticipant Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportParticipant -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportSetup = TestReportSetup
        { testReportSetup_id :: Maybe String_primitive
        , testReportSetup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportSetup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportSetup_action :: [TestReportAction]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestReportSetup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportSetup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReportSetup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportSetup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportSetup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportSetup_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testReportSetup_action x
            ]
instance Extension TestReportSetup BackboneElement where
    supertype (TestReportSetup a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReportSetup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportSetup -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportAction = TestReportAction
        { testReportAction_id :: Maybe String_primitive
        , testReportAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportAction_operation :: Maybe TestReportOperation
          -- ^ The operation performed.
        , testReportAction_assert :: Maybe TestReportAssert
          -- ^ The results of the assertion performed on the previous 
          --   operations.
        }
        deriving (Eq,Show)
instance SchemaType TestReportAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestReportAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportAction_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testReportAction_operation x
            , maybe [] (schemaTypeToXML "assert") $ testReportAction_assert x
            ]
instance Extension TestReportAction BackboneElement where
    supertype (TestReportAction a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestReportAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportAction -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportOperation = TestReportOperation
        { testReportOperation_id :: Maybe String_primitive
        , testReportOperation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportOperation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportOperation_result :: TestReportActionResult
          -- ^ The result of this operation.
        , testReportOperation_message :: Maybe Markdown
          -- ^ An explanatory message associated with the result.
        , testReportOperation_detail :: Maybe Uri
          -- ^ A link to further details on the result.
        }
        deriving (Eq,Show)
instance SchemaType TestReportOperation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportOperation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "message")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@TestReportOperation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportOperation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportOperation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportOperation_modifierExtension x
            , schemaTypeToXML "result" $ testReportOperation_result x
            , maybe [] (schemaTypeToXML "message") $ testReportOperation_message x
            , maybe [] (schemaTypeToXML "detail") $ testReportOperation_detail x
            ]
instance Extension TestReportOperation BackboneElement where
    supertype (TestReportOperation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReportOperation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportOperation -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportAssert = TestReportAssert
        { testReportAssert_id :: Maybe String_primitive
        , testReportAssert_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportAssert_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportAssert_result :: TestReportActionResult
          -- ^ The result of this assertion.
        , testReportAssert_message :: Maybe Markdown
          -- ^ An explanatory message associated with the result.
        , testReportAssert_detail :: Maybe Xsd.XsdString
          -- ^ A link to further details on the result.
        }
        deriving (Eq,Show)
instance SchemaType TestReportAssert where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportAssert a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "result"
            `apply` optional (parseSchemaType "message")
            `apply` optional (parseSchemaType "detail")
    schemaTypeToXML s x@TestReportAssert{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportAssert_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportAssert_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportAssert_modifierExtension x
            , schemaTypeToXML "result" $ testReportAssert_result x
            , maybe [] (schemaTypeToXML "message") $ testReportAssert_message x
            , maybe [] (schemaTypeToXML "detail") $ testReportAssert_detail x
            ]
instance Extension TestReportAssert BackboneElement where
    supertype (TestReportAssert a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReportAssert Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportAssert -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportTest = TestReportTest
        { testReportTest_id :: Maybe String_primitive
        , testReportTest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportTest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportTest_name :: Maybe Xsd.XsdString
          -- ^ The name of this test used for tracking/logging purposes by 
          --   test engines.
        , testReportTest_description :: Maybe Xsd.XsdString
          -- ^ A short description of the test used by test engines for 
          --   tracking and reporting purposes.
        , testReportTest_action :: [TestReportAction1]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestReportTest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportTest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReportTest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportTest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportTest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportTest_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ testReportTest_name x
            , maybe [] (schemaTypeToXML "description") $ testReportTest_description x
            , concatMap (schemaTypeToXML "action") $ testReportTest_action x
            ]
instance Extension TestReportTest BackboneElement where
    supertype (TestReportTest a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestReportTest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportTest -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportAction1 = TestReportAction1
        { testReportAction1_id :: Maybe String_primitive
        , testReportAction1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportAction1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportAction1_operation :: Maybe TestReportOperation
          -- ^ An operation would involve a REST request to a server.
        , testReportAction1_assert :: Maybe TestReportAssert
          -- ^ The results of the assertion performed on the previous 
          --   operations.
        }
        deriving (Eq,Show)
instance SchemaType TestReportAction1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportAction1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestReportAction1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportAction1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportAction1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportAction1_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testReportAction1_operation x
            , maybe [] (schemaTypeToXML "assert") $ testReportAction1_assert x
            ]
instance Extension TestReportAction1 BackboneElement where
    supertype (TestReportAction1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestReportAction1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportAction1 -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportTeardown = TestReportTeardown
        { testReportTeardown_id :: Maybe String_primitive
        , testReportTeardown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportTeardown_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportTeardown_action :: [TestReportAction2]
          -- ^ The teardown action will only contain an operation.
        }
        deriving (Eq,Show)
instance SchemaType TestReportTeardown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportTeardown a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestReportTeardown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportTeardown_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportTeardown_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportTeardown_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testReportTeardown_action x
            ]
instance Extension TestReportTeardown BackboneElement where
    supertype (TestReportTeardown a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReportTeardown Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportTeardown -> BackboneElement)
              
 
-- | A summary of information based on the results of executing 
--   a TestScript.
data TestReportAction2 = TestReportAction2
        { testReportAction2_id :: Maybe String_primitive
        , testReportAction2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testReportAction2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testReportAction2_operation :: TestReportOperation
          -- ^ An operation would involve a REST request to a server.
        }
        deriving (Eq,Show)
instance SchemaType TestReportAction2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestReportAction2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "operation"
    schemaTypeToXML s x@TestReportAction2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportAction2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportAction2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testReportAction2_modifierExtension x
            , schemaTypeToXML "operation" $ testReportAction2_operation x
            ]
instance Extension TestReportAction2 BackboneElement where
    supertype (TestReportAction2 a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestReportAction2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestReportAction2 -> BackboneElement)
              
 
data TestReportStatus_list
    = TestReportStatus_list_Completed
      -- ^ Completed
    | TestReportStatus_list_In_progress
      -- ^ In Progress
    | TestReportStatus_list_Waiting
      -- ^ Waiting
    | TestReportStatus_list_Stopped
      -- ^ Stopped
    | TestReportStatus_list_Entered_in_error
      -- ^ Entered In Error
    deriving (Eq,Show,Enum)
instance SchemaType TestReportStatus_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportStatus_list where
    acceptingParser =  do literal "completed"; return TestReportStatus_list_Completed
                      `onFail` do literal "in-progress"; return TestReportStatus_list_In_progress
                      `onFail` do literal "waiting"; return TestReportStatus_list_Waiting
                      `onFail` do literal "stopped"; return TestReportStatus_list_Stopped
                      `onFail` do literal "entered-in-error"; return TestReportStatus_list_Entered_in_error
                      
    simpleTypeText TestReportStatus_list_Completed = "completed"
    simpleTypeText TestReportStatus_list_In_progress = "in-progress"
    simpleTypeText TestReportStatus_list_Waiting = "waiting"
    simpleTypeText TestReportStatus_list_Stopped = "stopped"
    simpleTypeText TestReportStatus_list_Entered_in_error = "entered-in-error"
 
data TestReportStatus = TestReportStatus
        { testReportStatus_id :: Maybe String_primitive
        , testReportStatus_value :: Maybe TestReportStatus_list
        , testReportStatus_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportStatus where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportStatus a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportStatus{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportStatus_id x
                       , maybe [] (toXMLAttribute "value") $ testReportStatus_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportStatus_extension x
            ]
instance Extension TestReportStatus Element where
    supertype (TestReportStatus a0 a1 e0) =
               Element a0 e0
 
data TestReportActionResult_list
    = TestReportActionResult_list_Pass
      -- ^ Pass
    | TestReportActionResult_list_Skip
      -- ^ Skip
    | TestReportActionResult_list_Fail
      -- ^ Fail
    | TestReportActionResult_list_Warning
      -- ^ Warning
    | TestReportActionResult_list_Error
      -- ^ Error
    deriving (Eq,Show,Enum)
instance SchemaType TestReportActionResult_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportActionResult_list where
    acceptingParser =  do literal "pass"; return TestReportActionResult_list_Pass
                      `onFail` do literal "skip"; return TestReportActionResult_list_Skip
                      `onFail` do literal "fail"; return TestReportActionResult_list_Fail
                      `onFail` do literal "warning"; return TestReportActionResult_list_Warning
                      `onFail` do literal "error"; return TestReportActionResult_list_Error
                      
    simpleTypeText TestReportActionResult_list_Pass = "pass"
    simpleTypeText TestReportActionResult_list_Skip = "skip"
    simpleTypeText TestReportActionResult_list_Fail = "fail"
    simpleTypeText TestReportActionResult_list_Warning = "warning"
    simpleTypeText TestReportActionResult_list_Error = "error"
 
data TestReportActionResult = TestReportActionResult
        { testReportActionResult_id :: Maybe String_primitive
        , testReportActionResult_value :: Maybe TestReportActionResult_list
        , testReportActionResult_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportActionResult where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportActionResult a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportActionResult{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportActionResult_id x
                       , maybe [] (toXMLAttribute "value") $ testReportActionResult_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportActionResult_extension x
            ]
instance Extension TestReportActionResult Element where
    supertype (TestReportActionResult a0 a1 e0) =
               Element a0 e0
 
data TestReportParticipantType_list
    = TestReportParticipantType_list_Test_engine
      -- ^ Test Engine
    | TestReportParticipantType_list_Client
      -- ^ Client
    | TestReportParticipantType_list_Server
      -- ^ Server
    deriving (Eq,Show,Enum)
instance SchemaType TestReportParticipantType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportParticipantType_list where
    acceptingParser =  do literal "test-engine"; return TestReportParticipantType_list_Test_engine
                      `onFail` do literal "client"; return TestReportParticipantType_list_Client
                      `onFail` do literal "server"; return TestReportParticipantType_list_Server
                      
    simpleTypeText TestReportParticipantType_list_Test_engine = "test-engine"
    simpleTypeText TestReportParticipantType_list_Client = "client"
    simpleTypeText TestReportParticipantType_list_Server = "server"
 
data TestReportParticipantType = TestReportParticipantType
        { testReportParticipantType_id :: Maybe String_primitive
        , testReportParticipantType_value :: Maybe TestReportParticipantType_list
        , testReportParticipantType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportParticipantType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportParticipantType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportParticipantType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportParticipantType_id x
                       , maybe [] (toXMLAttribute "value") $ testReportParticipantType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportParticipantType_extension x
            ]
instance Extension TestReportParticipantType Element where
    supertype (TestReportParticipantType a0 a1 e0) =
               Element a0 e0
 
data TestReportResult_list
    = TestReportResult_list_Pass
      -- ^ Pass
    | TestReportResult_list_Fail
      -- ^ Fail
    | TestReportResult_list_Pending
      -- ^ Pending
    deriving (Eq,Show,Enum)
instance SchemaType TestReportResult_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestReportResult_list where
    acceptingParser =  do literal "pass"; return TestReportResult_list_Pass
                      `onFail` do literal "fail"; return TestReportResult_list_Fail
                      `onFail` do literal "pending"; return TestReportResult_list_Pending
                      
    simpleTypeText TestReportResult_list_Pass = "pass"
    simpleTypeText TestReportResult_list_Fail = "fail"
    simpleTypeText TestReportResult_list_Pending = "pending"
 
data TestReportResult = TestReportResult
        { testReportResult_id :: Maybe String_primitive
        , testReportResult_value :: Maybe TestReportResult_list
        , testReportResult_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestReportResult where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestReportResult a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestReportResult{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testReportResult_id x
                       , maybe [] (toXMLAttribute "value") $ testReportResult_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testReportResult_extension x
            ]
instance Extension TestReportResult Element where
    supertype (TestReportResult a0 a1 e0) =
               Element a0 e0
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
elementTestScript :: XMLParser TestScript
elementTestScript = parseSchemaType "TestScript"
elementToXMLTestScript :: TestScript -> [Content ()]
elementToXMLTestScript = schemaTypeToXML "TestScript"
 
data TestScript = TestScript
        { testScript_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , testScript_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , testScript_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , testScript_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , testScript_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , testScript_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , testScript_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScript_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScript_url :: Uri
          -- ^ An absolute URI that is used to identify this test script 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this test script 
          --   is (or will be) published. The URL SHOULD include the major 
          --   version of the test script. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , testScript_identifier :: Maybe Identifier
          -- ^ A formal identifier that is used to identify this test 
          --   script when it is represented in other formats, or 
          --   referenced in a specification, model, design or an 
          --   instance.
        , testScript_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   test script when it is referenced in a specification, 
          --   model, design or instance. This is an arbitrary value 
          --   managed by the test script author and is not expected to be 
          --   globally unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , testScript_name :: Xsd.XsdString
          -- ^ A natural language name identifying the test script. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , testScript_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the test 
          --   script.
        , testScript_status :: PublicationStatus
          -- ^ The status of this test script. Enables tracking the 
          --   life-cycle of the content.
        , testScript_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this test script is 
          --   authored for testing purposes (or 
          --   education/evaluation/marketing), and is not intended to be 
          --   used for genuine usage.
        , testScript_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the test script was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the test script changes.
        , testScript_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the test script.
        , testScript_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , testScript_description :: Maybe Markdown
          -- ^ A free text natural language description of the test script 
          --   from a consumer's perspective.
        , testScript_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   test script instances.
        , testScript_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the test script is 
          --   intended to be used.
        , testScript_purpose :: Maybe Markdown
          -- ^ Explaination of why this test script is needed and why it 
          --   has been designed as it has.
        , testScript_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the test script and/or 
          --   its contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the test script.
        , testScript_origin :: [TestScriptOrigin]
          -- ^ An abstract server used in operations within this test 
          --   script in the origin element.
        , testScript_destination :: [TestScriptDestination]
          -- ^ An abstract server used in operations within this test 
          --   script in the destination element.
        , testScript_metadata :: Maybe TestScriptMetadata
          -- ^ The required capability must exist and are assumed to 
          --   function correctly on the FHIR server being tested.
        , testScript_fixture :: [TestScriptFixture]
          -- ^ Fixture in the test script - by reference (uri). All 
          --   fixtures are required for the test script to execute.
        , testScript_profile :: [Reference]
          -- ^ Reference to the profile to be used for validation.
        , testScript_variable :: [TestScriptVariable]
          -- ^ Variable is set based either on element value in response 
          --   body or on header field value in the response headers.
        , testScript_rule :: [TestScriptRule]
          -- ^ Assert rule to be used in one or more asserts within the 
          --   test script.
        , testScript_ruleset :: [TestScriptRuleset]
          -- ^ Contains one or more rules. Offers a way to group rules so 
          --   assertions could reference the group of rules and have them 
          --   all applied.
        , testScript_setup :: Maybe TestScriptSetup
          -- ^ A series of required setup operations before tests are 
          --   executed.
        , testScript_test :: [TestScriptTest]
          -- ^ A test in this script.
        , testScript_teardown :: Maybe TestScriptTeardown
          -- ^ A series of operations required to clean up after the all 
          --   the tests are executed (successfully or otherwise).
        }
        deriving (Eq,Show)
instance SchemaType TestScript where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return TestScript
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` many (parseSchemaType "origin")
            `apply` many (parseSchemaType "destination")
            `apply` optional (parseSchemaType "metadata")
            `apply` many (parseSchemaType "fixture")
            `apply` many (parseSchemaType "profile")
            `apply` many (parseSchemaType "variable")
            `apply` many (parseSchemaType "rule")
            `apply` many (parseSchemaType "ruleset")
            `apply` optional (parseSchemaType "setup")
            `apply` many (parseSchemaType "test")
            `apply` optional (parseSchemaType "teardown")
    schemaTypeToXML s x@TestScript{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ testScript_id x
            , maybe [] (schemaTypeToXML "meta") $ testScript_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ testScript_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ testScript_language x
            , maybe [] (schemaTypeToXML "text") $ testScript_text x
            , concatMap (schemaTypeToXML "contained") $ testScript_contained x
            , concatMap (schemaTypeToXML "extension") $ testScript_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScript_modifierExtension x
            , schemaTypeToXML "url" $ testScript_url x
            , maybe [] (schemaTypeToXML "identifier") $ testScript_identifier x
            , maybe [] (schemaTypeToXML "version") $ testScript_version x
            , schemaTypeToXML "name" $ testScript_name x
            , maybe [] (schemaTypeToXML "title") $ testScript_title x
            , schemaTypeToXML "status" $ testScript_status x
            , maybe [] (schemaTypeToXML "experimental") $ testScript_experimental x
            , maybe [] (schemaTypeToXML "date") $ testScript_date x
            , maybe [] (schemaTypeToXML "publisher") $ testScript_publisher x
            , concatMap (schemaTypeToXML "contact") $ testScript_contact x
            , maybe [] (schemaTypeToXML "description") $ testScript_description x
            , concatMap (schemaTypeToXML "useContext") $ testScript_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ testScript_jurisdiction x
            , maybe [] (schemaTypeToXML "purpose") $ testScript_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ testScript_copyright x
            , concatMap (schemaTypeToXML "origin") $ testScript_origin x
            , concatMap (schemaTypeToXML "destination") $ testScript_destination x
            , maybe [] (schemaTypeToXML "metadata") $ testScript_metadata x
            , concatMap (schemaTypeToXML "fixture") $ testScript_fixture x
            , concatMap (schemaTypeToXML "profile") $ testScript_profile x
            , concatMap (schemaTypeToXML "variable") $ testScript_variable x
            , concatMap (schemaTypeToXML "rule") $ testScript_rule x
            , concatMap (schemaTypeToXML "ruleset") $ testScript_ruleset x
            , maybe [] (schemaTypeToXML "setup") $ testScript_setup x
            , concatMap (schemaTypeToXML "test") $ testScript_test x
            , maybe [] (schemaTypeToXML "teardown") $ testScript_teardown x
            ]
instance Extension TestScript DomainResource where
    supertype (TestScript e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26 e27 e28 e29 e30 e31 e32 e33) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension TestScript Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: TestScript -> DomainResource)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptOrigin = TestScriptOrigin
        { testScriptOrigin_id :: Maybe String_primitive
        , testScriptOrigin_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptOrigin_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptOrigin_index :: Integer
          -- ^ Abstract name given to an origin server in this test 
          --   script. The name is provided as a number starting at 1.
        , testScriptOrigin_profile :: Coding
          -- ^ The type of origin profile the test system supports.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptOrigin where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptOrigin a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "index"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@TestScriptOrigin{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptOrigin_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptOrigin_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptOrigin_modifierExtension x
            , schemaTypeToXML "index" $ testScriptOrigin_index x
            , schemaTypeToXML "profile" $ testScriptOrigin_profile x
            ]
instance Extension TestScriptOrigin BackboneElement where
    supertype (TestScriptOrigin a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptOrigin Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptOrigin -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptDestination = TestScriptDestination
        { testScriptDestination_id :: Maybe String_primitive
        , testScriptDestination_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptDestination_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptDestination_index :: Integer
          -- ^ Abstract name given to a destination server in this test 
          --   script. The name is provided as a number starting at 1.
        , testScriptDestination_profile :: Coding
          -- ^ The type of destination profile the test system supports.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptDestination where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptDestination a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "index"
            `apply` parseSchemaType "profile"
    schemaTypeToXML s x@TestScriptDestination{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptDestination_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptDestination_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptDestination_modifierExtension x
            , schemaTypeToXML "index" $ testScriptDestination_index x
            , schemaTypeToXML "profile" $ testScriptDestination_profile x
            ]
instance Extension TestScriptDestination BackboneElement where
    supertype (TestScriptDestination a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptDestination Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptDestination -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptMetadata = TestScriptMetadata
        { testScriptMetadata_id :: Maybe String_primitive
        , testScriptMetadata_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptMetadata_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptMetadata_link :: [TestScriptLink]
          -- ^ A link to the FHIR specification that this test is 
          --   covering.
        , testScriptMetadata_capability :: [TestScriptCapability]
          -- ^ Capabilities that must exist and are assumed to function 
          --   correctly on the FHIR server being tested.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptMetadata where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptMetadata a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "link")
            `apply` many1 (parseSchemaType "capability")
    schemaTypeToXML s x@TestScriptMetadata{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptMetadata_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptMetadata_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptMetadata_modifierExtension x
            , concatMap (schemaTypeToXML "link") $ testScriptMetadata_link x
            , concatMap (schemaTypeToXML "capability") $ testScriptMetadata_capability x
            ]
instance Extension TestScriptMetadata BackboneElement where
    supertype (TestScriptMetadata a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptMetadata Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptMetadata -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptLink = TestScriptLink
        { testScriptLink_id :: Maybe String_primitive
        , testScriptLink_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptLink_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptLink_url :: Uri
          -- ^ URL to a particular requirement or feature within the FHIR 
          --   specification.
        , testScriptLink_description :: Maybe Xsd.XsdString
          -- ^ Short description of the link.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptLink where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptLink a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "url"
            `apply` optional (parseSchemaType "description")
    schemaTypeToXML s x@TestScriptLink{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptLink_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptLink_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptLink_modifierExtension x
            , schemaTypeToXML "url" $ testScriptLink_url x
            , maybe [] (schemaTypeToXML "description") $ testScriptLink_description x
            ]
instance Extension TestScriptLink BackboneElement where
    supertype (TestScriptLink a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptLink Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptLink -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptCapability = TestScriptCapability
        { testScriptCapability_id :: Maybe String_primitive
        , testScriptCapability_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptCapability_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptCapability_required :: Maybe Boolean
          -- ^ Whether or not the test execution will require the given 
          --   capabilities of the server in order for this test script to 
          --   execute.
        , testScriptCapability_validated :: Maybe Boolean
          -- ^ Whether or not the test execution will validate the given 
          --   capabilities of the server in order for this test script to 
          --   execute.
        , testScriptCapability_description :: Maybe Xsd.XsdString
          -- ^ Description of the capabilities that this test script is 
          --   requiring the server to support.
        , testScriptCapability_origin :: [Integer]
          -- ^ Which origin server these requirements apply to.
        , testScriptCapability_destination :: Maybe Integer
          -- ^ Which server these requirements apply to.
        , testScriptCapability_link :: [Uri]
          -- ^ Links to the FHIR specification that describes this 
          --   interaction and the resources involved in more detail.
        , testScriptCapability_capabilities :: Reference
          -- ^ Minimum capabilities required of server for test script to 
          --   execute successfully. If server does not meet at a minimum 
          --   the referenced capability statement, then all tests in this 
          --   script are skipped.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptCapability where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptCapability a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "required")
            `apply` optional (parseSchemaType "validated")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "origin")
            `apply` optional (parseSchemaType "destination")
            `apply` many (parseSchemaType "link")
            `apply` parseSchemaType "capabilities"
    schemaTypeToXML s x@TestScriptCapability{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptCapability_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptCapability_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptCapability_modifierExtension x
            , maybe [] (schemaTypeToXML "required") $ testScriptCapability_required x
            , maybe [] (schemaTypeToXML "validated") $ testScriptCapability_validated x
            , maybe [] (schemaTypeToXML "description") $ testScriptCapability_description x
            , concatMap (schemaTypeToXML "origin") $ testScriptCapability_origin x
            , maybe [] (schemaTypeToXML "destination") $ testScriptCapability_destination x
            , concatMap (schemaTypeToXML "link") $ testScriptCapability_link x
            , schemaTypeToXML "capabilities" $ testScriptCapability_capabilities x
            ]
instance Extension TestScriptCapability BackboneElement where
    supertype (TestScriptCapability a0 e0 e1 e2 e3 e4 e5 e6 e7 e8) =
               BackboneElement a0 e0 e1
instance Extension TestScriptCapability Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptCapability -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptFixture = TestScriptFixture
        { testScriptFixture_id :: Maybe String_primitive
        , testScriptFixture_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptFixture_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptFixture_autocreate :: Maybe Boolean
          -- ^ Whether or not to implicitly create the fixture during 
          --   setup. If true, the fixture is automatically created on 
          --   each server being tested during setup, therefore no create 
          --   operation is required for this fixture in the 
          --   TestScript.setup section.
        , testScriptFixture_autodelete :: Maybe Boolean
          -- ^ Whether or not to implicitly delete the fixture during 
          --   teardown. If true, the fixture is automatically deleted on 
          --   each server being tested during teardown, therefore no 
          --   delete operation is required for this fixture in the 
          --   TestScript.teardown section.
        , testScriptFixture_resource :: Maybe Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   resource needed for operations).
        }
        deriving (Eq,Show)
instance SchemaType TestScriptFixture where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptFixture a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "autocreate")
            `apply` optional (parseSchemaType "autodelete")
            `apply` optional (parseSchemaType "resource")
    schemaTypeToXML s x@TestScriptFixture{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptFixture_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptFixture_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptFixture_modifierExtension x
            , maybe [] (schemaTypeToXML "autocreate") $ testScriptFixture_autocreate x
            , maybe [] (schemaTypeToXML "autodelete") $ testScriptFixture_autodelete x
            , maybe [] (schemaTypeToXML "resource") $ testScriptFixture_resource x
            ]
instance Extension TestScriptFixture BackboneElement where
    supertype (TestScriptFixture a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestScriptFixture Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptFixture -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptVariable = TestScriptVariable
        { testScriptVariable_id :: Maybe String_primitive
        , testScriptVariable_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptVariable_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptVariable_name :: Xsd.XsdString
          -- ^ Descriptive name for this variable.
        , testScriptVariable_defaultValue :: Maybe Xsd.XsdString
          -- ^ A default, hard-coded, or user-defined value for this 
          --   variable.
        , testScriptVariable_description :: Maybe Xsd.XsdString
          -- ^ A free text natural language description of the variable 
          --   and its purpose.
        , testScriptVariable_expression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to evaluate against the fixture 
          --   body. When variables are defined, only one of either 
          --   expression, headerField or path must be specified.
        , testScriptVariable_headerField :: Maybe Xsd.XsdString
          -- ^ Will be used to grab the HTTP header field value from the 
          --   headers that sourceId is pointing to.
        , testScriptVariable_hint :: Maybe Xsd.XsdString
          -- ^ Displayable text string with hint help information to the 
          --   user when entering a default value.
        , testScriptVariable_path :: Maybe Xsd.XsdString
          -- ^ XPath or JSONPath to evaluate against the fixture body. 
          --   When variables are defined, only one of either expression, 
          --   headerField or path must be specified.
        , testScriptVariable_sourceId :: Maybe Id
          -- ^ Fixture to evaluate the XPath/JSONPath expression or the 
          --   headerField against within this variable.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptVariable where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptVariable a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "defaultValue")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "headerField")
            `apply` optional (parseSchemaType "hint")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "sourceId")
    schemaTypeToXML s x@TestScriptVariable{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptVariable_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptVariable_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptVariable_modifierExtension x
            , schemaTypeToXML "name" $ testScriptVariable_name x
            , maybe [] (schemaTypeToXML "defaultValue") $ testScriptVariable_defaultValue x
            , maybe [] (schemaTypeToXML "description") $ testScriptVariable_description x
            , maybe [] (schemaTypeToXML "expression") $ testScriptVariable_expression x
            , maybe [] (schemaTypeToXML "headerField") $ testScriptVariable_headerField x
            , maybe [] (schemaTypeToXML "hint") $ testScriptVariable_hint x
            , maybe [] (schemaTypeToXML "path") $ testScriptVariable_path x
            , maybe [] (schemaTypeToXML "sourceId") $ testScriptVariable_sourceId x
            ]
instance Extension TestScriptVariable BackboneElement where
    supertype (TestScriptVariable a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension TestScriptVariable Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptVariable -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRule = TestScriptRule
        { testScriptRule_id :: Maybe String_primitive
        , testScriptRule_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRule_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRule_resource :: Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   rule needed for assertions).
        , testScriptRule_param :: [TestScriptParam]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRule where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRule a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "resource"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScriptRule{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRule_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRule_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRule_modifierExtension x
            , schemaTypeToXML "resource" $ testScriptRule_resource x
            , concatMap (schemaTypeToXML "param") $ testScriptRule_param x
            ]
instance Extension TestScriptRule BackboneElement where
    supertype (TestScriptRule a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRule Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRule -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptParam = TestScriptParam
        { testScriptParam_id :: Maybe String_primitive
        , testScriptParam_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptParam_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptParam_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert rule parameter name.
        , testScriptParam_value :: Maybe Xsd.XsdString
          -- ^ The explicit or dynamic value for the parameter that will 
          --   be passed on to the external rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptParam where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptParam a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@TestScriptParam{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptParam_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptParam_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptParam_modifierExtension x
            , schemaTypeToXML "name" $ testScriptParam_name x
            , maybe [] (schemaTypeToXML "value") $ testScriptParam_value x
            ]
instance Extension TestScriptParam BackboneElement where
    supertype (TestScriptParam a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptParam Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptParam -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRuleset = TestScriptRuleset
        { testScriptRuleset_id :: Maybe String_primitive
        , testScriptRuleset_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRuleset_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRuleset_resource :: Reference
          -- ^ Reference to the resource (containing the contents of the 
          --   ruleset needed for assertions).
        , testScriptRuleset_rule :: [TestScriptRule1]
          -- ^ The referenced rule within the external ruleset template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRuleset where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRuleset a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "resource"
            `apply` many1 (parseSchemaType "rule")
    schemaTypeToXML s x@TestScriptRuleset{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRuleset_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRuleset_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRuleset_modifierExtension x
            , schemaTypeToXML "resource" $ testScriptRuleset_resource x
            , concatMap (schemaTypeToXML "rule") $ testScriptRuleset_rule x
            ]
instance Extension TestScriptRuleset BackboneElement where
    supertype (TestScriptRuleset a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRuleset Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRuleset -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRule1 = TestScriptRule1
        { testScriptRule1_id :: Maybe String_primitive
        , testScriptRule1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRule1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRule1_ruleId :: Id
          -- ^ Id of the referenced rule within the external ruleset 
          --   template.
        , testScriptRule1_param :: [TestScriptParam1]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRule1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRule1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScriptRule1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRule1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRule1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRule1_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScriptRule1_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScriptRule1_param x
            ]
instance Extension TestScriptRule1 BackboneElement where
    supertype (TestScriptRule1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRule1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRule1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptParam1 = TestScriptParam1
        { testScriptParam1_id :: Maybe String_primitive
        , testScriptParam1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptParam1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptParam1_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert ruleset rule parameter name.
        , testScriptParam1_value :: Maybe Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external ruleset rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptParam1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptParam1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (parseSchemaType "value")
    schemaTypeToXML s x@TestScriptParam1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptParam1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptParam1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptParam1_modifierExtension x
            , schemaTypeToXML "name" $ testScriptParam1_name x
            , maybe [] (schemaTypeToXML "value") $ testScriptParam1_value x
            ]
instance Extension TestScriptParam1 BackboneElement where
    supertype (TestScriptParam1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptParam1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptParam1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptSetup = TestScriptSetup
        { testScriptSetup_id :: Maybe String_primitive
        , testScriptSetup_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptSetup_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptSetup_action :: [TestScriptAction]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptSetup where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptSetup a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScriptSetup{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptSetup_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptSetup_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptSetup_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testScriptSetup_action x
            ]
instance Extension TestScriptSetup BackboneElement where
    supertype (TestScriptSetup a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScriptSetup Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptSetup -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptAction = TestScriptAction
        { testScriptAction_id :: Maybe String_primitive
        , testScriptAction_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptAction_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptAction_operation :: Maybe TestScriptOperation
          -- ^ The operation to perform.
        , testScriptAction_assert :: Maybe TestScriptAssert
          -- ^ Evaluates the results of previous operations to determine 
          --   if the server under test behaves appropriately.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptAction where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptAction a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestScriptAction{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptAction_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptAction_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptAction_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testScriptAction_operation x
            , maybe [] (schemaTypeToXML "assert") $ testScriptAction_assert x
            ]
instance Extension TestScriptAction BackboneElement where
    supertype (TestScriptAction a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptAction Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptAction -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptOperation = TestScriptOperation
        { testScriptOperation_id :: Maybe String_primitive
        , testScriptOperation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptOperation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptOperation_type :: Maybe Coding
          -- ^ Server interaction or operation type.
        , testScriptOperation_resource :: Maybe FHIRDefinedType
          -- ^ The type of the resource. See 
          --   http://hl7.org/fhir/resourcelist.html.
        , testScriptOperation_label :: Maybe Xsd.XsdString
          -- ^ The label would be used for tracking/logging purposes by 
          --   test engines.
        , testScriptOperation_description :: Maybe Xsd.XsdString
          -- ^ The description would be used by test engines for tracking 
          --   and reporting purposes.
        , testScriptOperation_accept :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Accept' header.
        , testScriptOperation_contentType :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Content-Type' header.
        , testScriptOperation_destination :: Maybe Integer
          -- ^ The server where the request message is destined for. Must 
          --   be one of the server numbers listed in 
          --   TestScript.destination section.
        , testScriptOperation_encodeRequestUrl :: Maybe Boolean
          -- ^ Whether or not to implicitly send the request url in 
          --   encoded format. The default is true to match the standard 
          --   RESTful client behavior. Set to false when communicating 
          --   with a server that does not support encoded url paths.
        , testScriptOperation_origin :: Maybe Integer
          -- ^ The server where the request message originates from. Must 
          --   be one of the server numbers listed in TestScript.origin 
          --   section.
        , testScriptOperation_params :: Maybe Xsd.XsdString
          -- ^ Path plus parameters after [type]. Used to set parts of the 
          --   request URL explicitly.
        , testScriptOperation_requestHeader :: [TestScriptRequestHeader]
          -- ^ Header elements would be used to set HTTP headers.
        , testScriptOperation_requestId :: Maybe Id
          -- ^ The fixture id (maybe new) to map to the request.
        , testScriptOperation_responseId :: Maybe Id
          -- ^ The fixture id (maybe new) to map to the response.
        , testScriptOperation_sourceId :: Maybe Id
          -- ^ The id of the fixture used as the body of a PUT or POST 
          --   request.
        , testScriptOperation_targetId :: Maybe Id
          -- ^ Id of fixture used for extracting the [id], [type], and 
          --   [vid] for GET requests.
        , testScriptOperation_url :: Maybe Xsd.XsdString
          -- ^ Complete request URL.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptOperation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptOperation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "type")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "accept")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "destination")
            `apply` optional (parseSchemaType "encodeRequestUrl")
            `apply` optional (parseSchemaType "origin")
            `apply` optional (parseSchemaType "params")
            `apply` many (parseSchemaType "requestHeader")
            `apply` optional (parseSchemaType "requestId")
            `apply` optional (parseSchemaType "responseId")
            `apply` optional (parseSchemaType "sourceId")
            `apply` optional (parseSchemaType "targetId")
            `apply` optional (parseSchemaType "url")
    schemaTypeToXML s x@TestScriptOperation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptOperation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptOperation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptOperation_modifierExtension x
            , maybe [] (schemaTypeToXML "type") $ testScriptOperation_type x
            , maybe [] (schemaTypeToXML "resource") $ testScriptOperation_resource x
            , maybe [] (schemaTypeToXML "label") $ testScriptOperation_label x
            , maybe [] (schemaTypeToXML "description") $ testScriptOperation_description x
            , maybe [] (schemaTypeToXML "accept") $ testScriptOperation_accept x
            , maybe [] (schemaTypeToXML "contentType") $ testScriptOperation_contentType x
            , maybe [] (schemaTypeToXML "destination") $ testScriptOperation_destination x
            , maybe [] (schemaTypeToXML "encodeRequestUrl") $ testScriptOperation_encodeRequestUrl x
            , maybe [] (schemaTypeToXML "origin") $ testScriptOperation_origin x
            , maybe [] (schemaTypeToXML "params") $ testScriptOperation_params x
            , concatMap (schemaTypeToXML "requestHeader") $ testScriptOperation_requestHeader x
            , maybe [] (schemaTypeToXML "requestId") $ testScriptOperation_requestId x
            , maybe [] (schemaTypeToXML "responseId") $ testScriptOperation_responseId x
            , maybe [] (schemaTypeToXML "sourceId") $ testScriptOperation_sourceId x
            , maybe [] (schemaTypeToXML "targetId") $ testScriptOperation_targetId x
            , maybe [] (schemaTypeToXML "url") $ testScriptOperation_url x
            ]
instance Extension TestScriptOperation BackboneElement where
    supertype (TestScriptOperation a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17) =
               BackboneElement a0 e0 e1
instance Extension TestScriptOperation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptOperation -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRequestHeader = TestScriptRequestHeader
        { testScriptRequestHeader_id :: Maybe String_primitive
        , testScriptRequestHeader_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRequestHeader_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRequestHeader_field :: Xsd.XsdString
          -- ^ The HTTP header field e.g. &quot;Accept&quot;.
        , testScriptRequestHeader_value :: Xsd.XsdString
          -- ^ The value of the header e.g. 
          --   &quot;application/fhir+xml&quot;.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRequestHeader where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRequestHeader a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "field"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScriptRequestHeader{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRequestHeader_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRequestHeader_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRequestHeader_modifierExtension x
            , schemaTypeToXML "field" $ testScriptRequestHeader_field x
            , schemaTypeToXML "value" $ testScriptRequestHeader_value x
            ]
instance Extension TestScriptRequestHeader BackboneElement where
    supertype (TestScriptRequestHeader a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRequestHeader Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRequestHeader -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptAssert = TestScriptAssert
        { testScriptAssert_id :: Maybe String_primitive
        , testScriptAssert_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptAssert_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptAssert_label :: Maybe Xsd.XsdString
          -- ^ The label would be used for tracking/logging purposes by 
          --   test engines.
        , testScriptAssert_description :: Maybe Xsd.XsdString
          -- ^ The description would be used by test engines for tracking 
          --   and reporting purposes.
        , testScriptAssert_direction :: Maybe AssertionDirectionType
          -- ^ The direction to use for the assertion.
        , testScriptAssert_compareToSourceId :: Maybe Xsd.XsdString
          -- ^ Id of the source fixture used as the contents to be 
          --   evaluated by either the &quot;source/expression&quot; or 
          --   &quot;sourceId/path&quot; definition.
        , testScriptAssert_compareToSourceExpression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to evaluate against the source 
          --   fixture. When compareToSourceId is defined, either 
          --   compareToSourceExpression or compareToSourcePath must be 
          --   defined, but not both.
        , testScriptAssert_compareToSourcePath :: Maybe Xsd.XsdString
          -- ^ XPath or JSONPath expression to evaluate against the source 
          --   fixture. When compareToSourceId is defined, either 
          --   compareToSourceExpression or compareToSourcePath must be 
          --   defined, but not both.
        , testScriptAssert_contentType :: Maybe ContentType
          -- ^ The content-type or mime-type to use for RESTful operation 
          --   in the 'Content-Type' header.
        , testScriptAssert_expression :: Maybe Xsd.XsdString
          -- ^ The fluentpath expression to be evaluated against the 
          --   request or response message contents - HTTP headers and 
          --   payload.
        , testScriptAssert_headerField :: Maybe Xsd.XsdString
          -- ^ The HTTP header field name e.g. 'Location'.
        , testScriptAssert_minimumId :: Maybe Xsd.XsdString
          -- ^ The ID of a fixture. Asserts that the response contains at 
          --   a minimum the fixture specified by minimumId.
        , testScriptAssert_navigationLinks :: Maybe Boolean
          -- ^ Whether or not the test execution performs validation on 
          --   the bundle navigation links.
        , testScriptAssert_operator :: Maybe AssertionOperatorType
          -- ^ The operator type defines the conditional behavior of the 
          --   assert. If not defined, the default is equals.
        , testScriptAssert_path :: Maybe Xsd.XsdString
          -- ^ The XPath or JSONPath expression to be evaluated against 
          --   the fixture representing the response received from server.
        , testScriptAssert_requestMethod :: Maybe TestScriptRequestMethodCode
          -- ^ The request method or HTTP operation code to compare 
          --   against that used by the client system under test.
        , testScriptAssert_requestURL :: Maybe Xsd.XsdString
          -- ^ The value to use in a comparison against the request URL 
          --   path string.
        , testScriptAssert_resource :: Maybe FHIRDefinedType
          -- ^ The type of the resource. See 
          --   http://hl7.org/fhir/resourcelist.html.
        , testScriptAssert_response :: Maybe AssertionResponseTypes
          -- ^ okay | created | noContent | notModified | bad | forbidden 
          --   | notFound | methodNotAllowed | conflict | gone | 
          --   preconditionFailed | unprocessable.
        , testScriptAssert_responseCode :: Maybe Xsd.XsdString
          -- ^ The value of the HTTP response code to be tested.
        , testScriptAssert_rule :: Maybe TestScriptRule2
          -- ^ The TestScript.rule this assert will evaluate.
        , testScriptAssert_ruleset :: Maybe TestScriptRuleset1
          -- ^ The TestScript.ruleset this assert will evaluate.
        , testScriptAssert_sourceId :: Maybe Id
          -- ^ Fixture to evaluate the XPath/JSONPath expression or the 
          --   headerField against.
        , testScriptAssert_validateProfileId :: Maybe Id
          -- ^ The ID of the Profile to validate against.
        , testScriptAssert_value :: Maybe Xsd.XsdString
          -- ^ The value to compare to.
        , testScriptAssert_warningOnly :: Maybe Boolean
          -- ^ Whether or not the test execution will produce a warning 
          --   only on error for this assert.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptAssert where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptAssert a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "label")
            `apply` optional (parseSchemaType "description")
            `apply` optional (parseSchemaType "direction")
            `apply` optional (parseSchemaType "compareToSourceId")
            `apply` optional (parseSchemaType "compareToSourceExpression")
            `apply` optional (parseSchemaType "compareToSourcePath")
            `apply` optional (parseSchemaType "contentType")
            `apply` optional (parseSchemaType "expression")
            `apply` optional (parseSchemaType "headerField")
            `apply` optional (parseSchemaType "minimumId")
            `apply` optional (parseSchemaType "navigationLinks")
            `apply` optional (parseSchemaType "operator")
            `apply` optional (parseSchemaType "path")
            `apply` optional (parseSchemaType "requestMethod")
            `apply` optional (parseSchemaType "requestURL")
            `apply` optional (parseSchemaType "resource")
            `apply` optional (parseSchemaType "response")
            `apply` optional (parseSchemaType "responseCode")
            `apply` optional (parseSchemaType "rule")
            `apply` optional (parseSchemaType "ruleset")
            `apply` optional (parseSchemaType "sourceId")
            `apply` optional (parseSchemaType "validateProfileId")
            `apply` optional (parseSchemaType "value")
            `apply` optional (parseSchemaType "warningOnly")
    schemaTypeToXML s x@TestScriptAssert{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptAssert_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptAssert_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptAssert_modifierExtension x
            , maybe [] (schemaTypeToXML "label") $ testScriptAssert_label x
            , maybe [] (schemaTypeToXML "description") $ testScriptAssert_description x
            , maybe [] (schemaTypeToXML "direction") $ testScriptAssert_direction x
            , maybe [] (schemaTypeToXML "compareToSourceId") $ testScriptAssert_compareToSourceId x
            , maybe [] (schemaTypeToXML "compareToSourceExpression") $ testScriptAssert_compareToSourceExpression x
            , maybe [] (schemaTypeToXML "compareToSourcePath") $ testScriptAssert_compareToSourcePath x
            , maybe [] (schemaTypeToXML "contentType") $ testScriptAssert_contentType x
            , maybe [] (schemaTypeToXML "expression") $ testScriptAssert_expression x
            , maybe [] (schemaTypeToXML "headerField") $ testScriptAssert_headerField x
            , maybe [] (schemaTypeToXML "minimumId") $ testScriptAssert_minimumId x
            , maybe [] (schemaTypeToXML "navigationLinks") $ testScriptAssert_navigationLinks x
            , maybe [] (schemaTypeToXML "operator") $ testScriptAssert_operator x
            , maybe [] (schemaTypeToXML "path") $ testScriptAssert_path x
            , maybe [] (schemaTypeToXML "requestMethod") $ testScriptAssert_requestMethod x
            , maybe [] (schemaTypeToXML "requestURL") $ testScriptAssert_requestURL x
            , maybe [] (schemaTypeToXML "resource") $ testScriptAssert_resource x
            , maybe [] (schemaTypeToXML "response") $ testScriptAssert_response x
            , maybe [] (schemaTypeToXML "responseCode") $ testScriptAssert_responseCode x
            , maybe [] (schemaTypeToXML "rule") $ testScriptAssert_rule x
            , maybe [] (schemaTypeToXML "ruleset") $ testScriptAssert_ruleset x
            , maybe [] (schemaTypeToXML "sourceId") $ testScriptAssert_sourceId x
            , maybe [] (schemaTypeToXML "validateProfileId") $ testScriptAssert_validateProfileId x
            , maybe [] (schemaTypeToXML "value") $ testScriptAssert_value x
            , maybe [] (schemaTypeToXML "warningOnly") $ testScriptAssert_warningOnly x
            ]
instance Extension TestScriptAssert BackboneElement where
    supertype (TestScriptAssert a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25) =
               BackboneElement a0 e0 e1
instance Extension TestScriptAssert Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptAssert -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRule2 = TestScriptRule2
        { testScriptRule2_id :: Maybe String_primitive
        , testScriptRule2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRule2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRule2_ruleId :: Id
          -- ^ The TestScript.rule id value this assert will evaluate.
        , testScriptRule2_param :: [TestScriptParam2]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRule2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRule2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScriptRule2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRule2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRule2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRule2_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScriptRule2_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScriptRule2_param x
            ]
instance Extension TestScriptRule2 BackboneElement where
    supertype (TestScriptRule2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRule2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRule2 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptParam2 = TestScriptParam2
        { testScriptParam2_id :: Maybe String_primitive
        , testScriptParam2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptParam2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptParam2_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert rule parameter name.
        , testScriptParam2_value :: Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptParam2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptParam2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScriptParam2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptParam2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptParam2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptParam2_modifierExtension x
            , schemaTypeToXML "name" $ testScriptParam2_name x
            , schemaTypeToXML "value" $ testScriptParam2_value x
            ]
instance Extension TestScriptParam2 BackboneElement where
    supertype (TestScriptParam2 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptParam2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptParam2 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRuleset1 = TestScriptRuleset1
        { testScriptRuleset1_id :: Maybe String_primitive
        , testScriptRuleset1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRuleset1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRuleset1_rulesetId :: Id
          -- ^ The TestScript.ruleset id value this assert will evaluate.
        , testScriptRuleset1_rule :: [TestScriptRule3]
          -- ^ The referenced rule within the external ruleset template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRuleset1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRuleset1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "rulesetId"
            `apply` many (parseSchemaType "rule")
    schemaTypeToXML s x@TestScriptRuleset1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRuleset1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRuleset1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRuleset1_modifierExtension x
            , schemaTypeToXML "rulesetId" $ testScriptRuleset1_rulesetId x
            , concatMap (schemaTypeToXML "rule") $ testScriptRuleset1_rule x
            ]
instance Extension TestScriptRuleset1 BackboneElement where
    supertype (TestScriptRuleset1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRuleset1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRuleset1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptRule3 = TestScriptRule3
        { testScriptRule3_id :: Maybe String_primitive
        , testScriptRule3_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptRule3_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptRule3_ruleId :: Id
          -- ^ Id of the referenced rule within the external ruleset 
          --   template.
        , testScriptRule3_param :: [TestScriptParam3]
          -- ^ Each rule template can take one or more parameters for rule 
          --   evaluation.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRule3 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptRule3 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "ruleId"
            `apply` many (parseSchemaType "param")
    schemaTypeToXML s x@TestScriptRule3{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRule3_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRule3_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptRule3_modifierExtension x
            , schemaTypeToXML "ruleId" $ testScriptRule3_ruleId x
            , concatMap (schemaTypeToXML "param") $ testScriptRule3_param x
            ]
instance Extension TestScriptRule3 BackboneElement where
    supertype (TestScriptRule3 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptRule3 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptRule3 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptParam3 = TestScriptParam3
        { testScriptParam3_id :: Maybe String_primitive
        , testScriptParam3_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptParam3_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptParam3_name :: Xsd.XsdString
          -- ^ Descriptive name for this parameter that matches the 
          --   external assert ruleset rule parameter name.
        , testScriptParam3_value :: Xsd.XsdString
          -- ^ The value for the parameter that will be passed on to the 
          --   external ruleset rule template.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptParam3 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptParam3 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@TestScriptParam3{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptParam3_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptParam3_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptParam3_modifierExtension x
            , schemaTypeToXML "name" $ testScriptParam3_name x
            , schemaTypeToXML "value" $ testScriptParam3_value x
            ]
instance Extension TestScriptParam3 BackboneElement where
    supertype (TestScriptParam3 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptParam3 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptParam3 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptTest = TestScriptTest
        { testScriptTest_id :: Maybe String_primitive
        , testScriptTest_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptTest_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptTest_name :: Maybe Xsd.XsdString
          -- ^ The name of this test used for tracking/logging purposes by 
          --   test engines.
        , testScriptTest_description :: Maybe Xsd.XsdString
          -- ^ A short description of the test used by test engines for 
          --   tracking and reporting purposes.
        , testScriptTest_action :: [TestScriptAction1]
          -- ^ Action would contain either an operation or an assertion.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptTest where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptTest a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "description")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScriptTest{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptTest_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptTest_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptTest_modifierExtension x
            , maybe [] (schemaTypeToXML "name") $ testScriptTest_name x
            , maybe [] (schemaTypeToXML "description") $ testScriptTest_description x
            , concatMap (schemaTypeToXML "action") $ testScriptTest_action x
            ]
instance Extension TestScriptTest BackboneElement where
    supertype (TestScriptTest a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension TestScriptTest Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptTest -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptAction1 = TestScriptAction1
        { testScriptAction1_id :: Maybe String_primitive
        , testScriptAction1_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptAction1_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptAction1_operation :: Maybe TestScriptOperation
          -- ^ An operation would involve a REST request to a server.
        , testScriptAction1_assert :: Maybe TestScriptAssert
          -- ^ Evaluates the results of previous operations to determine 
          --   if the server under test behaves appropriately.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptAction1 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptAction1 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "operation")
            `apply` optional (parseSchemaType "assert")
    schemaTypeToXML s x@TestScriptAction1{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptAction1_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptAction1_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptAction1_modifierExtension x
            , maybe [] (schemaTypeToXML "operation") $ testScriptAction1_operation x
            , maybe [] (schemaTypeToXML "assert") $ testScriptAction1_assert x
            ]
instance Extension TestScriptAction1 BackboneElement where
    supertype (TestScriptAction1 a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension TestScriptAction1 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptAction1 -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptTeardown = TestScriptTeardown
        { testScriptTeardown_id :: Maybe String_primitive
        , testScriptTeardown_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptTeardown_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptTeardown_action :: [TestScriptAction2]
          -- ^ The teardown action will only contain an operation.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptTeardown where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptTeardown a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many1 (parseSchemaType "action")
    schemaTypeToXML s x@TestScriptTeardown{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptTeardown_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptTeardown_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptTeardown_modifierExtension x
            , concatMap (schemaTypeToXML "action") $ testScriptTeardown_action x
            ]
instance Extension TestScriptTeardown BackboneElement where
    supertype (TestScriptTeardown a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScriptTeardown Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptTeardown -> BackboneElement)
              
 
-- | A structured set of tests against a FHIR server 
--   implementation to determine compliance against the FHIR 
--   specification.
data TestScriptAction2 = TestScriptAction2
        { testScriptAction2_id :: Maybe String_primitive
        , testScriptAction2_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , testScriptAction2_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , testScriptAction2_operation :: TestScriptOperation
          -- ^ An operation would involve a REST request to a server.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptAction2 where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (TestScriptAction2 a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "operation"
    schemaTypeToXML s x@TestScriptAction2{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptAction2_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptAction2_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ testScriptAction2_modifierExtension x
            , schemaTypeToXML "operation" $ testScriptAction2_operation x
            ]
instance Extension TestScriptAction2 BackboneElement where
    supertype (TestScriptAction2 a0 e0 e1 e2) =
               BackboneElement a0 e0 e1
instance Extension TestScriptAction2 Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: TestScriptAction2 -> BackboneElement)
              
 
data FHIRDefinedType_list
    = FHIRDefinedType_list_Address
      -- ^ Address
    | FHIRDefinedType_list_Age
      -- ^ Age
    | FHIRDefinedType_list_Annotation
      -- ^ Annotation
    | FHIRDefinedType_list_Attachment
      -- ^ Attachment
    | FHIRDefinedType_list_BackboneElement
      -- ^ BackboneElement
    | FHIRDefinedType_list_CodeableConcept
      -- ^ CodeableConcept
    | FHIRDefinedType_list_Coding
      -- ^ Coding
    | FHIRDefinedType_list_ContactDetail
      -- ^ ContactDetail
    | FHIRDefinedType_list_ContactPoint
      -- ^ ContactPoint
    | FHIRDefinedType_list_Contributor
      -- ^ Contributor
    | FHIRDefinedType_list_Count
      -- ^ Count
    | FHIRDefinedType_list_DataRequirement
      -- ^ DataRequirement
    | FHIRDefinedType_list_Distance
      -- ^ Distance
    | FHIRDefinedType_list_Dosage
      -- ^ Dosage
    | FHIRDefinedType_list_Duration
      -- ^ Duration
    | FHIRDefinedType_list_Element
      -- ^ Element
    | FHIRDefinedType_list_ElementDefinition
      -- ^ ElementDefinition
    | FHIRDefinedType_list_Extension
      -- ^ Extension
    | FHIRDefinedType_list_HumanName
      -- ^ HumanName
    | FHIRDefinedType_list_Identifier
      -- ^ Identifier
    | FHIRDefinedType_list_Meta
      -- ^ Meta
    | FHIRDefinedType_list_Money
      -- ^ Money
    | FHIRDefinedType_list_Narrative
      -- ^ Narrative
    | FHIRDefinedType_list_ParameterDefinition
      -- ^ ParameterDefinition
    | FHIRDefinedType_list_Period
      -- ^ Period
    | FHIRDefinedType_list_Quantity
      -- ^ Quantity
    | FHIRDefinedType_list_Range
      -- ^ Range
    | FHIRDefinedType_list_Ratio
      -- ^ Ratio
    | FHIRDefinedType_list_Reference
      -- ^ Reference
    | FHIRDefinedType_list_RelatedArtifact
      -- ^ RelatedArtifact
    | FHIRDefinedType_list_SampledData
      -- ^ SampledData
    | FHIRDefinedType_list_Signature
      -- ^ Signature
    | FHIRDefinedType_list_SimpleQuantity
      -- ^ SimpleQuantity
    | FHIRDefinedType_list_Timing
      -- ^ Timing
    | FHIRDefinedType_list_TriggerDefinition
      -- ^ TriggerDefinition
    | FHIRDefinedType_list_UsageContext
      -- ^ UsageContext
    | FHIRDefinedType_list_Base64Binary
      -- ^ base64Binary
    | FHIRDefinedType_list_Boolean
      -- ^ boolean
    | FHIRDefinedType_list_Code
      -- ^ code
    | FHIRDefinedType_list_Date
      -- ^ date
    | FHIRDefinedType_list_DateTime
      -- ^ dateTime
    | FHIRDefinedType_list_Decimal
      -- ^ decimal
    | FHIRDefinedType_list_Id
      -- ^ id
    | FHIRDefinedType_list_Instant
      -- ^ instant
    | FHIRDefinedType_list_Integer
      -- ^ integer
    | FHIRDefinedType_list_Markdown
      -- ^ markdown
    | FHIRDefinedType_list_Oid
      -- ^ oid
    | FHIRDefinedType_list_PositiveInt
      -- ^ positiveInt
    | FHIRDefinedType_list_Xsd.XsdString
      -- ^ string
    | FHIRDefinedType_list_Time
      -- ^ time
    | FHIRDefinedType_list_UnsignedInt
      -- ^ unsignedInt
    | FHIRDefinedType_list_Uri
      -- ^ uri
    | FHIRDefinedType_list_Uuid
      -- ^ uuid
    | FHIRDefinedType_list_Xhtml
      -- ^ XHTML
    | FHIRDefinedType_list_Account
      -- ^ Account
    | FHIRDefinedType_list_ActivityDefinition
      -- ^ ActivityDefinition
    | FHIRDefinedType_list_AdverseEvent
      -- ^ AdverseEvent
    | FHIRDefinedType_list_AllergyIntolerance
      -- ^ AllergyIntolerance
    | FHIRDefinedType_list_Appointment
      -- ^ Appointment
    | FHIRDefinedType_list_AppointmentResponse
      -- ^ AppointmentResponse
    | FHIRDefinedType_list_AuditEvent
      -- ^ AuditEvent
    | FHIRDefinedType_list_Basic
      -- ^ Basic
    | FHIRDefinedType_list_Binary
      -- ^ Binary
    | FHIRDefinedType_list_BodySite
      -- ^ BodySite
    | FHIRDefinedType_list_Bundle
      -- ^ Bundle
    | FHIRDefinedType_list_CapabilityStatement
      -- ^ CapabilityStatement
    | FHIRDefinedType_list_CarePlan
      -- ^ CarePlan
    | FHIRDefinedType_list_CareTeam
      -- ^ CareTeam
    | FHIRDefinedType_list_ChargeItem
      -- ^ ChargeItem
    | FHIRDefinedType_list_Claim
      -- ^ Claim
    | FHIRDefinedType_list_ClaimResponse
      -- ^ ClaimResponse
    | FHIRDefinedType_list_ClinicalImpression
      -- ^ ClinicalImpression
    | FHIRDefinedType_list_CodeSystem
      -- ^ CodeSystem
    | FHIRDefinedType_list_Communication
      -- ^ Communication
    | FHIRDefinedType_list_CommunicationRequest
      -- ^ CommunicationRequest
    | FHIRDefinedType_list_CompartmentDefinition
      -- ^ CompartmentDefinition
    | FHIRDefinedType_list_Composition
      -- ^ Composition
    | FHIRDefinedType_list_ConceptMap
      -- ^ ConceptMap
    | FHIRDefinedType_list_Condition
      -- ^ Condition
    | FHIRDefinedType_list_Consent
      -- ^ Consent
    | FHIRDefinedType_list_Contract
      -- ^ Contract
    | FHIRDefinedType_list_Coverage
      -- ^ Coverage
    | FHIRDefinedType_list_DataElement
      -- ^ DataElement
    | FHIRDefinedType_list_DetectedIssue
      -- ^ DetectedIssue
    | FHIRDefinedType_list_Device
      -- ^ Device
    | FHIRDefinedType_list_DeviceComponent
      -- ^ DeviceComponent
    | FHIRDefinedType_list_DeviceMetric
      -- ^ DeviceMetric
    | FHIRDefinedType_list_DeviceRequest
      -- ^ DeviceRequest
    | FHIRDefinedType_list_DeviceUseStatement
      -- ^ DeviceUseStatement
    | FHIRDefinedType_list_DiagnosticReport
      -- ^ DiagnosticReport
    | FHIRDefinedType_list_DocumentManifest
      -- ^ DocumentManifest
    | FHIRDefinedType_list_DocumentReference
      -- ^ DocumentReference
    | FHIRDefinedType_list_DomainResource
      -- ^ DomainResource
    | FHIRDefinedType_list_EligibilityRequest
      -- ^ EligibilityRequest
    | FHIRDefinedType_list_EligibilityResponse
      -- ^ EligibilityResponse
    | FHIRDefinedType_list_Encounter
      -- ^ Encounter
    | FHIRDefinedType_list_Endpoint
      -- ^ Endpoint
    | FHIRDefinedType_list_EnrollmentRequest
      -- ^ EnrollmentRequest
    | FHIRDefinedType_list_EnrollmentResponse
      -- ^ EnrollmentResponse
    | FHIRDefinedType_list_EpisodeOfCare
      -- ^ EpisodeOfCare
    | FHIRDefinedType_list_ExpansionProfile
      -- ^ ExpansionProfile
    | FHIRDefinedType_list_ExplanationOfBenefit
      -- ^ ExplanationOfBenefit
    | FHIRDefinedType_list_FamilyMemberHistory
      -- ^ FamilyMemberHistory
    | FHIRDefinedType_list_Flag
      -- ^ Flag
    | FHIRDefinedType_list_Goal
      -- ^ Goal
    | FHIRDefinedType_list_GraphDefinition
      -- ^ GraphDefinition
    | FHIRDefinedType_list_Group
      -- ^ Group
    | FHIRDefinedType_list_GuidanceResponse
      -- ^ GuidanceResponse
    | FHIRDefinedType_list_HealthcareService
      -- ^ HealthcareService
    | FHIRDefinedType_list_ImagingManifest
      -- ^ ImagingManifest
    | FHIRDefinedType_list_ImagingStudy
      -- ^ ImagingStudy
    | FHIRDefinedType_list_Immunization
      -- ^ Immunization
    | FHIRDefinedType_list_ImmunizationRecommendation
      -- ^ ImmunizationRecommendation
    | FHIRDefinedType_list_ImplementationGuide
      -- ^ ImplementationGuide
    | FHIRDefinedType_list_Library
      -- ^ Library
    | FHIRDefinedType_list_Linkage
      -- ^ Linkage
    | FHIRDefinedType_list_List
      -- ^ List
    | FHIRDefinedType_list_Location
      -- ^ Location
    | FHIRDefinedType_list_Measure
      -- ^ Measure
    | FHIRDefinedType_list_MeasureReport
      -- ^ MeasureReport
    | FHIRDefinedType_list_Media
      -- ^ Media
    | FHIRDefinedType_list_Medication
      -- ^ Medication
    | FHIRDefinedType_list_MedicationAdministration
      -- ^ MedicationAdministration
    | FHIRDefinedType_list_MedicationDispense
      -- ^ MedicationDispense
    | FHIRDefinedType_list_MedicationRequest
      -- ^ MedicationRequest
    | FHIRDefinedType_list_MedicationStatement
      -- ^ MedicationStatement
    | FHIRDefinedType_list_MessageDefinition
      -- ^ MessageDefinition
    | FHIRDefinedType_list_MessageHeader
      -- ^ MessageHeader
    | FHIRDefinedType_list_NamingSystem
      -- ^ NamingSystem
    | FHIRDefinedType_list_NutritionOrder
      -- ^ NutritionOrder
    | FHIRDefinedType_list_Observation
      -- ^ Observation
    | FHIRDefinedType_list_OperationDefinition
      -- ^ OperationDefinition
    | FHIRDefinedType_list_OperationOutcome
      -- ^ OperationOutcome
    | FHIRDefinedType_list_Organization
      -- ^ Organization
    | FHIRDefinedType_list_Parameters
      -- ^ Parameters
    | FHIRDefinedType_list_Patient
      -- ^ Patient
    | FHIRDefinedType_list_PaymentNotice
      -- ^ PaymentNotice
    | FHIRDefinedType_list_PaymentReconciliation
      -- ^ PaymentReconciliation
    | FHIRDefinedType_list_Person
      -- ^ Person
    | FHIRDefinedType_list_PlanDefinition
      -- ^ PlanDefinition
    | FHIRDefinedType_list_Practitioner
      -- ^ Practitioner
    | FHIRDefinedType_list_PractitionerRole
      -- ^ PractitionerRole
    | FHIRDefinedType_list_Procedure
      -- ^ Procedure
    | FHIRDefinedType_list_ProcedureRequest
      -- ^ ProcedureRequest
    | FHIRDefinedType_list_ProcessRequest
      -- ^ ProcessRequest
    | FHIRDefinedType_list_ProcessResponse
      -- ^ ProcessResponse
    | FHIRDefinedType_list_Provenance
      -- ^ Provenance
    | FHIRDefinedType_list_Questionnaire
      -- ^ Questionnaire
    | FHIRDefinedType_list_QuestionnaireResponse
      -- ^ QuestionnaireResponse
    | FHIRDefinedType_list_ReferralRequest
      -- ^ ReferralRequest
    | FHIRDefinedType_list_RelatedPerson
      -- ^ RelatedPerson
    | FHIRDefinedType_list_RequestGroup
      -- ^ RequestGroup
    | FHIRDefinedType_list_ResearchStudy
      -- ^ ResearchStudy
    | FHIRDefinedType_list_ResearchSubject
      -- ^ ResearchSubject
    | FHIRDefinedType_list_Resource
      -- ^ Resource
    | FHIRDefinedType_list_RiskAssessment
      -- ^ RiskAssessment
    | FHIRDefinedType_list_Schedule
      -- ^ Schedule
    | FHIRDefinedType_list_SearchParameter
      -- ^ SearchParameter
    | FHIRDefinedType_list_Sequence
      -- ^ Sequence
    | FHIRDefinedType_list_ServiceDefinition
      -- ^ ServiceDefinition
    | FHIRDefinedType_list_Slot
      -- ^ Slot
    | FHIRDefinedType_list_Specimen
      -- ^ Specimen
    | FHIRDefinedType_list_StructureDefinition
      -- ^ StructureDefinition
    | FHIRDefinedType_list_StructureMap
      -- ^ StructureMap
    | FHIRDefinedType_list_Subscription
      -- ^ Subscription
    | FHIRDefinedType_list_Substance
      -- ^ Substance
    | FHIRDefinedType_list_SupplyDelivery
      -- ^ SupplyDelivery
    | FHIRDefinedType_list_SupplyRequest
      -- ^ SupplyRequest
    | FHIRDefinedType_list_Task
      -- ^ Task
    | FHIRDefinedType_list_TestReport
      -- ^ TestReport
    | FHIRDefinedType_list_TestScript
      -- ^ TestScript
    | FHIRDefinedType_list_ValueSet
      -- ^ ValueSet
    | FHIRDefinedType_list_VisionPrescription
      -- ^ VisionPrescription
    deriving (Eq,Show,Enum)
instance SchemaType FHIRDefinedType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType FHIRDefinedType_list where
    acceptingParser =  do literal "Address"; return FHIRDefinedType_list_Address
                      `onFail` do literal "Age"; return FHIRDefinedType_list_Age
                      `onFail` do literal "Annotation"; return FHIRDefinedType_list_Annotation
                      `onFail` do literal "Attachment"; return FHIRDefinedType_list_Attachment
                      `onFail` do literal "BackboneElement"; return FHIRDefinedType_list_BackboneElement
                      `onFail` do literal "CodeableConcept"; return FHIRDefinedType_list_CodeableConcept
                      `onFail` do literal "Coding"; return FHIRDefinedType_list_Coding
                      `onFail` do literal "ContactDetail"; return FHIRDefinedType_list_ContactDetail
                      `onFail` do literal "ContactPoint"; return FHIRDefinedType_list_ContactPoint
                      `onFail` do literal "Contributor"; return FHIRDefinedType_list_Contributor
                      `onFail` do literal "Count"; return FHIRDefinedType_list_Count
                      `onFail` do literal "DataRequirement"; return FHIRDefinedType_list_DataRequirement
                      `onFail` do literal "Distance"; return FHIRDefinedType_list_Distance
                      `onFail` do literal "Dosage"; return FHIRDefinedType_list_Dosage
                      `onFail` do literal "Duration"; return FHIRDefinedType_list_Duration
                      `onFail` do literal "Element"; return FHIRDefinedType_list_Element
                      `onFail` do literal "ElementDefinition"; return FHIRDefinedType_list_ElementDefinition
                      `onFail` do literal "Extension"; return FHIRDefinedType_list_Extension
                      `onFail` do literal "HumanName"; return FHIRDefinedType_list_HumanName
                      `onFail` do literal "Identifier"; return FHIRDefinedType_list_Identifier
                      `onFail` do literal "Meta"; return FHIRDefinedType_list_Meta
                      `onFail` do literal "Money"; return FHIRDefinedType_list_Money
                      `onFail` do literal "Narrative"; return FHIRDefinedType_list_Narrative
                      `onFail` do literal "ParameterDefinition"; return FHIRDefinedType_list_ParameterDefinition
                      `onFail` do literal "Period"; return FHIRDefinedType_list_Period
                      `onFail` do literal "Quantity"; return FHIRDefinedType_list_Quantity
                      `onFail` do literal "Range"; return FHIRDefinedType_list_Range
                      `onFail` do literal "Ratio"; return FHIRDefinedType_list_Ratio
                      `onFail` do literal "Reference"; return FHIRDefinedType_list_Reference
                      `onFail` do literal "RelatedArtifact"; return FHIRDefinedType_list_RelatedArtifact
                      `onFail` do literal "SampledData"; return FHIRDefinedType_list_SampledData
                      `onFail` do literal "Signature"; return FHIRDefinedType_list_Signature
                      `onFail` do literal "SimpleQuantity"; return FHIRDefinedType_list_SimpleQuantity
                      `onFail` do literal "Timing"; return FHIRDefinedType_list_Timing
                      `onFail` do literal "TriggerDefinition"; return FHIRDefinedType_list_TriggerDefinition
                      `onFail` do literal "UsageContext"; return FHIRDefinedType_list_UsageContext
                      `onFail` do literal "base64Binary"; return FHIRDefinedType_list_Base64Binary
                      `onFail` do literal "boolean"; return FHIRDefinedType_list_Boolean
                      `onFail` do literal "code"; return FHIRDefinedType_list_Code
                      `onFail` do literal "date"; return FHIRDefinedType_list_Date
                      `onFail` do literal "dateTime"; return FHIRDefinedType_list_DateTime
                      `onFail` do literal "decimal"; return FHIRDefinedType_list_Decimal
                      `onFail` do literal "id"; return FHIRDefinedType_list_Id
                      `onFail` do literal "instant"; return FHIRDefinedType_list_Instant
                      `onFail` do literal "integer"; return FHIRDefinedType_list_Integer
                      `onFail` do literal "markdown"; return FHIRDefinedType_list_Markdown
                      `onFail` do literal "oid"; return FHIRDefinedType_list_Oid
                      `onFail` do literal "positiveInt"; return FHIRDefinedType_list_PositiveInt
                      `onFail` do literal "string"; return FHIRDefinedType_list_Xsd.XsdString
                      `onFail` do literal "time"; return FHIRDefinedType_list_Time
                      `onFail` do literal "unsignedInt"; return FHIRDefinedType_list_UnsignedInt
                      `onFail` do literal "uri"; return FHIRDefinedType_list_Uri
                      `onFail` do literal "uuid"; return FHIRDefinedType_list_Uuid
                      `onFail` do literal "xhtml"; return FHIRDefinedType_list_Xhtml
                      `onFail` do literal "Account"; return FHIRDefinedType_list_Account
                      `onFail` do literal "ActivityDefinition"; return FHIRDefinedType_list_ActivityDefinition
                      `onFail` do literal "AdverseEvent"; return FHIRDefinedType_list_AdverseEvent
                      `onFail` do literal "AllergyIntolerance"; return FHIRDefinedType_list_AllergyIntolerance
                      `onFail` do literal "Appointment"; return FHIRDefinedType_list_Appointment
                      `onFail` do literal "AppointmentResponse"; return FHIRDefinedType_list_AppointmentResponse
                      `onFail` do literal "AuditEvent"; return FHIRDefinedType_list_AuditEvent
                      `onFail` do literal "Basic"; return FHIRDefinedType_list_Basic
                      `onFail` do literal "Binary"; return FHIRDefinedType_list_Binary
                      `onFail` do literal "BodySite"; return FHIRDefinedType_list_BodySite
                      `onFail` do literal "Bundle"; return FHIRDefinedType_list_Bundle
                      `onFail` do literal "CapabilityStatement"; return FHIRDefinedType_list_CapabilityStatement
                      `onFail` do literal "CarePlan"; return FHIRDefinedType_list_CarePlan
                      `onFail` do literal "CareTeam"; return FHIRDefinedType_list_CareTeam
                      `onFail` do literal "ChargeItem"; return FHIRDefinedType_list_ChargeItem
                      `onFail` do literal "Claim"; return FHIRDefinedType_list_Claim
                      `onFail` do literal "ClaimResponse"; return FHIRDefinedType_list_ClaimResponse
                      `onFail` do literal "ClinicalImpression"; return FHIRDefinedType_list_ClinicalImpression
                      `onFail` do literal "CodeSystem"; return FHIRDefinedType_list_CodeSystem
                      `onFail` do literal "Communication"; return FHIRDefinedType_list_Communication
                      `onFail` do literal "CommunicationRequest"; return FHIRDefinedType_list_CommunicationRequest
                      `onFail` do literal "CompartmentDefinition"; return FHIRDefinedType_list_CompartmentDefinition
                      `onFail` do literal "Composition"; return FHIRDefinedType_list_Composition
                      `onFail` do literal "ConceptMap"; return FHIRDefinedType_list_ConceptMap
                      `onFail` do literal "Condition"; return FHIRDefinedType_list_Condition
                      `onFail` do literal "Consent"; return FHIRDefinedType_list_Consent
                      `onFail` do literal "Contract"; return FHIRDefinedType_list_Contract
                      `onFail` do literal "Coverage"; return FHIRDefinedType_list_Coverage
                      `onFail` do literal "DataElement"; return FHIRDefinedType_list_DataElement
                      `onFail` do literal "DetectedIssue"; return FHIRDefinedType_list_DetectedIssue
                      `onFail` do literal "Device"; return FHIRDefinedType_list_Device
                      `onFail` do literal "DeviceComponent"; return FHIRDefinedType_list_DeviceComponent
                      `onFail` do literal "DeviceMetric"; return FHIRDefinedType_list_DeviceMetric
                      `onFail` do literal "DeviceRequest"; return FHIRDefinedType_list_DeviceRequest
                      `onFail` do literal "DeviceUseStatement"; return FHIRDefinedType_list_DeviceUseStatement
                      `onFail` do literal "DiagnosticReport"; return FHIRDefinedType_list_DiagnosticReport
                      `onFail` do literal "DocumentManifest"; return FHIRDefinedType_list_DocumentManifest
                      `onFail` do literal "DocumentReference"; return FHIRDefinedType_list_DocumentReference
                      `onFail` do literal "DomainResource"; return FHIRDefinedType_list_DomainResource
                      `onFail` do literal "EligibilityRequest"; return FHIRDefinedType_list_EligibilityRequest
                      `onFail` do literal "EligibilityResponse"; return FHIRDefinedType_list_EligibilityResponse
                      `onFail` do literal "Encounter"; return FHIRDefinedType_list_Encounter
                      `onFail` do literal "Endpoint"; return FHIRDefinedType_list_Endpoint
                      `onFail` do literal "EnrollmentRequest"; return FHIRDefinedType_list_EnrollmentRequest
                      `onFail` do literal "EnrollmentResponse"; return FHIRDefinedType_list_EnrollmentResponse
                      `onFail` do literal "EpisodeOfCare"; return FHIRDefinedType_list_EpisodeOfCare
                      `onFail` do literal "ExpansionProfile"; return FHIRDefinedType_list_ExpansionProfile
                      `onFail` do literal "ExplanationOfBenefit"; return FHIRDefinedType_list_ExplanationOfBenefit
                      `onFail` do literal "FamilyMemberHistory"; return FHIRDefinedType_list_FamilyMemberHistory
                      `onFail` do literal "Flag"; return FHIRDefinedType_list_Flag
                      `onFail` do literal "Goal"; return FHIRDefinedType_list_Goal
                      `onFail` do literal "GraphDefinition"; return FHIRDefinedType_list_GraphDefinition
                      `onFail` do literal "Group"; return FHIRDefinedType_list_Group
                      `onFail` do literal "GuidanceResponse"; return FHIRDefinedType_list_GuidanceResponse
                      `onFail` do literal "HealthcareService"; return FHIRDefinedType_list_HealthcareService
                      `onFail` do literal "ImagingManifest"; return FHIRDefinedType_list_ImagingManifest
                      `onFail` do literal "ImagingStudy"; return FHIRDefinedType_list_ImagingStudy
                      `onFail` do literal "Immunization"; return FHIRDefinedType_list_Immunization
                      `onFail` do literal "ImmunizationRecommendation"; return FHIRDefinedType_list_ImmunizationRecommendation
                      `onFail` do literal "ImplementationGuide"; return FHIRDefinedType_list_ImplementationGuide
                      `onFail` do literal "Library"; return FHIRDefinedType_list_Library
                      `onFail` do literal "Linkage"; return FHIRDefinedType_list_Linkage
                      `onFail` do literal "List"; return FHIRDefinedType_list_List
                      `onFail` do literal "Location"; return FHIRDefinedType_list_Location
                      `onFail` do literal "Measure"; return FHIRDefinedType_list_Measure
                      `onFail` do literal "MeasureReport"; return FHIRDefinedType_list_MeasureReport
                      `onFail` do literal "Media"; return FHIRDefinedType_list_Media
                      `onFail` do literal "Medication"; return FHIRDefinedType_list_Medication
                      `onFail` do literal "MedicationAdministration"; return FHIRDefinedType_list_MedicationAdministration
                      `onFail` do literal "MedicationDispense"; return FHIRDefinedType_list_MedicationDispense
                      `onFail` do literal "MedicationRequest"; return FHIRDefinedType_list_MedicationRequest
                      `onFail` do literal "MedicationStatement"; return FHIRDefinedType_list_MedicationStatement
                      `onFail` do literal "MessageDefinition"; return FHIRDefinedType_list_MessageDefinition
                      `onFail` do literal "MessageHeader"; return FHIRDefinedType_list_MessageHeader
                      `onFail` do literal "NamingSystem"; return FHIRDefinedType_list_NamingSystem
                      `onFail` do literal "NutritionOrder"; return FHIRDefinedType_list_NutritionOrder
                      `onFail` do literal "Observation"; return FHIRDefinedType_list_Observation
                      `onFail` do literal "OperationDefinition"; return FHIRDefinedType_list_OperationDefinition
                      `onFail` do literal "OperationOutcome"; return FHIRDefinedType_list_OperationOutcome
                      `onFail` do literal "Organization"; return FHIRDefinedType_list_Organization
                      `onFail` do literal "Parameters"; return FHIRDefinedType_list_Parameters
                      `onFail` do literal "Patient"; return FHIRDefinedType_list_Patient
                      `onFail` do literal "PaymentNotice"; return FHIRDefinedType_list_PaymentNotice
                      `onFail` do literal "PaymentReconciliation"; return FHIRDefinedType_list_PaymentReconciliation
                      `onFail` do literal "Person"; return FHIRDefinedType_list_Person
                      `onFail` do literal "PlanDefinition"; return FHIRDefinedType_list_PlanDefinition
                      `onFail` do literal "Practitioner"; return FHIRDefinedType_list_Practitioner
                      `onFail` do literal "PractitionerRole"; return FHIRDefinedType_list_PractitionerRole
                      `onFail` do literal "Procedure"; return FHIRDefinedType_list_Procedure
                      `onFail` do literal "ProcedureRequest"; return FHIRDefinedType_list_ProcedureRequest
                      `onFail` do literal "ProcessRequest"; return FHIRDefinedType_list_ProcessRequest
                      `onFail` do literal "ProcessResponse"; return FHIRDefinedType_list_ProcessResponse
                      `onFail` do literal "Provenance"; return FHIRDefinedType_list_Provenance
                      `onFail` do literal "Questionnaire"; return FHIRDefinedType_list_Questionnaire
                      `onFail` do literal "QuestionnaireResponse"; return FHIRDefinedType_list_QuestionnaireResponse
                      `onFail` do literal "ReferralRequest"; return FHIRDefinedType_list_ReferralRequest
                      `onFail` do literal "RelatedPerson"; return FHIRDefinedType_list_RelatedPerson
                      `onFail` do literal "RequestGroup"; return FHIRDefinedType_list_RequestGroup
                      `onFail` do literal "ResearchStudy"; return FHIRDefinedType_list_ResearchStudy
                      `onFail` do literal "ResearchSubject"; return FHIRDefinedType_list_ResearchSubject
                      `onFail` do literal "Resource"; return FHIRDefinedType_list_Resource
                      `onFail` do literal "RiskAssessment"; return FHIRDefinedType_list_RiskAssessment
                      `onFail` do literal "Schedule"; return FHIRDefinedType_list_Schedule
                      `onFail` do literal "SearchParameter"; return FHIRDefinedType_list_SearchParameter
                      `onFail` do literal "Sequence"; return FHIRDefinedType_list_Sequence
                      `onFail` do literal "ServiceDefinition"; return FHIRDefinedType_list_ServiceDefinition
                      `onFail` do literal "Slot"; return FHIRDefinedType_list_Slot
                      `onFail` do literal "Specimen"; return FHIRDefinedType_list_Specimen
                      `onFail` do literal "StructureDefinition"; return FHIRDefinedType_list_StructureDefinition
                      `onFail` do literal "StructureMap"; return FHIRDefinedType_list_StructureMap
                      `onFail` do literal "Subscription"; return FHIRDefinedType_list_Subscription
                      `onFail` do literal "Substance"; return FHIRDefinedType_list_Substance
                      `onFail` do literal "SupplyDelivery"; return FHIRDefinedType_list_SupplyDelivery
                      `onFail` do literal "SupplyRequest"; return FHIRDefinedType_list_SupplyRequest
                      `onFail` do literal "Task"; return FHIRDefinedType_list_Task
                      `onFail` do literal "TestReport"; return FHIRDefinedType_list_TestReport
                      `onFail` do literal "TestScript"; return FHIRDefinedType_list_TestScript
                      `onFail` do literal "ValueSet"; return FHIRDefinedType_list_ValueSet
                      `onFail` do literal "VisionPrescription"; return FHIRDefinedType_list_VisionPrescription
                      
    simpleTypeText FHIRDefinedType_list_Address = "Address"
    simpleTypeText FHIRDefinedType_list_Age = "Age"
    simpleTypeText FHIRDefinedType_list_Annotation = "Annotation"
    simpleTypeText FHIRDefinedType_list_Attachment = "Attachment"
    simpleTypeText FHIRDefinedType_list_BackboneElement = "BackboneElement"
    simpleTypeText FHIRDefinedType_list_CodeableConcept = "CodeableConcept"
    simpleTypeText FHIRDefinedType_list_Coding = "Coding"
    simpleTypeText FHIRDefinedType_list_ContactDetail = "ContactDetail"
    simpleTypeText FHIRDefinedType_list_ContactPoint = "ContactPoint"
    simpleTypeText FHIRDefinedType_list_Contributor = "Contributor"
    simpleTypeText FHIRDefinedType_list_Count = "Count"
    simpleTypeText FHIRDefinedType_list_DataRequirement = "DataRequirement"
    simpleTypeText FHIRDefinedType_list_Distance = "Distance"
    simpleTypeText FHIRDefinedType_list_Dosage = "Dosage"
    simpleTypeText FHIRDefinedType_list_Duration = "Duration"
    simpleTypeText FHIRDefinedType_list_Element = "Element"
    simpleTypeText FHIRDefinedType_list_ElementDefinition = "ElementDefinition"
    simpleTypeText FHIRDefinedType_list_Extension = "Extension"
    simpleTypeText FHIRDefinedType_list_HumanName = "HumanName"
    simpleTypeText FHIRDefinedType_list_Identifier = "Identifier"
    simpleTypeText FHIRDefinedType_list_Meta = "Meta"
    simpleTypeText FHIRDefinedType_list_Money = "Money"
    simpleTypeText FHIRDefinedType_list_Narrative = "Narrative"
    simpleTypeText FHIRDefinedType_list_ParameterDefinition = "ParameterDefinition"
    simpleTypeText FHIRDefinedType_list_Period = "Period"
    simpleTypeText FHIRDefinedType_list_Quantity = "Quantity"
    simpleTypeText FHIRDefinedType_list_Range = "Range"
    simpleTypeText FHIRDefinedType_list_Ratio = "Ratio"
    simpleTypeText FHIRDefinedType_list_Reference = "Reference"
    simpleTypeText FHIRDefinedType_list_RelatedArtifact = "RelatedArtifact"
    simpleTypeText FHIRDefinedType_list_SampledData = "SampledData"
    simpleTypeText FHIRDefinedType_list_Signature = "Signature"
    simpleTypeText FHIRDefinedType_list_SimpleQuantity = "SimpleQuantity"
    simpleTypeText FHIRDefinedType_list_Timing = "Timing"
    simpleTypeText FHIRDefinedType_list_TriggerDefinition = "TriggerDefinition"
    simpleTypeText FHIRDefinedType_list_UsageContext = "UsageContext"
    simpleTypeText FHIRDefinedType_list_Base64Binary = "base64Binary"
    simpleTypeText FHIRDefinedType_list_Boolean = "boolean"
    simpleTypeText FHIRDefinedType_list_Code = "code"
    simpleTypeText FHIRDefinedType_list_Date = "date"
    simpleTypeText FHIRDefinedType_list_DateTime = "dateTime"
    simpleTypeText FHIRDefinedType_list_Decimal = "decimal"
    simpleTypeText FHIRDefinedType_list_Id = "id"
    simpleTypeText FHIRDefinedType_list_Instant = "instant"
    simpleTypeText FHIRDefinedType_list_Integer = "integer"
    simpleTypeText FHIRDefinedType_list_Markdown = "markdown"
    simpleTypeText FHIRDefinedType_list_Oid = "oid"
    simpleTypeText FHIRDefinedType_list_PositiveInt = "positiveInt"
    simpleTypeText FHIRDefinedType_list_Xsd.XsdString = "string"
    simpleTypeText FHIRDefinedType_list_Time = "time"
    simpleTypeText FHIRDefinedType_list_UnsignedInt = "unsignedInt"
    simpleTypeText FHIRDefinedType_list_Uri = "uri"
    simpleTypeText FHIRDefinedType_list_Uuid = "uuid"
    simpleTypeText FHIRDefinedType_list_Xhtml = "xhtml"
    simpleTypeText FHIRDefinedType_list_Account = "Account"
    simpleTypeText FHIRDefinedType_list_ActivityDefinition = "ActivityDefinition"
    simpleTypeText FHIRDefinedType_list_AdverseEvent = "AdverseEvent"
    simpleTypeText FHIRDefinedType_list_AllergyIntolerance = "AllergyIntolerance"
    simpleTypeText FHIRDefinedType_list_Appointment = "Appointment"
    simpleTypeText FHIRDefinedType_list_AppointmentResponse = "AppointmentResponse"
    simpleTypeText FHIRDefinedType_list_AuditEvent = "AuditEvent"
    simpleTypeText FHIRDefinedType_list_Basic = "Basic"
    simpleTypeText FHIRDefinedType_list_Binary = "Binary"
    simpleTypeText FHIRDefinedType_list_BodySite = "BodySite"
    simpleTypeText FHIRDefinedType_list_Bundle = "Bundle"
    simpleTypeText FHIRDefinedType_list_CapabilityStatement = "CapabilityStatement"
    simpleTypeText FHIRDefinedType_list_CarePlan = "CarePlan"
    simpleTypeText FHIRDefinedType_list_CareTeam = "CareTeam"
    simpleTypeText FHIRDefinedType_list_ChargeItem = "ChargeItem"
    simpleTypeText FHIRDefinedType_list_Claim = "Claim"
    simpleTypeText FHIRDefinedType_list_ClaimResponse = "ClaimResponse"
    simpleTypeText FHIRDefinedType_list_ClinicalImpression = "ClinicalImpression"
    simpleTypeText FHIRDefinedType_list_CodeSystem = "CodeSystem"
    simpleTypeText FHIRDefinedType_list_Communication = "Communication"
    simpleTypeText FHIRDefinedType_list_CommunicationRequest = "CommunicationRequest"
    simpleTypeText FHIRDefinedType_list_CompartmentDefinition = "CompartmentDefinition"
    simpleTypeText FHIRDefinedType_list_Composition = "Composition"
    simpleTypeText FHIRDefinedType_list_ConceptMap = "ConceptMap"
    simpleTypeText FHIRDefinedType_list_Condition = "Condition"
    simpleTypeText FHIRDefinedType_list_Consent = "Consent"
    simpleTypeText FHIRDefinedType_list_Contract = "Contract"
    simpleTypeText FHIRDefinedType_list_Coverage = "Coverage"
    simpleTypeText FHIRDefinedType_list_DataElement = "DataElement"
    simpleTypeText FHIRDefinedType_list_DetectedIssue = "DetectedIssue"
    simpleTypeText FHIRDefinedType_list_Device = "Device"
    simpleTypeText FHIRDefinedType_list_DeviceComponent = "DeviceComponent"
    simpleTypeText FHIRDefinedType_list_DeviceMetric = "DeviceMetric"
    simpleTypeText FHIRDefinedType_list_DeviceRequest = "DeviceRequest"
    simpleTypeText FHIRDefinedType_list_DeviceUseStatement = "DeviceUseStatement"
    simpleTypeText FHIRDefinedType_list_DiagnosticReport = "DiagnosticReport"
    simpleTypeText FHIRDefinedType_list_DocumentManifest = "DocumentManifest"
    simpleTypeText FHIRDefinedType_list_DocumentReference = "DocumentReference"
    simpleTypeText FHIRDefinedType_list_DomainResource = "DomainResource"
    simpleTypeText FHIRDefinedType_list_EligibilityRequest = "EligibilityRequest"
    simpleTypeText FHIRDefinedType_list_EligibilityResponse = "EligibilityResponse"
    simpleTypeText FHIRDefinedType_list_Encounter = "Encounter"
    simpleTypeText FHIRDefinedType_list_Endpoint = "Endpoint"
    simpleTypeText FHIRDefinedType_list_EnrollmentRequest = "EnrollmentRequest"
    simpleTypeText FHIRDefinedType_list_EnrollmentResponse = "EnrollmentResponse"
    simpleTypeText FHIRDefinedType_list_EpisodeOfCare = "EpisodeOfCare"
    simpleTypeText FHIRDefinedType_list_ExpansionProfile = "ExpansionProfile"
    simpleTypeText FHIRDefinedType_list_ExplanationOfBenefit = "ExplanationOfBenefit"
    simpleTypeText FHIRDefinedType_list_FamilyMemberHistory = "FamilyMemberHistory"
    simpleTypeText FHIRDefinedType_list_Flag = "Flag"
    simpleTypeText FHIRDefinedType_list_Goal = "Goal"
    simpleTypeText FHIRDefinedType_list_GraphDefinition = "GraphDefinition"
    simpleTypeText FHIRDefinedType_list_Group = "Group"
    simpleTypeText FHIRDefinedType_list_GuidanceResponse = "GuidanceResponse"
    simpleTypeText FHIRDefinedType_list_HealthcareService = "HealthcareService"
    simpleTypeText FHIRDefinedType_list_ImagingManifest = "ImagingManifest"
    simpleTypeText FHIRDefinedType_list_ImagingStudy = "ImagingStudy"
    simpleTypeText FHIRDefinedType_list_Immunization = "Immunization"
    simpleTypeText FHIRDefinedType_list_ImmunizationRecommendation = "ImmunizationRecommendation"
    simpleTypeText FHIRDefinedType_list_ImplementationGuide = "ImplementationGuide"
    simpleTypeText FHIRDefinedType_list_Library = "Library"
    simpleTypeText FHIRDefinedType_list_Linkage = "Linkage"
    simpleTypeText FHIRDefinedType_list_List = "List"
    simpleTypeText FHIRDefinedType_list_Location = "Location"
    simpleTypeText FHIRDefinedType_list_Measure = "Measure"
    simpleTypeText FHIRDefinedType_list_MeasureReport = "MeasureReport"
    simpleTypeText FHIRDefinedType_list_Media = "Media"
    simpleTypeText FHIRDefinedType_list_Medication = "Medication"
    simpleTypeText FHIRDefinedType_list_MedicationAdministration = "MedicationAdministration"
    simpleTypeText FHIRDefinedType_list_MedicationDispense = "MedicationDispense"
    simpleTypeText FHIRDefinedType_list_MedicationRequest = "MedicationRequest"
    simpleTypeText FHIRDefinedType_list_MedicationStatement = "MedicationStatement"
    simpleTypeText FHIRDefinedType_list_MessageDefinition = "MessageDefinition"
    simpleTypeText FHIRDefinedType_list_MessageHeader = "MessageHeader"
    simpleTypeText FHIRDefinedType_list_NamingSystem = "NamingSystem"
    simpleTypeText FHIRDefinedType_list_NutritionOrder = "NutritionOrder"
    simpleTypeText FHIRDefinedType_list_Observation = "Observation"
    simpleTypeText FHIRDefinedType_list_OperationDefinition = "OperationDefinition"
    simpleTypeText FHIRDefinedType_list_OperationOutcome = "OperationOutcome"
    simpleTypeText FHIRDefinedType_list_Organization = "Organization"
    simpleTypeText FHIRDefinedType_list_Parameters = "Parameters"
    simpleTypeText FHIRDefinedType_list_Patient = "Patient"
    simpleTypeText FHIRDefinedType_list_PaymentNotice = "PaymentNotice"
    simpleTypeText FHIRDefinedType_list_PaymentReconciliation = "PaymentReconciliation"
    simpleTypeText FHIRDefinedType_list_Person = "Person"
    simpleTypeText FHIRDefinedType_list_PlanDefinition = "PlanDefinition"
    simpleTypeText FHIRDefinedType_list_Practitioner = "Practitioner"
    simpleTypeText FHIRDefinedType_list_PractitionerRole = "PractitionerRole"
    simpleTypeText FHIRDefinedType_list_Procedure = "Procedure"
    simpleTypeText FHIRDefinedType_list_ProcedureRequest = "ProcedureRequest"
    simpleTypeText FHIRDefinedType_list_ProcessRequest = "ProcessRequest"
    simpleTypeText FHIRDefinedType_list_ProcessResponse = "ProcessResponse"
    simpleTypeText FHIRDefinedType_list_Provenance = "Provenance"
    simpleTypeText FHIRDefinedType_list_Questionnaire = "Questionnaire"
    simpleTypeText FHIRDefinedType_list_QuestionnaireResponse = "QuestionnaireResponse"
    simpleTypeText FHIRDefinedType_list_ReferralRequest = "ReferralRequest"
    simpleTypeText FHIRDefinedType_list_RelatedPerson = "RelatedPerson"
    simpleTypeText FHIRDefinedType_list_RequestGroup = "RequestGroup"
    simpleTypeText FHIRDefinedType_list_ResearchStudy = "ResearchStudy"
    simpleTypeText FHIRDefinedType_list_ResearchSubject = "ResearchSubject"
    simpleTypeText FHIRDefinedType_list_Resource = "Resource"
    simpleTypeText FHIRDefinedType_list_RiskAssessment = "RiskAssessment"
    simpleTypeText FHIRDefinedType_list_Schedule = "Schedule"
    simpleTypeText FHIRDefinedType_list_SearchParameter = "SearchParameter"
    simpleTypeText FHIRDefinedType_list_Sequence = "Sequence"
    simpleTypeText FHIRDefinedType_list_ServiceDefinition = "ServiceDefinition"
    simpleTypeText FHIRDefinedType_list_Slot = "Slot"
    simpleTypeText FHIRDefinedType_list_Specimen = "Specimen"
    simpleTypeText FHIRDefinedType_list_StructureDefinition = "StructureDefinition"
    simpleTypeText FHIRDefinedType_list_StructureMap = "StructureMap"
    simpleTypeText FHIRDefinedType_list_Subscription = "Subscription"
    simpleTypeText FHIRDefinedType_list_Substance = "Substance"
    simpleTypeText FHIRDefinedType_list_SupplyDelivery = "SupplyDelivery"
    simpleTypeText FHIRDefinedType_list_SupplyRequest = "SupplyRequest"
    simpleTypeText FHIRDefinedType_list_Task = "Task"
    simpleTypeText FHIRDefinedType_list_TestReport = "TestReport"
    simpleTypeText FHIRDefinedType_list_TestScript = "TestScript"
    simpleTypeText FHIRDefinedType_list_ValueSet = "ValueSet"
    simpleTypeText FHIRDefinedType_list_VisionPrescription = "VisionPrescription"
 
data FHIRDefinedType = FHIRDefinedType
        { fHIRDefinedType_id :: Maybe String_primitive
        , fHIRDefinedType_value :: Maybe FHIRDefinedType_list
        , fHIRDefinedType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType FHIRDefinedType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (FHIRDefinedType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@FHIRDefinedType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ fHIRDefinedType_id x
                       , maybe [] (toXMLAttribute "value") $ fHIRDefinedType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ fHIRDefinedType_extension x
            ]
instance Extension FHIRDefinedType Element where
    supertype (FHIRDefinedType a0 a1 e0) =
               Element a0 e0
 
data ContentType_list
    = ContentType_list_Xml
      -- ^ xml
    | ContentType_list_Json
      -- ^ json
    | ContentType_list_Ttl
      -- ^ ttl
    | ContentType_list_None
      -- ^ none
    deriving (Eq,Show,Enum)
instance SchemaType ContentType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType ContentType_list where
    acceptingParser =  do literal "xml"; return ContentType_list_Xml
                      `onFail` do literal "json"; return ContentType_list_Json
                      `onFail` do literal "ttl"; return ContentType_list_Ttl
                      `onFail` do literal "none"; return ContentType_list_None
                      
    simpleTypeText ContentType_list_Xml = "xml"
    simpleTypeText ContentType_list_Json = "json"
    simpleTypeText ContentType_list_Ttl = "ttl"
    simpleTypeText ContentType_list_None = "none"
 
data ContentType = ContentType
        { contentType_id :: Maybe String_primitive
        , contentType_value :: Maybe ContentType_list
        , contentType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType ContentType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (ContentType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@ContentType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ contentType_id x
                       , maybe [] (toXMLAttribute "value") $ contentType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ contentType_extension x
            ]
instance Extension ContentType Element where
    supertype (ContentType a0 a1 e0) =
               Element a0 e0
 
data AssertionDirectionType_list
    = AssertionDirectionType_list_Response
      -- ^ response
    | AssertionDirectionType_list_Request
      -- ^ request
    deriving (Eq,Show,Enum)
instance SchemaType AssertionDirectionType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionDirectionType_list where
    acceptingParser =  do literal "response"; return AssertionDirectionType_list_Response
                      `onFail` do literal "request"; return AssertionDirectionType_list_Request
                      
    simpleTypeText AssertionDirectionType_list_Response = "response"
    simpleTypeText AssertionDirectionType_list_Request = "request"
 
data AssertionDirectionType = AssertionDirectionType
        { assertionDirectionType_id :: Maybe String_primitive
        , assertionDirectionType_value :: Maybe AssertionDirectionType_list
        , assertionDirectionType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionDirectionType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionDirectionType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionDirectionType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionDirectionType_id x
                       , maybe [] (toXMLAttribute "value") $ assertionDirectionType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionDirectionType_extension x
            ]
instance Extension AssertionDirectionType Element where
    supertype (AssertionDirectionType a0 a1 e0) =
               Element a0 e0
 
data AssertionOperatorType_list
    = AssertionOperatorType_list_Equals
      -- ^ equals
    | AssertionOperatorType_list_NotEquals
      -- ^ notEquals
    | AssertionOperatorType_list_In
      -- ^ in
    | AssertionOperatorType_list_NotIn
      -- ^ notIn
    | AssertionOperatorType_list_GreaterThan
      -- ^ greaterThan
    | AssertionOperatorType_list_LessThan
      -- ^ lessThan
    | AssertionOperatorType_list_Empty
      -- ^ empty
    | AssertionOperatorType_list_NotEmpty
      -- ^ notEmpty
    | AssertionOperatorType_list_Contains
      -- ^ contains
    | AssertionOperatorType_list_NotContains
      -- ^ notContains
    | AssertionOperatorType_list_Eval
      -- ^ evaluate
    deriving (Eq,Show,Enum)
instance SchemaType AssertionOperatorType_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionOperatorType_list where
    acceptingParser =  do literal "equals"; return AssertionOperatorType_list_Equals
                      `onFail` do literal "notEquals"; return AssertionOperatorType_list_NotEquals
                      `onFail` do literal "in"; return AssertionOperatorType_list_In
                      `onFail` do literal "notIn"; return AssertionOperatorType_list_NotIn
                      `onFail` do literal "greaterThan"; return AssertionOperatorType_list_GreaterThan
                      `onFail` do literal "lessThan"; return AssertionOperatorType_list_LessThan
                      `onFail` do literal "empty"; return AssertionOperatorType_list_Empty
                      `onFail` do literal "notEmpty"; return AssertionOperatorType_list_NotEmpty
                      `onFail` do literal "contains"; return AssertionOperatorType_list_Contains
                      `onFail` do literal "notContains"; return AssertionOperatorType_list_NotContains
                      `onFail` do literal "eval"; return AssertionOperatorType_list_Eval
                      
    simpleTypeText AssertionOperatorType_list_Equals = "equals"
    simpleTypeText AssertionOperatorType_list_NotEquals = "notEquals"
    simpleTypeText AssertionOperatorType_list_In = "in"
    simpleTypeText AssertionOperatorType_list_NotIn = "notIn"
    simpleTypeText AssertionOperatorType_list_GreaterThan = "greaterThan"
    simpleTypeText AssertionOperatorType_list_LessThan = "lessThan"
    simpleTypeText AssertionOperatorType_list_Empty = "empty"
    simpleTypeText AssertionOperatorType_list_NotEmpty = "notEmpty"
    simpleTypeText AssertionOperatorType_list_Contains = "contains"
    simpleTypeText AssertionOperatorType_list_NotContains = "notContains"
    simpleTypeText AssertionOperatorType_list_Eval = "eval"
 
data AssertionOperatorType = AssertionOperatorType
        { assertionOperatorType_id :: Maybe String_primitive
        , assertionOperatorType_value :: Maybe AssertionOperatorType_list
        , assertionOperatorType_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionOperatorType where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionOperatorType a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionOperatorType{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionOperatorType_id x
                       , maybe [] (toXMLAttribute "value") $ assertionOperatorType_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionOperatorType_extension x
            ]
instance Extension AssertionOperatorType Element where
    supertype (AssertionOperatorType a0 a1 e0) =
               Element a0 e0
 
data AssertionResponseTypes_list
    = AssertionResponseTypes_list_Okay
      -- ^ okay
    | AssertionResponseTypes_list_Created
      -- ^ created
    | AssertionResponseTypes_list_NoContent
      -- ^ noContent
    | AssertionResponseTypes_list_NotModified
      -- ^ notModified
    | AssertionResponseTypes_list_Bad
      -- ^ bad
    | AssertionResponseTypes_list_Forbidden
      -- ^ forbidden
    | AssertionResponseTypes_list_NotFound
      -- ^ notFound
    | AssertionResponseTypes_list_MethodNotAllowed
      -- ^ methodNotAllowed
    | AssertionResponseTypes_list_Conflict
      -- ^ conflict
    | AssertionResponseTypes_list_Gone
      -- ^ gone
    | AssertionResponseTypes_list_PreconditionFailed
      -- ^ preconditionFailed
    | AssertionResponseTypes_list_Unprocessable
      -- ^ unprocessable
    deriving (Eq,Show,Enum)
instance SchemaType AssertionResponseTypes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType AssertionResponseTypes_list where
    acceptingParser =  do literal "okay"; return AssertionResponseTypes_list_Okay
                      `onFail` do literal "created"; return AssertionResponseTypes_list_Created
                      `onFail` do literal "noContent"; return AssertionResponseTypes_list_NoContent
                      `onFail` do literal "notModified"; return AssertionResponseTypes_list_NotModified
                      `onFail` do literal "bad"; return AssertionResponseTypes_list_Bad
                      `onFail` do literal "forbidden"; return AssertionResponseTypes_list_Forbidden
                      `onFail` do literal "notFound"; return AssertionResponseTypes_list_NotFound
                      `onFail` do literal "methodNotAllowed"; return AssertionResponseTypes_list_MethodNotAllowed
                      `onFail` do literal "conflict"; return AssertionResponseTypes_list_Conflict
                      `onFail` do literal "gone"; return AssertionResponseTypes_list_Gone
                      `onFail` do literal "preconditionFailed"; return AssertionResponseTypes_list_PreconditionFailed
                      `onFail` do literal "unprocessable"; return AssertionResponseTypes_list_Unprocessable
                      
    simpleTypeText AssertionResponseTypes_list_Okay = "okay"
    simpleTypeText AssertionResponseTypes_list_Created = "created"
    simpleTypeText AssertionResponseTypes_list_NoContent = "noContent"
    simpleTypeText AssertionResponseTypes_list_NotModified = "notModified"
    simpleTypeText AssertionResponseTypes_list_Bad = "bad"
    simpleTypeText AssertionResponseTypes_list_Forbidden = "forbidden"
    simpleTypeText AssertionResponseTypes_list_NotFound = "notFound"
    simpleTypeText AssertionResponseTypes_list_MethodNotAllowed = "methodNotAllowed"
    simpleTypeText AssertionResponseTypes_list_Conflict = "conflict"
    simpleTypeText AssertionResponseTypes_list_Gone = "gone"
    simpleTypeText AssertionResponseTypes_list_PreconditionFailed = "preconditionFailed"
    simpleTypeText AssertionResponseTypes_list_Unprocessable = "unprocessable"
 
data AssertionResponseTypes = AssertionResponseTypes
        { assertionResponseTypes_id :: Maybe String_primitive
        , assertionResponseTypes_value :: Maybe AssertionResponseTypes_list
        , assertionResponseTypes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType AssertionResponseTypes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (AssertionResponseTypes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@AssertionResponseTypes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ assertionResponseTypes_id x
                       , maybe [] (toXMLAttribute "value") $ assertionResponseTypes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ assertionResponseTypes_extension x
            ]
instance Extension AssertionResponseTypes Element where
    supertype (AssertionResponseTypes a0 a1 e0) =
               Element a0 e0
 
data TestScriptRequestMethodCode_list
    = TestScriptRequestMethodCode_list_Delete
      -- ^ DELETE
    | TestScriptRequestMethodCode_list_Get
      -- ^ GET
    | TestScriptRequestMethodCode_list_Options
      -- ^ OPTIONS
    | TestScriptRequestMethodCode_list_Patch
      -- ^ PATCH
    | TestScriptRequestMethodCode_list_Post
      -- ^ POST
    | TestScriptRequestMethodCode_list_Put
      -- ^ PUT
    deriving (Eq,Show,Enum)
instance SchemaType TestScriptRequestMethodCode_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType TestScriptRequestMethodCode_list where
    acceptingParser =  do literal "delete"; return TestScriptRequestMethodCode_list_Delete
                      `onFail` do literal "get"; return TestScriptRequestMethodCode_list_Get
                      `onFail` do literal "options"; return TestScriptRequestMethodCode_list_Options
                      `onFail` do literal "patch"; return TestScriptRequestMethodCode_list_Patch
                      `onFail` do literal "post"; return TestScriptRequestMethodCode_list_Post
                      `onFail` do literal "put"; return TestScriptRequestMethodCode_list_Put
                      
    simpleTypeText TestScriptRequestMethodCode_list_Delete = "delete"
    simpleTypeText TestScriptRequestMethodCode_list_Get = "get"
    simpleTypeText TestScriptRequestMethodCode_list_Options = "options"
    simpleTypeText TestScriptRequestMethodCode_list_Patch = "patch"
    simpleTypeText TestScriptRequestMethodCode_list_Post = "post"
    simpleTypeText TestScriptRequestMethodCode_list_Put = "put"
 
data TestScriptRequestMethodCode = TestScriptRequestMethodCode
        { testScriptRequestMethodCode_id :: Maybe String_primitive
        , testScriptRequestMethodCode_value :: Maybe TestScriptRequestMethodCode_list
        , testScriptRequestMethodCode_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType TestScriptRequestMethodCode where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (TestScriptRequestMethodCode a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@TestScriptRequestMethodCode{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ testScriptRequestMethodCode_id x
                       , maybe [] (toXMLAttribute "value") $ testScriptRequestMethodCode_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ testScriptRequestMethodCode_extension x
            ]
instance Extension TestScriptRequestMethodCode Element where
    supertype (TestScriptRequestMethodCode a0 a1 e0) =
               Element a0 e0
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
elementValueSet :: XMLParser ValueSet
elementValueSet = parseSchemaType "ValueSet"
elementToXMLValueSet :: ValueSet -> [Content ()]
elementToXMLValueSet = schemaTypeToXML "ValueSet"
 
data ValueSet = ValueSet
        { valueSet_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , valueSet_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , valueSet_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , valueSet_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , valueSet_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , valueSet_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , valueSet_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSet_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSet_url :: Maybe Uri
          -- ^ An absolute URI that is used to identify this value set 
          --   when it is referenced in a specification, model, design or 
          --   an instance. This SHALL be a URL, SHOULD be globally 
          --   unique, and SHOULD be an address at which this value set is 
          --   (or will be) published. The URL SHOULD include the major 
          --   version of the value set. For more information see 
          --   [Technical and Business Versions](resource.html#versions).
        , valueSet_identifier :: [Identifier]
          -- ^ A formal identifier that is used to identify this value set 
          --   when it is represented in other formats, or referenced in a 
          --   specification, model, design or an instance.
        , valueSet_version :: Maybe Xsd.XsdString
          -- ^ The identifier that is used to identify this version of the 
          --   value set when it is referenced in a specification, model, 
          --   design or instance. This is an arbitrary value managed by 
          --   the value set author and is not expected to be globally 
          --   unique. For example, it might be a timestamp (e.g. 
          --   yyyymmdd) if a managed version is not available. There is 
          --   also no expectation that versions can be placed in a 
          --   lexicographical sequence.
        , valueSet_name :: Maybe Xsd.XsdString
          -- ^ A natural language name identifying the value set. This 
          --   name should be usable as an identifier for the module by 
          --   machine processing applications such as code generation.
        , valueSet_title :: Maybe Xsd.XsdString
          -- ^ A short, descriptive, user-friendly title for the value 
          --   set.
        , valueSet_status :: PublicationStatus
          -- ^ The status of this value set. Enables tracking the 
          --   life-cycle of the content.
        , valueSet_experimental :: Maybe Boolean
          -- ^ A boolean value to indicate that this value set is authored 
          --   for testing purposes (or education/evaluation/marketing), 
          --   and is not intended to be used for genuine usage.
        , valueSet_date :: Maybe DateTime
          -- ^ The date (and optionally time) when the value set was 
          --   published. The date must change if and when the business 
          --   version changes and it must change if the status code 
          --   changes. In addition, it should change when the substantive 
          --   content of the value set changes. (e.g. the 'content 
          --   logical definition').
        , valueSet_publisher :: Maybe Xsd.XsdString
          -- ^ The name of the individual or organization that published 
          --   the value set.
        , valueSet_contact :: [ContactDetail]
          -- ^ Contact details to assist a user in finding and 
          --   communicating with the publisher.
        , valueSet_description :: Maybe Markdown
          -- ^ A free text natural language description of the value set 
          --   from a consumer's perspective.
        , valueSet_useContext :: [UsageContext]
          -- ^ The content was developed with a focus and intent of 
          --   supporting the contexts that are listed. These terms may be 
          --   used to assist with indexing and searching for appropriate 
          --   value set instances.
        , valueSet_jurisdiction :: [CodeableConcept]
          -- ^ A legal or geographic region in which the value set is 
          --   intended to be used.
        , valueSet_immutable :: Maybe Boolean
          -- ^ If this is set to 'true', then no new versions of the 
          --   content logical definition can be created. Note: Other 
          --   metadata might still change.
        , valueSet_purpose :: Maybe Markdown
          -- ^ Explaination of why this value set is needed and why it has 
          --   been designed as it has.
        , valueSet_copyright :: Maybe Markdown
          -- ^ A copyright statement relating to the value set and/or its 
          --   contents. Copyright statements are generally legal 
          --   restrictions on the use and publishing of the value set.
        , valueSet_extensible :: Maybe Boolean
          -- ^ Whether this is intended to be used with an extensible 
          --   binding or not.
        , valueSet_compose :: Maybe ValueSetCompose
          -- ^ A set of criteria that define the content logical 
          --   definition of the value set by including or excluding codes 
          --   from outside this value set. This I also known as the 
          --   &quot;Content Logical Definition&quot; (CLD).
        , valueSet_expansion :: Maybe ValueSetExpansion
          -- ^ A value set can also be &quot;expanded&quot;, where the 
          --   value set is turned into a simple collection of enumerated 
          --   codes. This element holds the expansion, if it has been 
          --   performed.
        }
        deriving (Eq,Show)
instance SchemaType ValueSet where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return ValueSet
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "url")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "name")
            `apply` optional (parseSchemaType "title")
            `apply` parseSchemaType "status"
            `apply` optional (parseSchemaType "experimental")
            `apply` optional (parseSchemaType "date")
            `apply` optional (parseSchemaType "publisher")
            `apply` many (parseSchemaType "contact")
            `apply` optional (parseSchemaType "description")
            `apply` many (parseSchemaType "useContext")
            `apply` many (parseSchemaType "jurisdiction")
            `apply` optional (parseSchemaType "immutable")
            `apply` optional (parseSchemaType "purpose")
            `apply` optional (parseSchemaType "copyright")
            `apply` optional (parseSchemaType "extensible")
            `apply` optional (parseSchemaType "compose")
            `apply` optional (parseSchemaType "expansion")
    schemaTypeToXML s x@ValueSet{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ valueSet_id x
            , maybe [] (schemaTypeToXML "meta") $ valueSet_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ valueSet_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ valueSet_language x
            , maybe [] (schemaTypeToXML "text") $ valueSet_text x
            , concatMap (schemaTypeToXML "contained") $ valueSet_contained x
            , concatMap (schemaTypeToXML "extension") $ valueSet_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSet_modifierExtension x
            , maybe [] (schemaTypeToXML "url") $ valueSet_url x
            , concatMap (schemaTypeToXML "identifier") $ valueSet_identifier x
            , maybe [] (schemaTypeToXML "version") $ valueSet_version x
            , maybe [] (schemaTypeToXML "name") $ valueSet_name x
            , maybe [] (schemaTypeToXML "title") $ valueSet_title x
            , schemaTypeToXML "status" $ valueSet_status x
            , maybe [] (schemaTypeToXML "experimental") $ valueSet_experimental x
            , maybe [] (schemaTypeToXML "date") $ valueSet_date x
            , maybe [] (schemaTypeToXML "publisher") $ valueSet_publisher x
            , concatMap (schemaTypeToXML "contact") $ valueSet_contact x
            , maybe [] (schemaTypeToXML "description") $ valueSet_description x
            , concatMap (schemaTypeToXML "useContext") $ valueSet_useContext x
            , concatMap (schemaTypeToXML "jurisdiction") $ valueSet_jurisdiction x
            , maybe [] (schemaTypeToXML "immutable") $ valueSet_immutable x
            , maybe [] (schemaTypeToXML "purpose") $ valueSet_purpose x
            , maybe [] (schemaTypeToXML "copyright") $ valueSet_copyright x
            , maybe [] (schemaTypeToXML "extensible") $ valueSet_extensible x
            , maybe [] (schemaTypeToXML "compose") $ valueSet_compose x
            , maybe [] (schemaTypeToXML "expansion") $ valueSet_expansion x
            ]
instance Extension ValueSet DomainResource where
    supertype (ValueSet e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16 e17 e18 e19 e20 e21 e22 e23 e24 e25 e26) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension ValueSet Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: ValueSet -> DomainResource)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetCompose = ValueSetCompose
        { valueSetCompose_id :: Maybe String_primitive
        , valueSetCompose_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetCompose_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetCompose_lockedDate :: Maybe Date
          -- ^ If a locked date is defined, then the Content Logical 
          --   Definition must be evaluated using the current version as 
          --   of the locked date for referenced code system(s) and value 
          --   set instances where ValueSet.compose.include.version is not 
          --   defined.
        , valueSetCompose_inactive :: Maybe Boolean
          -- ^ Whether inactive codes - codes that are not approved for 
          --   current use - are in the value set. If inactive = true, 
          --   inactive codes are to be included in the expansion, if 
          --   inactive = false, the inactive codes will not be included 
          --   in the expansion. If absent, the behavior is determined by 
          --   the implementation, or by the applicable ExpansionProfile 
          --   (but generally, inactive codes would be expected to be 
          --   included).
        , valueSetCompose_include :: [ValueSetInclude]
          -- ^ Include one or more codes from a code system or other value 
          --   set(s).
        , valueSetCompose_exclude :: [ValueSetInclude]
          -- ^ Exclude one or more codes from the value set based on code 
          --   system filters and/or other value sets.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetCompose where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetCompose a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "lockedDate")
            `apply` optional (parseSchemaType "inactive")
            `apply` many1 (parseSchemaType "include")
            `apply` many (parseSchemaType "exclude")
    schemaTypeToXML s x@ValueSetCompose{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetCompose_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetCompose_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetCompose_modifierExtension x
            , maybe [] (schemaTypeToXML "lockedDate") $ valueSetCompose_lockedDate x
            , maybe [] (schemaTypeToXML "inactive") $ valueSetCompose_inactive x
            , concatMap (schemaTypeToXML "include") $ valueSetCompose_include x
            , concatMap (schemaTypeToXML "exclude") $ valueSetCompose_exclude x
            ]
instance Extension ValueSetCompose BackboneElement where
    supertype (ValueSetCompose a0 e0 e1 e2 e3 e4 e5) =
               BackboneElement a0 e0 e1
instance Extension ValueSetCompose Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetCompose -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetInclude = ValueSetInclude
        { valueSetInclude_id :: Maybe String_primitive
        , valueSetInclude_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetInclude_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetInclude_system :: Maybe Uri
          -- ^ An absolute URI which is the code system from which the 
          --   selected codes come from.
        , valueSetInclude_version :: Maybe Xsd.XsdString
          -- ^ The version of the code system that the codes are selected 
          --   from.
        , valueSetInclude_concept :: [ValueSetConcept]
          -- ^ Specifies a concept to be included or excluded.
        , valueSetInclude_filter :: [ValueSetFilter]
          -- ^ Select concepts by specify a matching criteria based on the 
          --   properties (including relationships) defined by the system. 
          --   If multiple filters are specified, they SHALL all be true.
        , valueSetInclude_valueSet :: [Uri]
          -- ^ Selects concepts found in this value set. This is an 
          --   absolute URI that is a reference to ValueSet.url.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetInclude where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetInclude a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "version")
            `apply` many (parseSchemaType "concept")
            `apply` many (parseSchemaType "filter")
            `apply` many (parseSchemaType "valueSet")
    schemaTypeToXML s x@ValueSetInclude{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetInclude_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetInclude_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetInclude_modifierExtension x
            , maybe [] (schemaTypeToXML "system") $ valueSetInclude_system x
            , maybe [] (schemaTypeToXML "version") $ valueSetInclude_version x
            , concatMap (schemaTypeToXML "concept") $ valueSetInclude_concept x
            , concatMap (schemaTypeToXML "filter") $ valueSetInclude_filter x
            , concatMap (schemaTypeToXML "valueSet") $ valueSetInclude_valueSet x
            ]
instance Extension ValueSetInclude BackboneElement where
    supertype (ValueSetInclude a0 e0 e1 e2 e3 e4 e5 e6) =
               BackboneElement a0 e0 e1
instance Extension ValueSetInclude Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetInclude -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetConcept = ValueSetConcept
        { valueSetConcept_id :: Maybe String_primitive
        , valueSetConcept_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetConcept_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetConcept_code :: Code
          -- ^ Specifies a code for the concept to be included or 
          --   excluded.
        , valueSetConcept_display :: Maybe Xsd.XsdString
          -- ^ The text to display to the user for this concept in the 
          --   context of this valueset. If no display is provided, then 
          --   applications using the value set use the display specified 
          --   for the code by the system.
        , valueSetConcept_designation :: [ValueSetDesignation]
          -- ^ Additional representations for this concept when used in 
          --   this value set - other languages, aliases, specialized 
          --   purposes, used for particular purposes, etc.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetConcept where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetConcept a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "code"
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "designation")
    schemaTypeToXML s x@ValueSetConcept{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetConcept_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetConcept_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetConcept_modifierExtension x
            , schemaTypeToXML "code" $ valueSetConcept_code x
            , maybe [] (schemaTypeToXML "display") $ valueSetConcept_display x
            , concatMap (schemaTypeToXML "designation") $ valueSetConcept_designation x
            ]
instance Extension ValueSetConcept BackboneElement where
    supertype (ValueSetConcept a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSetConcept Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetConcept -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetDesignation = ValueSetDesignation
        { valueSetDesignation_id :: Maybe String_primitive
        , valueSetDesignation_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetDesignation_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetDesignation_language :: Maybe Code
          -- ^ The language this designation is defined for.
        , valueSetDesignation_use :: Maybe Coding
          -- ^ A code that details how this designation would be used.
        , valueSetDesignation_value :: Xsd.XsdString
          -- ^ The text value for this designation.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetDesignation where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetDesignation a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "use")
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ValueSetDesignation{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetDesignation_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetDesignation_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetDesignation_modifierExtension x
            , maybe [] (schemaTypeToXML "language") $ valueSetDesignation_language x
            , maybe [] (schemaTypeToXML "use") $ valueSetDesignation_use x
            , schemaTypeToXML "value" $ valueSetDesignation_value x
            ]
instance Extension ValueSetDesignation BackboneElement where
    supertype (ValueSetDesignation a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSetDesignation Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetDesignation -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetFilter = ValueSetFilter
        { valueSetFilter_id :: Maybe String_primitive
        , valueSetFilter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetFilter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetFilter_property :: Code
          -- ^ A code that identifies a property defined in the code 
          --   system.
        , valueSetFilter_op :: FilterOperator
          -- ^ The kind of operation to perform as a part of the filter 
          --   criteria.
        , valueSetFilter_value :: Code
          -- ^ The match value may be either a code defined by the system, 
          --   or a string value, which is a regex match on the literal 
          --   string of the property value when the operation is 'regex', 
          --   or one of the values (true and false), when the operation 
          --   is 'exists'.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetFilter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetFilter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "property"
            `apply` parseSchemaType "op"
            `apply` parseSchemaType "value"
    schemaTypeToXML s x@ValueSetFilter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetFilter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetFilter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetFilter_modifierExtension x
            , schemaTypeToXML "property" $ valueSetFilter_property x
            , schemaTypeToXML "op" $ valueSetFilter_op x
            , schemaTypeToXML "value" $ valueSetFilter_value x
            ]
instance Extension ValueSetFilter BackboneElement where
    supertype (ValueSetFilter a0 e0 e1 e2 e3 e4) =
               BackboneElement a0 e0 e1
instance Extension ValueSetFilter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetFilter -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetExpansion = ValueSetExpansion
        { valueSetExpansion_id :: Maybe String_primitive
        , valueSetExpansion_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetExpansion_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetExpansion_identifier :: Uri
          -- ^ An identifier that uniquely identifies this expansion of 
          --   the valueset. Systems may re-use the same identifier as 
          --   long as the expansion and the definition remain the same, 
          --   but are not required to do so.
        , valueSetExpansion_timestamp :: DateTime
          -- ^ The time at which the expansion was produced by the 
          --   expanding system.
        , valueSetExpansion_total :: Maybe Integer
          -- ^ The total number of concepts in the expansion. If the 
          --   number of concept nodes in this resource is less than the 
          --   stated number, then the server can return more using the 
          --   offset parameter.
        , valueSetExpansion_offset :: Maybe Integer
          -- ^ If paging is being used, the offset at which this resource 
          --   starts. I.e. this resource is a partial view into the 
          --   expansion. If paging is not being used, this element SHALL 
          --   not be present.
        , valueSetExpansion_parameter :: [ValueSetParameter]
          -- ^ A parameter that controlled the expansion process. These 
          --   parameters may be used by users of expanded value sets to 
          --   check whether the expansion is suitable for a particular 
          --   purpose, or to pick the correct expansion.
        , valueSetExpansion_contains :: [ValueSetContains]
          -- ^ The codes that are contained in the value set expansion.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetExpansion where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetExpansion a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "identifier"
            `apply` parseSchemaType "timestamp"
            `apply` optional (parseSchemaType "total")
            `apply` optional (parseSchemaType "offset")
            `apply` many (parseSchemaType "parameter")
            `apply` many (parseSchemaType "contains")
    schemaTypeToXML s x@ValueSetExpansion{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetExpansion_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetExpansion_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetExpansion_modifierExtension x
            , schemaTypeToXML "identifier" $ valueSetExpansion_identifier x
            , schemaTypeToXML "timestamp" $ valueSetExpansion_timestamp x
            , maybe [] (schemaTypeToXML "total") $ valueSetExpansion_total x
            , maybe [] (schemaTypeToXML "offset") $ valueSetExpansion_offset x
            , concatMap (schemaTypeToXML "parameter") $ valueSetExpansion_parameter x
            , concatMap (schemaTypeToXML "contains") $ valueSetExpansion_contains x
            ]
instance Extension ValueSetExpansion BackboneElement where
    supertype (ValueSetExpansion a0 e0 e1 e2 e3 e4 e5 e6 e7) =
               BackboneElement a0 e0 e1
instance Extension ValueSetExpansion Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetExpansion -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetParameter = ValueSetParameter
        { valueSetParameter_id :: Maybe String_primitive
        , valueSetParameter_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetParameter_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetParameter_name :: Xsd.XsdString
          -- ^ The name of the parameter.
        , valueSetParameter_choice3 :: (Maybe (OneOf6 Xsd.XsdString Boolean Integer Decimal Uri Code))
          -- ^ The value of the parameter.
          --   
          --   Choice between:
          --   
          --   (1) valueString
          --   
          --   (2) valueBoolean
          --   
          --   (3) valueInteger
          --   
          --   (4) valueDecimal
          --   
          --   (5) valueUri
          --   
          --   (6) valueCode
        }
        deriving (Eq,Show)
instance SchemaType ValueSetParameter where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetParameter a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` parseSchemaType "name"
            `apply` optional (oneOf' [ ("Xsd.XsdString", fmap OneOf6 (parseSchemaType "valueString"))
                                     , ("Boolean", fmap TwoOf6 (parseSchemaType "valueBoolean"))
                                     , ("Integer", fmap ThreeOf6 (parseSchemaType "valueInteger"))
                                     , ("Decimal", fmap FourOf6 (parseSchemaType "valueDecimal"))
                                     , ("Uri", fmap FiveOf6 (parseSchemaType "valueUri"))
                                     , ("Code", fmap SixOf6 (parseSchemaType "valueCode"))
                                     ])
    schemaTypeToXML s x@ValueSetParameter{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetParameter_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetParameter_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetParameter_modifierExtension x
            , schemaTypeToXML "name" $ valueSetParameter_name x
            , maybe [] (foldOneOf6  (schemaTypeToXML "valueString")
                                    (schemaTypeToXML "valueBoolean")
                                    (schemaTypeToXML "valueInteger")
                                    (schemaTypeToXML "valueDecimal")
                                    (schemaTypeToXML "valueUri")
                                    (schemaTypeToXML "valueCode")
                                   ) $ valueSetParameter_choice3 x
            ]
instance Extension ValueSetParameter BackboneElement where
    supertype (ValueSetParameter a0 e0 e1 e2 e3) =
               BackboneElement a0 e0 e1
instance Extension ValueSetParameter Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetParameter -> BackboneElement)
              
 
-- | A value set specifies a set of codes drawn from one or more 
--   code systems.
data ValueSetContains = ValueSetContains
        { valueSetContains_id :: Maybe String_primitive
        , valueSetContains_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , valueSetContains_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , valueSetContains_system :: Maybe Uri
          -- ^ An absolute URI which is the code system in which the code 
          --   for this item in the expansion is defined.
        , valueSetContains_abstract :: Maybe Boolean
          -- ^ If true, this entry is included in the expansion for 
          --   navigational purposes, and the user cannot select the code 
          --   directly as a proper value.
        , valueSetContains_inactive :: Maybe Boolean
          -- ^ If the concept is inactive in the code system that defines 
          --   it. Inactive codes are those that are no longer to be used, 
          --   but are maintained by the code system for understanding 
          --   legacy data.
        , valueSetContains_version :: Maybe Xsd.XsdString
          -- ^ The version of this code system that defined this code 
          --   and/or display. This should only be used with code systems 
          --   that do not enforce concept permanence.
        , valueSetContains_code :: Maybe Code
          -- ^ The code for this item in the expansion hierarchy. If this 
          --   code is missing the entry in the hierarchy is a place 
          --   holder (abstract) and does not represent a valid code in 
          --   the value set.
        , valueSetContains_display :: Maybe Xsd.XsdString
          -- ^ The recommended display for this item in the expansion.
        , valueSetContains_designation :: [ValueSetDesignation]
          -- ^ Additional representations for this item - other languages, 
          --   aliases, specialized purposes, used for particular 
          --   purposes, etc. These are relevant when the conditions of 
          --   the expansion do not fix to a single correct 
          --   representation.
        , valueSetContains_contains :: [ValueSetContains]
          -- ^ Other codes and entries contained under this entry in the 
          --   hierarchy.
        }
        deriving (Eq,Show)
instance SchemaType ValueSetContains where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (ValueSetContains a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "system")
            `apply` optional (parseSchemaType "abstract")
            `apply` optional (parseSchemaType "inactive")
            `apply` optional (parseSchemaType "version")
            `apply` optional (parseSchemaType "code")
            `apply` optional (parseSchemaType "display")
            `apply` many (parseSchemaType "designation")
            `apply` many (parseSchemaType "contains")
    schemaTypeToXML s x@ValueSetContains{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ valueSetContains_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ valueSetContains_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ valueSetContains_modifierExtension x
            , maybe [] (schemaTypeToXML "system") $ valueSetContains_system x
            , maybe [] (schemaTypeToXML "abstract") $ valueSetContains_abstract x
            , maybe [] (schemaTypeToXML "inactive") $ valueSetContains_inactive x
            , maybe [] (schemaTypeToXML "version") $ valueSetContains_version x
            , maybe [] (schemaTypeToXML "code") $ valueSetContains_code x
            , maybe [] (schemaTypeToXML "display") $ valueSetContains_display x
            , concatMap (schemaTypeToXML "designation") $ valueSetContains_designation x
            , concatMap (schemaTypeToXML "contains") $ valueSetContains_contains x
            ]
instance Extension ValueSetContains BackboneElement where
    supertype (ValueSetContains a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9) =
               BackboneElement a0 e0 e1
instance Extension ValueSetContains Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: ValueSetContains -> BackboneElement)
              
 
-- | An authorization for the supply of glasses and/or contact 
--   lenses to a patient.
elementVisionPrescription :: XMLParser VisionPrescription
elementVisionPrescription = parseSchemaType "VisionPrescription"
elementToXMLVisionPrescription :: VisionPrescription -> [Content ()]
elementToXMLVisionPrescription = schemaTypeToXML "VisionPrescription"
 
data VisionPrescription = VisionPrescription
        { visionPrescription_id :: Maybe Id
          -- ^ The logical id of the resource, as used in the URL for the 
          --   resource. Once assigned, this value never changes.
        , visionPrescription_meta :: Maybe Meta
          -- ^ The metadata about the resource. This is content that is 
          --   maintained by the infrastructure. Changes to the content 
          --   may not always be associated with version changes to the 
          --   resource.
        , visionPrescription_implicitRules :: Maybe Uri
          -- ^ A reference to a set of rules that were followed when the 
          --   resource was constructed, and which must be understood when 
          --   processing the content.
        , visionPrescription_language :: Maybe Code
          -- ^ The base language in which the resource is written.
        , visionPrescription_text :: Maybe Narrative
          -- ^ A human-readable narrative that contains a summary of the 
          --   resource, and may be used to represent the content of the 
          --   resource to a human. The narrative need not encode all the 
          --   structured data, but is required to contain sufficient 
          --   detail to make it &quot;clinically safe&quot; for a human 
          --   to just read the narrative. Resource definitions may define 
          --   what content should be represented in the narrative to 
          --   ensure clinical safety.
        , visionPrescription_contained :: [ResourceContainer]
          -- ^ These resources do not have an independent existence apart 
          --   from the resource that contains them - they cannot be 
          --   identified independently, and nor can they have their own 
          --   independent transaction scope.
        , visionPrescription_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , visionPrescription_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the resource, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , visionPrescription_identifier :: [Identifier]
          -- ^ Business identifier which may be used by other parties to 
          --   reference or identify the prescription.
        , visionPrescription_status :: Maybe FinancialResourceStatusCodes
          -- ^ The status of the resource instance.
        , visionPrescription_patient :: Maybe Reference
          -- ^ A link to a resource representing the person to whom the 
          --   vision products will be supplied.
        , visionPrescription_encounter :: Maybe Reference
          -- ^ A link to a resource that identifies the particular 
          --   occurrence of contact between patient and health care 
          --   provider.
        , visionPrescription_dateWritten :: Maybe DateTime
          -- ^ The date (and perhaps time) when the prescription was 
          --   written.
        , visionPrescription_prescriber :: Maybe Reference
          -- ^ The healthcare professional responsible for authorizing the 
          --   prescription.
        , visionPrescription_choice14 :: (Maybe (OneOf2 CodeableConcept Reference))
          -- ^ Can be the reason or the indication for writing the 
          --   prescription.
          --   
          --   Choice between:
          --   
          --   (1) reasonCodeableConcept
          --   
          --   (2) reasonReference
        , visionPrescription_dispense :: [VisionPrescriptionDispense]
          -- ^ Deals with details of the dispense part of the supply 
          --   specification.
        }
        deriving (Eq,Show)
instance SchemaType VisionPrescription where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        commit $ interior e $ return VisionPrescription
            `apply` optional (parseSchemaType "id")
            `apply` optional (parseSchemaType "meta")
            `apply` optional (parseSchemaType "implicitRules")
            `apply` optional (parseSchemaType "language")
            `apply` optional (parseSchemaType "text")
            `apply` many (parseSchemaType "contained")
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` many (parseSchemaType "identifier")
            `apply` optional (parseSchemaType "status")
            `apply` optional (parseSchemaType "patient")
            `apply` optional (parseSchemaType "encounter")
            `apply` optional (parseSchemaType "dateWritten")
            `apply` optional (parseSchemaType "prescriber")
            `apply` optional (oneOf' [ ("CodeableConcept", fmap OneOf2 (parseSchemaType "reasonCodeableConcept"))
                                     , ("Reference", fmap TwoOf2 (parseSchemaType "reasonReference"))
                                     ])
            `apply` many (parseSchemaType "dispense")
    schemaTypeToXML s x@VisionPrescription{} =
        toXMLElement s []
            [ maybe [] (schemaTypeToXML "id") $ visionPrescription_id x
            , maybe [] (schemaTypeToXML "meta") $ visionPrescription_meta x
            , maybe [] (schemaTypeToXML "implicitRules") $ visionPrescription_implicitRules x
            , maybe [] (schemaTypeToXML "language") $ visionPrescription_language x
            , maybe [] (schemaTypeToXML "text") $ visionPrescription_text x
            , concatMap (schemaTypeToXML "contained") $ visionPrescription_contained x
            , concatMap (schemaTypeToXML "extension") $ visionPrescription_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ visionPrescription_modifierExtension x
            , concatMap (schemaTypeToXML "identifier") $ visionPrescription_identifier x
            , maybe [] (schemaTypeToXML "status") $ visionPrescription_status x
            , maybe [] (schemaTypeToXML "patient") $ visionPrescription_patient x
            , maybe [] (schemaTypeToXML "encounter") $ visionPrescription_encounter x
            , maybe [] (schemaTypeToXML "dateWritten") $ visionPrescription_dateWritten x
            , maybe [] (schemaTypeToXML "prescriber") $ visionPrescription_prescriber x
            , maybe [] (foldOneOf2  (schemaTypeToXML "reasonCodeableConcept")
                                    (schemaTypeToXML "reasonReference")
                                   ) $ visionPrescription_choice14 x
            , concatMap (schemaTypeToXML "dispense") $ visionPrescription_dispense x
            ]
instance Extension VisionPrescription DomainResource where
    supertype (VisionPrescription e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15) =
               DomainResource e0 e1 e2 e3 e4 e5 e6 e7
instance Extension VisionPrescription Resource where
    supertype = (supertype :: DomainResource -> Resource)
              . (supertype :: VisionPrescription -> DomainResource)
              
 
-- | An authorization for the supply of glasses and/or contact 
--   lenses to a patient.
data VisionPrescriptionDispense = VisionPrescriptionDispense
        { visionPrescriptionDispense_id :: Maybe String_primitive
        , visionPrescriptionDispense_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        , visionPrescriptionDispense_modifierExtension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element, and that 
          --   modifies the understanding of the element that contains it. 
          --   Usually modifier elements provide negation or 
          --   qualification. In order to make the use of extensions safe 
          --   and manageable, there is a strict set of governance applied 
          --   to the definition and use of extensions. Though any 
          --   implementer is allowed to define an extension, there is a 
          --   set of requirements that SHALL be met as part of the 
          --   definition of the extension. Applications processing a 
          --   resource are required to check for modifier extensions.
        , visionPrescriptionDispense_product :: Maybe CodeableConcept
          -- ^ Identifies the type of vision correction product which is 
          --   required for the patient.
        , visionPrescriptionDispense_eye :: Maybe VisionEyes
          -- ^ The eye for which the lens applies.
        , visionPrescriptionDispense_sphere :: Maybe Decimal
          -- ^ Lens power measured in diopters (0.25 units).
        , visionPrescriptionDispense_cylinder :: Maybe Decimal
          -- ^ Power adjustment for astigmatism measured in diopters (0.25 
          --   units).
        , visionPrescriptionDispense_axis :: Maybe Integer
          -- ^ Adjustment for astigmatism measured in integer degrees.
        , visionPrescriptionDispense_prism :: Maybe Decimal
          -- ^ Amount of prism to compensate for eye alignment in 
          --   fractional units.
        , visionPrescriptionDispense_base :: Maybe VisionBase
          -- ^ The relative base, or reference lens edge, for the prism.
        , visionPrescriptionDispense_add :: Maybe Decimal
          -- ^ Power adjustment for multifocal lenses measured in diopters 
          --   (0.25 units).
        , visionPrescriptionDispense_power :: Maybe Decimal
          -- ^ Contact lens power measured in diopters (0.25 units).
        , visionPrescriptionDispense_backCurve :: Maybe Decimal
          -- ^ Back curvature measured in millimeters.
        , visionPrescriptionDispense_diameter :: Maybe Decimal
          -- ^ Contact lens diameter measured in millimeters.
        , visionPrescriptionDispense_duration :: Maybe Quantity
          -- ^ The recommended maximum wear period for the lens.
        , visionPrescriptionDispense_color :: Maybe Xsd.XsdString
          -- ^ Special color or pattern.
        , visionPrescriptionDispense_brand :: Maybe Xsd.XsdString
          -- ^ Brand recommendations or restrictions.
        , visionPrescriptionDispense_note :: [Annotation]
          -- ^ Notes for special requirements such as coatings and lens 
          --   materials.
        }
        deriving (Eq,Show)
instance SchemaType VisionPrescriptionDispense where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        commit $ interior e $ return (VisionPrescriptionDispense a0)
            `apply` many (parseSchemaType "extension")
            `apply` many (parseSchemaType "modifierExtension")
            `apply` optional (parseSchemaType "product")
            `apply` optional (parseSchemaType "eye")
            `apply` optional (parseSchemaType "sphere")
            `apply` optional (parseSchemaType "cylinder")
            `apply` optional (parseSchemaType "axis")
            `apply` optional (parseSchemaType "prism")
            `apply` optional (parseSchemaType "base")
            `apply` optional (parseSchemaType "add")
            `apply` optional (parseSchemaType "power")
            `apply` optional (parseSchemaType "backCurve")
            `apply` optional (parseSchemaType "diameter")
            `apply` optional (parseSchemaType "duration")
            `apply` optional (parseSchemaType "color")
            `apply` optional (parseSchemaType "brand")
            `apply` many (parseSchemaType "note")
    schemaTypeToXML s x@VisionPrescriptionDispense{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionPrescriptionDispense_id x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionPrescriptionDispense_extension x
            , concatMap (schemaTypeToXML "modifierExtension") $ visionPrescriptionDispense_modifierExtension x
            , maybe [] (schemaTypeToXML "product") $ visionPrescriptionDispense_product x
            , maybe [] (schemaTypeToXML "eye") $ visionPrescriptionDispense_eye x
            , maybe [] (schemaTypeToXML "sphere") $ visionPrescriptionDispense_sphere x
            , maybe [] (schemaTypeToXML "cylinder") $ visionPrescriptionDispense_cylinder x
            , maybe [] (schemaTypeToXML "axis") $ visionPrescriptionDispense_axis x
            , maybe [] (schemaTypeToXML "prism") $ visionPrescriptionDispense_prism x
            , maybe [] (schemaTypeToXML "base") $ visionPrescriptionDispense_base x
            , maybe [] (schemaTypeToXML "add") $ visionPrescriptionDispense_add x
            , maybe [] (schemaTypeToXML "power") $ visionPrescriptionDispense_power x
            , maybe [] (schemaTypeToXML "backCurve") $ visionPrescriptionDispense_backCurve x
            , maybe [] (schemaTypeToXML "diameter") $ visionPrescriptionDispense_diameter x
            , maybe [] (schemaTypeToXML "duration") $ visionPrescriptionDispense_duration x
            , maybe [] (schemaTypeToXML "color") $ visionPrescriptionDispense_color x
            , maybe [] (schemaTypeToXML "brand") $ visionPrescriptionDispense_brand x
            , concatMap (schemaTypeToXML "note") $ visionPrescriptionDispense_note x
            ]
instance Extension VisionPrescriptionDispense BackboneElement where
    supertype (VisionPrescriptionDispense a0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 e13 e14 e15 e16) =
               BackboneElement a0 e0 e1
instance Extension VisionPrescriptionDispense Element where
    supertype = (supertype :: BackboneElement -> Element)
              . (supertype :: VisionPrescriptionDispense -> BackboneElement)
              
 
data VisionBase_list
    = VisionBase_list_Up
      -- ^ Up
    | VisionBase_list_Down
      -- ^ Down
    | VisionBase_list_In
      -- ^ In
    | VisionBase_list_Out
      -- ^ Out
    deriving (Eq,Show,Enum)
instance SchemaType VisionBase_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType VisionBase_list where
    acceptingParser =  do literal "up"; return VisionBase_list_Up
                      `onFail` do literal "down"; return VisionBase_list_Down
                      `onFail` do literal "in"; return VisionBase_list_In
                      `onFail` do literal "out"; return VisionBase_list_Out
                      
    simpleTypeText VisionBase_list_Up = "up"
    simpleTypeText VisionBase_list_Down = "down"
    simpleTypeText VisionBase_list_In = "in"
    simpleTypeText VisionBase_list_Out = "out"
 
data VisionBase = VisionBase
        { visionBase_id :: Maybe String_primitive
        , visionBase_value :: Maybe VisionBase_list
        , visionBase_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType VisionBase where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (VisionBase a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@VisionBase{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionBase_id x
                       , maybe [] (toXMLAttribute "value") $ visionBase_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionBase_extension x
            ]
instance Extension VisionBase Element where
    supertype (VisionBase a0 a1 e0) =
               Element a0 e0
 
data VisionEyes_list
    = VisionEyes_list_Right
      -- ^ Right Eye
    | VisionEyes_list_Left
      -- ^ Left Eye
    deriving (Eq,Show,Enum)
instance SchemaType VisionEyes_list where
    parseSchemaType s = do
        e <- element [s]
        commit $ interior e $ parseSimpleType
    schemaTypeToXML s x = 
        toXMLElement s [] [toXMLText (simpleTypeText x)]
instance SimpleType VisionEyes_list where
    acceptingParser =  do literal "right"; return VisionEyes_list_Right
                      `onFail` do literal "left"; return VisionEyes_list_Left
                      
    simpleTypeText VisionEyes_list_Right = "right"
    simpleTypeText VisionEyes_list_Left = "left"
 
data VisionEyes = VisionEyes
        { visionEyes_id :: Maybe String_primitive
        , visionEyes_value :: Maybe VisionEyes_list
        , visionEyes_extension :: [Extension]
          -- ^ May be used to represent additional information that is not 
          --   part of the basic definition of the element. In order to 
          --   make the use of extensions safe and manageable, there is a 
          --   strict set of governance applied to the definition and use 
          --   of extensions. Though any implementer is allowed to define 
          --   an extension, there is a set of requirements that SHALL be 
          --   met as part of the definition of the extension.
        }
        deriving (Eq,Show)
instance SchemaType VisionEyes where
    parseSchemaType s = do
        (pos,e) <- posnElement [s]
        a0 <- optional $ getAttribute "id" e pos
        a1 <- optional $ getAttribute "value" e pos
        commit $ interior e $ return (VisionEyes a0 a1)
            `apply` many (parseSchemaType "extension")
    schemaTypeToXML s x@VisionEyes{} =
        toXMLElement s [ maybe [] (toXMLAttribute "id") $ visionEyes_id x
                       , maybe [] (toXMLAttribute "value") $ visionEyes_value x
                       ]
            [ concatMap (schemaTypeToXML "extension") $ visionEyes_extension x
            ]
instance Extension VisionEyes Element where
    supertype (VisionEyes a0 a1 e0) =
               Element a0 e0
